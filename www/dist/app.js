(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var state = require('@codemirror/state');
var view = require('@codemirror/view');
var tooltip = require('@codemirror/tooltip');
var language = require('@codemirror/language');
var text = require('@codemirror/text');

/**
An instance of this is passed to completion source functions.
*/
class CompletionContext {
    /**
    Create a new completion context. (Mostly useful for testing
    completion sources‚Äîin the editor, the extension will create
    these for you.)
    */
    constructor(
    /**
    The editor state that the completion happens in.
    */
    state, 
    /**
    The position at which the completion is happening.
    */
    pos, 
    /**
    Indicates whether completion was activated explicitly, or
    implicitly by typing. The usual way to respond to this is to
    only return completions when either there is part of a
    completable entity before the cursor, or `explicit` is true.
    */
    explicit) {
        this.state = state;
        this.pos = pos;
        this.explicit = explicit;
        /**
        @internal
        */
        this.abortListeners = [];
    }
    /**
    Get the extent, content, and (if there is a token) type of the
    token before `this.pos`.
    */
    tokenBefore(types) {
        let token = language.syntaxTree(this.state).resolve(this.pos, -1);
        while (token && types.indexOf(token.name) < 0)
            token = token.parent;
        return token ? { from: token.from, to: this.pos,
            text: this.state.sliceDoc(token.from, this.pos),
            type: token.type } : null;
    }
    /**
    Get the match of the given expression directly before the
    cursor.
    */
    matchBefore(expr) {
        let line = this.state.doc.lineAt(this.pos);
        let start = Math.max(line.from, this.pos - 250);
        let str = line.text.slice(start - line.from, this.pos - line.from);
        let found = str.search(ensureAnchor(expr, false));
        return found < 0 ? null : { from: start + found, to: this.pos, text: str.slice(found) };
    }
    /**
    Yields true when the query has been aborted. Can be useful in
    asynchronous queries to avoid doing work that will be ignored.
    */
    get aborted() { return this.abortListeners == null; }
    /**
    Allows you to register abort handlers, which will be called when
    the query is
    [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
    */
    addEventListener(type, listener) {
        if (type == "abort" && this.abortListeners)
            this.abortListeners.push(listener);
    }
}
function toSet(chars) {
    let flat = Object.keys(chars).join("");
    let words = /\w/.test(flat);
    if (words)
        flat = flat.replace(/\w/g, "");
    return `[${words ? "\\w" : ""}${flat.replace(/[^\w\s]/g, "\\$&")}]`;
}
function prefixMatch(options) {
    let first = Object.create(null), rest = Object.create(null);
    for (let { label } of options) {
        first[label[0]] = true;
        for (let i = 1; i < label.length; i++)
            rest[label[i]] = true;
    }
    let source = toSet(first) + toSet(rest) + "*$";
    return [new RegExp("^" + source), new RegExp(source)];
}
/**
Given a a fixed array of options, return an autocompleter that
completes them.
*/
function completeFromList(list) {
    let options = list.map(o => typeof o == "string" ? { label: o } : o);
    let [span, match] = options.every(o => /^\w+$/.test(o.label)) ? [/\w*$/, /\w+$/] : prefixMatch(options);
    return (context) => {
        let token = context.matchBefore(match);
        return token || context.explicit ? { from: token ? token.from : context.pos, options, span } : null;
    };
}
/**
Wrap the given completion source so that it will not fire when the
cursor is in a syntax node with one of the given names.
*/
function ifNotIn(nodes, source) {
    return (context) => {
        for (let pos = language.syntaxTree(context.state).resolve(context.pos, -1); pos; pos = pos.parent)
            if (nodes.indexOf(pos.name) > -1)
                return null;
        return source(context);
    };
}
class Option {
    constructor(completion, source, match) {
        this.completion = completion;
        this.source = source;
        this.match = match;
    }
}
function cur(state) { return state.selection.main.head; }
// Make sure the given regexp has a $ at its end and, if `start` is
// true, a ^ at its start.
function ensureAnchor(expr, start) {
    var _a;
    let { source } = expr;
    let addStart = start && source[0] != "^", addEnd = source[source.length - 1] != "$";
    if (!addStart && !addEnd)
        return expr;
    return new RegExp(`${addStart ? "^" : ""}(?:${source})${addEnd ? "$" : ""}`, (_a = expr.flags) !== null && _a !== void 0 ? _a : (expr.ignoreCase ? "i" : ""));
}
function applyCompletion(view, option) {
    let apply = option.completion.apply || option.completion.label;
    let result = option.source;
    if (typeof apply == "string") {
        view.dispatch({
            changes: { from: result.from, to: result.to, insert: apply },
            selection: { anchor: result.from + apply.length }
        });
    }
    else {
        apply(view, option.completion, result.from, result.to);
    }
}
const SourceCache = new WeakMap();
function asSource(source) {
    if (!Array.isArray(source))
        return source;
    let known = SourceCache.get(source);
    if (!known)
        SourceCache.set(source, known = completeFromList(source));
    return known;
}

// A pattern matcher for fuzzy completion matching. Create an instance
// once for a pattern, and then use that to match any number of
// completions.
class FuzzyMatcher {
    constructor(pattern) {
        this.pattern = pattern;
        this.chars = [];
        this.folded = [];
        // Buffers reused by calls to `match` to track matched character
        // positions.
        this.any = [];
        this.precise = [];
        this.byWord = [];
        for (let p = 0; p < pattern.length;) {
            let char = text.codePointAt(pattern, p), size = text.codePointSize(char);
            this.chars.push(char);
            let part = pattern.slice(p, p + size), upper = part.toUpperCase();
            this.folded.push(text.codePointAt(upper == part ? part.toLowerCase() : upper, 0));
            p += size;
        }
        this.astral = pattern.length != this.chars.length;
    }
    // Matches a given word (completion) against the pattern (input).
    // Will return null for no match, and otherwise an array that starts
    // with the match score, followed by any number of `from, to` pairs
    // indicating the matched parts of `word`.
    //
    // The score is a number that is more negative the worse the match
    // is. See `Penalty` above.
    match(word) {
        if (this.pattern.length == 0)
            return [0];
        if (word.length < this.pattern.length)
            return null;
        let { chars, folded, any, precise, byWord } = this;
        // For single-character queries, only match when they occur right
        // at the start
        if (chars.length == 1) {
            let first = text.codePointAt(word, 0);
            return first == chars[0] ? [0, 0, text.codePointSize(first)]
                : first == folded[0] ? [-200 /* CaseFold */, 0, text.codePointSize(first)] : null;
        }
        let direct = word.indexOf(this.pattern);
        if (direct == 0)
            return [0, 0, this.pattern.length];
        let len = chars.length, anyTo = 0;
        if (direct < 0) {
            for (let i = 0, e = Math.min(word.length, 200); i < e && anyTo < len;) {
                let next = text.codePointAt(word, i);
                if (next == chars[anyTo] || next == folded[anyTo])
                    any[anyTo++] = i;
                i += text.codePointSize(next);
            }
            // No match, exit immediately
            if (anyTo < len)
                return null;
        }
        // This tracks the extent of the precise (non-folded, not
        // necessarily adjacent) match
        let preciseTo = 0;
        // Tracks whether there is a match that hits only characters that
        // appear to be starting words. `byWordFolded` is set to true when
        // a case folded character is encountered in such a match
        let byWordTo = 0, byWordFolded = false;
        // If we've found a partial adjacent match, these track its state
        let adjacentTo = 0, adjacentStart = -1, adjacentEnd = -1;
        let hasLower = /[a-z]/.test(word);
        // Go over the option's text, scanning for the various kinds of matches
        for (let i = 0, e = Math.min(word.length, 200), prevType = 0 /* NonWord */; i < e && byWordTo < len;) {
            let next = text.codePointAt(word, i);
            if (direct < 0) {
                if (preciseTo < len && next == chars[preciseTo])
                    precise[preciseTo++] = i;
                if (adjacentTo < len) {
                    if (next == chars[adjacentTo] || next == folded[adjacentTo]) {
                        if (adjacentTo == 0)
                            adjacentStart = i;
                        adjacentEnd = i;
                        adjacentTo++;
                    }
                    else {
                        adjacentTo = 0;
                    }
                }
            }
            let ch, type = next < 0xff
                ? (next >= 48 && next <= 57 || next >= 97 && next <= 122 ? 2 /* Lower */ : next >= 65 && next <= 90 ? 1 /* Upper */ : 0 /* NonWord */)
                : ((ch = text.fromCodePoint(next)) != ch.toLowerCase() ? 1 /* Upper */ : ch != ch.toUpperCase() ? 2 /* Lower */ : 0 /* NonWord */);
            if ((type == 1 /* Upper */ && hasLower || prevType == 0 /* NonWord */ && type != 0 /* NonWord */) &&
                (chars[byWordTo] == next || (folded[byWordTo] == next && (byWordFolded = true))))
                byWord[byWordTo++] = i;
            prevType = type;
            i += text.codePointSize(next);
        }
        if (byWordTo == len && byWord[0] == 0)
            return this.result(-100 /* ByWord */ + (byWordFolded ? -200 /* CaseFold */ : 0), byWord, word);
        if (adjacentTo == len && adjacentStart == 0)
            return [-200 /* CaseFold */, 0, adjacentEnd];
        if (direct > -1)
            return [-700 /* NotStart */, direct, direct + this.pattern.length];
        if (adjacentTo == len)
            return [-200 /* CaseFold */ + -700 /* NotStart */, adjacentStart, adjacentEnd];
        if (byWordTo == len)
            return this.result(-100 /* ByWord */ + (byWordFolded ? -200 /* CaseFold */ : 0) + -700 /* NotStart */, byWord, word);
        return chars.length == 2 ? null : this.result((any[0] ? -700 /* NotStart */ : 0) + -200 /* CaseFold */ + -1100 /* Gap */, any, word);
    }
    result(score, positions, word) {
        let result = [score], i = 1;
        for (let pos of positions) {
            let to = pos + (this.astral ? text.codePointSize(text.codePointAt(word, pos)) : 1);
            if (i > 1 && result[i - 1] == pos)
                result[i - 1] = to;
            else {
                result[i++] = pos;
                result[i++] = to;
            }
        }
        return result;
    }
}

const completionConfig = state.Facet.define({
    combine(configs) {
        return state.combineConfig(configs, {
            activateOnTyping: true,
            override: null,
            maxRenderedOptions: 100,
            defaultKeymap: true
        }, {
            defaultKeymap: (a, b) => a && b
        });
    }
});

const MaxInfoWidth = 300;
const baseTheme = view.EditorView.baseTheme({
    ".cm-tooltip.cm-tooltip-autocomplete": {
        "& > ul": {
            fontFamily: "monospace",
            whiteSpace: "nowrap",
            overflow: "auto",
            maxWidth_fallback: "700px",
            maxWidth: "min(700px, 95vw)",
            maxHeight: "10em",
            listStyle: "none",
            margin: 0,
            padding: 0,
            "& > li": {
                cursor: "pointer",
                padding: "1px 1em 1px 3px",
                lineHeight: 1.2
            },
            "& > li[aria-selected]": {
                background_fallback: "#bdf",
                backgroundColor: "Highlight",
                color_fallback: "white",
                color: "HighlightText"
            }
        }
    },
    ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
        content: '"¬∑¬∑¬∑"',
        opacity: 0.5,
        display: "block",
        textAlign: "center"
    },
    ".cm-tooltip.cm-completionInfo": {
        position: "absolute",
        padding: "3px 9px",
        width: "max-content",
        maxWidth: MaxInfoWidth + "px",
    },
    ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
    ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
    "&light .cm-snippetField": { backgroundColor: "#00000022" },
    "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
    ".cm-snippetFieldPosition": {
        verticalAlign: "text-top",
        width: 0,
        height: "1.15em",
        margin: "0 -0.7px -.7em",
        borderLeft: "1.4px dotted #888"
    },
    ".cm-completionMatchedText": {
        textDecoration: "underline"
    },
    ".cm-completionDetail": {
        marginLeft: "0.5em",
        fontStyle: "italic"
    },
    ".cm-completionIcon": {
        fontSize: "90%",
        width: ".8em",
        display: "inline-block",
        textAlign: "center",
        paddingRight: ".6em",
        opacity: "0.6"
    },
    ".cm-completionIcon-function, .cm-completionIcon-method": {
        "&:after": { content: "'∆í'" }
    },
    ".cm-completionIcon-class": {
        "&:after": { content: "'‚óã'" }
    },
    ".cm-completionIcon-interface": {
        "&:after": { content: "'‚óå'" }
    },
    ".cm-completionIcon-variable": {
        "&:after": { content: "'ùë•'" }
    },
    ".cm-completionIcon-constant": {
        "&:after": { content: "'ùê∂'" }
    },
    ".cm-completionIcon-type": {
        "&:after": { content: "'ùë°'" }
    },
    ".cm-completionIcon-enum": {
        "&:after": { content: "'‚à™'" }
    },
    ".cm-completionIcon-property": {
        "&:after": { content: "'‚ñ°'" }
    },
    ".cm-completionIcon-keyword": {
        "&:after": { content: "'üîë\uFE0E'" } // Disable emoji rendering
    },
    ".cm-completionIcon-namespace": {
        "&:after": { content: "'‚ñ¢'" }
    },
    ".cm-completionIcon-text": {
        "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
    }
});

function createListBox(options, id, range) {
    const ul = document.createElement("ul");
    ul.id = id;
    ul.setAttribute("role", "listbox");
    ul.setAttribute("aria-expanded", "true");
    for (let i = range.from; i < range.to; i++) {
        let { completion, match } = options[i];
        const li = ul.appendChild(document.createElement("li"));
        li.id = id + "-" + i;
        let icon = li.appendChild(document.createElement("div"));
        icon.classList.add("cm-completionIcon");
        if (completion.type)
            icon.classList.add("cm-completionIcon-" + completion.type);
        icon.setAttribute("aria-hidden", "true");
        let labelElt = li.appendChild(document.createElement("span"));
        labelElt.className = "cm-completionLabel";
        let { label, detail } = completion, off = 0;
        for (let j = 1; j < match.length;) {
            let from = match[j++], to = match[j++];
            if (from > off)
                labelElt.appendChild(document.createTextNode(label.slice(off, from)));
            let span = labelElt.appendChild(document.createElement("span"));
            span.appendChild(document.createTextNode(label.slice(from, to)));
            span.className = "cm-completionMatchedText";
            off = to;
        }
        if (off < label.length)
            labelElt.appendChild(document.createTextNode(label.slice(off)));
        if (detail) {
            let detailElt = li.appendChild(document.createElement("span"));
            detailElt.className = "cm-completionDetail";
            detailElt.textContent = detail;
        }
        li.setAttribute("role", "option");
    }
    if (range.from)
        ul.classList.add("cm-completionListIncompleteTop");
    if (range.to < options.length)
        ul.classList.add("cm-completionListIncompleteBottom");
    return ul;
}
function createInfoDialog(option, view$1) {
    let dom = document.createElement("div");
    dom.className = "cm-tooltip cm-completionInfo";
    let { info } = option.completion;
    if (typeof info == "string") {
        dom.textContent = info;
    }
    else {
        let content = info(option.completion);
        if (content.then)
            content.then(node => dom.appendChild(node), e => view.logException(view$1.state, e, "completion info"));
        else
            dom.appendChild(content);
    }
    return dom;
}
function rangeAroundSelected(total, selected, max) {
    if (total <= max)
        return { from: 0, to: total };
    if (selected <= (total >> 1)) {
        let off = Math.floor(selected / max);
        return { from: off * max, to: (off + 1) * max };
    }
    let off = Math.floor((total - selected) / max);
    return { from: total - (off + 1) * max, to: total - off * max };
}
class CompletionTooltip {
    constructor(view, stateField) {
        this.view = view;
        this.stateField = stateField;
        this.info = null;
        this.placeInfo = {
            read: () => this.measureInfo(),
            write: (pos) => this.positionInfo(pos),
            key: this
        };
        let cState = view.state.field(stateField);
        let { options, selected } = cState.open;
        let config = view.state.facet(completionConfig);
        this.range = rangeAroundSelected(options.length, selected, config.maxRenderedOptions);
        this.dom = document.createElement("div");
        this.dom.className = "cm-tooltip-autocomplete";
        this.dom.addEventListener("mousedown", (e) => {
            for (let dom = e.target, match; dom && dom != this.dom; dom = dom.parentNode) {
                if (dom.nodeName == "LI" && (match = /-(\d+)$/.exec(dom.id)) && +match[1] < options.length) {
                    applyCompletion(view, options[+match[1]]);
                    e.preventDefault();
                    return;
                }
            }
        });
        this.list = this.dom.appendChild(createListBox(options, cState.id, this.range));
        this.list.addEventListener("scroll", () => {
            if (this.info)
                this.view.requestMeasure(this.placeInfo);
        });
    }
    mount() { this.updateSel(); }
    update(update) {
        if (update.state.field(this.stateField) != update.startState.field(this.stateField))
            this.updateSel();
    }
    positioned() {
        if (this.info)
            this.view.requestMeasure(this.placeInfo);
    }
    updateSel() {
        let cState = this.view.state.field(this.stateField), open = cState.open;
        if (open.selected < this.range.from || open.selected >= this.range.to) {
            this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);
            this.list.remove();
            this.list = this.dom.appendChild(createListBox(open.options, cState.id, this.range));
            this.list.addEventListener("scroll", () => {
                if (this.info)
                    this.view.requestMeasure(this.placeInfo);
            });
        }
        if (this.updateSelectedOption(open.selected)) {
            if (this.info) {
                this.info.remove();
                this.info = null;
            }
            let option = open.options[open.selected];
            if (option.completion.info) {
                this.info = this.dom.appendChild(createInfoDialog(option, this.view));
                this.view.requestMeasure(this.placeInfo);
            }
        }
    }
    updateSelectedOption(selected) {
        let set = null;
        for (let opt = this.list.firstChild, i = this.range.from; opt; opt = opt.nextSibling, i++) {
            if (i == selected) {
                if (!opt.hasAttribute("aria-selected")) {
                    opt.setAttribute("aria-selected", "true");
                    set = opt;
                }
            }
            else {
                if (opt.hasAttribute("aria-selected"))
                    opt.removeAttribute("aria-selected");
            }
        }
        if (set)
            scrollIntoView(this.list, set);
        return set;
    }
    measureInfo() {
        let sel = this.dom.querySelector("[aria-selected]");
        if (!sel)
            return null;
        let rect = this.dom.getBoundingClientRect();
        let top = sel.getBoundingClientRect().top - rect.top;
        if (top < 0 || top > this.list.clientHeight - 10)
            return null;
        let left = this.view.textDirection == view.Direction.RTL;
        let spaceLeft = rect.left, spaceRight = innerWidth - rect.right;
        if (left && spaceLeft < Math.min(MaxInfoWidth, spaceRight))
            left = false;
        else if (!left && spaceRight < Math.min(MaxInfoWidth, spaceLeft))
            left = true;
        return { top, left };
    }
    positionInfo(pos) {
        if (this.info && pos) {
            this.info.style.top = pos.top + "px";
            this.info.classList.toggle("cm-completionInfo-left", pos.left);
            this.info.classList.toggle("cm-completionInfo-right", !pos.left);
        }
    }
}
// We allocate a new function instance every time the completion
// changes to force redrawing/repositioning of the tooltip
function completionTooltip(stateField) {
    return (view) => new CompletionTooltip(view, stateField);
}
function scrollIntoView(container, element) {
    let parent = container.getBoundingClientRect();
    let self = element.getBoundingClientRect();
    if (self.top < parent.top)
        container.scrollTop -= parent.top - self.top;
    else if (self.bottom > parent.bottom)
        container.scrollTop += self.bottom - parent.bottom;
}

const MaxOptions = 300;
// Used to pick a preferred option when two options with the same
// label occur in the result.
function score(option) {
    return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) +
        (option.type ? 1 : 0);
}
function sortOptions(active, state) {
    let options = [];
    for (let a of active)
        if (a.hasResult()) {
            let matcher = new FuzzyMatcher(state.sliceDoc(a.from, a.to)), match;
            for (let option of a.result.options)
                if (match = matcher.match(option.label)) {
                    if (option.boost != null)
                        match[0] += option.boost;
                    options.push(new Option(option, a, match));
                }
        }
    options.sort(cmpOption);
    let result = [], prev = null;
    for (let opt of options.sort(cmpOption)) {
        if (result.length == MaxOptions)
            break;
        if (!prev || prev.label != opt.completion.label || prev.detail != opt.completion.detail)
            result.push(opt);
        else if (score(opt.completion) > score(prev))
            result[result.length - 1] = opt;
        prev = opt.completion;
    }
    return result;
}
class CompletionDialog {
    constructor(options, attrs, tooltip, timestamp, selected) {
        this.options = options;
        this.attrs = attrs;
        this.tooltip = tooltip;
        this.timestamp = timestamp;
        this.selected = selected;
    }
    setSelected(selected, id) {
        return selected == this.selected || selected >= this.options.length ? this
            : new CompletionDialog(this.options, makeAttrs(id, selected), this.tooltip, this.timestamp, selected);
    }
    static build(active, state, id, prev) {
        let options = sortOptions(active, state);
        if (!options.length)
            return null;
        let selected = 0;
        if (prev && prev.selected) {
            let selectedValue = prev.options[prev.selected].completion;
            for (let i = 0; i < options.length && !selected; i++) {
                if (options[i].completion == selectedValue)
                    selected = i;
            }
        }
        return new CompletionDialog(options, makeAttrs(id, selected), {
            pos: active.reduce((a, b) => b.hasResult() ? Math.min(a, b.from) : a, 1e8),
            create: completionTooltip(completionState)
        }, prev ? prev.timestamp : Date.now(), selected);
    }
    map(changes) {
        return new CompletionDialog(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: changes.mapPos(this.tooltip.pos) }), this.timestamp, this.selected);
    }
}
class CompletionState {
    constructor(active, id, open) {
        this.active = active;
        this.id = id;
        this.open = open;
    }
    static start() {
        return new CompletionState(none, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
    }
    update(tr) {
        let { state } = tr, conf = state.facet(completionConfig);
        let sources = conf.override ||
            state.languageDataAt("autocomplete", cur(state)).map(asSource);
        let active = sources.map(source => {
            let value = this.active.find(s => s.source == source) || new ActiveSource(source, 0 /* Inactive */, false);
            return value.update(tr, conf);
        });
        if (active.length == this.active.length && active.every((a, i) => a == this.active[i]))
            active = this.active;
        let open = tr.selection || active.some(a => a.hasResult() && tr.changes.touchesRange(a.from, a.to)) ||
            !sameResults(active, this.active) ? CompletionDialog.build(active, state, this.id, this.open)
            : this.open && tr.docChanged ? this.open.map(tr.changes) : this.open;
        if (!open && active.every(a => a.state != 1 /* Pending */) && active.some(a => a.hasResult()))
            active = active.map(a => a.hasResult() ? new ActiveSource(a.source, 0 /* Inactive */, false) : a);
        for (let effect of tr.effects)
            if (effect.is(setSelectedEffect))
                open = open && open.setSelected(effect.value, this.id);
        return active == this.active && open == this.open ? this : new CompletionState(active, this.id, open);
    }
    get tooltip() { return this.open ? this.open.tooltip : null; }
    get attrs() { return this.open ? this.open.attrs : baseAttrs; }
}
function sameResults(a, b) {
    if (a == b)
        return true;
    for (let iA = 0, iB = 0;;) {
        while (iA < a.length && !a[iA].hasResult)
            iA++;
        while (iB < b.length && !b[iB].hasResult)
            iB++;
        let endA = iA == a.length, endB = iB == b.length;
        if (endA || endB)
            return endA == endB;
        if (a[iA++].result != b[iB++].result)
            return false;
    }
}
function makeAttrs(id, selected) {
    return {
        "aria-autocomplete": "list",
        "aria-activedescendant": id + "-" + selected,
        "aria-owns": id
    };
}
const baseAttrs = { "aria-autocomplete": "list" }, none = [];
function cmpOption(a, b) {
    let dScore = b.match[0] - a.match[0];
    if (dScore)
        return dScore;
    let lA = a.completion.label, lB = b.completion.label;
    return lA < lB ? -1 : lA == lB ? 0 : 1;
}
class ActiveSource {
    constructor(source, state, explicit) {
        this.source = source;
        this.state = state;
        this.explicit = explicit;
    }
    hasResult() { return false; }
    update(tr, conf) {
        let event = tr.annotation(state.Transaction.userEvent), value = this;
        if (event == "input" || event == "delete")
            value = value.handleUserEvent(tr, event, conf);
        else if (tr.docChanged)
            value = value.handleChange(tr);
        else if (tr.selection && value.state != 0 /* Inactive */)
            value = new ActiveSource(value.source, 0 /* Inactive */, false);
        for (let effect of tr.effects) {
            if (effect.is(startCompletionEffect))
                value = new ActiveSource(value.source, 1 /* Pending */, effect.value);
            else if (effect.is(closeCompletionEffect))
                value = new ActiveSource(value.source, 0 /* Inactive */, false);
            else if (effect.is(setActiveEffect))
                for (let active of effect.value)
                    if (active.source == value.source)
                        value = active;
        }
        return value;
    }
    handleUserEvent(_tr, type, conf) {
        return type == "delete" || !conf.activateOnTyping ? this : new ActiveSource(this.source, 1 /* Pending */, false);
    }
    handleChange(tr) {
        return tr.changes.touchesRange(cur(tr.startState)) ? new ActiveSource(this.source, 0 /* Inactive */, false) : this;
    }
}
class ActiveResult extends ActiveSource {
    constructor(source, explicit, result, from, to, span) {
        super(source, 2 /* Result */, explicit);
        this.result = result;
        this.from = from;
        this.to = to;
        this.span = span;
    }
    hasResult() { return true; }
    handleUserEvent(tr, type, conf) {
        let from = tr.changes.mapPos(this.from), to = tr.changes.mapPos(this.to, 1);
        let pos = cur(tr.state);
        if ((this.explicit ? pos < from : pos <= from) || pos > to)
            return new ActiveSource(this.source, type == "input" && conf.activateOnTyping ? 1 /* Pending */ : 0 /* Inactive */, false);
        if (this.span && (from == to || this.span.test(tr.state.sliceDoc(from, to))))
            return new ActiveResult(this.source, this.explicit, this.result, from, to, this.span);
        return new ActiveSource(this.source, 1 /* Pending */, this.explicit);
    }
    handleChange(tr) {
        return tr.changes.touchesRange(this.from, this.to)
            ? new ActiveSource(this.source, 0 /* Inactive */, false)
            : new ActiveResult(this.source, this.explicit, this.result, tr.changes.mapPos(this.from), tr.changes.mapPos(this.to, 1), this.span);
    }
    map(mapping) {
        return new ActiveResult(this.source, this.explicit, this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1), this.span);
    }
}
const startCompletionEffect = state.StateEffect.define();
const closeCompletionEffect = state.StateEffect.define();
const setActiveEffect = state.StateEffect.define({
    map(sources, mapping) { return sources.map(s => s.hasResult() && !mapping.empty ? s.map(mapping) : s); }
});
const setSelectedEffect = state.StateEffect.define();
const completionState = state.StateField.define({
    create() { return CompletionState.start(); },
    update(value, tr) { return value.update(tr); },
    provide: f => [
        tooltip.showTooltip.from(f, val => val.tooltip),
        view.EditorView.contentAttributes.from(f, state => state.attrs)
    ]
});

const CompletionInteractMargin = 75;
/**
Returns a command that moves the completion selection forward or
backward by the given amount.
*/
function moveCompletionSelection(forward, by = "option") {
    return (view) => {
        let cState = view.state.field(completionState, false);
        if (!cState || !cState.open || Date.now() - cState.open.timestamp < CompletionInteractMargin)
            return false;
        let step = 1, tooltip;
        if (by == "page" && (tooltip = view.dom.querySelector(".cm-tooltip-autocomplete")))
            step = Math.max(2, Math.floor(tooltip.offsetHeight / tooltip.firstChild.offsetHeight));
        let selected = cState.open.selected + step * (forward ? 1 : -1), { length } = cState.open.options;
        if (selected < 0)
            selected = by == "page" ? 0 : length - 1;
        else if (selected >= length)
            selected = by == "page" ? length - 1 : 0;
        view.dispatch({ effects: setSelectedEffect.of(selected) });
        return true;
    };
}
/**
Accept the current completion.
*/
const acceptCompletion = (view) => {
    let cState = view.state.field(completionState, false);
    if (!cState || !cState.open || Date.now() - cState.open.timestamp < CompletionInteractMargin)
        return false;
    applyCompletion(view, cState.open.options[cState.open.selected]);
    return true;
};
/**
Explicitly start autocompletion.
*/
const startCompletion = (view) => {
    let cState = view.state.field(completionState, false);
    if (!cState)
        return false;
    view.dispatch({ effects: startCompletionEffect.of(true) });
    return true;
};
/**
Close the currently active completion.
*/
const closeCompletion = (view) => {
    let cState = view.state.field(completionState, false);
    if (!cState || !cState.active.some(a => a.state != 0 /* Inactive */))
        return false;
    view.dispatch({ effects: closeCompletionEffect.of(null) });
    return true;
};
class RunningQuery {
    constructor(source, context) {
        this.source = source;
        this.context = context;
        this.time = Date.now();
        this.updates = [];
        // Note that 'undefined' means 'not done yet', whereas 'null' means
        // 'query returned null'.
        this.done = undefined;
    }
}
const DebounceTime = 50, MaxUpdateCount = 50, MinAbortTime = 1000;
const completionPlugin = view.ViewPlugin.fromClass(class {
    constructor(view) {
        this.view = view;
        this.debounceUpdate = -1;
        this.running = [];
        this.debounceAccept = -1;
        this.composing = 0 /* None */;
        for (let active of view.state.field(completionState).active)
            if (active.state == 1 /* Pending */)
                this.startQuery(active);
    }
    update(update) {
        let cState = update.state.field(completionState);
        if (!update.selectionSet && !update.docChanged && update.startState.field(completionState) == cState)
            return;
        let doesReset = update.transactions.some(tr => {
            let event = tr.annotation(state.Transaction.userEvent);
            return (tr.selection || tr.docChanged) && event != "input" && event != "delete";
        });
        for (let i = 0; i < this.running.length; i++) {
            let query = this.running[i];
            if (doesReset ||
                query.updates.length + update.transactions.length > MaxUpdateCount && query.time - Date.now() > MinAbortTime) {
                for (let handler of query.context.abortListeners) {
                    try {
                        handler();
                    }
                    catch (e) {
                        view.logException(this.view.state, e);
                    }
                }
                query.context.abortListeners = null;
                this.running.splice(i--, 1);
            }
            else {
                query.updates.push(...update.transactions);
            }
        }
        if (this.debounceUpdate > -1)
            clearTimeout(this.debounceUpdate);
        this.debounceUpdate = cState.active.some(a => a.state == 1 /* Pending */ && !this.running.some(q => q.source == a.source))
            ? setTimeout(() => this.startUpdate(), DebounceTime) : -1;
        if (this.composing != 0 /* None */)
            for (let tr of update.transactions) {
                if (tr.annotation(state.Transaction.userEvent) == "input")
                    this.composing = 2 /* Changed */;
                else if (this.composing == 2 /* Changed */ && tr.selection)
                    this.composing = 3 /* ChangedAndMoved */;
            }
    }
    startUpdate() {
        this.debounceUpdate = -1;
        let { state } = this.view, cState = state.field(completionState);
        for (let active of cState.active) {
            if (active.state == 1 /* Pending */ && !this.running.some(r => r.source == active.source))
                this.startQuery(active);
        }
    }
    startQuery(active) {
        let { state } = this.view, pos = cur(state);
        let context = new CompletionContext(state, pos, active.explicit);
        let pending = new RunningQuery(active.source, context);
        this.running.push(pending);
        Promise.resolve(active.source(context)).then(result => {
            if (!pending.context.aborted) {
                pending.done = result || null;
                this.scheduleAccept();
            }
        }, err => {
            this.view.dispatch({ effects: closeCompletionEffect.of(null) });
            view.logException(this.view.state, err);
        });
    }
    scheduleAccept() {
        if (this.running.every(q => q.done !== undefined))
            this.accept();
        else if (this.debounceAccept < 0)
            this.debounceAccept = setTimeout(() => this.accept(), DebounceTime);
    }
    // For each finished query in this.running, try to create a result
    // or, if appropriate, restart the query.
    accept() {
        var _a;
        if (this.debounceAccept > -1)
            clearTimeout(this.debounceAccept);
        this.debounceAccept = -1;
        let updated = [];
        let conf = this.view.state.facet(completionConfig);
        for (let i = 0; i < this.running.length; i++) {
            let query = this.running[i];
            if (query.done === undefined)
                continue;
            this.running.splice(i--, 1);
            if (query.done) {
                let active = new ActiveResult(query.source, query.context.explicit, query.done, query.done.from, (_a = query.done.to) !== null && _a !== void 0 ? _a : cur(query.updates.length ? query.updates[0].startState : this.view.state), query.done.span ? ensureAnchor(query.done.span, true) : null);
                // Replay the transactions that happened since the start of
                // the request and see if that preserves the result
                for (let tr of query.updates)
                    active = active.update(tr, conf);
                if (active.hasResult()) {
                    updated.push(active);
                    continue;
                }
            }
            let current = this.view.state.field(completionState).active.find(a => a.source == query.source);
            if (current && current.state == 1 /* Pending */) {
                if (query.done == null) {
                    // Explicitly failed. Should clear the pending status if it
                    // hasn't been re-set in the meantime.
                    let active = new ActiveSource(query.source, 0 /* Inactive */, false);
                    for (let tr of query.updates)
                        active = active.update(tr, conf);
                    if (active.state != 1 /* Pending */)
                        updated.push(active);
                }
                else {
                    // Cleared by subsequent transactions. Restart.
                    this.startQuery(current);
                }
            }
        }
        if (updated.length)
            this.view.dispatch({ effects: setActiveEffect.of(updated) });
    }
}, {
    eventHandlers: {
        compositionstart() {
            this.composing = 1 /* Started */;
        },
        compositionend() {
            if (this.composing == 3 /* ChangedAndMoved */)
                this.view.dispatch({ effects: startCompletionEffect.of(false) });
            this.composing = 0 /* None */;
        }
    }
});

class FieldPos {
    constructor(field, line, from, to) {
        this.field = field;
        this.line = line;
        this.from = from;
        this.to = to;
    }
}
class FieldRange {
    constructor(field, from, to) {
        this.field = field;
        this.from = from;
        this.to = to;
    }
    map(changes) {
        return new FieldRange(this.field, changes.mapPos(this.from, -1), changes.mapPos(this.to, 1));
    }
}
class Snippet {
    constructor(lines, fieldPositions) {
        this.lines = lines;
        this.fieldPositions = fieldPositions;
    }
    instantiate(state, pos) {
        let text = [], lineStart = [pos];
        let lineObj = state.doc.lineAt(pos), baseIndent = /^\s*/.exec(lineObj.text)[0];
        for (let line of this.lines) {
            if (text.length) {
                let indent = baseIndent, tabs = /^\t*/.exec(line)[0].length;
                for (let i = 0; i < tabs; i++)
                    indent += state.facet(language.indentUnit);
                lineStart.push(pos + indent.length - tabs);
                line = indent + line.slice(tabs);
            }
            text.push(line);
            pos += line.length + 1;
        }
        let ranges = this.fieldPositions.map(pos => new FieldRange(pos.field, lineStart[pos.line] + pos.from, lineStart[pos.line] + pos.to));
        return { text, ranges };
    }
    static parse(template) {
        let fields = [];
        let lines = [], positions = [], m;
        for (let line of template.split(/\r\n?|\n/)) {
            while (m = /[#$]\{(?:(\d+)(?::([^}]*))?|([^}]*))\}/.exec(line)) {
                let seq = m[1] ? +m[1] : null, name = m[2] || m[3], found = -1;
                for (let i = 0; i < fields.length; i++) {
                    if (name ? fields[i].name == name : seq != null && fields[i].seq == seq)
                        found = i;
                }
                if (found < 0) {
                    let i = 0;
                    while (i < fields.length && (seq == null || (fields[i].seq != null && fields[i].seq < seq)))
                        i++;
                    fields.splice(i, 0, { seq, name: name || null });
                    found = i;
                }
                positions.push(new FieldPos(found, lines.length, m.index, m.index + name.length));
                line = line.slice(0, m.index) + name + line.slice(m.index + m[0].length);
            }
            lines.push(line);
        }
        return new Snippet(lines, positions);
    }
}
let fieldMarker = view.Decoration.widget({ widget: new class extends view.WidgetType {
        toDOM() {
            let span = document.createElement("span");
            span.className = "cm-snippetFieldPosition";
            return span;
        }
        ignoreEvent() { return false; }
    } });
let fieldRange = view.Decoration.mark({ class: "cm-snippetField" });
class ActiveSnippet {
    constructor(ranges, active) {
        this.ranges = ranges;
        this.active = active;
        this.deco = view.Decoration.set(ranges.map(r => (r.from == r.to ? fieldMarker : fieldRange).range(r.from, r.to)));
    }
    map(changes) {
        return new ActiveSnippet(this.ranges.map(r => r.map(changes)), this.active);
    }
    selectionInsideField(sel) {
        return sel.ranges.every(range => this.ranges.some(r => r.field == this.active && r.from <= range.from && r.to >= range.to));
    }
}
const setActive = state.StateEffect.define({
    map(value, changes) { return value && value.map(changes); }
});
const moveToField = state.StateEffect.define();
const snippetState = state.StateField.define({
    create() { return null; },
    update(value, tr) {
        for (let effect of tr.effects) {
            if (effect.is(setActive))
                return effect.value;
            if (effect.is(moveToField) && value)
                return new ActiveSnippet(value.ranges, effect.value);
        }
        if (value && tr.docChanged)
            value = value.map(tr.changes);
        if (value && tr.selection && !value.selectionInsideField(tr.selection))
            value = null;
        return value;
    },
    provide: f => view.EditorView.decorations.from(f, val => val ? val.deco : view.Decoration.none)
});
function fieldSelection(ranges, field) {
    return state.EditorSelection.create(ranges.filter(r => r.field == field).map(r => state.EditorSelection.range(r.from, r.to)));
}
/**
Convert a snippet template to a function that can apply it.
Snippets are written using syntax like this:

    "for (let ${index} = 0; ${index} < ${end}; ${index}++) {\n\t${}\n}"

Each `${}` placeholder (you may also use `#{}`) indicates a field
that the user can fill in. Its name, if any, will be the default
content for the field.

When the snippet is activated by calling the returned function,
the code is inserted at the given position. Newlines in the
template are indented by the indentation of the start line, plus
one [indent unit](https://codemirror.net/6/docs/ref/#language.indentUnit) per tab character after
the newline.

On activation, (all instances of) the first field are selected.
The user can move between fields with Tab and Shift-Tab as long as
the fields are active. Moving to the last field or moving the
cursor out of the current field deactivates the fields.

The order of fields defaults to textual order, but you can add
numbers to placeholders (`${1}` or `${1:defaultText}`) to provide
a custom order.
*/
function snippet(template) {
    let snippet = Snippet.parse(template);
    return (editor, _completion, from, to) => {
        let { text, ranges } = snippet.instantiate(editor.state, from);
        let spec = { changes: { from, to, insert: state.Text.of(text) } };
        if (ranges.length)
            spec.selection = fieldSelection(ranges, 0);
        if (ranges.length > 1) {
            let effects = spec.effects = [setActive.of(new ActiveSnippet(ranges, 0))];
            if (editor.state.field(snippetState, false) === undefined)
                effects.push(state.StateEffect.appendConfig.of([snippetState, addSnippetKeymap, snippetPointerHandler, baseTheme]));
        }
        editor.dispatch(editor.state.update(spec));
    };
}
function moveField(dir) {
    return ({ state, dispatch }) => {
        let active = state.field(snippetState, false);
        if (!active || dir < 0 && active.active == 0)
            return false;
        let next = active.active + dir, last = dir > 0 && !active.ranges.some(r => r.field == next + dir);
        dispatch(state.update({
            selection: fieldSelection(active.ranges, next),
            effects: setActive.of(last ? null : new ActiveSnippet(active.ranges, next))
        }));
        return true;
    };
}
/**
A command that clears the active snippet, if any.
*/
const clearSnippet = ({ state, dispatch }) => {
    let active = state.field(snippetState, false);
    if (!active)
        return false;
    dispatch(state.update({ effects: setActive.of(null) }));
    return true;
};
/**
Move to the next snippet field, if available.
*/
const nextSnippetField = moveField(1);
/**
Move to the previous snippet field, if available.
*/
const prevSnippetField = moveField(-1);
const defaultSnippetKeymap = [
    { key: "Tab", run: nextSnippetField, shift: prevSnippetField },
    { key: "Escape", run: clearSnippet }
];
/**
A facet that can be used to configure the key bindings used by
snippets. The default binds Tab to
[`nextSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.nextSnippetField), Shift-Tab to
[`prevSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.prevSnippetField), and Escape
to [`clearSnippet`](https://codemirror.net/6/docs/ref/#autocomplete.clearSnippet).
*/
const snippetKeymap = state.Facet.define({
    combine(maps) { return maps.length ? maps[0] : defaultSnippetKeymap; }
});
const addSnippetKeymap = state.Prec.override(view.keymap.compute([snippetKeymap], state => state.facet(snippetKeymap)));
/**
Create a completion from a snippet. Returns an object with the
properties from `completion`, plus an `apply` function that
applies the snippet.
*/
function snippetCompletion(template, completion) {
    return Object.assign(Object.assign({}, completion), { apply: snippet(template) });
}
const snippetPointerHandler = view.EditorView.domEventHandlers({
    mousedown(event, view) {
        let active = view.state.field(snippetState, false), pos;
        if (!active || (pos = view.posAtCoords({ x: event.clientX, y: event.clientY })) == null)
            return false;
        let match = active.ranges.find(r => r.from <= pos && r.to >= pos);
        if (!match || match.field == active.active)
            return false;
        view.dispatch({
            selection: fieldSelection(active.ranges, match.field),
            effects: setActive.of(active.ranges.some(r => r.field > match.field) ? new ActiveSnippet(active.ranges, match.field) : null)
        });
        return true;
    }
});

/**
A completion source that will scan the document for words (using a
[character categorizer](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer)), and
return those as completions.
*/
const completeAnyWord = context => {
    let options = [], seen = Object.create(null);
    let cat = context.state.charCategorizer(context.pos);
    let start = Math.max(0, context.pos - 50000 /* Range */), end = Math.min(context.state.doc.length, start + 50000 /* Range */ * 2);
    let from = context.pos;
    for (let cur = context.state.doc.iterRange(start, end), pos = start; !(cur.next()).done;) {
        let { value } = cur, start = -1;
        for (let i = 0;; i++) {
            if (i < value.length && cat(value[i]) == state.CharCategory.Word) {
                if (start < 0)
                    start = i;
            }
            else if (start > -1) {
                if (pos + start <= context.pos && pos + i >= context.pos) {
                    from = pos + start;
                }
                else {
                    let word = value.slice(start, i);
                    if (!seen[word]) {
                        options.push({ type: "text", label: word });
                        seen[word] = true;
                    }
                }
                start = -1;
            }
            if (i == value.length)
                break;
        }
        pos += value.length;
    }
    return { from, options, span: /^\w*/ };
};

/**
Returns an extension that enables autocompletion.
*/
function autocompletion(config = {}) {
    return [
        completionState,
        completionConfig.of(config),
        completionPlugin,
        completionKeymapExt,
        baseTheme
    ];
}
/**
Basic keybindings for autocompletion.

 - Ctrl-Space: [`startCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.startCompletion)
 - Escape: [`closeCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.closeCompletion)
 - ArrowDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true)`
 - ArrowUp: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(false)`
 - PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, "page")`
 - PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, "page")`
 - Enter: [`acceptCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.acceptCompletion)
*/
const completionKeymap = [
    { key: "Ctrl-Space", run: startCompletion },
    { key: "Escape", run: closeCompletion },
    { key: "ArrowDown", run: moveCompletionSelection(true) },
    { key: "ArrowUp", run: moveCompletionSelection(false) },
    { key: "PageDown", run: moveCompletionSelection(true, "page") },
    { key: "PageUp", run: moveCompletionSelection(false, "page") },
    { key: "Enter", run: acceptCompletion }
];
const completionKeymapExt = state.Prec.override(view.keymap.computeN([completionConfig], state => state.facet(completionConfig).defaultKeymap ? [completionKeymap] : []));
/**
Get the current completion status. When completions are available,
this will return `"active"`. When completions are pending (in the
process of being queried), this returns `"pending"`. Otherwise, it
returns `null`.
*/
function completionStatus(state) {
    let cState = state.field(completionState, false);
    return cState && cState.active.some(a => a.state == 1 /* Pending */) ? "pending"
        : cState && cState.active.some(a => a.state != 0 /* Inactive */) ? "active" : null;
}
/**
Returns the available completions as an array.
*/
function currentCompletions(state) {
    var _a;
    let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;
    return open ? open.options.map(o => o.completion) : [];
}

exports.CompletionContext = CompletionContext;
exports.acceptCompletion = acceptCompletion;
exports.autocompletion = autocompletion;
exports.clearSnippet = clearSnippet;
exports.closeCompletion = closeCompletion;
exports.completeAnyWord = completeAnyWord;
exports.completeFromList = completeFromList;
exports.completionKeymap = completionKeymap;
exports.completionStatus = completionStatus;
exports.currentCompletions = currentCompletions;
exports.ifNotIn = ifNotIn;
exports.moveCompletionSelection = moveCompletionSelection;
exports.nextSnippetField = nextSnippetField;
exports.prevSnippetField = prevSnippetField;
exports.snippet = snippet;
exports.snippetCompletion = snippetCompletion;
exports.snippetKeymap = snippetKeymap;
exports.startCompletion = startCompletion;

},{"@codemirror/language":10,"@codemirror/state":17,"@codemirror/text":18,"@codemirror/tooltip":19,"@codemirror/view":20}],2:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var view = require('@codemirror/view');
var state = require('@codemirror/state');
var history = require('@codemirror/history');
var fold = require('@codemirror/fold');
var language = require('@codemirror/language');
var gutter = require('@codemirror/gutter');
var commands = require('@codemirror/commands');
var matchbrackets = require('@codemirror/matchbrackets');
var closebrackets = require('@codemirror/closebrackets');
var search = require('@codemirror/search');
var autocomplete = require('@codemirror/autocomplete');
var comment = require('@codemirror/comment');
var rectangularSelection = require('@codemirror/rectangular-selection');
var highlight = require('@codemirror/highlight');
var lint = require('@codemirror/lint');

/// This is an extension value that just pulls together a whole lot of
/// extensions that you might want in a basic editor. It is meant as a
/// convenient helper to quickly set up CodeMirror without installing
/// and importing a lot of packages.
///
/// Specifically, it includes...
///
///  - [the default command bindings](#commands.defaultKeymap)
///  - [line numbers](#gutter.lineNumbers)
///  - [special character highlighting](#view.highlightSpecialChars)
///  - [the undo history](#history.history)
///  - [a fold gutter](#fold.foldGutter)
///  - [custom selection drawing](#view.drawSelection)
///  - [multiple selections](#state.EditorState^allowMultipleSelections)
///  - [reindentation on input](#language.indentOnInput)
///  - [the default highlight style](#highlight.defaultHighlightStyle) (as fallback)
///  - [bracket matching](#matchbrackets.bracketMatching)
///  - [bracket closing](#closebrackets.closeBrackets)
///  - [autocompletion](#autocomplete.autocompletion)
///  - [rectangular selection](#rectangular-selection.rectangularSelection)
///  - [active line highlighting](#view.highlightActiveLine)
///  - [selection match highlighting](#search.highlightSelectionMatches)
///  - [search](#search.searchKeymap)
///  - [commenting](#comment.commentKeymap)
///  - [linting](#lint.lintKeymap)
///
/// (You'll probably want to add some language package to your setup
/// too.)
///
/// This package does not allow customization. The idea is that, once
/// you decide you want to configure your editor more precisely, you
/// take this package's source (which is just a bunch of imports and
/// an array literal), copy it into your own code, and adjust it as
/// desired.
const basicSetup = [
    gutter.lineNumbers(),
    view.highlightSpecialChars(),
    history.history(),
    fold.foldGutter(),
    view.drawSelection(),
    state.EditorState.allowMultipleSelections.of(true),
    language.indentOnInput(),
    highlight.defaultHighlightStyle.fallback,
    matchbrackets.bracketMatching(),
    closebrackets.closeBrackets(),
    autocomplete.autocompletion(),
    rectangularSelection.rectangularSelection(),
    view.highlightActiveLine(),
    search.highlightSelectionMatches(),
    view.keymap.of([
        ...closebrackets.closeBracketsKeymap,
        ...commands.defaultKeymap,
        ...search.searchKeymap,
        ...history.historyKeymap,
        ...fold.foldKeymap,
        ...comment.commentKeymap,
        ...autocomplete.completionKeymap,
        ...lint.lintKeymap
    ])
];

Object.defineProperty(exports, 'EditorView', {
    enumerable: true,
    get: function () {
        return view.EditorView;
    }
});
Object.defineProperty(exports, 'EditorState', {
    enumerable: true,
    get: function () {
        return state.EditorState;
    }
});
exports.basicSetup = basicSetup;

},{"@codemirror/autocomplete":1,"@codemirror/closebrackets":3,"@codemirror/commands":4,"@codemirror/comment":5,"@codemirror/fold":6,"@codemirror/gutter":7,"@codemirror/highlight":8,"@codemirror/history":9,"@codemirror/language":10,"@codemirror/lint":11,"@codemirror/matchbrackets":12,"@codemirror/rectangular-selection":15,"@codemirror/search":16,"@codemirror/state":17,"@codemirror/view":20}],3:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var view = require('@codemirror/view');
var state = require('@codemirror/state');
var rangeset = require('@codemirror/rangeset');
var text = require('@codemirror/text');
var language = require('@codemirror/language');

const defaults = {
    brackets: ["(", "[", "{", "'", '"'],
    before: ")]}'\":;>"
};
const closeBracketEffect = state.StateEffect.define({
    map(value, mapping) {
        let mapped = mapping.mapPos(value, -1, state.MapMode.TrackAfter);
        return mapped == null ? undefined : mapped;
    }
});
const skipBracketEffect = state.StateEffect.define({
    map(value, mapping) { return mapping.mapPos(value); }
});
const closedBracket = new class extends rangeset.RangeValue {
};
closedBracket.startSide = 1;
closedBracket.endSide = -1;
const bracketState = state.StateField.define({
    create() { return rangeset.RangeSet.empty; },
    update(value, tr) {
        if (tr.selection) {
            let lineStart = tr.state.doc.lineAt(tr.selection.main.head).from;
            let prevLineStart = tr.startState.doc.lineAt(tr.startState.selection.main.head).from;
            if (lineStart != tr.changes.mapPos(prevLineStart, -1))
                value = rangeset.RangeSet.empty;
        }
        value = value.map(tr.changes);
        for (let effect of tr.effects) {
            if (effect.is(closeBracketEffect))
                value = value.update({ add: [closedBracket.range(effect.value, effect.value + 1)] });
            else if (effect.is(skipBracketEffect))
                value = value.update({ filter: from => from != effect.value });
        }
        return value;
    }
});
/// Extension to enable bracket-closing behavior. When a closeable
/// bracket is typed, its closing bracket is immediately inserted
/// after the cursor. When closing a bracket directly in front of a
/// closing bracket inserted by the extension, the cursor moves over
/// that bracket.
function closeBrackets() {
    return [view.EditorView.inputHandler.of(handleInput), bracketState];
}
const definedClosing = "()[]{}<>";
function closing(ch) {
    for (let i = 0; i < definedClosing.length; i += 2)
        if (definedClosing.charCodeAt(i) == ch)
            return definedClosing.charAt(i + 1);
    return text.fromCodePoint(ch < 128 ? ch : ch + 1);
}
function config(state, pos) {
    return state.languageDataAt("closeBrackets", pos)[0] || defaults;
}
function handleInput(view, from, to, insert) {
    if (view.composing)
        return false;
    let sel = view.state.selection.main;
    if (insert.length > 2 || insert.length == 2 && text.codePointSize(text.codePointAt(insert, 0)) == 1 ||
        from != sel.from || to != sel.to)
        return false;
    let tr = insertBracket(view.state, insert);
    if (!tr)
        return false;
    view.dispatch(tr);
    return true;
}
/// Command that implements deleting a pair of matching brackets when
/// the cursor is between them.
const deleteBracketPair = ({ state: state$1, dispatch }) => {
    let conf = config(state$1, state$1.selection.main.head);
    let tokens = conf.brackets || defaults.brackets;
    let dont = null, changes = state$1.changeByRange(range => {
        if (range.empty) {
            let before = prevChar(state$1.doc, range.head);
            for (let token of tokens) {
                if (token == before && nextChar(state$1.doc, range.head) == closing(text.codePointAt(token, 0)))
                    return { changes: { from: range.head - token.length, to: range.head + token.length },
                        range: state.EditorSelection.cursor(range.head - token.length),
                        annotations: state.Transaction.userEvent.of("delete") };
            }
        }
        return { range: dont = range };
    });
    if (!dont)
        dispatch(state$1.update(changes, { scrollIntoView: true }));
    return !dont;
};
/// Close-brackets related key bindings. Binds Backspace to
/// [`deleteBracketPair`](#closebrackets.deleteBracketPair).
const closeBracketsKeymap = [
    { key: "Backspace", run: deleteBracketPair }
];
/// Implements the extension's behavior on text insertion. If the
/// given string counts as a bracket in the language around the
/// selection, and replacing the selection with it requires custom
/// behavior (inserting a closing version or skipping past a
/// previously-closed bracket), this function returns a transaction
/// representing that custom behavior. (You only need this if you want
/// to programmatically insert brackets‚Äîthe
/// [`closeBrackets`](#closebrackets.closeBrackets) extension will
/// take care of running this for user input.)
function insertBracket(state, bracket) {
    let conf = config(state, state.selection.main.head);
    let tokens = conf.brackets || defaults.brackets;
    for (let tok of tokens) {
        let closed = closing(text.codePointAt(tok, 0));
        if (bracket == tok)
            return closed == tok ? handleSame(state, tok, tokens.indexOf(tok + tok + tok) > -1)
                : handleOpen(state, tok, closed, conf.before || defaults.before);
        if (bracket == closed && closedBracketAt(state, state.selection.main.from))
            return handleClose(state, tok, closed);
    }
    return null;
}
function closedBracketAt(state, pos) {
    let found = false;
    state.field(bracketState).between(0, state.doc.length, from => {
        if (from == pos)
            found = true;
    });
    return found;
}
function nextChar(doc, pos) {
    let next = doc.sliceString(pos, pos + 2);
    return next.slice(0, text.codePointSize(text.codePointAt(next, 0)));
}
function prevChar(doc, pos) {
    let prev = doc.sliceString(pos - 2, pos);
    return text.codePointSize(text.codePointAt(prev, 0)) == prev.length ? prev : prev.slice(1);
}
function handleOpen(state$1, open, close, closeBefore) {
    let dont = null, changes = state$1.changeByRange(range => {
        if (!range.empty)
            return { changes: [{ insert: open, from: range.from }, { insert: close, from: range.to }],
                effects: closeBracketEffect.of(range.to + open.length),
                range: state.EditorSelection.range(range.anchor + open.length, range.head + open.length) };
        let next = nextChar(state$1.doc, range.head);
        if (!next || /\s/.test(next) || closeBefore.indexOf(next) > -1)
            return { changes: { insert: open + close, from: range.head },
                effects: closeBracketEffect.of(range.head + open.length),
                range: state.EditorSelection.cursor(range.head + open.length) };
        return { range: dont = range };
    });
    return dont ? null : state$1.update(changes, {
        scrollIntoView: true,
        annotations: state.Transaction.userEvent.of("input")
    });
}
function handleClose(state$1, _open, close) {
    let dont = null, moved = state$1.selection.ranges.map(range => {
        if (range.empty && nextChar(state$1.doc, range.head) == close)
            return state.EditorSelection.cursor(range.head + close.length);
        return dont = range;
    });
    return dont ? null : state$1.update({
        selection: state.EditorSelection.create(moved, state$1.selection.mainIndex),
        scrollIntoView: true,
        effects: state$1.selection.ranges.map(({ from }) => skipBracketEffect.of(from))
    });
}
// Handles cases where the open and close token are the same, and
// possibly triple quotes (as in `"""abc"""`-style quoting).
function handleSame(state$1, token, allowTriple) {
    let dont = null, changes = state$1.changeByRange(range => {
        if (!range.empty)
            return { changes: [{ insert: token, from: range.from }, { insert: token, from: range.to }],
                effects: closeBracketEffect.of(range.to + token.length),
                range: state.EditorSelection.range(range.anchor + token.length, range.head + token.length) };
        let pos = range.head, next = nextChar(state$1.doc, pos);
        if (next == token) {
            if (nodeStart(state$1, pos)) {
                return { changes: { insert: token + token, from: pos },
                    effects: closeBracketEffect.of(pos + token.length),
                    range: state.EditorSelection.cursor(pos + token.length) };
            }
            else if (closedBracketAt(state$1, pos)) {
                let isTriple = allowTriple && state$1.sliceDoc(pos, pos + token.length * 3) == token + token + token;
                return { range: state.EditorSelection.cursor(pos + token.length * (isTriple ? 3 : 1)),
                    effects: skipBracketEffect.of(pos) };
            }
        }
        else if (allowTriple && state$1.sliceDoc(pos - 2 * token.length, pos) == token + token &&
            nodeStart(state$1, pos - 2 * token.length)) {
            return { changes: { insert: token + token + token + token, from: pos },
                effects: closeBracketEffect.of(pos + token.length),
                range: state.EditorSelection.cursor(pos + token.length) };
        }
        else if (state$1.charCategorizer(pos)(next) != state.CharCategory.Word) {
            let prev = state$1.sliceDoc(pos - 1, pos);
            if (prev != token && state$1.charCategorizer(pos)(prev) != state.CharCategory.Word)
                return { changes: { insert: token + token, from: pos },
                    effects: closeBracketEffect.of(pos + token.length),
                    range: state.EditorSelection.cursor(pos + token.length) };
        }
        return { range: dont = range };
    });
    return dont ? null : state$1.update(changes, {
        scrollIntoView: true,
        annotations: state.Transaction.userEvent.of("input")
    });
}
function nodeStart(state, pos) {
    let tree = language.syntaxTree(state).resolve(pos + 1);
    return tree.parent && tree.from == pos;
}

exports.closeBrackets = closeBrackets;
exports.closeBracketsKeymap = closeBracketsKeymap;
exports.deleteBracketPair = deleteBracketPair;
exports.insertBracket = insertBracket;

},{"@codemirror/language":10,"@codemirror/rangeset":14,"@codemirror/state":17,"@codemirror/text":18,"@codemirror/view":20}],4:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var state = require('@codemirror/state');
var text = require('@codemirror/text');
var view = require('@codemirror/view');
var matchbrackets = require('@codemirror/matchbrackets');
var language = require('@codemirror/language');
var lezerTree = require('lezer-tree');

function updateSel(sel, by) {
    return state.EditorSelection.create(sel.ranges.map(by), sel.mainIndex);
}
function setSel(state$1, selection) {
    return state$1.update({ selection, scrollIntoView: true, annotations: state.Transaction.userEvent.of("keyboardselection") });
}
function moveSel({ state, dispatch }, how) {
    let selection = updateSel(state.selection, how);
    if (selection.eq(state.selection))
        return false;
    dispatch(setSel(state, selection));
    return true;
}
function rangeEnd(range, forward) {
    return state.EditorSelection.cursor(forward ? range.to : range.from);
}
function cursorByChar(view, forward) {
    return moveSel(view, range => range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));
}
/**
Move the selection one character to the left (which is backward in
left-to-right text, forward in right-to-left text).
*/
const cursorCharLeft = view$1 => cursorByChar(view$1, view$1.textDirection != view.Direction.LTR);
/**
Move the selection one character to the right.
*/
const cursorCharRight = view$1 => cursorByChar(view$1, view$1.textDirection == view.Direction.LTR);
/**
Move the selection one character forward.
*/
const cursorCharForward = view => cursorByChar(view, true);
/**
Move the selection one character backward.
*/
const cursorCharBackward = view => cursorByChar(view, false);
function cursorByGroup(view, forward) {
    return moveSel(view, range => range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));
}
/**
Move the selection across one group of word or non-word (but also
non-space) characters.
*/
const cursorGroupLeft = view$1 => cursorByGroup(view$1, view$1.textDirection != view.Direction.LTR);
/**
Move the selection one group to the right.
*/
const cursorGroupRight = view$1 => cursorByGroup(view$1, view$1.textDirection == view.Direction.LTR);
/**
Move the selection one group forward.
*/
const cursorGroupForward = view => cursorByGroup(view, true);
/**
Move the selection one group backward.
*/
const cursorGroupBackward = view => cursorByGroup(view, false);
function interestingNode(state, node, bracketProp) {
    if (node.type.prop(bracketProp))
        return true;
    let len = node.to - node.from;
    return len && (len > 2 || /[^\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;
}
function moveBySyntax(state$1, start, forward) {
    let pos = language.syntaxTree(state$1).resolve(start.head);
    let bracketProp = forward ? lezerTree.NodeProp.closedBy : lezerTree.NodeProp.openedBy;
    // Scan forward through child nodes to see if there's an interesting
    // node ahead.
    for (let at = start.head;;) {
        let next = forward ? pos.childAfter(at) : pos.childBefore(at);
        if (!next)
            break;
        if (interestingNode(state$1, next, bracketProp))
            pos = next;
        else
            at = forward ? next.to : next.from;
    }
    let bracket = pos.type.prop(bracketProp), match, newPos;
    if (bracket && (match = forward ? matchbrackets.matchBrackets(state$1, pos.from, 1) : matchbrackets.matchBrackets(state$1, pos.to, -1)) && match.matched)
        newPos = forward ? match.end.to : match.end.from;
    else
        newPos = forward ? pos.to : pos.from;
    return state.EditorSelection.cursor(newPos, forward ? -1 : 1);
}
/**
Move the cursor over the next syntactic element to the left.
*/
const cursorSyntaxLeft = view$1 => moveSel(view$1, range => moveBySyntax(view$1.state, range, view$1.textDirection != view.Direction.LTR));
/**
Move the cursor over the next syntactic element to the right.
*/
const cursorSyntaxRight = view$1 => moveSel(view$1, range => moveBySyntax(view$1.state, range, view$1.textDirection == view.Direction.LTR));
function cursorByLine(view, forward) {
    return moveSel(view, range => range.empty ? view.moveVertically(range, forward) : rangeEnd(range, forward));
}
/**
Move the selection one line up.
*/
const cursorLineUp = view => cursorByLine(view, false);
/**
Move the selection one line down.
*/
const cursorLineDown = view => cursorByLine(view, true);
function cursorByPage(view, forward) {
    return moveSel(view, range => range.empty ? view.moveVertically(range, forward, view.dom.clientHeight) : rangeEnd(range, forward));
}
/**
Move the selection one page up.
*/
const cursorPageUp = view => cursorByPage(view, false);
/**
Move the selection one page down.
*/
const cursorPageDown = view => cursorByPage(view, true);
function moveByLineBoundary(view, start, forward) {
    let line = view.visualLineAt(start.head), moved = view.moveToLineBoundary(start, forward);
    if (moved.head == start.head && moved.head != (forward ? line.to : line.from))
        moved = view.moveToLineBoundary(start, forward, false);
    if (!forward && moved.head == line.from && line.length) {
        let space = /^\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;
        if (space && start.head != line.from + space)
            moved = state.EditorSelection.cursor(line.from + space);
    }
    return moved;
}
/**
Move the selection to the next line wrap point, or to the end of
the line if there isn't one left on this line.
*/
const cursorLineBoundaryForward = view => moveSel(view, range => moveByLineBoundary(view, range, true));
/**
Move the selection to previous line wrap point, or failing that to
the start of the line. If the line is indented, and the cursor
isn't already at the end of the indentation, this will move to the
end of the indentation instead of the start of the line.
*/
const cursorLineBoundaryBackward = view => moveSel(view, range => moveByLineBoundary(view, range, false));
/**
Move the selection to the start of the line.
*/
const cursorLineStart = view => moveSel(view, range => state.EditorSelection.cursor(view.visualLineAt(range.head).from, 1));
/**
Move the selection to the end of the line.
*/
const cursorLineEnd = view => moveSel(view, range => state.EditorSelection.cursor(view.visualLineAt(range.head).to, -1));
function toMatchingBracket(state$1, dispatch, extend) {
    let found = false, selection = updateSel(state$1.selection, range => {
        let matching = matchbrackets.matchBrackets(state$1, range.head, -1)
            || matchbrackets.matchBrackets(state$1, range.head, 1)
            || (range.head > 0 && matchbrackets.matchBrackets(state$1, range.head - 1, 1))
            || (range.head < state$1.doc.length && matchbrackets.matchBrackets(state$1, range.head + 1, -1));
        if (!matching || !matching.end)
            return range;
        found = true;
        let head = matching.start.from == range.head ? matching.end.to : matching.end.from;
        return extend ? state.EditorSelection.range(range.anchor, head) : state.EditorSelection.cursor(head);
    });
    if (!found)
        return false;
    dispatch(setSel(state$1, selection));
    return true;
}
/**
Move the selection to the bracket matching the one it is currently
on, if any.
*/
const cursorMatchingBracket = ({ state, dispatch }) => toMatchingBracket(state, dispatch, false);
/**
Extend the selection to the bracket matching the one the selection
head is currently on, if any.
*/
const selectMatchingBracket = ({ state, dispatch }) => toMatchingBracket(state, dispatch, true);
function extendSel(view, how) {
    let selection = updateSel(view.state.selection, range => {
        let head = how(range);
        return state.EditorSelection.range(range.anchor, head.head, head.goalColumn);
    });
    if (selection.eq(view.state.selection))
        return false;
    view.dispatch(setSel(view.state, selection));
    return true;
}
function selectByChar(view, forward) {
    return extendSel(view, range => view.moveByChar(range, forward));
}
/**
Move the selection head one character to the left, while leaving
the anchor in place.
*/
const selectCharLeft = view$1 => selectByChar(view$1, view$1.textDirection != view.Direction.LTR);
/**
Move the selection head one character to the right.
*/
const selectCharRight = view$1 => selectByChar(view$1, view$1.textDirection == view.Direction.LTR);
/**
Move the selection head one character forward.
*/
const selectCharForward = view => selectByChar(view, true);
/**
Move the selection head one character backward.
*/
const selectCharBackward = view => selectByChar(view, false);
function selectByGroup(view, forward) {
    return extendSel(view, range => view.moveByGroup(range, forward));
}
/**
Move the selection head one [group](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) to
the left.
*/
const selectGroupLeft = view$1 => selectByGroup(view$1, view$1.textDirection != view.Direction.LTR);
/**
Move the selection head one group to the right.
*/
const selectGroupRight = view$1 => selectByGroup(view$1, view$1.textDirection == view.Direction.LTR);
/**
Move the selection head one group forward.
*/
const selectGroupForward = view => selectByGroup(view, true);
/**
Move the selection head one group backward.
*/
const selectGroupBackward = view => selectByGroup(view, false);
/**
Move the selection head over the next syntactic element to the left.
*/
const selectSyntaxLeft = view$1 => extendSel(view$1, range => moveBySyntax(view$1.state, range, view$1.textDirection != view.Direction.LTR));
/**
Move the selection head over the next syntactic element to the right.
*/
const selectSyntaxRight = view$1 => extendSel(view$1, range => moveBySyntax(view$1.state, range, view$1.textDirection == view.Direction.LTR));
function selectByLine(view, forward) {
    return extendSel(view, range => view.moveVertically(range, forward));
}
/**
Move the selection head one line up.
*/
const selectLineUp = view => selectByLine(view, false);
/**
Move the selection head one line down.
*/
const selectLineDown = view => selectByLine(view, true);
function selectByPage(view, forward) {
    return extendSel(view, range => view.moveVertically(range, forward, view.dom.clientHeight));
}
/**
Move the selection head one page up.
*/
const selectPageUp = view => selectByPage(view, false);
/**
Move the selection head one page down.
*/
const selectPageDown = view => selectByPage(view, true);
/**
Move the selection head to the next line boundary.
*/
const selectLineBoundaryForward = view => extendSel(view, range => moveByLineBoundary(view, range, true));
/**
Move the selection head to the previous line boundary.
*/
const selectLineBoundaryBackward = view => extendSel(view, range => moveByLineBoundary(view, range, false));
/**
Move the selection head to the start of the line.
*/
const selectLineStart = view => extendSel(view, range => state.EditorSelection.cursor(view.visualLineAt(range.head).from));
/**
Move the selection head to the end of the line.
*/
const selectLineEnd = view => extendSel(view, range => state.EditorSelection.cursor(view.visualLineAt(range.head).to));
/**
Move the selection to the start of the document.
*/
const cursorDocStart = ({ state, dispatch }) => {
    dispatch(setSel(state, { anchor: 0 }));
    return true;
};
/**
Move the selection to the end of the document.
*/
const cursorDocEnd = ({ state, dispatch }) => {
    dispatch(setSel(state, { anchor: state.doc.length }));
    return true;
};
/**
Move the selection head to the start of the document.
*/
const selectDocStart = ({ state, dispatch }) => {
    dispatch(setSel(state, { anchor: state.selection.main.anchor, head: 0 }));
    return true;
};
/**
Move the selection head to the end of the document.
*/
const selectDocEnd = ({ state, dispatch }) => {
    dispatch(setSel(state, { anchor: state.selection.main.anchor, head: state.doc.length }));
    return true;
};
/**
Select the entire document.
*/
const selectAll = ({ state: state$1, dispatch }) => {
    dispatch(state$1.update({ selection: { anchor: 0, head: state$1.doc.length }, annotations: state.Transaction.userEvent.of("keyboardselection") }));
    return true;
};
/**
Expand the selection to cover entire lines.
*/
const selectLine = ({ state: state$1, dispatch }) => {
    let ranges = selectedLineBlocks(state$1).map(({ from, to }) => state.EditorSelection.range(from, Math.min(to + 1, state$1.doc.length)));
    dispatch(state$1.update({ selection: state.EditorSelection.create(ranges), annotations: state.Transaction.userEvent.of("keyboardselection") }));
    return true;
};
/**
Select the next syntactic construct that is larger than the
selection. Note that this will only work insofar as the language
[provider](https://codemirror.net/6/docs/ref/#language.language) you use builds up a full
syntax tree.
*/
const selectParentSyntax = ({ state: state$1, dispatch }) => {
    let selection = updateSel(state$1.selection, range => {
        var _a;
        let context = language.syntaxTree(state$1).resolve(range.head, 1);
        while (!((context.from < range.from && context.to >= range.to) ||
            (context.to > range.to && context.from <= range.from) ||
            !((_a = context.parent) === null || _a === void 0 ? void 0 : _a.parent)))
            context = context.parent;
        return state.EditorSelection.range(context.to, context.from);
    });
    dispatch(setSel(state$1, selection));
    return true;
};
/**
Simplify the current selection. When multiple ranges are selected,
reduce it to its main range. Otherwise, if the selection is
non-empty, convert it to a cursor selection.
*/
const simplifySelection = ({ state: state$1, dispatch }) => {
    let cur = state$1.selection, selection = null;
    if (cur.ranges.length > 1)
        selection = state.EditorSelection.create([cur.main]);
    else if (!cur.main.empty)
        selection = state.EditorSelection.create([state.EditorSelection.cursor(cur.main.head)]);
    if (!selection)
        return false;
    dispatch(setSel(state$1, selection));
    return true;
};
function deleteBy({ state: state$1, dispatch }, by) {
    let changes = state$1.changeByRange(range => {
        let { from, to } = range;
        if (from == to) {
            let towards = by(from);
            from = Math.min(from, towards);
            to = Math.max(to, towards);
        }
        return from == to ? { range } : { changes: { from, to }, range: state.EditorSelection.cursor(from) };
    });
    if (changes.changes.empty)
        return false;
    dispatch(state$1.update(changes, { scrollIntoView: true, annotations: state.Transaction.userEvent.of("delete") }));
    return true;
}
const deleteByChar = (target, forward, codePoint) => deleteBy(target, pos => {
    let { state } = target, line = state.doc.lineAt(pos), before;
    if (!forward && pos > line.from && pos < line.from + 200 &&
        !/[^ \t]/.test(before = line.text.slice(0, pos - line.from))) {
        if (before[before.length - 1] == "\t")
            return pos - 1;
        let col = text.countColumn(before, 0, state.tabSize), drop = col % language.getIndentUnit(state) || language.getIndentUnit(state);
        for (let i = 0; i < drop && before[before.length - 1 - i] == " "; i++)
            pos--;
        return pos;
    }
    let targetPos;
    if (codePoint) {
        let next = line.text.slice(pos - line.from + (forward ? 0 : -2), pos - line.from + (forward ? 2 : 0));
        let size = next ? text.codePointSize(text.codePointAt(next, 0)) : 1;
        targetPos = forward ? Math.min(state.doc.length, pos + size) : Math.max(0, pos - size);
    }
    else {
        targetPos = text.findClusterBreak(line.text, pos - line.from, forward) + line.from;
    }
    if (targetPos == pos && line.number != (forward ? state.doc.lines : 1))
        targetPos += forward ? 1 : -1;
    return targetPos;
});
/**
Delete the selection, or, for cursor selections, the code point
before the cursor.
*/
const deleteCodePointBackward = view => deleteByChar(view, false, true);
/**
Delete the selection, or, for cursor selections, the code point
after the cursor.
*/
const deleteCodePointForward = view => deleteByChar(view, true, true);
/**
Delete the selection, or, for cursor selections, the character
before the cursor.
*/
const deleteCharBackward = view => deleteByChar(view, false, false);
/**
Delete the selection or the character after the cursor.
*/
const deleteCharForward = view => deleteByChar(view, true, false);
const deleteByGroup = (target, forward) => deleteBy(target, start => {
    let pos = start, { state } = target, line = state.doc.lineAt(pos);
    let categorize = state.charCategorizer(pos);
    for (let cat = null;;) {
        if (pos == (forward ? line.to : line.from)) {
            if (pos == start && line.number != (forward ? state.doc.lines : 1))
                pos += forward ? 1 : -1;
            break;
        }
        let next = text.findClusterBreak(line.text, pos - line.from, forward) + line.from;
        let nextChar = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);
        let nextCat = categorize(nextChar);
        if (cat != null && nextCat != cat)
            break;
        if (nextChar != " " || pos != start)
            cat = nextCat;
        pos = next;
    }
    return pos;
});
/**
Delete the selection or backward until the end of the next
[group](https://codemirror.net/6/docs/ref/#view.EditorView.moveByGroup), only skipping groups of
whitespace when they consist of a single space.
*/
const deleteGroupBackward = target => deleteByGroup(target, false);
/**
Delete the selection or forward until the end of the next group.
*/
const deleteGroupForward = target => deleteByGroup(target, true);
/**
Delete the selection, or, if it is a cursor selection, delete to
the end of the line. If the cursor is directly at the end of the
line, delete the line break after it.
*/
const deleteToLineEnd = view => deleteBy(view, pos => {
    let lineEnd = view.visualLineAt(pos).to;
    if (pos < lineEnd)
        return lineEnd;
    return Math.min(view.state.doc.length, pos + 1);
});
/**
Delete the selection, or, if it is a cursor selection, delete to
the start of the line. If the cursor is directly at the start of the
line, delete the line break before it.
*/
const deleteToLineStart = view => deleteBy(view, pos => {
    let lineStart = view.visualLineAt(pos).from;
    if (pos > lineStart)
        return lineStart;
    return Math.max(0, pos - 1);
});
/**
Delete all whitespace directly before a line end from the
document.
*/
const deleteTrailingWhitespace = ({ state, dispatch }) => {
    let changes = [];
    for (let pos = 0, prev = "", iter = state.doc.iter();;) {
        iter.next();
        if (iter.lineBreak || iter.done) {
            let trailing = prev.search(/\s+$/);
            if (trailing > -1)
                changes.push({ from: pos - (prev.length - trailing), to: pos });
            if (iter.done)
                break;
            prev = "";
        }
        else {
            prev = iter.value;
        }
        pos += iter.value.length;
    }
    if (!changes.length)
        return false;
    dispatch(state.update({ changes }));
    return true;
};
/**
Replace each selection range with a line break, leaving the cursor
on the line before the break.
*/
const splitLine = ({ state: state$1, dispatch }) => {
    let changes = state$1.changeByRange(range => {
        return { changes: { from: range.from, to: range.to, insert: text.Text.of(["", ""]) },
            range: state.EditorSelection.cursor(range.from) };
    });
    dispatch(state$1.update(changes, { scrollIntoView: true, annotations: state.Transaction.userEvent.of("input") }));
    return true;
};
/**
Flip the characters before and after the cursor(s).
*/
const transposeChars = ({ state: state$1, dispatch }) => {
    let changes = state$1.changeByRange(range => {
        if (!range.empty || range.from == 0 || range.from == state$1.doc.length)
            return { range };
        let pos = range.from, line = state$1.doc.lineAt(pos);
        let from = pos == line.from ? pos - 1 : text.findClusterBreak(line.text, pos - line.from, false) + line.from;
        let to = pos == line.to ? pos + 1 : text.findClusterBreak(line.text, pos - line.from, true) + line.from;
        return { changes: { from, to, insert: state$1.doc.slice(pos, to).append(state$1.doc.slice(from, pos)) },
            range: state.EditorSelection.cursor(to) };
    });
    if (changes.changes.empty)
        return false;
    dispatch(state$1.update(changes, { scrollIntoView: true }));
    return true;
};
function selectedLineBlocks(state) {
    let blocks = [], upto = -1;
    for (let range of state.selection.ranges) {
        let startLine = state.doc.lineAt(range.from), endLine = state.doc.lineAt(range.to);
        if (upto == startLine.number)
            blocks[blocks.length - 1].to = endLine.to;
        else
            blocks.push({ from: startLine.from, to: endLine.to });
        upto = endLine.number;
    }
    return blocks;
}
function moveLine(state, dispatch, forward) {
    let changes = [];
    for (let block of selectedLineBlocks(state)) {
        if (forward ? block.to == state.doc.length : block.from == 0)
            continue;
        let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);
        if (forward)
            changes.push({ from: block.to, to: nextLine.to }, { from: block.from, insert: nextLine.text + state.lineBreak });
        else
            changes.push({ from: nextLine.from, to: block.from }, { from: block.to, insert: state.lineBreak + nextLine.text });
    }
    if (!changes.length)
        return false;
    dispatch(state.update({ changes, scrollIntoView: true }));
    return true;
}
/**
Move the selected lines up one line.
*/
const moveLineUp = ({ state, dispatch }) => moveLine(state, dispatch, false);
/**
Move the selected lines down one line.
*/
const moveLineDown = ({ state, dispatch }) => moveLine(state, dispatch, true);
function copyLine(state, dispatch, forward) {
    let changes = [];
    for (let block of selectedLineBlocks(state)) {
        if (forward)
            changes.push({ from: block.from, insert: state.doc.slice(block.from, block.to) + state.lineBreak });
        else
            changes.push({ from: block.to, insert: state.lineBreak + state.doc.slice(block.from, block.to) });
    }
    dispatch(state.update({ changes, scrollIntoView: true }));
    return true;
}
/**
Create a copy of the selected lines. Keep the selection in the top copy.
*/
const copyLineUp = ({ state, dispatch }) => copyLine(state, dispatch, false);
/**
Create a copy of the selected lines. Keep the selection in the bottom copy.
*/
const copyLineDown = ({ state, dispatch }) => copyLine(state, dispatch, true);
/**
Delete selected lines.
*/
const deleteLine = view => {
    let { state } = view, changes = state.changes(selectedLineBlocks(state).map(({ from, to }) => {
        if (from > 0)
            from--;
        else if (to < state.doc.length)
            to++;
        return { from, to };
    }));
    let selection = updateSel(state.selection, range => view.moveVertically(range, true)).map(changes);
    view.dispatch({ changes, selection, scrollIntoView: true });
    return true;
};
/**
Replace the selection with a newline.
*/
const insertNewline = ({ state, dispatch }) => {
    dispatch(state.update(state.replaceSelection(state.lineBreak), { scrollIntoView: true }));
    return true;
};
function isBetweenBrackets(state, pos) {
    if (/\(\)|\[\]|\{\}/.test(state.sliceDoc(pos - 1, pos + 1)))
        return { from: pos, to: pos };
    let context = language.syntaxTree(state).resolve(pos);
    let before = context.childBefore(pos), after = context.childAfter(pos), closedBy;
    if (before && after && before.to <= pos && after.from >= pos &&
        (closedBy = before.type.prop(lezerTree.NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 &&
        state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from)
        return { from: before.to, to: after.from };
    return null;
}
/**
Replace the selection with a newline and indent the newly created
line(s). If the current line consists only of whitespace, this
will also delete that whitespace. When the cursor is between
matching brackets, an additional newline will be inserted after
the cursor.
*/
const insertNewlineAndIndent = ({ state: state$1, dispatch }) => {
    let changes = state$1.changeByRange(({ from, to }) => {
        let explode = from == to && isBetweenBrackets(state$1, from);
        let cx = new language.IndentContext(state$1, { simulateBreak: from, simulateDoubleBreak: !!explode });
        let indent = language.getIndentation(cx, from);
        if (indent == null)
            indent = /^\s*/.exec(state$1.doc.lineAt(from).text)[0].length;
        let line = state$1.doc.lineAt(from);
        while (to < line.to && /\s/.test(line.text.slice(to - line.from, to + 1 - line.from)))
            to++;
        if (explode)
            ({ from, to } = explode);
        else if (from > line.from && from < line.from + 100 && !/\S/.test(line.text.slice(0, from)))
            from = line.from;
        let insert = ["", language.indentString(state$1, indent)];
        if (explode)
            insert.push(language.indentString(state$1, cx.lineIndent(line)));
        return { changes: { from, to, insert: text.Text.of(insert) },
            range: state.EditorSelection.cursor(from + 1 + insert[1].length) };
    });
    dispatch(state$1.update(changes, { scrollIntoView: true }));
    return true;
};
function changeBySelectedLine(state$1, f) {
    let atLine = -1;
    return state$1.changeByRange(range => {
        let changes = [];
        for (let pos = range.from; pos <= range.to;) {
            let line = state$1.doc.lineAt(pos);
            if (line.number > atLine && (range.empty || range.to > line.from)) {
                f(line, changes, range);
                atLine = line.number;
            }
            pos = line.to + 1;
        }
        let changeSet = state$1.changes(changes);
        return { changes,
            range: state.EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1)) };
    });
}
/**
Auto-indent the selected lines. This uses the [indentation service
facet](https://codemirror.net/6/docs/ref/#language.indentService) as source for auto-indent
information.
*/
const indentSelection = ({ state, dispatch }) => {
    let updated = Object.create(null);
    let context = new language.IndentContext(state, { overrideIndentation: start => {
            let found = updated[start];
            return found == null ? -1 : found;
        } });
    let changes = changeBySelectedLine(state, (line, changes, range) => {
        let indent = language.getIndentation(context, line.from);
        if (indent == null)
            return;
        let cur = /^\s*/.exec(line.text)[0];
        let norm = language.indentString(state, indent);
        if (cur != norm || range.from < line.from + cur.length) {
            updated[line.from] = indent;
            changes.push({ from: line.from, to: line.from + cur.length, insert: norm });
        }
    });
    if (!changes.changes.empty)
        dispatch(state.update(changes));
    return true;
};
/**
Add a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation to all selected
lines.
*/
const indentMore = ({ state, dispatch }) => {
    dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
        changes.push({ from: line.from, insert: state.facet(language.indentUnit) });
    })));
    return true;
};
/**
Remove a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation from all
selected lines.
*/
const indentLess = ({ state, dispatch }) => {
    dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
        let space = /^\s*/.exec(line.text)[0];
        if (!space)
            return;
        let col = text.countColumn(space, 0, state.tabSize), keep = 0;
        let insert = language.indentString(state, Math.max(0, col - language.getIndentUnit(state)));
        while (keep < space.length && keep < insert.length && space.charCodeAt(keep) == insert.charCodeAt(keep))
            keep++;
        changes.push({ from: line.from + keep, to: line.from + space.length, insert: insert.slice(keep) });
    })));
    return true;
};
/**
Insert a tab character at the cursor or, if something is selected,
use [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) to indent the entire
selection.
*/
const insertTab = ({ state: state$1, dispatch }) => {
    if (state$1.selection.ranges.some(r => !r.empty))
        return indentMore({ state: state$1, dispatch });
    dispatch(state$1.update(state$1.replaceSelection("\t"), { scrollIntoView: true, annotations: state.Transaction.userEvent.of("input") }));
    return true;
};
/**
Array of key bindings containing the Emacs-style bindings that are
available on macOS by default.

 - Ctrl-b: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)
 - Ctrl-f: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)
 - Ctrl-p: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)
 - Ctrl-n: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)
 - Ctrl-a: [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)
 - Ctrl-e: [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)
 - Ctrl-d: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)
 - Ctrl-h: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)
 - Ctrl-k: [`deleteToLineEnd`](https://codemirror.net/6/docs/ref/#commands.deleteToLineEnd)
 - Alt-d: [`deleteGroupForward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupForward)
 - Ctrl-Alt-h: [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)
 - Ctrl-o: [`splitLine`](https://codemirror.net/6/docs/ref/#commands.splitLine)
 - Ctrl-t: [`transposeChars`](https://codemirror.net/6/docs/ref/#commands.transposeChars)
 - Alt-f: [`cursorGroupForward`](https://codemirror.net/6/docs/ref/#commands.cursorGroupForward) ([`selectGroupForward`](https://codemirror.net/6/docs/ref/#commands.selectGroupForward) with Shift)
 - Alt-b: [`cursorGroupBackward`](https://codemirror.net/6/docs/ref/#commands.cursorGroupBackward) ([`selectGroupBackward`](https://codemirror.net/6/docs/ref/#commands.selectGroupBackward) with Shift)
 - Alt-<: [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart)
 - Alt->: [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd)
 - Ctrl-v: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown)
 - Alt-v: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp)
*/
const emacsStyleKeymap = [
    { key: "Ctrl-b", run: cursorCharLeft, shift: selectCharLeft },
    { key: "Ctrl-f", run: cursorCharRight, shift: selectCharRight },
    { key: "Ctrl-p", run: cursorLineUp, shift: selectLineUp },
    { key: "Ctrl-n", run: cursorLineDown, shift: selectLineDown },
    { key: "Ctrl-a", run: cursorLineStart, shift: selectLineStart },
    { key: "Ctrl-e", run: cursorLineEnd, shift: selectLineEnd },
    { key: "Ctrl-d", run: deleteCharForward },
    { key: "Ctrl-h", run: deleteCharBackward },
    { key: "Ctrl-k", run: deleteToLineEnd },
    { key: "Alt-d", run: deleteGroupForward },
    { key: "Ctrl-Alt-h", run: deleteGroupBackward },
    { key: "Ctrl-o", run: splitLine },
    { key: "Ctrl-t", run: transposeChars },
    { key: "Alt-f", run: cursorGroupForward, shift: selectGroupForward },
    { key: "Alt-b", run: cursorGroupBackward, shift: selectGroupBackward },
    { key: "Alt-<", run: cursorDocStart },
    { key: "Alt->", run: cursorDocEnd },
    { key: "Ctrl-v", run: cursorPageDown },
    { key: "Alt-v", run: cursorPageUp },
];
/**
An array of key bindings closely sticking to platform-standard or
widely used bindings. (This includes the bindings from
[`emacsStyleKeymap`](https://codemirror.net/6/docs/ref/#commands.emacsStyleKeymap), with their `key`
property changed to `mac`.)

 - ArrowLeft: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)
 - ArrowRight: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)
 - Ctrl-ArrowLeft (Alt-ArrowLeft on macOS): [`cursorGroupLeft`](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) ([`selectGroupLeft`](https://codemirror.net/6/docs/ref/#commands.selectGroupLeft) with Shift)
 - Ctrl-ArrowRight (Alt-ArrowRight on macOS): [`cursorGroupRight`](https://codemirror.net/6/docs/ref/#commands.cursorGroupRight) ([`selectGroupRight`](https://codemirror.net/6/docs/ref/#commands.selectGroupRight) with Shift)
 - Cmd-ArrowLeft (on macOS): [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)
 - Cmd-ArrowRight (on macOS): [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)
 - ArrowUp: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)
 - ArrowDown: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)
 - Cmd-ArrowUp (on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)
 - Cmd-ArrowDown (on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)
 - Ctrl-ArrowUp (on macOS): [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)
 - Ctrl-ArrowDown (on macOS): [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)
 - PageUp: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)
 - PageDown: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)
 - Home: [`cursorLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryBackward) ([`selectLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryBackward) with Shift)
 - End: [`cursorLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryForward) ([`selectLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryForward) with Shift)
 - Ctrl-Home (Cmd-Home on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)
 - Ctrl-End (Cmd-Home on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)
 - Enter: [`insertNewlineAndIndent`](https://codemirror.net/6/docs/ref/#commands.insertNewlineAndIndent)
 - Ctrl-a (Cmd-a on macOS): [`selectAll`](https://codemirror.net/6/docs/ref/#commands.selectAll)
 - Backspace: [`deleteCodePointBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCodePointBackward)
 - Delete: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)
 - Ctrl-Backspace (Alt-Backspace on macOS): [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)
 - Ctrl-Delete (Alt-Delete on macOS): [`deleteGroupForward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupForward)
 - Cmd-Backspace (macOS): [`deleteToLineStart`](https://codemirror.net/6/docs/ref/#commands.deleteToLineStart).
 - Cmd-Delete (macOS): [`deleteToLineEnd`](https://codemirror.net/6/docs/ref/#commands.deleteToLineEnd).
*/
const standardKeymap = [
    { key: "ArrowLeft", run: cursorCharLeft, shift: selectCharLeft },
    { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: cursorGroupLeft, shift: selectGroupLeft },
    { mac: "Cmd-ArrowLeft", run: cursorLineStart, shift: selectLineStart },
    { key: "ArrowRight", run: cursorCharRight, shift: selectCharRight },
    { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: cursorGroupRight, shift: selectGroupRight },
    { mac: "Cmd-ArrowRight", run: cursorLineEnd, shift: selectLineEnd },
    { key: "ArrowUp", run: cursorLineUp, shift: selectLineUp },
    { mac: "Cmd-ArrowUp", run: cursorDocStart, shift: selectDocStart },
    { mac: "Ctrl-ArrowUp", run: cursorPageUp, shift: selectPageUp },
    { key: "ArrowDown", run: cursorLineDown, shift: selectLineDown },
    { mac: "Cmd-ArrowDown", run: cursorDocEnd, shift: selectDocEnd },
    { mac: "Ctrl-ArrowDown", run: cursorPageDown, shift: selectPageDown },
    { key: "PageUp", run: cursorPageUp, shift: selectPageUp },
    { key: "PageDown", run: cursorPageDown, shift: selectPageDown },
    { key: "Home", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward },
    { key: "Mod-Home", run: cursorDocStart, shift: selectDocStart },
    { key: "End", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward },
    { key: "Mod-End", run: cursorDocEnd, shift: selectDocEnd },
    { key: "Enter", run: insertNewlineAndIndent },
    { key: "Mod-a", run: selectAll },
    { key: "Backspace", run: deleteCodePointBackward, shift: deleteCodePointBackward },
    { key: "Delete", run: deleteCharForward, shift: deleteCharForward },
    { key: "Mod-Backspace", mac: "Alt-Backspace", run: deleteGroupBackward },
    { key: "Mod-Delete", mac: "Alt-Delete", run: deleteGroupForward },
    { mac: "Mod-Backspace", run: deleteToLineStart },
    { mac: "Mod-Delete", run: deleteToLineEnd }
].concat(emacsStyleKeymap.map(b => ({ mac: b.key, run: b.run, shift: b.shift })));
/**
The default keymap. Includes all bindings from
[`standardKeymap`](https://codemirror.net/6/docs/ref/#commands.standardKeymap) plus the following:

- Alt-ArrowLeft (Ctrl-ArrowLeft on macOS): [`cursorSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxLeft) ([`selectSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxLeft) with Shift)
- Alt-ArrowRight (Ctrl-ArrowRight on macOS): [`cursorSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxRight) ([`selectSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxRight) with Shift)
- Alt-ArrowUp: [`moveLineUp`](https://codemirror.net/6/docs/ref/#commands.moveLineUp)
- Alt-ArrowDown: [`moveLineDown`](https://codemirror.net/6/docs/ref/#commands.moveLineDown)
- Shift-Alt-ArrowUp: [`copyLineUp`](https://codemirror.net/6/docs/ref/#commands.copyLineUp)
- Shift-Alt-ArrowDown: [`copyLineDown`](https://codemirror.net/6/docs/ref/#commands.copyLineDown)
- Escape: [`simplifySelection`](https://codemirror.net/6/docs/ref/#commands.simplifySelection)
- Alt-l: [`selectLine`](https://codemirror.net/6/docs/ref/#commands.selectLine)
- Ctrl-i (Cmd-i on macOS): [`selectParentSyntax`](https://codemirror.net/6/docs/ref/#commands.selectParentSyntax)
- Ctrl-[ (Cmd-[ on macOS): [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess)
- Ctrl-] (Cmd-] on macOS): [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore)
- Ctrl-Alt-\\ (Cmd-Alt-\\ on macOS): [`indentSelection`](https://codemirror.net/6/docs/ref/#commands.indentSelection)
- Shift-Ctrl-k (Shift-Cmd-k on macOS): [`deleteLine`](https://codemirror.net/6/docs/ref/#commands.deleteLine)
- Shift-Ctrl-\\ (Shift-Cmd-\\ on macOS): [`cursorMatchingBracket`](https://codemirror.net/6/docs/ref/#commands.cursorMatchingBracket)
*/
const defaultKeymap = [
    { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: cursorSyntaxLeft, shift: selectSyntaxLeft },
    { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: cursorSyntaxRight, shift: selectSyntaxRight },
    { key: "Alt-ArrowUp", run: moveLineUp },
    { key: "Shift-Alt-ArrowUp", run: copyLineUp },
    { key: "Alt-ArrowDown", run: moveLineDown },
    { key: "Shift-Alt-ArrowDown", run: copyLineDown },
    { key: "Escape", run: simplifySelection },
    { key: "Alt-l", run: selectLine },
    { key: "Mod-i", run: selectParentSyntax },
    { key: "Mod-[", run: indentLess },
    { key: "Mod-]", run: indentMore },
    { key: "Mod-Alt-\\", run: indentSelection },
    { key: "Shift-Mod-k", run: deleteLine },
    { key: "Shift-Mod-\\", run: cursorMatchingBracket }
].concat(standardKeymap);
/**
A binding that binds Tab to [`insertTab`](https://codemirror.net/6/docs/ref/#commands.insertTab) and
Shift-Tab to [`indentSelection`](https://codemirror.net/6/docs/ref/#commands.indentSelection).
Please see the [Tab example](../../examples/tab/) before using
this.
*/
const defaultTabBinding = { key: "Tab", run: insertTab, shift: indentSelection };

exports.copyLineDown = copyLineDown;
exports.copyLineUp = copyLineUp;
exports.cursorCharBackward = cursorCharBackward;
exports.cursorCharForward = cursorCharForward;
exports.cursorCharLeft = cursorCharLeft;
exports.cursorCharRight = cursorCharRight;
exports.cursorDocEnd = cursorDocEnd;
exports.cursorDocStart = cursorDocStart;
exports.cursorGroupBackward = cursorGroupBackward;
exports.cursorGroupForward = cursorGroupForward;
exports.cursorGroupLeft = cursorGroupLeft;
exports.cursorGroupRight = cursorGroupRight;
exports.cursorLineBoundaryBackward = cursorLineBoundaryBackward;
exports.cursorLineBoundaryForward = cursorLineBoundaryForward;
exports.cursorLineDown = cursorLineDown;
exports.cursorLineEnd = cursorLineEnd;
exports.cursorLineStart = cursorLineStart;
exports.cursorLineUp = cursorLineUp;
exports.cursorMatchingBracket = cursorMatchingBracket;
exports.cursorPageDown = cursorPageDown;
exports.cursorPageUp = cursorPageUp;
exports.cursorSyntaxLeft = cursorSyntaxLeft;
exports.cursorSyntaxRight = cursorSyntaxRight;
exports.defaultKeymap = defaultKeymap;
exports.defaultTabBinding = defaultTabBinding;
exports.deleteCharBackward = deleteCharBackward;
exports.deleteCharForward = deleteCharForward;
exports.deleteCodePointBackward = deleteCodePointBackward;
exports.deleteCodePointForward = deleteCodePointForward;
exports.deleteGroupBackward = deleteGroupBackward;
exports.deleteGroupForward = deleteGroupForward;
exports.deleteLine = deleteLine;
exports.deleteToLineEnd = deleteToLineEnd;
exports.deleteToLineStart = deleteToLineStart;
exports.deleteTrailingWhitespace = deleteTrailingWhitespace;
exports.emacsStyleKeymap = emacsStyleKeymap;
exports.indentLess = indentLess;
exports.indentMore = indentMore;
exports.indentSelection = indentSelection;
exports.insertNewline = insertNewline;
exports.insertNewlineAndIndent = insertNewlineAndIndent;
exports.insertTab = insertTab;
exports.moveLineDown = moveLineDown;
exports.moveLineUp = moveLineUp;
exports.selectAll = selectAll;
exports.selectCharBackward = selectCharBackward;
exports.selectCharForward = selectCharForward;
exports.selectCharLeft = selectCharLeft;
exports.selectCharRight = selectCharRight;
exports.selectDocEnd = selectDocEnd;
exports.selectDocStart = selectDocStart;
exports.selectGroupBackward = selectGroupBackward;
exports.selectGroupForward = selectGroupForward;
exports.selectGroupLeft = selectGroupLeft;
exports.selectGroupRight = selectGroupRight;
exports.selectLine = selectLine;
exports.selectLineBoundaryBackward = selectLineBoundaryBackward;
exports.selectLineBoundaryForward = selectLineBoundaryForward;
exports.selectLineDown = selectLineDown;
exports.selectLineEnd = selectLineEnd;
exports.selectLineStart = selectLineStart;
exports.selectLineUp = selectLineUp;
exports.selectMatchingBracket = selectMatchingBracket;
exports.selectPageDown = selectPageDown;
exports.selectPageUp = selectPageUp;
exports.selectParentSyntax = selectParentSyntax;
exports.selectSyntaxLeft = selectSyntaxLeft;
exports.selectSyntaxRight = selectSyntaxRight;
exports.simplifySelection = simplifySelection;
exports.splitLine = splitLine;
exports.standardKeymap = standardKeymap;
exports.transposeChars = transposeChars;

},{"@codemirror/language":10,"@codemirror/matchbrackets":12,"@codemirror/state":17,"@codemirror/text":18,"@codemirror/view":20,"lezer-tree":23}],5:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var state = require('@codemirror/state');

/// Comment or uncomment the current selection. Will use line comments
/// if available, otherwise falling back to block comments.
const toggleComment = target => {
    let config = getConfig(target.state);
    return config.line ? toggleLineComment(target) : config.block ? toggleBlockComment(target) : false;
};
function command(f, option) {
    return ({ state, dispatch }) => {
        let tr = f(option, state.selection.ranges, state);
        if (!tr)
            return false;
        dispatch(state.update(tr));
        return true;
    };
}
/// Comment or uncomment the current selection using line comments.
/// The line comment syntax is taken from the
/// [`commentTokens`](#comment.CommentTokens) [language
/// data](#state.EditorState.languageDataAt).
const toggleLineComment = command(changeLineComment, 0 /* Toggle */);
/// Comment the current selection using line comments.
const lineComment = command(changeLineComment, 1 /* Comment */);
/// Uncomment the current selection using line comments.
const lineUncomment = command(changeLineComment, 2 /* Uncomment */);
/// Comment or uncomment the current selection using block comments.
/// The block comment syntax is taken from the
/// [`commentTokens`](#comment.CommentTokens) [language
/// data](#state.EditorState.languageDataAt).
const toggleBlockComment = command(changeBlockComment, 0 /* Toggle */);
/// Comment the current selection using block comments.
const blockComment = command(changeBlockComment, 1 /* Comment */);
/// Uncomment the current selection using block comments.
const blockUncomment = command(changeBlockComment, 2 /* Uncomment */);
/// Default key bindings for this package.
///
///  - Ctrl-/ (Cmd-/ on macOS): [`toggleComment`](#comment.toggleComment).
///  - Shift-Alt-a: [`toggleBlockComment`](#comment.toggleBlockComment).
const commentKeymap = [
    { key: "Mod-/", run: toggleComment },
    { key: "Alt-A", run: toggleBlockComment }
];
function getConfig(state, pos = state.selection.main.head) {
    let data = state.languageDataAt("commentTokens", pos);
    return data.length ? data[0] : {};
}
const SearchMargin = 50;
/// Determines if the given range is block-commented in the given
/// state.
function findBlockComment(state, { open, close }, from, to) {
    let textBefore = state.sliceDoc(from - SearchMargin, from);
    let textAfter = state.sliceDoc(to, to + SearchMargin);
    let spaceBefore = /\s*$/.exec(textBefore)[0].length, spaceAfter = /^\s*/.exec(textAfter)[0].length;
    let beforeOff = textBefore.length - spaceBefore;
    if (textBefore.slice(beforeOff - open.length, beforeOff) == open &&
        textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {
        return { open: { pos: from - spaceBefore, margin: spaceBefore && 1 },
            close: { pos: to + spaceAfter, margin: spaceAfter && 1 } };
    }
    let startText, endText;
    if (to - from <= 2 * SearchMargin) {
        startText = endText = state.sliceDoc(from, to);
    }
    else {
        startText = state.sliceDoc(from, from + SearchMargin);
        endText = state.sliceDoc(to - SearchMargin, to);
    }
    let startSpace = /^\s*/.exec(startText)[0].length, endSpace = /\s*$/.exec(endText)[0].length;
    let endOff = endText.length - endSpace - close.length;
    if (startText.slice(startSpace, startSpace + open.length) == open &&
        endText.slice(endOff, endOff + close.length) == close) {
        return { open: { pos: from + startSpace + open.length,
                margin: /\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0 },
            close: { pos: to - endSpace - close.length,
                margin: /\s/.test(endText.charAt(endOff - 1)) ? 1 : 0 } };
    }
    return null;
}
// Performs toggle, comment and uncomment of block comments in
// languages that support them.
function changeBlockComment(option, ranges, state$1) {
    let tokens = ranges.map(r => getConfig(state$1, r.from).block);
    if (!tokens.every(c => c))
        return null;
    let comments = ranges.map((r, i) => findBlockComment(state$1, tokens[i], r.from, r.to));
    if (option != 2 /* Uncomment */ && !comments.every(c => c)) {
        let index = 0;
        return state$1.changeByRange(range => {
            let { open, close } = tokens[index++];
            if (comments[index])
                return { range };
            let shift = open.length + 1;
            return {
                changes: [{ from: range.from, insert: open + " " }, { from: range.to, insert: " " + close }],
                range: state.EditorSelection.range(range.anchor + shift, range.head + shift)
            };
        });
    }
    else if (option != 1 /* Comment */ && comments.some(c => c)) {
        let changes = [];
        for (let i = 0, comment; i < comments.length; i++)
            if (comment = comments[i]) {
                let token = tokens[i], { open, close } = comment;
                changes.push({ from: open.pos - token.open.length, to: open.pos + open.margin }, { from: close.pos - close.margin, to: close.pos + token.close.length });
            }
        return { changes };
    }
    return null;
}
// Performs toggle, comment and uncomment of line comments.
function changeLineComment(option, ranges, state) {
    let lines = [];
    let prevLine = -1;
    for (let { from, to } of ranges) {
        let startI = lines.length, minIndent = 1e9;
        for (let pos = from; pos <= to;) {
            let line = state.doc.lineAt(pos);
            if (line.from > prevLine && (from == to || to > line.from)) {
                prevLine = line.from;
                let token = getConfig(state, pos).line;
                if (!token)
                    continue;
                let indent = /^\s*/.exec(line.text)[0].length;
                let comment = line.text.slice(indent, indent + token.length) == token ? indent : -1;
                if (indent < line.text.length && indent < minIndent)
                    minIndent = indent;
                lines.push({ line, comment, token, indent, single: false });
            }
            pos = line.to + 1;
        }
        if (minIndent < 1e9)
            for (let i = startI; i < lines.length; i++)
                if (lines[i].indent < lines[i].line.text.length)
                    lines[i].indent = minIndent;
        if (lines.length == startI + 1)
            lines[startI].single = true;
    }
    if (option != 1 /* Comment */ && lines.some(l => l.comment >= 0)) {
        let changes = [];
        for (let { line, comment, token } of lines)
            if (comment >= 0) {
                let from = line.from + comment, to = from + token.length;
                if (line.text[to - line.from] == " ")
                    to++;
                changes.push({ from, to });
            }
        return { changes };
    }
    else if (option != 2 /* Uncomment */ && lines.some(l => l.comment < 0)) {
        let changes = [];
        for (let { line, comment, token, indent, single } of lines)
            if (comment != indent && (single || /\S/.test(line.text)))
                changes.push({ from: line.from + indent, insert: token + " " });
        let changeSet = state.changes(changes);
        return { changes: changeSet, selection: state.selection.map(changeSet, 1) };
    }
    return null;
}

exports.blockComment = blockComment;
exports.blockUncomment = blockUncomment;
exports.commentKeymap = commentKeymap;
exports.lineComment = lineComment;
exports.lineUncomment = lineUncomment;
exports.toggleBlockComment = toggleBlockComment;
exports.toggleComment = toggleComment;
exports.toggleLineComment = toggleLineComment;

},{"@codemirror/state":17}],6:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var state = require('@codemirror/state');
var view = require('@codemirror/view');
var language = require('@codemirror/language');
var gutter = require('@codemirror/gutter');
var rangeset = require('@codemirror/rangeset');

function mapRange(range, mapping) {
    let from = mapping.mapPos(range.from, 1), to = mapping.mapPos(range.to, -1);
    return from >= to ? undefined : { from, to };
}
const foldEffect = state.StateEffect.define({ map: mapRange });
const unfoldEffect = state.StateEffect.define({ map: mapRange });
function selectedLines(view) {
    let lines = [];
    for (let { head } of view.state.selection.ranges) {
        if (lines.some(l => l.from <= head && l.to >= head))
            continue;
        lines.push(view.visualLineAt(head));
    }
    return lines;
}
const foldState = state.StateField.define({
    create() {
        return view.Decoration.none;
    },
    update(folded, tr) {
        folded = folded.map(tr.changes);
        for (let e of tr.effects) {
            if (e.is(foldEffect) && !foldExists(folded, e.value.from, e.value.to))
                folded = folded.update({ add: [foldWidget.range(e.value.from, e.value.to)] });
            else if (e.is(unfoldEffect)) {
                folded = folded.update({ filter: (from, to) => e.value.from != from || e.value.to != to,
                    filterFrom: e.value.from, filterTo: e.value.to });
            }
        }
        // Clear folded ranges that cover the selection head
        if (tr.selection) {
            let onSelection = false, { head } = tr.selection.main;
            folded.between(head, head, (a, b) => { if (a < head && b > head)
                onSelection = true; });
            if (onSelection)
                folded = folded.update({
                    filterFrom: head,
                    filterTo: head,
                    filter: (a, b) => b <= head || a >= head
                });
        }
        return folded;
    },
    provide: f => view.EditorView.decorations.compute([f], s => s.field(f))
});
function foldInside(state, from, to) {
    var _a;
    let found = null;
    (_a = state.field(foldState, false)) === null || _a === void 0 ? void 0 : _a.between(from, to, (from, to) => {
        if (!found || found.from > from)
            found = { from, to };
    });
    return found;
}
function foldExists(folded, from, to) {
    let found = false;
    folded.between(from, from, (a, b) => { if (a == from && b == to)
        found = true; });
    return found;
}
function maybeEnable(state$1, other) {
    return state$1.field(foldState, false) ? other : other.concat(state.StateEffect.appendConfig.of(codeFolding()));
}
/// Fold the lines that are selected, if possible.
const foldCode = view => {
    for (let line of selectedLines(view)) {
        let range = language.foldable(view.state, line.from, line.to);
        if (range) {
            view.dispatch({ effects: maybeEnable(view.state, [foldEffect.of(range), announceFold(view, range)]) });
            return true;
        }
    }
    return false;
};
/// Unfold folded ranges on selected lines.
const unfoldCode = view => {
    if (!view.state.field(foldState, false))
        return false;
    let effects = [];
    for (let line of selectedLines(view)) {
        let folded = foldInside(view.state, line.from, line.to);
        if (folded)
            effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));
    }
    if (effects.length)
        view.dispatch({ effects });
    return effects.length > 0;
};
function announceFold(view$1, range, fold = true) {
    let lineFrom = view$1.state.doc.lineAt(range.from).number, lineTo = view$1.state.doc.lineAt(range.to).number;
    return view.EditorView.announce.of(`${view$1.state.phrase(fold ? "Folded lines" : "Unfolded lines")} ${lineFrom} ${view$1.state.phrase("to")} ${lineTo}.`);
}
/// Fold all top-level foldable ranges.
const foldAll = view => {
    let { state } = view, effects = [];
    for (let pos = 0; pos < state.doc.length;) {
        let line = view.visualLineAt(pos), range = language.foldable(state, line.from, line.to);
        if (range)
            effects.push(foldEffect.of(range));
        pos = (range ? view.visualLineAt(range.to) : line).to + 1;
    }
    if (effects.length)
        view.dispatch({ effects: maybeEnable(view.state, effects) });
    return !!effects.length;
};
/// Unfold all folded code.
const unfoldAll = view => {
    let field = view.state.field(foldState, false);
    if (!field || !field.size)
        return false;
    let effects = [];
    field.between(0, view.state.doc.length, (from, to) => { effects.push(unfoldEffect.of({ from, to })); });
    view.dispatch({ effects });
    return true;
};
/// Default fold-related key bindings.
///
///  - Ctrl-Shift-[ (Cmd-Alt-[ on macOS): [`foldCode`](#fold.foldCode).
///  - Ctrl-Shift-] (Cmd-Alt-] on macOS): [`unfoldCode`](#fold.unfoldCode).
///  - Ctrl-Alt-[: [`foldAll`](#fold.foldAll).
///  - Ctrl-Alt-]: [`unfoldAll`](#fold.unfoldAll).
const foldKeymap = [
    { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: foldCode },
    { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: unfoldCode },
    { key: "Ctrl-Alt-[", run: foldAll },
    { key: "Ctrl-Alt-]", run: unfoldAll }
];
const defaultConfig = {
    placeholderDOM: null,
    placeholderText: "‚Ä¶"
};
const foldConfig = state.Facet.define({
    combine(values) { return state.combineConfig(values, defaultConfig); }
});
/// Create an extension that configures code folding.
function codeFolding(config) {
    let result = [foldState, baseTheme];
    if (config)
        result.push(foldConfig.of(config));
    return result;
}
const foldWidget = view.Decoration.replace({ widget: new class extends view.WidgetType {
        ignoreEvents() { return false; }
        toDOM(view) {
            let { state } = view, conf = state.facet(foldConfig);
            if (conf.placeholderDOM)
                return conf.placeholderDOM();
            let element = document.createElement("span");
            element.textContent = conf.placeholderText;
            element.setAttribute("aria-label", state.phrase("folded code"));
            element.title = state.phrase("unfold");
            element.className = "cm-foldPlaceholder";
            element.onclick = event => {
                let line = view.visualLineAt(view.posAtDOM(event.target));
                let folded = foldInside(view.state, line.from, line.to);
                if (folded)
                    view.dispatch({ effects: unfoldEffect.of(folded) });
                event.preventDefault();
            };
            return element;
        }
    } });
const foldGutterDefaults = {
    openText: "‚åÑ",
    closedText: "‚Ä∫"
};
class FoldMarker extends gutter.GutterMarker {
    constructor(config, open) {
        super();
        this.config = config;
        this.open = open;
    }
    eq(other) { return this.config == other.config && this.open == other.open; }
    toDOM(view) {
        let span = document.createElement("span");
        span.textContent = this.open ? this.config.openText : this.config.closedText;
        span.title = view.state.phrase(this.open ? "Fold line" : "Unfold line");
        return span;
    }
}
/// Create an extension that registers a fold gutter, which shows a
/// fold status indicator before foldable lines (which can be clicked
/// to fold or unfold the line).
function foldGutter(config = {}) {
    let fullConfig = Object.assign(Object.assign({}, foldGutterDefaults), config);
    let canFold = new FoldMarker(fullConfig, true), canUnfold = new FoldMarker(fullConfig, false);
    let markers = view.ViewPlugin.fromClass(class {
        constructor(view) {
            this.from = view.viewport.from;
            this.markers = rangeset.RangeSet.of(this.buildMarkers(view));
        }
        update(update) {
            let firstChange = -1;
            update.changes.iterChangedRanges(from => { if (firstChange < 0)
                firstChange = from; });
            let foldChange = update.startState.field(foldState, false) != update.state.field(foldState, false);
            if (!foldChange && update.docChanged && update.view.viewport.from == this.from && firstChange > this.from) {
                let start = update.view.visualLineAt(firstChange).from;
                this.markers = this.markers.update({
                    filter: () => false,
                    filterFrom: start,
                    add: this.buildMarkers(update.view, start)
                });
            }
            else if (foldChange || update.docChanged || update.viewportChanged) {
                this.from = update.view.viewport.from;
                this.markers = rangeset.RangeSet.of(this.buildMarkers(update.view));
            }
        }
        buildMarkers(view, from = 0) {
            let ranges = [];
            view.viewportLines(line => {
                if (line.from >= from) {
                    let mark = foldInside(view.state, line.from, line.to) ? canUnfold
                        : language.foldable(view.state, line.from, line.to) ? canFold : null;
                    if (mark)
                        ranges.push(mark.range(line.from));
                }
            });
            return ranges;
        }
    });
    return [
        markers,
        gutter.gutter({
            class: "cm-foldGutter",
            markers(view) { var _a; return ((_a = view.plugin(markers)) === null || _a === void 0 ? void 0 : _a.markers) || rangeset.RangeSet.empty; },
            initialSpacer() {
                return new FoldMarker(fullConfig, false);
            },
            domEventHandlers: {
                click: (view, line) => {
                    let folded = foldInside(view.state, line.from, line.to);
                    if (folded) {
                        view.dispatch({ effects: unfoldEffect.of(folded) });
                        return true;
                    }
                    let range = language.foldable(view.state, line.from, line.to);
                    if (range) {
                        view.dispatch({ effects: foldEffect.of(range) });
                        return true;
                    }
                    return false;
                }
            }
        }),
        codeFolding()
    ];
}
const baseTheme = view.EditorView.baseTheme({
    ".cm-foldPlaceholder": {
        backgroundColor: "#eee",
        border: "1px solid #ddd",
        color: "#888",
        borderRadius: ".2em",
        margin: "0 1px",
        padding: "0 1px",
        cursor: "pointer"
    },
    ".cm-foldGutter .cm-gutterElement": {
        padding: "0 1px",
        cursor: "pointer"
    }
});

exports.codeFolding = codeFolding;
exports.foldAll = foldAll;
exports.foldCode = foldCode;
exports.foldGutter = foldGutter;
exports.foldKeymap = foldKeymap;
exports.unfoldAll = unfoldAll;
exports.unfoldCode = unfoldCode;

},{"@codemirror/gutter":7,"@codemirror/language":10,"@codemirror/rangeset":14,"@codemirror/state":17,"@codemirror/view":20}],7:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var view = require('@codemirror/view');
var rangeset = require('@codemirror/rangeset');
var state = require('@codemirror/state');

/**
A gutter marker represents a bit of information attached to a line
in a specific gutter. Your own custom markers have to extend this
class.
*/
class GutterMarker extends rangeset.RangeValue {
    /**
    @internal
    */
    compare(other) {
        return this == other || this.constructor == other.constructor && this.eq(other);
    }
    /**
    Render the DOM node for this marker, if any.
    */
    toDOM(_view) { return null; }
    /**
    Create a range that places this marker at the given position.
    */
    at(pos) { return this.range(pos); }
}
GutterMarker.prototype.elementClass = "";
GutterMarker.prototype.mapMode = state.MapMode.TrackBefore;
const defaults = {
    class: "",
    renderEmptyElements: false,
    elementStyle: "",
    markers: () => rangeset.RangeSet.empty,
    lineMarker: () => null,
    initialSpacer: null,
    updateSpacer: null,
    domEventHandlers: {}
};
const activeGutters = state.Facet.define();
/**
Define an editor gutter. The order in which the gutters appear is
determined by their extension priority.
*/
function gutter(config) {
    return [gutters(), activeGutters.of(Object.assign(Object.assign({}, defaults), config))];
}
const baseTheme = view.EditorView.baseTheme({
    ".cm-gutters": {
        display: "flex",
        height: "100%",
        boxSizing: "border-box",
        left: 0,
        zIndex: 200
    },
    "&light .cm-gutters": {
        backgroundColor: "#f5f5f5",
        color: "#999",
        borderRight: "1px solid #ddd"
    },
    "&dark .cm-gutters": {
        backgroundColor: "#333338",
        color: "#ccc"
    },
    ".cm-gutter": {
        display: "flex !important",
        flexDirection: "column",
        flexShrink: 0,
        boxSizing: "border-box",
        height: "100%",
        overflow: "hidden"
    },
    ".cm-gutterElement": {
        boxSizing: "border-box"
    },
    ".cm-lineNumbers .cm-gutterElement": {
        padding: "0 3px 0 5px",
        minWidth: "20px",
        textAlign: "right",
        whiteSpace: "nowrap"
    }
});
const unfixGutters = state.Facet.define({
    combine: values => values.some(x => x)
});
/**
The gutter-drawing plugin is automatically enabled when you add a
gutter, but you can use this function to explicitly configure it.

Unless `fixed` is explicitly set to `false`, the gutters are
fixed, meaning they don't scroll along with the content
horizontally (except on Internet Explorer, which doesn't support
CSS [`position:
sticky`](https://developer.mozilla.org/en-US/docs/Web/CSS/position#sticky)).
*/
function gutters(config) {
    let result = [
        gutterView,
        baseTheme
    ];
    if (config && config.fixed === false)
        result.push(unfixGutters.of(true));
    return result;
}
const gutterView = view.ViewPlugin.fromClass(class {
    constructor(view) {
        this.view = view;
        this.dom = document.createElement("div");
        this.dom.className = "cm-gutters";
        this.dom.setAttribute("aria-hidden", "true");
        this.gutters = view.state.facet(activeGutters).map(conf => new SingleGutterView(view, conf));
        for (let gutter of this.gutters)
            this.dom.appendChild(gutter.dom);
        this.fixed = !view.state.facet(unfixGutters);
        if (this.fixed) {
            // FIXME IE11 fallback, which doesn't support position: sticky,
            // by using position: relative + event handlers that realign the
            // gutter (or just force fixed=false on IE11?)
            this.dom.style.position = "sticky";
        }
        view.scrollDOM.insertBefore(this.dom, view.contentDOM);
    }
    update(update) {
        if (!this.updateGutters(update))
            return;
        let contexts = this.gutters.map(gutter => new UpdateContext(gutter, this.view.viewport));
        this.view.viewportLines(line => {
            let text;
            if (Array.isArray(line.type)) {
                for (let b of line.type)
                    if (b.type == view.BlockType.Text) {
                        text = b;
                        break;
                    }
            }
            else {
                text = line.type == view.BlockType.Text ? line : undefined;
            }
            if (!text)
                return;
            for (let cx of contexts)
                cx.line(this.view, text);
        }, 0);
        for (let cx of contexts)
            cx.finish();
        this.dom.style.minHeight = this.view.contentHeight + "px";
        if (update.state.facet(unfixGutters) != !this.fixed) {
            this.fixed = !this.fixed;
            this.dom.style.position = this.fixed ? "sticky" : "";
        }
    }
    updateGutters(update) {
        let prev = update.startState.facet(activeGutters), cur = update.state.facet(activeGutters);
        let change = update.docChanged || update.heightChanged || update.viewportChanged;
        if (prev == cur) {
            for (let gutter of this.gutters)
                if (gutter.update(update))
                    change = true;
        }
        else {
            change = true;
            let gutters = [];
            for (let conf of cur) {
                let known = prev.indexOf(conf);
                if (known < 0) {
                    gutters.push(new SingleGutterView(this.view, conf));
                }
                else {
                    this.gutters[known].update(update);
                    gutters.push(this.gutters[known]);
                }
            }
            for (let g of this.gutters)
                g.dom.remove();
            for (let g of gutters)
                this.dom.appendChild(g.dom);
            this.gutters = gutters;
        }
        return change;
    }
    destroy() {
        this.dom.remove();
    }
}, {
    provide: view.PluginField.scrollMargins.from(value => {
        if (value.gutters.length == 0 || !value.fixed)
            return null;
        return value.view.textDirection == view.Direction.LTR ? { left: value.dom.offsetWidth } : { right: value.dom.offsetWidth };
    })
});
function asArray(val) { return (Array.isArray(val) ? val : [val]); }
class UpdateContext {
    constructor(gutter, viewport) {
        this.gutter = gutter;
        this.localMarkers = [];
        this.i = 0;
        this.height = 0;
        this.cursor = rangeset.RangeSet.iter(gutter.markers, viewport.from);
    }
    line(view, line) {
        if (this.localMarkers.length)
            this.localMarkers = [];
        while (this.cursor.value && this.cursor.from <= line.from) {
            if (this.cursor.from == line.from)
                this.localMarkers.push(this.cursor.value);
            this.cursor.next();
        }
        let forLine = this.gutter.config.lineMarker(view, line, this.localMarkers);
        if (forLine)
            this.localMarkers.unshift(forLine);
        let gutter = this.gutter;
        if (this.localMarkers.length == 0 && !gutter.config.renderEmptyElements)
            return;
        let above = line.top - this.height;
        if (this.i == gutter.elements.length) {
            let newElt = new GutterElement(view, line.height, above, this.localMarkers);
            gutter.elements.push(newElt);
            gutter.dom.appendChild(newElt.dom);
        }
        else {
            let markers = this.localMarkers, elt = gutter.elements[this.i];
            if (sameMarkers(markers, elt.markers)) {
                markers = elt.markers;
                this.localMarkers.length = 0;
            }
            elt.update(view, line.height, above, markers);
        }
        this.height = line.bottom;
        this.i++;
    }
    finish() {
        let gutter = this.gutter;
        while (gutter.elements.length > this.i)
            gutter.dom.removeChild(gutter.elements.pop().dom);
    }
}
class SingleGutterView {
    constructor(view, config) {
        this.view = view;
        this.config = config;
        this.elements = [];
        this.spacer = null;
        this.dom = document.createElement("div");
        this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
        for (let prop in config.domEventHandlers) {
            this.dom.addEventListener(prop, (event) => {
                let line = view.visualLineAtHeight(event.clientY, view.contentDOM.getBoundingClientRect().top);
                if (config.domEventHandlers[prop](view, line, event))
                    event.preventDefault();
            });
        }
        this.markers = asArray(config.markers(view));
        if (config.initialSpacer) {
            this.spacer = new GutterElement(view, 0, 0, [config.initialSpacer(view)]);
            this.dom.appendChild(this.spacer.dom);
            this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none";
        }
    }
    update(update) {
        let prevMarkers = this.markers;
        this.markers = asArray(this.config.markers(update.view));
        if (this.spacer && this.config.updateSpacer) {
            let updated = this.config.updateSpacer(this.spacer.markers[0], update);
            if (updated != this.spacer.markers[0])
                this.spacer.update(update.view, 0, 0, [updated]);
        }
        return this.markers != prevMarkers;
    }
}
class GutterElement {
    constructor(view, height, above, markers) {
        this.height = -1;
        this.above = 0;
        this.dom = document.createElement("div");
        this.update(view, height, above, markers);
    }
    update(view, height, above, markers) {
        if (this.height != height)
            this.dom.style.height = (this.height = height) + "px";
        if (this.above != above)
            this.dom.style.marginTop = (this.above = above) ? above + "px" : "";
        if (this.markers != markers) {
            this.markers = markers;
            for (let ch; ch = this.dom.lastChild;)
                ch.remove();
            let cls = "cm-gutterElement";
            for (let m of markers) {
                let dom = m.toDOM(view);
                if (dom)
                    this.dom.appendChild(dom);
                let c = m.elementClass;
                if (c)
                    cls += " " + c;
            }
            this.dom.className = cls;
        }
    }
}
function sameMarkers(a, b) {
    if (a.length != b.length)
        return false;
    for (let i = 0; i < a.length; i++)
        if (!a[i].compare(b[i]))
            return false;
    return true;
}
/**
Facet used to provide markers to the line number gutter.
*/
const lineNumberMarkers = state.Facet.define();
const lineNumberConfig = state.Facet.define({
    combine(values) {
        return state.combineConfig(values, { formatNumber: String, domEventHandlers: {} }, {
            domEventHandlers(a, b) {
                let result = Object.assign({}, a);
                for (let event in b) {
                    let exists = result[event], add = b[event];
                    result[event] = exists ? (view, line, event) => exists(view, line, event) || add(view, line, event) : add;
                }
                return result;
            }
        });
    }
});
class NumberMarker extends GutterMarker {
    constructor(number) {
        super();
        this.number = number;
    }
    eq(other) { return this.number == other.number; }
    toDOM() {
        return document.createTextNode(this.number);
    }
}
function formatNumber(view, number) {
    return view.state.facet(lineNumberConfig).formatNumber(number, view.state);
}
const lineNumberGutter = gutter({
    class: "cm-lineNumbers",
    markers(view) { return view.state.facet(lineNumberMarkers); },
    lineMarker(view, line, others) {
        if (others.length)
            return null;
        return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));
    },
    initialSpacer(view) {
        return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));
    },
    updateSpacer(spacer, update) {
        let max = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));
        return max == spacer.number ? spacer : new NumberMarker(max);
    }
});
/**
Create a line number gutter extension.
*/
function lineNumbers(config = {}) {
    return [
        lineNumberConfig.of(config),
        lineNumberGutter
    ];
}
function maxLineNumber(lines) {
    let last = 9;
    while (last < lines)
        last = last * 10 + 9;
    return last;
}

exports.GutterMarker = GutterMarker;
exports.gutter = gutter;
exports.gutters = gutters;
exports.lineNumberMarkers = lineNumberMarkers;
exports.lineNumbers = lineNumbers;

},{"@codemirror/rangeset":14,"@codemirror/state":17,"@codemirror/view":20}],8:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var lezerTree = require('lezer-tree');
var styleMod = require('style-mod');
var view = require('@codemirror/view');
var state = require('@codemirror/state');
var language = require('@codemirror/language');
var rangeset = require('@codemirror/rangeset');

let nextTagID = 0;
/// Highlighting tags are markers that denote a highlighting category.
/// They are [associated](#highlight.styleTags) with parts of a syntax
/// tree by a language mode, and then mapped to an actual CSS style by
/// a [highlight style](#highlight.HighlightStyle).
///
/// Because syntax tree node types and highlight styles have to be
/// able to talk the same language, CodeMirror uses a mostly _closed_
/// [vocabulary](#highlight.tags) of syntax tags (as opposed to
/// traditional open string-based systems, which make it hard for
/// highlighting themes to cover all the tokens produced by the
/// various languages).
///
/// It _is_ possible to [define](#highlight.Tag^define) your own
/// highlighting tags for system-internal use (where you control both
/// the language package and the highlighter), but such tags will not
/// be picked up by regular highlighters (though you can derive them
/// from standard tags to allow highlighters to fall back to those).
class Tag {
    /// @internal
    constructor(
    /// The set of tags that match this tag, starting with this one
    /// itself, sorted in order of decreasing specificity. @internal
    set, 
    /// The base unmodified tag that this one is based on, if it's
    /// modified @internal
    base, 
    /// The modifiers applied to this.base @internal
    modified) {
        this.set = set;
        this.base = base;
        this.modified = modified;
        /// @internal
        this.id = nextTagID++;
    }
    /// Define a new tag. If `parent` is given, the tag is treated as a
    /// sub-tag of that parent, and [highlight
    /// styles](#highlight.HighlightStyle) that don't mention this tag
    /// will try to fall back to the parent tag (or grandparent tag,
    /// etc).
    static define(parent) {
        if (parent === null || parent === void 0 ? void 0 : parent.base)
            throw new Error("Can not derive from a modified tag");
        let tag = new Tag([], null, []);
        tag.set.push(tag);
        if (parent)
            for (let t of parent.set)
                tag.set.push(t);
        return tag;
    }
    /// Define a tag _modifier_, which is a function that, given a tag,
    /// will return a tag that is a subtag of the original. Applying the
    /// same modifier to a twice tag will return the same value (`m1(t1)
    /// == m1(t1)`) and applying multiple modifiers will, regardless or
    /// order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
    ///
    /// When multiple modifiers are applied to a given base tag, each
    /// smaller set of modifiers is registered as a parent, so that for
    /// example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
    /// `m1(m3(t1)`, and so on.
    static defineModifier() {
        let mod = new Modifier;
        return (tag) => {
            if (tag.modified.indexOf(mod) > -1)
                return tag;
            return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));
        };
    }
}
let nextModifierID = 0;
class Modifier {
    constructor() {
        this.instances = [];
        this.id = nextModifierID++;
    }
    static get(base, mods) {
        if (!mods.length)
            return base;
        let exists = mods[0].instances.find(t => t.base == base && sameArray(mods, t.modified));
        if (exists)
            return exists;
        let set = [], tag = new Tag(set, base, mods);
        for (let m of mods)
            m.instances.push(tag);
        let configs = permute(mods);
        for (let parent of base.set)
            for (let config of configs)
                set.push(Modifier.get(parent, config));
        return tag;
    }
}
function sameArray(a, b) {
    return a.length == b.length && a.every((x, i) => x == b[i]);
}
function permute(array) {
    let result = [array];
    for (let i = 0; i < array.length; i++) {
        for (let a of permute(array.slice(0, i).concat(array.slice(i + 1))))
            result.push(a);
    }
    return result;
}
/// This function is used to add a set of tags to a language syntax
/// via
/// [`Parser.configure`](https://lezer.codemirror.net/docs/ref#lezer.Parser.configure).
///
/// The argument object maps node selectors to [highlighting
/// tags](#highlight.Tag) or arrays of tags.
///
/// Node selectors may hold one or more (space-separated) node paths.
/// Such a path can be a [node
/// name](https://lezer.codemirror.net/docs/ref#tree.NodeType.name),
/// or multiple node names (or `*` wildcards) separated by slash
/// characters, as in `"Block/Declaration/VariableName"`. Such a path
/// matches the final node but only if its direct parent nodes are the
/// other nodes mentioned. A `*` in such a path matches any parent,
/// but only a single level‚Äîwildcards that match multiple parents
/// aren't supported, both for efficiency reasons and because Lezer
/// trees make it rather hard to reason about what they would match.)
///
/// A path can be ended with `/...` to indicate that the tag assigned
/// to the node should also apply to all child nodes, even if they
/// match their own style (by default, only the innermost style is
/// used).
///
/// When a path ends in `!`, as in `Attribute!`, no further matching
/// happens for the node's child nodes, and the entire node gets the
/// given style.
///
/// In this notation, node names that contain `/`, `!`, `*`, or `...`
/// must be quoted as JSON strings.
///
/// For example:
///
/// ```javascript
/// parser.withProps(
///   styleTags({
///     // Style Number and BigNumber nodes
///     "Number BigNumber": tags.number,
///     // Style Escape nodes whose parent is String
///     "String/Escape": tags.escape,
///     // Style anything inside Attributes nodes
///     "Attributes!": tags.meta,
///     // Add a style to all content inside Italic nodes
///     "Italic/...": tags.emphasis,
///     // Style InvalidString nodes as both `string` and `invalid`
///     "InvalidString": [tags.string, tags.invalid],
///     // Style the node named "/" as punctuation
///     '"/"': tags.punctuation
///   })
/// )
/// ```
function styleTags(spec) {
    let byName = Object.create(null);
    for (let prop in spec) {
        let tags = spec[prop];
        if (!Array.isArray(tags))
            tags = [tags];
        for (let part of prop.split(" "))
            if (part) {
                let pieces = [], mode = 2 /* Normal */, rest = part;
                for (let pos = 0;;) {
                    if (rest == "..." && pos > 0 && pos + 3 == part.length) {
                        mode = 1 /* Inherit */;
                        break;
                    }
                    let m = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
                    if (!m)
                        throw new RangeError("Invalid path: " + part);
                    pieces.push(m[0] == "*" ? null : m[0][0] == '"' ? JSON.parse(m[0]) : m[0]);
                    pos += m[0].length;
                    if (pos == part.length)
                        break;
                    let next = part[pos++];
                    if (pos == part.length && next == "!") {
                        mode = 0 /* Opaque */;
                        break;
                    }
                    if (next != "/")
                        throw new RangeError("Invalid path: " + part);
                    rest = part.slice(pos);
                }
                let last = pieces.length - 1, inner = pieces[last];
                if (!inner)
                    throw new RangeError("Invalid path: " + part);
                let rule = new Rule(tags, mode, last > 0 ? pieces.slice(0, last) : null);
                byName[inner] = rule.sort(byName[inner]);
            }
    }
    return ruleNodeProp.add(byName);
}
const ruleNodeProp = new lezerTree.NodeProp();
const highlightStyle = state.Facet.define({
    combine(stylings) { return stylings.length ? HighlightStyle.combinedMatch(stylings) : null; }
});
const fallbackHighlightStyle = state.Facet.define({
    combine(values) { return values.length ? values[0].match : null; }
});
function noHighlight() { return null; }
function getHighlightStyle(state) {
    return state.facet(highlightStyle) || state.facet(fallbackHighlightStyle) || noHighlight;
}
class Rule {
    constructor(tags, mode, context, next) {
        this.tags = tags;
        this.mode = mode;
        this.context = context;
        this.next = next;
    }
    sort(other) {
        if (!other || other.depth < this.depth) {
            this.next = other;
            return this;
        }
        other.next = this.sort(other.next);
        return other;
    }
    get depth() { return this.context ? this.context.length : 0; }
}
/// A highlight style associates CSS styles with higlighting
/// [tags](#highlight.Tag).
class HighlightStyle {
    constructor(spec, options) {
        this.map = Object.create(null);
        let modSpec;
        function def(spec) {
            let cls = styleMod.StyleModule.newName();
            (modSpec || (modSpec = Object.create(null)))["." + cls] = spec;
            return cls;
        }
        this.all = typeof options.all == "string" ? options.all : options.all ? def(options.all) : null;
        for (let style of spec) {
            let cls = (style.class || def(Object.assign({}, style, { tag: null }))) +
                (this.all ? " " + this.all : "");
            let tags = style.tag;
            if (!Array.isArray(tags))
                this.map[tags.id] = cls;
            else
                for (let tag of tags)
                    this.map[tag.id] = cls;
        }
        this.module = modSpec ? new styleMod.StyleModule(modSpec) : null;
        this.scope = options.scope || null;
        this.match = this.match.bind(this);
        let ext = [treeHighlighter];
        if (this.module)
            ext.push(view.EditorView.styleModule.of(this.module));
        this.extension = ext.concat(highlightStyle.of(this));
        this.fallback = ext.concat(fallbackHighlightStyle.of(this));
    }
    /// Returns the CSS class associated with the given tag, if any.
    /// This method is bound to the instance by the constructor.
    match(tag, scope) {
        if (this.scope && scope != this.scope)
            return null;
        for (let t of tag.set) {
            let match = this.map[t.id];
            if (match !== undefined) {
                if (t != tag)
                    this.map[tag.id] = match;
                return match;
            }
        }
        return this.map[tag.id] = this.all;
    }
    /// Combines an array of highlight styles into a single match
    /// function that returns all of the classes assigned by the styles
    /// for a given tag.
    static combinedMatch(styles) {
        if (styles.length == 1)
            return styles[0].match;
        let cache = styles.some(s => s.scope) ? undefined : Object.create(null);
        return (tag, scope) => {
            let cached = cache && cache[tag.id];
            if (cached !== undefined)
                return cached;
            let result = null;
            for (let style of styles) {
                let value = style.match(tag, scope);
                if (value)
                    result = result ? result + " " + value : value;
            }
            if (cache)
                cache[tag.id] = result;
            return result;
        };
    }
    /// Create a highlighter style that associates the given styles to
    /// the given tags. The spec must be objects that hold a style tag
    /// or array of tags in their `tag` property, and either a single
    /// `class` property providing a static CSS class (for highlighters
    /// like [`classHighlightStyle`](#highlight.classHighlightStyle)
    /// that rely on external styling), or a
    /// [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
    /// set of CSS properties (which define the styling for those tags).
    ///
    /// The CSS rules created for a highlighter will be emitted in the
    /// order of the spec's properties. That means that for elements that
    /// have multiple tags associated with them, styles defined further
    /// down in the list will have a higher CSS precedence than styles
    /// defined earlier.
    static define(specs, options) {
        return new HighlightStyle(specs, options || {});
    }
    /// Returns the CSS classes (if any) that the highlight styles
    /// active in the given state would assign to the given a style
    /// [tag](#highlight.Tag) and (optional) language
    /// [scope](#highlight.HighlightStyle^define^options.scope).
    static get(state, tag, scope) {
        return getHighlightStyle(state)(tag, scope || lezerTree.NodeType.none);
    }
}
/// Given a string of code and a language, parse the code in that
/// language and run the tree highlighter over the resulting syntax
/// tree.
function highlightTree(tree, 
/// Get the CSS classes used to style a given [tag](#highlight.Tag),
/// or `null` if it isn't styled. (You'll often want to pass a
/// highlight style's [`match`](#highlight.HighlightStyle.match)
/// method here.)
getStyle, 
/// Assign styling to a region of the text. Will be called, in order
/// of position, for any ranges where more than zero classes apply.
/// `classes` is a space separated string of CSS classes.
putStyle) {
    highlightTreeRange(tree, 0, tree.length, getStyle, putStyle);
}
class TreeHighlighter {
    constructor(view) {
        this.markCache = Object.create(null);
        this.tree = language.syntaxTree(view.state);
        this.decorations = this.buildDeco(view, getHighlightStyle(view.state));
    }
    update(update) {
        let tree = language.syntaxTree(update.state), style = getHighlightStyle(update.state);
        let styleChange = style != update.startState.facet(highlightStyle);
        if (tree.length < update.view.viewport.to && !styleChange) {
            this.decorations = this.decorations.map(update.changes);
        }
        else if (tree != this.tree || update.viewportChanged || styleChange) {
            this.tree = tree;
            this.decorations = this.buildDeco(update.view, style);
        }
    }
    buildDeco(view$1, match) {
        if (match == noHighlight || !this.tree.length)
            return view.Decoration.none;
        let builder = new rangeset.RangeSetBuilder();
        for (let { from, to } of view$1.visibleRanges) {
            highlightTreeRange(this.tree, from, to, match, (from, to, style) => {
                builder.add(from, to, this.markCache[style] || (this.markCache[style] = view.Decoration.mark({ class: style })));
            });
        }
        return builder.finish();
    }
}
// This extension installs a highlighter that highlights based on the
// syntax tree and highlight style.
const treeHighlighter = state.Prec.fallback(view.ViewPlugin.fromClass(TreeHighlighter, {
    decorations: v => v.decorations
}));
const nodeStack = [""];
function highlightTreeRange(tree, from, to, style, span) {
    let spanStart = from, spanClass = "";
    let cursor = tree.topNode.cursor;
    function node(inheritedClass, depth, scope) {
        let { type, from: start, to: end } = cursor;
        if (start >= to || end <= from)
            return;
        nodeStack[depth] = type.name;
        if (type.isTop)
            scope = type;
        let cls = inheritedClass;
        let rule = type.prop(ruleNodeProp), opaque = false;
        while (rule) {
            if (!rule.context || matchContext(rule.context, nodeStack, depth)) {
                for (let tag of rule.tags) {
                    let st = style(tag, scope);
                    if (st) {
                        if (cls)
                            cls += " ";
                        cls += st;
                        if (rule.mode == 1 /* Inherit */)
                            inheritedClass += (inheritedClass ? " " : "") + st;
                        else if (rule.mode == 0 /* Opaque */)
                            opaque = true;
                    }
                }
                break;
            }
            rule = rule.next;
        }
        if (cls != spanClass) {
            if (start > spanStart && spanClass)
                span(spanStart, cursor.from, spanClass);
            spanStart = start;
            spanClass = cls;
        }
        if (!opaque && cursor.firstChild()) {
            do {
                let end = cursor.to;
                node(inheritedClass, depth + 1, scope);
                if (spanClass != cls) {
                    let pos = Math.min(to, end);
                    if (pos > spanStart && spanClass)
                        span(spanStart, pos, spanClass);
                    spanStart = pos;
                    spanClass = cls;
                }
            } while (cursor.nextSibling());
            cursor.parent();
        }
    }
    node("", 0, tree.type);
}
function matchContext(context, stack, depth) {
    if (context.length > depth - 1)
        return false;
    for (let d = depth - 1, i = context.length - 1; i >= 0; i--, d--) {
        let check = context[i];
        if (check && check != stack[d])
            return false;
    }
    return true;
}
const t = Tag.define;
const comment = t(), name = t(), typeName = t(name), literal = t(), string = t(literal), number = t(literal), content = t(), heading = t(content), keyword = t(), operator = t(), punctuation = t(), bracket = t(punctuation), meta = t();
/// The default set of highlighting [tags](#highlight.Tag^define) used
/// by regular language packages and themes.
///
/// This collection is heavily biased towards programming languages,
/// and necessarily incomplete. A full ontology of syntactic
/// constructs would fill a stack of books, and be impractical to
/// write themes for. So try to make do with this set. If all else
/// fails, [open an
/// issue](https://github.com/codemirror/codemirror.next) to propose a
/// new tag, or [define](#highlight.Tag^define) a local custom tag for
/// your use case.
///
/// Note that it is not obligatory to always attach the most specific
/// tag possible to an element‚Äîif your grammar can't easily
/// distinguish a certain type of element (such as a local variable),
/// it is okay to style it as its more general variant (a variable).
/// 
/// For tags that extend some parent tag, the documentation links to
/// the parent.
const tags = {
    /// A comment.
    comment,
    /// A line [comment](#highlight.tags.comment).
    lineComment: t(comment),
    /// A block [comment](#highlight.tags.comment).
    blockComment: t(comment),
    /// A documentation [comment](#highlight.tags.comment).
    docComment: t(comment),
    /// Any kind of identifier.
    name,
    /// The [name](#highlight.tags.name) of a variable.
    variableName: t(name),
    /// A type [name](#highlight.tags.name).
    typeName: typeName,
    /// A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
    tagName: t(typeName),
    /// A property, field, or attribute [name](#highlight.tags.name).
    propertyName: t(name),
    /// The [name](#highlight.tags.name) of a class.
    className: t(name),
    /// A label [name](#highlight.tags.name).
    labelName: t(name),
    /// A namespace [name](#highlight.tags.name).
    namespace: t(name),
    /// The [name](#highlight.tags.name) of a macro.
    macroName: t(name),
    /// A literal value.
    literal,
    /// A string [literal](#highlight.tags.literal).
    string,
    /// A documentation [string](#highlight.tags.string).
    docString: t(string),
    /// A character literal (subtag of [string](#highlight.tags.string)).
    character: t(string),
    /// A number [literal](#highlight.tags.literal).
    number,
    /// An integer [number](#highlight.tags.number) literal.
    integer: t(number),
    /// A floating-point [number](#highlight.tags.number) literal.
    float: t(number),
    /// A boolean [literal](#highlight.tags.literal).
    bool: t(literal),
    /// Regular expression [literal](#highlight.tags.literal).
    regexp: t(literal),
    /// An escape [literal](#highlight.tags.literal), for example a
    /// backslash escape in a string.
    escape: t(literal),
    /// A color [literal](#highlight.tags.literal).
    color: t(literal),
    /// A URL [literal](#highlight.tags.literal).
    url: t(literal),
    /// A language keyword.
    keyword,
    /// The [keyword](#highlight.tags.keyword) for the self or this
    /// object.
    self: t(keyword),
    /// The [keyword](#highlight.tags.keyword) for null.
    null: t(keyword),
    /// A [keyword](#highlight.tags.keyword) denoting some atomic value.
    atom: t(keyword),
    /// A [keyword](#highlight.tags.keyword) that represents a unit.
    unit: t(keyword),
    /// A modifier [keyword](#highlight.tags.keyword).
    modifier: t(keyword),
    /// A [keyword](#highlight.tags.keyword) that acts as an operator.
    operatorKeyword: t(keyword),
    /// A control-flow related [keyword](#highlight.tags.keyword).
    controlKeyword: t(keyword),
    /// A [keyword](#highlight.tags.keyword) that defines something.
    definitionKeyword: t(keyword),
    /// An operator.
    operator,
    /// An [operator](#highlight.tags.operator) that defines something.
    derefOperator: t(operator),
    /// Arithmetic-related [operator](#highlight.tags.operator).
    arithmeticOperator: t(operator),
    /// Logical [operator](#highlight.tags.operator).
    logicOperator: t(operator),
    /// Bit [operator](#highlight.tags.operator).
    bitwiseOperator: t(operator),
    /// Comparison [operator](#highlight.tags.operator).
    compareOperator: t(operator),
    /// [Operator](#highlight.tags.operator) that updates its operand.
    updateOperator: t(operator),
    /// [Operator](#highlight.tags.operator) that defines something.
    definitionOperator: t(operator),
    /// Type-related [operator](#highlight.tags.operator).
    typeOperator: t(operator),
    /// Control-flow [operator](#highlight.tags.operator).
    controlOperator: t(operator),
    /// Program or markup punctuation.
    punctuation,
    /// [Punctuation](#highlight.tags.punctuation) that separates
    /// things.
    separator: t(punctuation),
    /// Bracket-style [punctuation](#highlight.tags.punctuation).
    bracket,
    /// Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
    /// tokens).
    angleBracket: t(bracket),
    /// Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
    /// tokens).
    squareBracket: t(bracket),
    /// Parentheses (usually `(` and `)` tokens). Subtag of
    /// [bracket](#highlight.tags.bracket).
    paren: t(bracket),
    /// Braces (usually `{` and `}` tokens). Subtag of
    /// [bracket](#highlight.tags.bracket).
    brace: t(bracket),
    /// Content, for example plain text in XML or markup documents.
    content,
    /// [Content](#highlight.tags.content) that represents a heading.
    heading,
    /// A level 1 [heading](#highlight.tags.heading).
    heading1: t(heading),
    /// A level 2 [heading](#highlight.tags.heading).
    heading2: t(heading),
    /// A level 3 [heading](#highlight.tags.heading).
    heading3: t(heading),
    /// A level 4 [heading](#highlight.tags.heading).
    heading4: t(heading),
    /// A level 5 [heading](#highlight.tags.heading).
    heading5: t(heading),
    /// A level 6 [heading](#highlight.tags.heading).
    heading6: t(heading),
    /// A prose separator (such as a horizontal rule).
    contentSeparator: t(content),
    /// [Content](#highlight.tags.content) that represents a list.
    list: t(content),
    /// [Content](#highlight.tags.content) that represents a quote.
    quote: t(content),
    /// [Content](#highlight.tags.content) that is emphasized.
    emphasis: t(content),
    /// [Content](#highlight.tags.content) that is styled strong.
    strong: t(content),
    /// [Content](#highlight.tags.content) that is part of a link.
    link: t(content),
    /// [Content](#highlight.tags.content) that is styled as code or
    /// monospace.
    monospace: t(content),
    /// Inserted text in a change-tracking format.
    inserted: t(),
    /// Deleted text.
    deleted: t(),
    /// Changed text.
    changed: t(),
    /// An invalid or unsyntactic element.
    invalid: t(),
    /// Metadata or meta-instruction.
    meta,
    /// [Metadata](#highlight.tags.meta) that applies to the entire
    /// document.
    documentMeta: t(meta),
    /// [Metadata](#highlight.tags.meta) that annotates or adds
    /// attributes to a given syntactic element.
    annotation: t(meta),
    /// Processing instruction or preprocessor directive. Subtag of
    /// [meta](#highlight.tags.meta).
    processingInstruction: t(meta),
    /// [Modifier](#highlight.Tag^defineModifier) that indicates that a
    /// given element is being defined. Expected to be used with the
    /// various [name](#highlight.tags.name) tags.
    definition: Tag.defineModifier(),
    /// [Modifier](#highlight.Tag^defineModifier) that indicates that
    /// something is constant. Mostly expected to be used with
    /// [variable names](#highlight.tags.variableName).
    constant: Tag.defineModifier(),
    /// [Modifier](#highlight.Tag^defineModifier) used to indicate that
    /// a [variable](#highlight.tags.variableName) or [property
    /// name](#highlight.tags.propertyName) is being called or defined
    /// as a function.
    function: Tag.defineModifier(),
    /// [Modifier](#highlight.Tag^defineModifier) that can be applied to
    /// [names](#highlight.tags.name) to indicate that they belong to
    /// the language's standard environment.
    standard: Tag.defineModifier(),
    /// [Modifier](#highlight.Tag^defineModifier) that indicates a given
    /// [names](#highlight.tags.name) is local to some scope.
    local: Tag.defineModifier(),
    /// A generic variant [modifier](#highlight.Tag^defineModifier) that
    /// can be used to tag language-specific alternative variants of
    /// some common tag. It is recommended for themes to define special
    /// forms of at least the [string](#highlight.tags.string) and
    /// [variable name](#highlight.tags.variableName) tags, since those
    /// come up a lot.
    special: Tag.defineModifier()
};
/// A default highlight style (works well with light themes).
const defaultHighlightStyle = HighlightStyle.define([
    { tag: tags.link,
        textDecoration: "underline" },
    { tag: tags.heading,
        textDecoration: "underline",
        fontWeight: "bold" },
    { tag: tags.emphasis,
        fontStyle: "italic" },
    { tag: tags.strong,
        fontWeight: "bold" },
    { tag: tags.keyword,
        color: "#708" },
    { tag: [tags.atom, tags.bool, tags.url, tags.contentSeparator, tags.labelName],
        color: "#219" },
    { tag: [tags.literal, tags.inserted],
        color: "#164" },
    { tag: [tags.string, tags.deleted],
        color: "#a11" },
    { tag: [tags.regexp, tags.escape, tags.special(tags.string)],
        color: "#e40" },
    { tag: tags.definition(tags.variableName),
        color: "#00f" },
    { tag: tags.local(tags.variableName),
        color: "#30a" },
    { tag: [tags.typeName, tags.namespace],
        color: "#085" },
    { tag: tags.className,
        color: "#167" },
    { tag: [tags.special(tags.variableName), tags.macroName],
        color: "#256" },
    { tag: tags.definition(tags.propertyName),
        color: "#00c" },
    { tag: tags.comment,
        color: "#940" },
    { tag: tags.meta,
        color: "#7a757a" },
    { tag: tags.invalid,
        color: "#f00" }
]);
/// This is a highlight style that adds stable, predictable classes to
/// tokens, for styling with external CSS.
///
/// These tags are mapped to their name prefixed with `"cmt-"` (for
/// example `"cmt-comment"`):
///
/// * [`link`](#highlight.tags.link)
/// * [`heading`](#highlight.tags.heading)
/// * [`emphasis`](#highlight.tags.emphasis)
/// * [`strong`](#highlight.tags.strong)
/// * [`keyword`](#highlight.tags.keyword)
/// * [`atom`](#highlight.tags.atom) [`bool`](#highlight.tags.bool)
/// * [`url`](#highlight.tags.url)
/// * [`labelName`](#highlight.tags.labelName)
/// * [`inserted`](#highlight.tags.inserted)
/// * [`deleted`](#highlight.tags.deleted)
/// * [`literal`](#highlight.tags.literal)
/// * [`string`](#highlight.tags.string)
/// * [`number`](#highlight.tags.number)
/// * [`variableName`](#highlight.tags.variableName)
/// * [`typeName`](#highlight.tags.typeName)
/// * [`namespace`](#highlight.tags.namespace)
/// * [`macroName`](#highlight.tags.macroName)
/// * [`propertyName`](#highlight.tags.propertyName)
/// * [`operator`](#highlight.tags.operator)
/// * [`comment`](#highlight.tags.comment)
/// * [`meta`](#highlight.tags.meta)
/// * [`punctuation`](#highlight.tags.puncutation)
/// * [`invalid`](#highlight.tags.invalid)
///
/// In addition, these mappings are provided:
///
/// * [`regexp`](#highlight.tags.regexp),
///   [`escape`](#highlight.tags.escape), and
///   [`special`](#highlight.tags.special)[`(string)`](#highlight.tags.string)
///   are mapped to `"cmt-string2"`
/// * [`special`](#highlight.tags.special)[`(variableName)`](#highlight.tags.variableName)
///   to `"cmt-variableName2"`
/// * [`local`](#highlight.tags.local)[`(variableName)`](#highlight.tags.variableName)
///   to `"cmt-variableName cmt-local"`
/// * [`definition`](#highlight.tags.definition)[`(variableName)`](#highlight.tags.variableName)
///   to `"cmt-variableName cmt-definition"`
const classHighlightStyle = HighlightStyle.define([
    { tag: tags.link, class: "cmt-link" },
    { tag: tags.heading, class: "cmt-heading" },
    { tag: tags.emphasis, class: "cmt-emphasis" },
    { tag: tags.strong, class: "cmt-strong" },
    { tag: tags.keyword, class: "cmt-keyword" },
    { tag: tags.atom, class: "cmt-atom" },
    { tag: tags.bool, class: "cmt-bool" },
    { tag: tags.url, class: "cmt-url" },
    { tag: tags.labelName, class: "cmt-labelName" },
    { tag: tags.inserted, class: "cmt-inserted" },
    { tag: tags.deleted, class: "cmt-deleted" },
    { tag: tags.literal, class: "cmt-literal" },
    { tag: tags.string, class: "cmt-string" },
    { tag: tags.number, class: "cmt-number" },
    { tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: "cmt-string2" },
    { tag: tags.variableName, class: "cmt-variableName" },
    { tag: tags.local(tags.variableName), class: "cmt-variableName cmt-local" },
    { tag: tags.definition(tags.variableName), class: "cmt-variableName cmt-definition" },
    { tag: tags.special(tags.variableName), class: "cmt-variableName2" },
    { tag: tags.typeName, class: "cmt-typeName" },
    { tag: tags.namespace, class: "cmt-namespace" },
    { tag: tags.macroName, class: "cmt-macroName" },
    { tag: tags.propertyName, class: "cmt-propertyName" },
    { tag: tags.operator, class: "cmt-operator" },
    { tag: tags.comment, class: "cmt-comment" },
    { tag: tags.meta, class: "cmt-meta" },
    { tag: tags.invalid, class: "cmt-invalid" },
    { tag: tags.punctuation, class: "cmt-punctuation" }
]);

exports.HighlightStyle = HighlightStyle;
exports.Tag = Tag;
exports.classHighlightStyle = classHighlightStyle;
exports.defaultHighlightStyle = defaultHighlightStyle;
exports.highlightTree = highlightTree;
exports.styleTags = styleTags;
exports.tags = tags;

},{"@codemirror/language":10,"@codemirror/rangeset":14,"@codemirror/state":17,"@codemirror/view":20,"lezer-tree":23,"style-mod":24}],9:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var state = require('@codemirror/state');
var view = require('@codemirror/view');

const fromHistory = state.Annotation.define();
/**
Transaction annotation that will prevent that transaction from
being combined with other transactions in the undo history. Given
`"before"`, it'll prevent merging with previous transactions. With
`"after"`, subsequent transactions won't be combined with this
one. With `"full"`, the transaction is isolated on both sides.
*/
const isolateHistory = state.Annotation.define();
/**
This facet provides a way to register functions that, given a
transaction, provide a set of effects that the history should
store when inverting the transaction. This can be used to
integrate some kinds of effects in the history, so that they can
be undone (and redone again).
*/
const invertedEffects = state.Facet.define();
const historyConfig = state.Facet.define({
    combine(configs) {
        return state.combineConfig(configs, {
            minDepth: 100,
            newGroupDelay: 500
        }, { minDepth: Math.max, newGroupDelay: Math.min });
    }
});
const historyField_ = state.StateField.define({
    create() {
        return HistoryState.empty;
    },
    update(state$1, tr) {
        let config = tr.state.facet(historyConfig);
        let fromHist = tr.annotation(fromHistory);
        if (fromHist) {
            let item = HistEvent.fromTransaction(tr), from = fromHist.side;
            let other = from == 0 /* Done */ ? state$1.undone : state$1.done;
            if (item)
                other = updateBranch(other, other.length, config.minDepth, item);
            else
                other = addSelection(other, tr.startState.selection);
            return new HistoryState(from == 0 /* Done */ ? fromHist.rest : other, from == 0 /* Done */ ? other : fromHist.rest);
        }
        let isolate = tr.annotation(isolateHistory);
        if (isolate == "full" || isolate == "before")
            state$1 = state$1.isolate();
        if (tr.annotation(state.Transaction.addToHistory) === false)
            return !tr.changes.empty ? state$1.addMapping(tr.changes.desc) : state$1;
        let event = HistEvent.fromTransaction(tr);
        let time = tr.annotation(state.Transaction.time), userEvent = tr.annotation(state.Transaction.userEvent);
        if (event)
            state$1 = state$1.addChanges(event, time, userEvent, config.newGroupDelay, config.minDepth);
        else if (tr.selection)
            state$1 = state$1.addSelection(tr.startState.selection, time, userEvent, config.newGroupDelay);
        if (isolate == "full" || isolate == "after")
            state$1 = state$1.isolate();
        return state$1;
    },
    toJSON(value) {
        return { done: value.done.map(e => e.toJSON()), undone: value.undone.map(e => e.toJSON()) };
    },
    fromJSON(json) {
        return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));
    }
});
/**
Create a history extension with the given configuration.
*/
function history(config = {}) {
    return [
        historyField_,
        historyConfig.of(config),
        view.EditorView.domEventHandlers({
            beforeinput(e, view) {
                if (e.inputType == "historyUndo")
                    return undo(view);
                if (e.inputType == "historyRedo")
                    return redo(view);
                return false;
            }
        })
    ];
}
/**
The state field used to store the history data. Should probably
only be used when you want to
[serialize](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) or
[deserialize](https://codemirror.net/6/docs/ref/#state.EditorState^fromJSON) state objects in a way
that preserves history.
*/
const historyField = historyField_;
function cmd(side, selection) {
    return function ({ state, dispatch }) {
        let historyState = state.field(historyField_, false);
        if (!historyState)
            return false;
        let tr = historyState.pop(side, state, selection);
        if (!tr)
            return false;
        dispatch(tr);
        return true;
    };
}
/**
Undo a single group of history events. Returns false if no group
was available.
*/
const undo = cmd(0 /* Done */, false);
/**
Redo a group of history events. Returns false if no group was
available.
*/
const redo = cmd(1 /* Undone */, false);
/**
Undo a selection change.
*/
const undoSelection = cmd(0 /* Done */, true);
/**
Redo a selection change.
*/
const redoSelection = cmd(1 /* Undone */, true);
function depth(side) {
    return function (state) {
        let histState = state.field(historyField_, false);
        if (!histState)
            return 0;
        let branch = side == 0 /* Done */ ? histState.done : histState.undone;
        return branch.length - (branch.length && !branch[0].changes ? 1 : 0);
    };
}
/**
The amount of undoable change events available in a given state.
*/
const undoDepth = depth(0 /* Done */);
/**
The amount of redoable change events available in a given state.
*/
const redoDepth = depth(1 /* Undone */);
// History events store groups of changes or effects that need to be
// undone/redone together.
class HistEvent {
    constructor(
    // The changes in this event. Normal events hold at least one
    // change or effect. But it may be necessary to store selection
    // events before the first change, in which case a special type of
    // instance is created which doesn't hold any changes, with
    // changes == startSelection == undefined
    changes, 
    // The effects associated with this event
    effects, mapped, 
    // The selection before this event
    startSelection, 
    // Stores selection changes after this event, to be used for
    // selection undo/redo.
    selectionsAfter) {
        this.changes = changes;
        this.effects = effects;
        this.mapped = mapped;
        this.startSelection = startSelection;
        this.selectionsAfter = selectionsAfter;
    }
    setSelAfter(after) {
        return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);
    }
    toJSON() {
        var _a, _b, _c;
        return {
            changes: (_a = this.changes) === null || _a === void 0 ? void 0 : _a.toJSON(),
            mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),
            startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),
            selectionsAfter: this.selectionsAfter.map(s => s.toJSON())
        };
    }
    static fromJSON(json) {
        return new HistEvent(json.changes && state.ChangeSet.fromJSON(json.changes), [], json.mapped && state.ChangeDesc.fromJSON(json.mapped), json.startSelection && state.EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(state.EditorSelection.fromJSON));
    }
    // This does not check `addToHistory` and such, it assumes the
    // transaction needs to be converted to an item. Returns null when
    // there are no changes or effects in the transaction.
    static fromTransaction(tr) {
        let effects = none;
        for (let invert of tr.startState.facet(invertedEffects)) {
            let result = invert(tr);
            if (result.length)
                effects = effects.concat(result);
        }
        if (!effects.length && tr.changes.empty)
            return null;
        return new HistEvent(tr.changes.invert(tr.startState.doc), effects, undefined, tr.startState.selection, none);
    }
    static selection(selections) {
        return new HistEvent(undefined, none, undefined, undefined, selections);
    }
}
function updateBranch(branch, to, maxLen, newEvent) {
    let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;
    let newBranch = branch.slice(start, to);
    newBranch.push(newEvent);
    return newBranch;
}
function isAdjacent(a, b) {
    let ranges = [], isAdjacent = false;
    a.iterChangedRanges((f, t) => ranges.push(f, t));
    b.iterChangedRanges((_f, _t, f, t) => {
        for (let i = 0; i < ranges.length;) {
            let from = ranges[i++], to = ranges[i++];
            if (t >= from && f <= to)
                isAdjacent = true;
        }
    });
    return isAdjacent;
}
function eqSelectionShape(a, b) {
    return a.ranges.length == b.ranges.length &&
        a.ranges.filter((r, i) => r.empty != b.ranges[i].empty).length === 0;
}
function conc(a, b) {
    return !a.length ? b : !b.length ? a : a.concat(b);
}
const none = [];
const MaxSelectionsPerEvent = 200;
function addSelection(branch, selection) {
    if (!branch.length) {
        return [HistEvent.selection([selection])];
    }
    else {
        let lastEvent = branch[branch.length - 1];
        let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));
        if (sels.length && sels[sels.length - 1].eq(selection))
            return branch;
        sels.push(selection);
        return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));
    }
}
// Assumes the top item has one or more selectionAfter values
function popSelection(branch) {
    let last = branch[branch.length - 1];
    let newBranch = branch.slice();
    newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));
    return newBranch;
}
// Add a mapping to the top event in the given branch. If this maps
// away all the changes and effects in that item, drop it and
// propagate the mapping to the next item.
function addMappingToBranch(branch, mapping) {
    if (!branch.length)
        return branch;
    let length = branch.length, selections = none;
    while (length) {
        let event = mapEvent(branch[length - 1], mapping, selections);
        if (event.changes && !event.changes.empty || event.effects.length) { // Event survived mapping
            let result = branch.slice(0, length);
            result[length - 1] = event;
            return result;
        }
        else { // Drop this event, since there's no changes or effects left
            mapping = event.mapped;
            length--;
            selections = event.selectionsAfter;
        }
    }
    return selections.length ? [HistEvent.selection(selections)] : none;
}
function mapEvent(event, mapping, extraSelections) {
    let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map(s => s.map(mapping)) : none, extraSelections);
    // Change-less events don't store mappings (they are always the last event in a branch)
    if (!event.changes)
        return HistEvent.selection(selections);
    let mappedChanges = event.changes.map(mapping), before = mapping.mapDesc(event.changes, true);
    let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;
    return new HistEvent(mappedChanges, state.StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);
}
class HistoryState {
    constructor(done, undone, prevTime = 0, prevUserEvent = undefined) {
        this.done = done;
        this.undone = undone;
        this.prevTime = prevTime;
        this.prevUserEvent = prevUserEvent;
    }
    isolate() {
        return this.prevTime ? new HistoryState(this.done, this.undone) : this;
    }
    addChanges(event, time, userEvent, newGroupDelay, maxLen) {
        let done = this.done, lastEvent = done[done.length - 1];
        if (lastEvent && lastEvent.changes &&
            time - this.prevTime < newGroupDelay &&
            !lastEvent.selectionsAfter.length &&
            !lastEvent.changes.empty && event.changes &&
            isAdjacent(lastEvent.changes, event.changes)) {
            done = updateBranch(done, done.length - 1, maxLen, new HistEvent(event.changes.compose(lastEvent.changes), conc(event.effects, lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none));
        }
        else {
            done = updateBranch(done, done.length, maxLen, event);
        }
        return new HistoryState(done, none, time, userEvent);
    }
    addSelection(selection, time, userEvent, newGroupDelay) {
        let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none;
        if (last.length > 0 &&
            time - this.prevTime < newGroupDelay &&
            userEvent == "keyboardselection" && this.prevUserEvent == userEvent &&
            eqSelectionShape(last[last.length - 1], selection))
            return this;
        return new HistoryState(addSelection(this.done, selection), this.undone, time, userEvent);
    }
    addMapping(mapping) {
        return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);
    }
    pop(side, state, selection) {
        let branch = side == 0 /* Done */ ? this.done : this.undone;
        if (branch.length == 0)
            return null;
        let event = branch[branch.length - 1];
        if (selection && event.selectionsAfter.length) {
            return state.update({
                selection: event.selectionsAfter[event.selectionsAfter.length - 1],
                annotations: fromHistory.of({ side, rest: popSelection(branch) })
            });
        }
        else if (!event.changes) {
            return null;
        }
        else {
            let rest = branch.length == 1 ? none : branch.slice(0, branch.length - 1);
            if (event.mapped)
                rest = addMappingToBranch(rest, event.mapped);
            return state.update({
                changes: event.changes,
                selection: event.startSelection,
                effects: event.effects,
                annotations: fromHistory.of({ side, rest }),
                filter: false
            });
        }
    }
}
HistoryState.empty = new HistoryState(none, none);
/**
Default key bindings for the undo history.

- Mod-z: [`undo`](https://codemirror.net/6/docs/ref/#history.undo).
- Mod-y (Mod-Shift-z on macOS): [`redo`](https://codemirror.net/6/docs/ref/#history.redo).
- Mod-u: [`undoSelection`](https://codemirror.net/6/docs/ref/#history.undoSelection).
- Alt-u (Mod-Shift-u on macOS): [`redoSelection`](https://codemirror.net/6/docs/ref/#history.redoSelection).
*/
const historyKeymap = [
    { key: "Mod-z", run: undo, preventDefault: true },
    { key: "Mod-y", mac: "Mod-Shift-z", run: redo, preventDefault: true },
    { key: "Mod-u", run: undoSelection, preventDefault: true },
    { key: "Alt-u", mac: "Mod-Shift-u", run: redoSelection, preventDefault: true }
];

exports.history = history;
exports.historyField = historyField;
exports.historyKeymap = historyKeymap;
exports.invertedEffects = invertedEffects;
exports.isolateHistory = isolateHistory;
exports.redo = redo;
exports.redoDepth = redoDepth;
exports.redoSelection = redoSelection;
exports.undo = undo;
exports.undoDepth = undoDepth;
exports.undoSelection = undoSelection;

},{"@codemirror/state":17,"@codemirror/view":20}],10:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var lezerTree = require('lezer-tree');
var text = require('@codemirror/text');
var state = require('@codemirror/state');
var view = require('@codemirror/view');

/**
Node prop stored in a grammar's top syntax node to provide the
facet that stores language data for that language.
*/
const languageDataProp = new lezerTree.NodeProp();
/**
Helper function to define a facet (to be added to the top syntax
node(s) for a language via
[`languageDataProp`](https://codemirror.net/6/docs/ref/#language.languageDataProp)), that will be
used to associate language data with the language. You
probably only need this when subclassing
[`Language`](https://codemirror.net/6/docs/ref/#language.Language).
*/
function defineLanguageFacet(baseData) {
    return state.Facet.define({
        combine: baseData ? values => values.concat(baseData) : undefined
    });
}
/**
A language object manages parsing and per-language
[metadata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt). Parse data is
managed as a [Lezer](https://lezer.codemirror.net) tree. You'll
want to subclass this class for custom parsers, or use the
[`LezerLanguage`](https://codemirror.net/6/docs/ref/#language.LezerLanguage) or
[`StreamLanguage`](https://codemirror.net/6/docs/ref/#stream-parser.StreamLanguage) abstractions for
[Lezer](https://lezer.codemirror.net/) or stream parsers.
*/
class Language {
    /**
    Construct a language object. You usually don't need to invoke
    this directly. But when you do, make sure you use
    [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet) to create
    the first argument.
    */
    constructor(
    /**
    The [language data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt) data
    facet used for this language.
    */
    data, parser, 
    /**
    The node type of the top node of trees produced by this parser.
    */
    topNode, extraExtensions = []) {
        this.data = data;
        this.topNode = topNode;
        // Kludge to define EditorState.tree as a debugging helper,
        // without the EditorState package actually knowing about
        // languages and lezer trees.
        if (!state.EditorState.prototype.hasOwnProperty("tree"))
            Object.defineProperty(state.EditorState.prototype, "tree", { get() { return syntaxTree(this); } });
        this.parser = parser;
        this.extension = [
            language.of(this),
            state.EditorState.languageData.of((state, pos) => state.facet(languageDataFacetAt(state, pos)))
        ].concat(extraExtensions);
    }
    /**
    Query whether this language is active at the given position.
    */
    isActiveAt(state, pos) {
        return languageDataFacetAt(state, pos) == this.data;
    }
    /**
    Find the document regions that were parsed using this language.
    The returned regions will _include_ any nested languages rooted
    in this language, when those exist.
    */
    findRegions(state) {
        let lang = state.facet(language);
        if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data)
            return [{ from: 0, to: state.doc.length }];
        if (!lang || !lang.allowsNesting)
            return [];
        let result = [];
        syntaxTree(state).iterate({
            enter: (type, from, to) => {
                if (type.isTop && type.prop(languageDataProp) == this.data) {
                    result.push({ from, to });
                    return false;
                }
                return undefined;
            }
        });
        return result;
    }
    /**
    Indicates whether this language allows nested languages. The
    default implementation returns true.
    */
    get allowsNesting() { return true; }
    /**
    Use this language to parse the given string into a tree.
    */
    parseString(code) {
        let doc = text.Text.of(code.split("\n"));
        let parse = this.parser.startParse(new DocInput(doc), 0, new EditorParseContext(this.parser, state.EditorState.create({ doc }), [], lezerTree.Tree.empty, { from: 0, to: code.length }, [], null));
        let tree;
        while (!(tree = parse.advance())) { }
        return tree;
    }
}
/**
@internal
*/
Language.setState = state.StateEffect.define();
function languageDataFacetAt(state, pos) {
    let topLang = state.facet(language);
    if (!topLang)
        return null;
    if (!topLang.allowsNesting)
        return topLang.data;
    let tree = syntaxTree(state);
    let target = tree.resolve(pos, -1);
    while (target) {
        let facet = target.type.prop(languageDataProp);
        if (facet)
            return facet;
        target = target.parent;
    }
    return topLang.data;
}
/**
A subclass of [`Language`](https://codemirror.net/6/docs/ref/#language.Language) for use with
[Lezer](https://lezer.codemirror.net/docs/ref#lezer.Parser)
parsers.
*/
class LezerLanguage extends Language {
    constructor(data, parser) {
        super(data, parser, parser.topNode);
        this.parser = parser;
    }
    /**
    Define a language from a parser.
    */
    static define(spec) {
        let data = defineLanguageFacet(spec.languageData);
        return new LezerLanguage(data, spec.parser.configure({
            props: [languageDataProp.add(type => type.isTop ? data : undefined)]
        }));
    }
    /**
    Create a new instance of this language with a reconfigured
    version of its parser.
    */
    configure(options) {
        return new LezerLanguage(this.data, this.parser.configure(options));
    }
    get allowsNesting() { return this.parser.hasNested; }
}
/**
Get the syntax tree for a state, which is the current (possibly
incomplete) parse tree of active [language](https://codemirror.net/6/docs/ref/#language.Language),
or the empty tree if there is no language available.
*/
function syntaxTree(state) {
    let field = state.field(Language.state, false);
    return field ? field.tree : lezerTree.Tree.empty;
}
/**
Try to get a parse tree that spans at least up to `upto`. The
method will do at most `timeout` milliseconds of work to parse
up to that point if the tree isn't already available.
*/
function ensureSyntaxTree(state, upto, timeout = 50) {
    var _a;
    let parse = (_a = state.field(Language.state, false)) === null || _a === void 0 ? void 0 : _a.context;
    return !parse ? null : parse.tree.length >= upto || parse.work(timeout, upto) ? parse.tree : null;
}
// Lezer-style Input object for a Text document.
class DocInput {
    constructor(doc, length = doc.length) {
        this.doc = doc;
        this.length = length;
        this.cursorPos = 0;
        this.string = "";
        this.prevString = "";
        this.cursor = doc.iter();
    }
    syncTo(pos) {
        if (pos < this.cursorPos) { // Reset the cursor if we have to go back
            this.cursor = this.doc.iter();
            this.cursorPos = 0;
        }
        this.prevString = pos == this.cursorPos ? this.string : "";
        this.string = this.cursor.next(pos - this.cursorPos).value;
        this.cursorPos = pos + this.string.length;
        return this.cursorPos - this.string.length;
    }
    get(pos) {
        if (pos >= this.length)
            return -1;
        let stringStart = this.cursorPos - this.string.length;
        if (pos < stringStart || pos >= this.cursorPos) {
            if (pos < stringStart && pos >= stringStart - this.prevString.length)
                return this.prevString.charCodeAt(pos - (stringStart - this.prevString.length));
            stringStart = this.syncTo(pos);
        }
        return this.string.charCodeAt(pos - stringStart);
    }
    lineAfter(pos) {
        if (pos >= this.length || pos < 0)
            return "";
        let stringStart = this.cursorPos - this.string.length;
        if (pos < stringStart || pos >= this.cursorPos)
            stringStart = this.syncTo(pos);
        return this.cursor.lineBreak ? "" : this.string.slice(pos - stringStart, Math.min(this.length - stringStart, this.string.length));
    }
    read(from, to) {
        let stringStart = this.cursorPos - this.string.length;
        if (from < stringStart || to >= this.cursorPos)
            return this.doc.sliceString(from, to);
        else
            return this.string.slice(from - stringStart, to - stringStart);
    }
    clip(at) {
        return new DocInput(this.doc, at);
    }
}
/**
A parse context provided to parsers working on the editor content.
*/
class EditorParseContext {
    /**
    @internal
    */
    constructor(parser, 
    /**
    The current editor state.
    */
    state, 
    /**
    Tree fragments that can be reused by incremental re-parses.
    */
    fragments = [], 
    /**
    @internal
    */
    tree, 
    /**
    The current editor viewport (or some overapproximation
    thereof). Intended to be used for opportunistically avoiding
    work (in which case
    [`skipUntilInView`](https://codemirror.net/6/docs/ref/#language.EditorParseContext.skipUntilInView)
    should be called to make sure the parser is restarted when the
    skipped region becomes visible).
    */
    viewport, 
    /**
    @internal
    */
    skipped, 
    /**
    This is where skipping parsers can register a promise that,
    when resolved, will schedule a new parse. It is cleared when
    the parse worker picks up the promise. @internal
    */
    scheduleOn) {
        this.parser = parser;
        this.state = state;
        this.fragments = fragments;
        this.tree = tree;
        this.viewport = viewport;
        this.skipped = skipped;
        this.scheduleOn = scheduleOn;
        this.parse = null;
        /**
        @internal
        */
        this.tempSkipped = [];
    }
    /**
    @internal
    */
    work(time, upto) {
        if (this.tree != lezerTree.Tree.empty && (upto == null ? this.tree.length == this.state.doc.length : this.tree.length >= upto)) {
            this.takeTree();
            return true;
        }
        if (!this.parse)
            this.parse = this.parser.startParse(new DocInput(this.state.doc), 0, this);
        let endTime = Date.now() + time;
        for (;;) {
            let done = this.parse.advance();
            if (done) {
                this.fragments = this.withoutTempSkipped(lezerTree.TreeFragment.addTree(done));
                this.parse = null;
                this.tree = done;
                return true;
            }
            else if (upto != null && this.parse.pos >= upto) {
                this.takeTree();
                return true;
            }
            if (Date.now() > endTime)
                return false;
        }
    }
    /**
    @internal
    */
    takeTree() {
        if (this.parse && this.parse.pos > this.tree.length) {
            this.tree = this.parse.forceFinish();
            this.fragments = this.withoutTempSkipped(lezerTree.TreeFragment.addTree(this.tree, this.fragments, true));
        }
    }
    withoutTempSkipped(fragments) {
        for (let r; r = this.tempSkipped.pop();)
            fragments = cutFragments(fragments, r.from, r.to);
        return fragments;
    }
    /**
    @internal
    */
    changes(changes, newState) {
        let { fragments, tree, viewport, skipped } = this;
        this.takeTree();
        if (!changes.empty) {
            let ranges = [];
            changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({ fromA, toA, fromB, toB }));
            fragments = lezerTree.TreeFragment.applyChanges(fragments, ranges);
            tree = lezerTree.Tree.empty;
            viewport = { from: changes.mapPos(viewport.from, -1), to: changes.mapPos(viewport.to, 1) };
            if (this.skipped.length) {
                skipped = [];
                for (let r of this.skipped) {
                    let from = changes.mapPos(r.from, 1), to = changes.mapPos(r.to, -1);
                    if (from < to)
                        skipped.push({ from, to });
                }
            }
        }
        return new EditorParseContext(this.parser, newState, fragments, tree, viewport, skipped, this.scheduleOn);
    }
    /**
    @internal
    */
    updateViewport(viewport) {
        this.viewport = viewport;
        let startLen = this.skipped.length;
        for (let i = 0; i < this.skipped.length; i++) {
            let { from, to } = this.skipped[i];
            if (from < viewport.to && to > viewport.from) {
                this.fragments = cutFragments(this.fragments, from, to);
                this.skipped.splice(i--, 1);
            }
        }
        return this.skipped.length < startLen;
    }
    /**
    @internal
    */
    reset() {
        if (this.parse) {
            this.takeTree();
            this.parse = null;
        }
    }
    /**
    Notify the parse scheduler that the given region was skipped
    because it wasn't in view, and the parse should be restarted
    when it comes into view.
    */
    skipUntilInView(from, to) {
        this.skipped.push({ from, to });
    }
    /**
    Returns a parser intended to be used as placeholder when
    asynchronously loading a nested parser. It'll skip its input and
    mark it as not-really-parsed, so that the next update will parse
    it again.
    
    When `until` is given, a reparse will be scheduled when that
    promise resolves.
    */
    static getSkippingParser(until) {
        return {
            startParse(input, startPos, context) {
                return {
                    pos: startPos,
                    advance() {
                        let ecx = context;
                        ecx.tempSkipped.push({ from: startPos, to: input.length });
                        if (until)
                            ecx.scheduleOn = ecx.scheduleOn ? Promise.all([ecx.scheduleOn, until]) : until;
                        this.pos = input.length;
                        return new lezerTree.Tree(lezerTree.NodeType.none, [], [], input.length - startPos);
                    },
                    forceFinish() { return this.advance(); }
                };
            }
        };
    }
    /**
    @internal
    */
    movedPast(pos) {
        return this.tree.length < pos && this.parse && this.parse.pos >= pos;
    }
}
/**
FIXME backwards compatible shim, remove on next major @internal
*/
EditorParseContext.skippingParser = EditorParseContext.getSkippingParser();
function cutFragments(fragments, from, to) {
    return lezerTree.TreeFragment.applyChanges(fragments, [{ fromA: from, toA: to, fromB: from, toB: to }]);
}
class LanguageState {
    constructor(
    // A mutable parse state that is used to preserve work done during
    // the lifetime of a state when moving to the next state.
    context) {
        this.context = context;
        this.tree = context.tree;
    }
    apply(tr) {
        if (!tr.docChanged)
            return this;
        let newCx = this.context.changes(tr.changes, tr.state);
        // If the previous parse wasn't done, go forward only up to its
        // end position or the end of the viewport, to avoid slowing down
        // state updates with parse work beyond the viewport.
        let upto = this.context.tree.length == tr.startState.doc.length ? undefined
            : Math.max(tr.changes.mapPos(this.context.tree.length), newCx.viewport.to);
        if (!newCx.work(25 /* Apply */, upto))
            newCx.takeTree();
        return new LanguageState(newCx);
    }
    static init(state) {
        let parseState = new EditorParseContext(state.facet(language).parser, state, [], lezerTree.Tree.empty, { from: 0, to: state.doc.length }, [], null);
        if (!parseState.work(25 /* Apply */))
            parseState.takeTree();
        return new LanguageState(parseState);
    }
}
Language.state = state.StateField.define({
    create: LanguageState.init,
    update(value, tr) {
        for (let e of tr.effects)
            if (e.is(Language.setState))
                return e.value;
        if (tr.startState.facet(language) != tr.state.facet(language))
            return LanguageState.init(tr.state);
        return value.apply(tr);
    }
});
let requestIdle = typeof window != "undefined" && window.requestIdleCallback ||
    ((callback, { timeout }) => setTimeout(callback, timeout));
let cancelIdle = typeof window != "undefined" && window.cancelIdleCallback || clearTimeout;
const parseWorker = view.ViewPlugin.fromClass(class ParseWorker {
    constructor(view) {
        this.view = view;
        this.working = -1;
        // End of the current time chunk
        this.chunkEnd = -1;
        // Milliseconds of budget left for this chunk
        this.chunkBudget = -1;
        this.work = this.work.bind(this);
        this.scheduleWork();
    }
    update(update) {
        let cx = this.view.state.field(Language.state).context;
        if (update.viewportChanged) {
            if (cx.updateViewport(update.view.viewport))
                cx.reset();
            if (this.view.viewport.to > cx.tree.length)
                this.scheduleWork();
        }
        if (update.docChanged) {
            if (this.view.hasFocus)
                this.chunkBudget += 50 /* ChangeBonus */;
            this.scheduleWork();
        }
        this.checkAsyncSchedule(cx);
    }
    scheduleWork(force = false) {
        if (this.working > -1)
            return;
        let { state } = this.view, field = state.field(Language.state);
        if (!force && field.tree.length >= state.doc.length)
            return;
        this.working = requestIdle(this.work, { timeout: 500 /* Pause */ });
    }
    work(deadline) {
        this.working = -1;
        let now = Date.now();
        if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) { // Start a new chunk
            this.chunkEnd = now + 30000 /* ChunkTime */;
            this.chunkBudget = 3000 /* ChunkBudget */;
        }
        if (this.chunkBudget <= 0)
            return; // No more budget
        let { state, viewport: { to: vpTo } } = this.view, field = state.field(Language.state);
        if (field.tree.length >= vpTo + 1000000 /* MaxParseAhead */)
            return;
        let time = Math.min(this.chunkBudget, deadline ? Math.max(25 /* MinSlice */, deadline.timeRemaining()) : 100 /* Slice */);
        let done = field.context.work(time, vpTo + 1000000 /* MaxParseAhead */);
        this.chunkBudget -= Date.now() - now;
        if (done || this.chunkBudget <= 0 || field.context.movedPast(vpTo)) {
            field.context.takeTree();
            this.view.dispatch({ effects: Language.setState.of(new LanguageState(field.context)) });
        }
        if (!done && this.chunkBudget > 0)
            this.scheduleWork();
        this.checkAsyncSchedule(field.context);
    }
    checkAsyncSchedule(cx) {
        if (cx.scheduleOn) {
            cx.scheduleOn.then(() => this.scheduleWork(true));
            cx.scheduleOn = null;
        }
    }
    destroy() {
        if (this.working >= 0)
            cancelIdle(this.working);
    }
}, {
    eventHandlers: { focus() { this.scheduleWork(); } }
});
/**
The facet used to associate a language with an editor state.
*/
const language = state.Facet.define({
    combine(languages) { return languages.length ? languages[0] : null; },
    enables: [Language.state, parseWorker]
});
/**
This class bundles a [language object](https://codemirror.net/6/docs/ref/#language.Language) with an
optional set of supporting extensions. Language packages are
encouraged to export a function that optionally takes a
configuration object and returns a `LanguageSupport` instance, as
the main way for client code to use the package.
*/
class LanguageSupport {
    /**
    Create a support object.
    */
    constructor(
    /**
    The language object.
    */
    language, 
    /**
    An optional set of supporting extensions. When nesting a
    language in another language, the outer language is encouraged
    to include the supporting extensions for its inner languages
    in its own set of support extensions.
    */
    support = []) {
        this.language = language;
        this.support = support;
        this.extension = [language, support];
    }
}
/**
Language descriptions are used to store metadata about languages
and to dynamically load them. Their main role is finding the
appropriate language for a filename or dynamically loading nested
parsers.
*/
class LanguageDescription {
    constructor(
    /**
    The name of this language.
    */
    name, 
    /**
    Alternative names for the mode (lowercased, includes `this.name`).
    */
    alias, 
    /**
    File extensions associated with this language.
    */
    extensions, 
    /**
    Optional filename pattern that should be associated with this
    language.
    */
    filename, loadFunc) {
        this.name = name;
        this.alias = alias;
        this.extensions = extensions;
        this.filename = filename;
        this.loadFunc = loadFunc;
        /**
        If the language has been loaded, this will hold its value.
        */
        this.support = undefined;
        this.loading = null;
    }
    /**
    Start loading the the language. Will return a promise that
    resolves to a [`LanguageSupport`](https://codemirror.net/6/docs/ref/#language.LanguageSupport)
    object when the language successfully loads.
    */
    load() {
        return this.loading || (this.loading = this.loadFunc().then(support => this.support = support, err => { this.loading = null; throw err; }));
    }
    /**
    Create a language description.
    */
    static of(spec) {
        return new LanguageDescription(spec.name, (spec.alias || []).concat(spec.name).map(s => s.toLowerCase()), spec.extensions || [], spec.filename, spec.load);
    }
    /**
    Look for a language in the given array of descriptions that
    matches the filename. Will first match
    [`filename`](https://codemirror.net/6/docs/ref/#language.LanguageDescription.filename) patterns,
    and then [extensions](https://codemirror.net/6/docs/ref/#language.LanguageDescription.extensions),
    and return the first language that matches.
    */
    static matchFilename(descs, filename) {
        for (let d of descs)
            if (d.filename && d.filename.test(filename))
                return d;
        let ext = /\.([^.]+)$/.exec(filename);
        if (ext)
            for (let d of descs)
                if (d.extensions.indexOf(ext[1]) > -1)
                    return d;
        return null;
    }
    /**
    Look for a language whose name or alias matches the the given
    name (case-insensitively). If `fuzzy` is true, and no direct
    matchs is found, this'll also search for a language whose name
    or alias occurs in the string (for names shorter than three
    characters, only when surrounded by non-word characters).
    */
    static matchLanguageName(descs, name, fuzzy = true) {
        name = name.toLowerCase();
        for (let d of descs)
            if (d.alias.some(a => a == name))
                return d;
        if (fuzzy)
            for (let d of descs)
                for (let a of d.alias) {
                    let found = name.indexOf(a);
                    if (found > -1 && (a.length > 2 || !/\w/.test(name[found - 1]) && !/\w/.test(name[found + a.length])))
                        return d;
                }
        return null;
    }
}

/**
Facet that defines a way to provide a function that computes the
appropriate indentation depth at the start of a given line, or
`null` to indicate no appropriate indentation could be determined.
*/
const indentService = state.Facet.define();
/**
Facet for overriding the unit by which indentation happens.
Should be a string consisting either entirely of spaces or
entirely of tabs. When not set, this defaults to 2 spaces.
*/
const indentUnit = state.Facet.define({
    combine: values => {
        if (!values.length)
            return "  ";
        if (!/^(?: +|\t+)$/.test(values[0]))
            throw new Error("Invalid indent unit: " + JSON.stringify(values[0]));
        return values[0];
    }
});
/**
Return the _column width_ of an indent unit in the state.
Determined by the [`indentUnit`](https://codemirror.net/6/docs/ref/#language.indentUnit)
facet, and [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) when that
contains tabs.
*/
function getIndentUnit(state) {
    let unit = state.facet(indentUnit);
    return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;
}
/**
Create an indentation string that covers columns 0 to `cols`.
Will use tabs for as much of the columns as possible when the
[`indentUnit`](https://codemirror.net/6/docs/ref/#language.indentUnit) facet contains
tabs.
*/
function indentString(state, cols) {
    let result = "", ts = state.tabSize;
    if (state.facet(indentUnit).charCodeAt(0) == 9)
        while (cols >= ts) {
            result += "\t";
            cols -= ts;
        }
    for (let i = 0; i < cols; i++)
        result += " ";
    return result;
}
/**
Get the indentation at the given position. Will first consult any
[indent services](https://codemirror.net/6/docs/ref/#language.indentService) that are registered,
and if none of those return an indentation, this will check the
syntax tree for the [indent node prop](https://codemirror.net/6/docs/ref/#language.indentNodeProp)
and use that if found. Returns a number when an indentation could
be determined, and null otherwise.
*/
function getIndentation(context, pos) {
    if (context instanceof state.EditorState)
        context = new IndentContext(context);
    for (let service of context.state.facet(indentService)) {
        let result = service(context, pos);
        if (result != null)
            return result;
    }
    let tree = syntaxTree(context.state);
    return tree ? syntaxIndentation(context, tree, pos) : null;
}
/**
Indentation contexts are used when calling [indentation
services](https://codemirror.net/6/docs/ref/#language.indentService). They provide helper utilities
useful in indentation logic, and can selectively override the
indentation reported for some lines.
*/
class IndentContext {
    /**
    Create an indent context.
    */
    constructor(
    /**
    The editor state.
    */
    state, 
    /**
    @internal
    */
    options = {}) {
        this.state = state;
        this.options = options;
        this.unit = getIndentUnit(state);
    }
    /**
    Get the text directly after `pos`, either the entire line
    or the next 100 characters, whichever is shorter.
    */
    textAfterPos(pos) {
        var _a, _b;
        let sim = (_a = this.options) === null || _a === void 0 ? void 0 : _a.simulateBreak;
        if (pos == sim && ((_b = this.options) === null || _b === void 0 ? void 0 : _b.simulateDoubleBreak))
            return "";
        return this.state.sliceDoc(pos, Math.min(pos + 100, sim != null && sim > pos ? sim : 1e9, this.state.doc.lineAt(pos).to));
    }
    /**
    Find the column for the given position.
    */
    column(pos) {
        var _a;
        let line = this.state.doc.lineAt(pos), text = line.text.slice(0, pos - line.from);
        let result = this.countColumn(text, pos - line.from);
        let override = ((_a = this.options) === null || _a === void 0 ? void 0 : _a.overrideIndentation) ? this.options.overrideIndentation(line.from) : -1;
        if (override > -1)
            result += override - this.countColumn(text, text.search(/\S/));
        return result;
    }
    /**
    find the column position (taking tabs into account) of the given
    position in the given string.
    */
    countColumn(line, pos) {
        return text.countColumn(pos < 0 ? line : line.slice(0, pos), 0, this.state.tabSize);
    }
    /**
    Find the indentation column of the given document line.
    */
    lineIndent(line) {
        var _a;
        let override = (_a = this.options) === null || _a === void 0 ? void 0 : _a.overrideIndentation;
        if (override) {
            let overriden = override(line.from);
            if (overriden > -1)
                return overriden;
        }
        return this.countColumn(line.text, line.text.search(/\S/));
    }
}
/**
A syntax tree node prop used to associate indentation strategies
with node types. Such a strategy is a function from an indentation
context to a column number or null, where null indicates that no
definitive indentation can be determined.
*/
const indentNodeProp = new lezerTree.NodeProp();
// Compute the indentation for a given position from the syntax tree.
function syntaxIndentation(cx, ast, pos) {
    let tree = ast.resolve(pos);
    // Enter previous nodes that end in empty error terms, which means
    // they were broken off by error recovery, so that indentation
    // works even if the constructs haven't been finished.
    for (let scan = tree, scanPos = pos;;) {
        let last = scan.childBefore(scanPos);
        if (!last)
            break;
        if (last.type.isError && last.from == last.to) {
            tree = scan;
            scanPos = last.from;
        }
        else {
            scan = last;
            scanPos = scan.to + 1;
        }
    }
    return indentFrom(tree, pos, cx);
}
function ignoreClosed(cx) {
    var _a, _b;
    return cx.pos == ((_a = cx.options) === null || _a === void 0 ? void 0 : _a.simulateBreak) && ((_b = cx.options) === null || _b === void 0 ? void 0 : _b.simulateDoubleBreak);
}
function indentStrategy(tree) {
    let strategy = tree.type.prop(indentNodeProp);
    if (strategy)
        return strategy;
    let first = tree.firstChild, close;
    if (first && (close = first.type.prop(lezerTree.NodeProp.closedBy))) {
        let last = tree.lastChild, closed = last && close.indexOf(last.name) > -1;
        return cx => delimitedStrategy(cx, true, 1, undefined, closed && !ignoreClosed(cx) ? last.from : undefined);
    }
    return tree.parent == null ? topIndent : null;
}
function indentFrom(node, pos, base) {
    for (; node; node = node.parent) {
        let strategy = indentStrategy(node);
        if (strategy)
            return strategy(new TreeIndentContext(base, pos, node));
    }
    return null;
}
function topIndent() { return 0; }
/**
Objects of this type provide context information and helper
methods to indentation functions.
*/
class TreeIndentContext extends IndentContext {
    /**
    @internal
    */
    constructor(base, 
    /**
    The position at which indentation is being computed.
    */
    pos, 
    /**
    The syntax tree node to which the indentation strategy
    applies.
    */
    node) {
        super(base.state, base.options);
        this.base = base;
        this.pos = pos;
        this.node = node;
    }
    /**
    Get the text directly after `this.pos`, either the entire line
    or the next 100 characters, whichever is shorter.
    */
    get textAfter() {
        return this.textAfterPos(this.pos);
    }
    /**
    Get the indentation at the reference line for `this.node`, which
    is the line on which it starts, unless there is a node that is
    _not_ a parent of this node covering the start of that line. If
    so, the line at the start of that node is tried, again skipping
    on if it is covered by another such node.
    */
    get baseIndent() {
        let line = this.state.doc.lineAt(this.node.from);
        // Skip line starts that are covered by a sibling (or cousin, etc)
        for (;;) {
            let atBreak = this.node.resolve(line.from);
            while (atBreak.parent && atBreak.parent.from == atBreak.from)
                atBreak = atBreak.parent;
            if (isParent(atBreak, this.node))
                break;
            line = this.state.doc.lineAt(atBreak.from);
        }
        return this.lineIndent(line);
    }
    /**
    Continue looking for indentations in the node's parent nodes,
    and return the result of that.
    */
    continue() {
        let parent = this.node.parent;
        return parent ? indentFrom(parent, this.pos, this.base) : 0;
    }
}
function isParent(parent, of) {
    for (let cur = of; cur; cur = cur.parent)
        if (parent == cur)
            return true;
    return false;
}
// Check whether a delimited node is aligned (meaning there are
// non-skipped nodes on the same line as the opening delimiter). And
// if so, return the opening token.
function bracketedAligned(context) {
    var _a;
    let tree = context.node;
    let openToken = tree.childAfter(tree.from), last = tree.lastChild;
    if (!openToken)
        return null;
    let sim = (_a = context.options) === null || _a === void 0 ? void 0 : _a.simulateBreak;
    let openLine = context.state.doc.lineAt(openToken.from);
    let lineEnd = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);
    for (let pos = openToken.to;;) {
        let next = tree.childAfter(pos);
        if (!next || next == last)
            return null;
        if (!next.type.isSkipped)
            return next.from < lineEnd ? openToken : null;
        pos = next.to;
    }
}
/**
An indentation strategy for delimited (usually bracketed) nodes.
Will, by default, indent one unit more than the parent's base
indent unless the line starts with a closing token. When `align`
is true and there are non-skipped nodes on the node's opening
line, the content of the node will be aligned with the end of the
opening node, like this:

    foo(bar,
        baz)
*/
function delimitedIndent({ closing, align = true, units = 1 }) {
    return (context) => delimitedStrategy(context, align, units, closing);
}
function delimitedStrategy(context, align, units, closing, closedAt) {
    let after = context.textAfter, space = after.match(/^\s*/)[0].length;
    let closed = closing && after.slice(space, space + closing.length) == closing || closedAt == context.pos + space;
    let aligned = align ? bracketedAligned(context) : null;
    if (aligned)
        return closed ? context.column(aligned.from) : context.column(aligned.to);
    return context.baseIndent + (closed ? 0 : context.unit * units);
}
/**
An indentation strategy that aligns a node's content to its base
indentation.
*/
const flatIndent = (context) => context.baseIndent;
/**
Creates an indentation strategy that, by default, indents
continued lines one unit more than the node's base indentation.
You can provide `except` to prevent indentation of lines that
match a pattern (for example `/^else\b/` in `if`/`else`
constructs), and you can change the amount of units used with the
`units` option.
*/
function continuedIndent({ except, units = 1 } = {}) {
    return (context) => {
        let matchExcept = except && except.test(context.textAfter);
        return context.baseIndent + (matchExcept ? 0 : units * context.unit);
    };
}
const DontIndentBeyond = 200;
/**
Enables reindentation on input. When a language defines an
`indentOnInput` field in its [language
data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt), which must hold a regular
expression, the line at the cursor will be reindented whenever new
text is typed and the input from the start of the line up to the
cursor matches that regexp.

To avoid unneccesary reindents, it is recommended to start the
regexp with `^` (usually followed by `\s*`), and end it with `$`.
For example, `/^\s*\}$/` will reindent when a closing brace is
added at the start of a line.
*/
function indentOnInput() {
    return state.EditorState.transactionFilter.of(tr => {
        if (!tr.docChanged || tr.annotation(state.Transaction.userEvent) != "input")
            return tr;
        let rules = tr.startState.languageDataAt("indentOnInput", tr.startState.selection.main.head);
        if (!rules.length)
            return tr;
        let doc = tr.newDoc, { head } = tr.newSelection.main, line = doc.lineAt(head);
        if (head > line.from + DontIndentBeyond)
            return tr;
        let lineStart = doc.sliceString(line.from, head);
        if (!rules.some(r => r.test(lineStart)))
            return tr;
        let { state: state$1 } = tr, last = -1, changes = [];
        for (let { head } of state$1.selection.ranges) {
            let line = state$1.doc.lineAt(head);
            if (line.from == last)
                continue;
            last = line.from;
            let indent = getIndentation(state$1, line.from);
            if (indent == null)
                continue;
            let cur = /^\s*/.exec(line.text)[0];
            let norm = indentString(state$1, indent);
            if (cur != norm)
                changes.push({ from: line.from, to: line.from + cur.length, insert: norm });
        }
        return changes.length ? [tr, { changes }] : tr;
    });
}

/**
A facet that registers a code folding service. When called with
the extent of a line, such a function should return a foldable
range that starts on that line (but continues beyond it), if one
can be found.
*/
const foldService = state.Facet.define();
/**
This node prop is used to associate folding information with
syntax node types. Given a syntax node, it should check whether
that tree is foldable and return the range that can be collapsed
when it is.
*/
const foldNodeProp = new lezerTree.NodeProp();
/**
[Fold](https://codemirror.net/6/docs/ref/#language.foldNodeProp) function that folds everything but
the first and the last child of a syntax node. Useful for nodes
that start and end with delimiters.
*/
function foldInside(node) {
    let first = node.firstChild, last = node.lastChild;
    return first && first.to < last.from ? { from: first.to, to: last.type.isError ? node.to : last.from } : null;
}
function syntaxFolding(state, start, end) {
    let tree = syntaxTree(state);
    if (tree.length == 0)
        return null;
    let inner = tree.resolve(end);
    let found = null;
    for (let cur = inner; cur; cur = cur.parent) {
        if (cur.to <= end || cur.from > end)
            continue;
        if (found && cur.from < start)
            break;
        let prop = cur.type.prop(foldNodeProp);
        if (prop) {
            let value = prop(cur, state);
            if (value && value.from <= end && value.from >= start && value.to > end)
                found = value;
        }
    }
    return found;
}
/**
Check whether the given line is foldable. First asks any fold
services registered through
[`foldService`](https://codemirror.net/6/docs/ref/#language.foldService), and if none of them return
a result, tries to query the [fold node
prop](https://codemirror.net/6/docs/ref/#language.foldNodeProp) of syntax nodes that cover the end
of the line.
*/
function foldable(state, lineStart, lineEnd) {
    for (let service of state.facet(foldService)) {
        let result = service(state, lineStart, lineEnd);
        if (result)
            return result;
    }
    return syntaxFolding(state, lineStart, lineEnd);
}

exports.EditorParseContext = EditorParseContext;
exports.IndentContext = IndentContext;
exports.Language = Language;
exports.LanguageDescription = LanguageDescription;
exports.LanguageSupport = LanguageSupport;
exports.LezerLanguage = LezerLanguage;
exports.TreeIndentContext = TreeIndentContext;
exports.continuedIndent = continuedIndent;
exports.defineLanguageFacet = defineLanguageFacet;
exports.delimitedIndent = delimitedIndent;
exports.ensureSyntaxTree = ensureSyntaxTree;
exports.flatIndent = flatIndent;
exports.foldInside = foldInside;
exports.foldNodeProp = foldNodeProp;
exports.foldService = foldService;
exports.foldable = foldable;
exports.getIndentUnit = getIndentUnit;
exports.getIndentation = getIndentation;
exports.indentNodeProp = indentNodeProp;
exports.indentOnInput = indentOnInput;
exports.indentService = indentService;
exports.indentString = indentString;
exports.indentUnit = indentUnit;
exports.language = language;
exports.languageDataProp = languageDataProp;
exports.syntaxTree = syntaxTree;

},{"@codemirror/state":17,"@codemirror/text":18,"@codemirror/view":20,"lezer-tree":23}],11:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var view = require('@codemirror/view');
var state = require('@codemirror/state');
var tooltip = require('@codemirror/tooltip');
var panel = require('@codemirror/panel');
var elt = require('crelt');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var elt__default = /*#__PURE__*/_interopDefaultLegacy(elt);

class SelectedDiagnostic {
    constructor(from, to, diagnostic) {
        this.from = from;
        this.to = to;
        this.diagnostic = diagnostic;
    }
}
class LintState {
    constructor(diagnostics, panel, selected) {
        this.diagnostics = diagnostics;
        this.panel = panel;
        this.selected = selected;
    }
}
function findDiagnostic(diagnostics, diagnostic = null, after = 0) {
    let found = null;
    diagnostics.between(after, 1e9, (from, to, { spec }) => {
        if (diagnostic && spec.diagnostic != diagnostic)
            return;
        found = new SelectedDiagnostic(from, to, spec.diagnostic);
        return false;
    });
    return found;
}
function maybeEnableLint(state$1, effects) {
    return state$1.field(lintState, false) ? effects : effects.concat(state.StateEffect.appendConfig.of([
        lintState,
        view.EditorView.decorations.compute([lintState], state => {
            let { selected, panel } = state.field(lintState);
            return !selected || !panel || selected.from == selected.to ? view.Decoration.none : view.Decoration.set([
                activeMark.range(selected.from, selected.to)
            ]);
        }),
        tooltip.hoverTooltip(lintTooltip),
        baseTheme
    ]));
}
/**
Returns a transaction spec which updates the current set of
diagnostics.
*/
function setDiagnostics(state, diagnostics) {
    return {
        effects: maybeEnableLint(state, [setDiagnosticsEffect.of(diagnostics)])
    };
}
const setDiagnosticsEffect = state.StateEffect.define();
const togglePanel = state.StateEffect.define();
const movePanelSelection = state.StateEffect.define();
const lintState = state.StateField.define({
    create() {
        return new LintState(view.Decoration.none, null, null);
    },
    update(value, tr) {
        if (tr.docChanged) {
            let mapped = value.diagnostics.map(tr.changes), selected = null;
            if (value.selected) {
                let selPos = tr.changes.mapPos(value.selected.from, 1);
                selected = findDiagnostic(mapped, value.selected.diagnostic, selPos) || findDiagnostic(mapped, null, selPos);
            }
            value = new LintState(mapped, value.panel, selected);
        }
        for (let effect of tr.effects) {
            if (effect.is(setDiagnosticsEffect)) {
                let ranges = view.Decoration.set(effect.value.map((d) => {
                    return d.from < d.to
                        ? view.Decoration.mark({
                            attributes: { class: "cm-lintRange cm-lintRange-" + d.severity },
                            diagnostic: d
                        }).range(d.from, d.to)
                        : view.Decoration.widget({
                            widget: new DiagnosticWidget(d),
                            diagnostic: d
                        }).range(d.from);
                }));
                value = new LintState(ranges, value.panel, findDiagnostic(ranges));
            }
            else if (effect.is(togglePanel)) {
                value = new LintState(value.diagnostics, effect.value ? LintPanel.open : null, value.selected);
            }
            else if (effect.is(movePanelSelection)) {
                value = new LintState(value.diagnostics, value.panel, effect.value);
            }
        }
        return value;
    },
    provide: f => [panel.showPanel.from(f, val => val.panel),
        view.EditorView.decorations.from(f, s => s.diagnostics)]
});
const activeMark = view.Decoration.mark({ class: "cm-lintRange cm-lintRange-active" });
function lintTooltip(view, pos, side) {
    let { diagnostics } = view.state.field(lintState);
    let found = [], stackStart = 2e8, stackEnd = 0;
    diagnostics.between(pos - (side < 0 ? 1 : 0), pos + (side > 0 ? 1 : 0), (from, to, { spec }) => {
        if (pos >= from && pos <= to &&
            (from == to || ((pos > from || side > 0) && (pos < to || side < 0)))) {
            found.push(spec.diagnostic);
            stackStart = Math.min(from, stackStart);
            stackEnd = Math.max(to, stackEnd);
        }
    });
    if (!found.length)
        return null;
    return {
        pos: stackStart,
        end: stackEnd,
        above: view.state.doc.lineAt(stackStart).to < stackEnd,
        create() {
            return { dom: elt__default['default']("ul", { class: "cm-tooltip-lint" }, found.map(d => renderDiagnostic(view, d, false))) };
        }
    };
}
/**
Command to open and focus the lint panel.
*/
const openLintPanel = (view) => {
    let field = view.state.field(lintState, false);
    if (!field || !field.panel)
        view.dispatch({ effects: maybeEnableLint(view.state, [togglePanel.of(true)]) });
    let panel$1 = panel.getPanel(view, LintPanel.open);
    if (panel$1)
        panel$1.dom.querySelector(".cm-panel-lint ul").focus();
    return true;
};
/**
Command to close the lint panel, when open.
*/
const closeLintPanel = (view) => {
    let field = view.state.field(lintState, false);
    if (!field || !field.panel)
        return false;
    view.dispatch({ effects: togglePanel.of(false) });
    return true;
};
/**
Move the selection to the next diagnostic.
*/
const nextDiagnostic = (view) => {
    let field = view.state.field(lintState, false);
    if (!field)
        return false;
    let sel = view.state.selection.main, next = field.diagnostics.iter(sel.to + 1);
    if (!next.value) {
        next = field.diagnostics.iter(0);
        if (!next.value || next.from == sel.from && next.to == sel.to)
            return false;
    }
    view.dispatch({ selection: { anchor: next.from, head: next.to }, scrollIntoView: true });
    return true;
};
/**
A set of default key bindings for the lint functionality.

- Ctrl-Shift-m (Cmd-Shift-m on macOS): [`openLintPanel`](https://codemirror.net/6/docs/ref/#lint.openLintPanel)
- F8: [`nextDiagnostic`](https://codemirror.net/6/docs/ref/#lint.nextDiagnostic)
*/
const lintKeymap = [
    { key: "Mod-Shift-m", run: openLintPanel },
    { key: "F8", run: nextDiagnostic }
];
/**
Given a diagnostic source, this function returns an extension that
enables linting with that source. It will be called whenever the
editor is idle (after its content changed).
*/
function linter(source, config = {}) {
    var _a;
    let delay = (_a = config.delay) !== null && _a !== void 0 ? _a : 750;
    return view.ViewPlugin.fromClass(class {
        constructor(view) {
            this.view = view;
            this.lintTime = Date.now() + delay;
            this.set = true;
            this.run = this.run.bind(this);
            setTimeout(this.run, delay);
        }
        run() {
            let now = Date.now();
            if (now < this.lintTime - 10) {
                setTimeout(this.run, this.lintTime - now);
            }
            else {
                this.set = false;
                let { state } = this.view;
                Promise.resolve(source(this.view)).then(annotations => {
                    var _a, _b;
                    if (this.view.state.doc == state.doc &&
                        (annotations.length || ((_b = (_a = this.view.state.field(lintState, false)) === null || _a === void 0 ? void 0 : _a.diagnostics) === null || _b === void 0 ? void 0 : _b.size)))
                        this.view.dispatch(setDiagnostics(this.view.state, annotations));
                }, error => { view.logException(this.view.state, error); });
            }
        }
        update(update) {
            if (update.docChanged) {
                this.lintTime = Date.now() + delay;
                if (!this.set) {
                    this.set = true;
                    setTimeout(this.run, delay);
                }
            }
        }
    });
}
function assignKeys(actions) {
    let assigned = [];
    if (actions)
        actions: for (let { name } of actions) {
            for (let i = 0; i < name.length; i++) {
                let ch = name[i];
                if (/[a-zA-Z]/.test(ch) && !assigned.some(c => c.toLowerCase() == ch.toLowerCase())) {
                    assigned.push(ch);
                    continue actions;
                }
            }
            assigned.push("");
        }
    return assigned;
}
function renderDiagnostic(view, diagnostic, inPanel) {
    var _a;
    let keys = inPanel ? assignKeys(diagnostic.actions) : [];
    return elt__default['default']("li", { class: "cm-diagnostic cm-diagnostic-" + diagnostic.severity }, elt__default['default']("span", { class: "cm-diagnosticText" }, diagnostic.message), (_a = diagnostic.actions) === null || _a === void 0 ? void 0 : _a.map((action, i) => {
        let click = (e) => {
            e.preventDefault();
            let found = findDiagnostic(view.state.field(lintState).diagnostics, diagnostic);
            if (found)
                action.apply(view, found.from, found.to);
        };
        let { name } = action, keyIndex = keys[i] ? name.indexOf(keys[i]) : -1;
        let nameElt = keyIndex < 0 ? name : [name.slice(0, keyIndex),
            elt__default['default']("u", name.slice(keyIndex, keyIndex + 1)),
            name.slice(keyIndex + 1)];
        return elt__default['default']("button", {
            class: "cm-diagnosticAction",
            onclick: click,
            onmousedown: click,
            "aria-label": ` Action: ${name}${keyIndex < 0 ? "" : ` (access key "${keys[i]})"`}.`
        }, nameElt);
    }), diagnostic.source && elt__default['default']("div", { class: "cm-diagnosticSource" }, diagnostic.source));
}
class DiagnosticWidget extends view.WidgetType {
    constructor(diagnostic) {
        super();
        this.diagnostic = diagnostic;
    }
    eq(other) { return other.diagnostic == this.diagnostic; }
    toDOM() {
        return elt__default['default']("span", { class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity });
    }
}
class PanelItem {
    constructor(view, diagnostic) {
        this.diagnostic = diagnostic;
        this.id = "item_" + Math.floor(Math.random() * 0xffffffff).toString(16);
        this.dom = renderDiagnostic(view, diagnostic, true);
        this.dom.id = this.id;
        this.dom.setAttribute("role", "option");
    }
}
class LintPanel {
    constructor(view) {
        this.view = view;
        this.items = [];
        let onkeydown = (event) => {
            if (event.keyCode == 27) { // Escape
                closeLintPanel(this.view);
                this.view.focus();
            }
            else if (event.keyCode == 38 || event.keyCode == 33) { // ArrowUp, PageUp
                this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
            }
            else if (event.keyCode == 40 || event.keyCode == 34) { // ArrowDown, PageDown
                this.moveSelection((this.selectedIndex + 1) % this.items.length);
            }
            else if (event.keyCode == 36) { // Home
                this.moveSelection(0);
            }
            else if (event.keyCode == 35) { // End
                this.moveSelection(this.items.length - 1);
            }
            else if (event.keyCode == 13) { // Enter
                this.view.focus();
            }
            else if (event.keyCode >= 65 && event.keyCode <= 90 && this.items.length) { // A-Z
                let { diagnostic } = this.items[this.selectedIndex], keys = assignKeys(diagnostic.actions);
                for (let i = 0; i < keys.length; i++)
                    if (keys[i].toUpperCase().charCodeAt(0) == event.keyCode) {
                        let found = findDiagnostic(this.view.state.field(lintState).diagnostics, diagnostic);
                        if (found)
                            diagnostic.actions[i].apply(view, found.from, found.to);
                    }
            }
            else {
                return;
            }
            event.preventDefault();
        };
        let onclick = (event) => {
            for (let i = 0; i < this.items.length; i++) {
                if (this.items[i].dom.contains(event.target))
                    this.moveSelection(i);
            }
        };
        this.list = elt__default['default']("ul", {
            tabIndex: 0,
            role: "listbox",
            "aria-label": this.view.state.phrase("Diagnostics"),
            onkeydown,
            onclick
        });
        this.dom = elt__default['default']("div", { class: "cm-panel-lint" }, this.list, elt__default['default']("button", {
            name: "close",
            "aria-label": this.view.state.phrase("close"),
            onclick: () => closeLintPanel(this.view)
        }, "√ó"));
        this.update();
    }
    get selectedIndex() {
        let selected = this.view.state.field(lintState).selected;
        if (!selected)
            return -1;
        for (let i = 0; i < this.items.length; i++)
            if (this.items[i].diagnostic == selected.diagnostic)
                return i;
        return -1;
    }
    update() {
        let { diagnostics, selected } = this.view.state.field(lintState);
        let i = 0, needsSync = false, newSelectedItem = null;
        diagnostics.between(0, this.view.state.doc.length, (_start, _end, { spec }) => {
            let found = -1, item;
            for (let j = i; j < this.items.length; j++)
                if (this.items[j].diagnostic == spec.diagnostic) {
                    found = j;
                    break;
                }
            if (found < 0) {
                item = new PanelItem(this.view, spec.diagnostic);
                this.items.splice(i, 0, item);
                needsSync = true;
            }
            else {
                item = this.items[found];
                if (found > i) {
                    this.items.splice(i, found - i);
                    needsSync = true;
                }
            }
            if (selected && item.diagnostic == selected.diagnostic) {
                if (!item.dom.hasAttribute("aria-selected")) {
                    item.dom.setAttribute("aria-selected", "true");
                    newSelectedItem = item;
                }
            }
            else if (item.dom.hasAttribute("aria-selected")) {
                item.dom.removeAttribute("aria-selected");
            }
            i++;
        });
        while (i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0)) {
            needsSync = true;
            this.items.pop();
        }
        if (this.items.length == 0) {
            this.items.push(new PanelItem(this.view, {
                from: -1, to: -1,
                severity: "info",
                message: this.view.state.phrase("No diagnostics")
            }));
            needsSync = true;
        }
        if (newSelectedItem) {
            this.list.setAttribute("aria-activedescendant", newSelectedItem.id);
            this.view.requestMeasure({
                key: this,
                read: () => ({ sel: newSelectedItem.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
                write: ({ sel, panel }) => {
                    if (sel.top < panel.top)
                        this.list.scrollTop -= panel.top - sel.top;
                    else if (sel.bottom > panel.bottom)
                        this.list.scrollTop += sel.bottom - panel.bottom;
                }
            });
        }
        else if (!this.items.length) {
            this.list.removeAttribute("aria-activedescendant");
        }
        if (needsSync)
            this.sync();
    }
    sync() {
        let domPos = this.list.firstChild;
        function rm() {
            let prev = domPos;
            domPos = prev.nextSibling;
            prev.remove();
        }
        for (let item of this.items) {
            if (item.dom.parentNode == this.list) {
                while (domPos != item.dom)
                    rm();
                domPos = item.dom.nextSibling;
            }
            else {
                this.list.insertBefore(item.dom, domPos);
            }
        }
        while (domPos)
            rm();
    }
    moveSelection(selectedIndex) {
        if (this.items.length == 0)
            return;
        let field = this.view.state.field(lintState);
        let selection = findDiagnostic(field.diagnostics, this.items[selectedIndex].diagnostic);
        if (!selection)
            return;
        this.view.dispatch({
            selection: { anchor: selection.from, head: selection.to },
            scrollIntoView: true,
            effects: movePanelSelection.of(selection)
        });
    }
    static open(view) { return new LintPanel(view); }
}
function underline(color) {
    if (typeof btoa != "function")
        return "none";
    let svg = `<svg xmlns="http://www.w3.org/2000/svg" width="6" height="3">
    <path d="m0 3 l2 -2 l1 0 l2 2 l1 0" stroke="${color}" fill="none" stroke-width=".7"/>
  </svg>`;
    return `url('data:image/svg+xml;base64,${btoa(svg)}')`;
}
const baseTheme = view.EditorView.baseTheme({
    ".cm-diagnostic": {
        padding: "3px 6px 3px 8px",
        marginLeft: "-1px",
        display: "block",
        whiteSpace: "pre-wrap"
    },
    ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
    ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
    ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
    ".cm-diagnosticAction": {
        font: "inherit",
        border: "none",
        padding: "2px 4px",
        backgroundColor: "#444",
        color: "white",
        borderRadius: "3px",
        marginLeft: "8px"
    },
    ".cm-diagnosticSource": {
        fontSize: "70%",
        opacity: .7
    },
    ".cm-lintRange": {
        backgroundPosition: "left bottom",
        backgroundRepeat: "repeat-x"
    },
    ".cm-lintRange-error": { backgroundImage: underline("#d11") },
    ".cm-lintRange-warning": { backgroundImage: underline("orange") },
    ".cm-lintRange-info": { backgroundImage: underline("#999") },
    ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
    ".cm-lintPoint": {
        position: "relative",
        "&:after": {
            content: '""',
            position: "absolute",
            bottom: 0,
            left: "-2px",
            borderLeft: "3px solid transparent",
            borderRight: "3px solid transparent",
            borderBottom: "4px solid #d11"
        }
    },
    ".cm-lintPoint-warning": {
        "&:after": { borderBottomColor: "orange" }
    },
    ".cm-lintPoint-info": {
        "&:after": { borderBottomColor: "#999" }
    },
    ".cm-panel.cm-panel-lint": {
        position: "relative",
        "& ul": {
            maxHeight: "100px",
            overflowY: "auto",
            "& [aria-selected]": {
                backgroundColor: "#ddd",
                "& u": { textDecoration: "underline" }
            },
            "&:focus [aria-selected]": {
                background_fallback: "#bdf",
                backgroundColor: "Highlight",
                color_fallback: "white",
                color: "HighlightText"
            },
            "& u": { textDecoration: "none" },
            padding: 0,
            margin: 0
        },
        "& [name=close]": {
            position: "absolute",
            top: "0",
            right: "2px",
            background: "inherit",
            border: "none",
            font: "inherit",
            padding: 0,
            margin: 0
        }
    },
    ".cm-tooltip.cm-tooltip-lint": {
        padding: 0,
        margin: 0
    }
});

exports.closeLintPanel = closeLintPanel;
exports.lintKeymap = lintKeymap;
exports.linter = linter;
exports.nextDiagnostic = nextDiagnostic;
exports.openLintPanel = openLintPanel;
exports.setDiagnostics = setDiagnostics;

},{"@codemirror/panel":13,"@codemirror/state":17,"@codemirror/tooltip":19,"@codemirror/view":20,"crelt":22}],12:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var state = require('@codemirror/state');
var language = require('@codemirror/language');
var view = require('@codemirror/view');
var lezerTree = require('lezer-tree');

const baseTheme = view.EditorView.baseTheme({
    ".cm-matchingBracket": { color: "#0b0" },
    ".cm-nonmatchingBracket": { color: "#a22" }
});
const DefaultScanDist = 10000, DefaultBrackets = "()[]{}";
const bracketMatchingConfig = state.Facet.define({
    combine(configs) {
        return state.combineConfig(configs, {
            afterCursor: true,
            brackets: DefaultBrackets,
            maxScanDistance: DefaultScanDist
        });
    }
});
const matchingMark = view.Decoration.mark({ class: "cm-matchingBracket" }), nonmatchingMark = view.Decoration.mark({ class: "cm-nonmatchingBracket" });
const bracketMatchingState = state.StateField.define({
    create() { return view.Decoration.none; },
    update(deco, tr) {
        if (!tr.docChanged && !tr.selection)
            return deco;
        let decorations = [];
        let config = tr.state.facet(bracketMatchingConfig);
        for (let range of tr.state.selection.ranges) {
            if (!range.empty)
                continue;
            let match = matchBrackets(tr.state, range.head, -1, config)
                || (range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config))
                || (config.afterCursor &&
                    (matchBrackets(tr.state, range.head, 1, config) ||
                        (range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config))));
            if (!match)
                continue;
            let mark = match.matched ? matchingMark : nonmatchingMark;
            decorations.push(mark.range(match.start.from, match.start.to));
            if (match.end)
                decorations.push(mark.range(match.end.from, match.end.to));
        }
        return view.Decoration.set(decorations, true);
    },
    provide: f => view.EditorView.decorations.from(f)
});
const bracketMatchingUnique = [
    bracketMatchingState,
    baseTheme
];
/// Create an extension that enables bracket matching. Whenever the
/// cursor is next to a bracket, that bracket and the one it matches
/// are highlighted. Or, when no matching bracket is found, another
/// highlighting style is used to indicate this.
function bracketMatching(config = {}) {
    return [bracketMatchingConfig.of(config), bracketMatchingUnique];
}
function matchingNodes(node, dir, brackets) {
    let byProp = node.prop(dir < 0 ? lezerTree.NodeProp.openedBy : lezerTree.NodeProp.closedBy);
    if (byProp)
        return byProp;
    if (node.name.length == 1) {
        let index = brackets.indexOf(node.name);
        if (index > -1 && index % 2 == (dir < 0 ? 1 : 0))
            return [brackets[index + dir]];
    }
    return null;
}
/// Find the matching bracket for the token at `pos`, scanning
/// direction `dir`. Only the `brackets` and `maxScanDistance`
/// properties are used from `config`, if given. Returns null if no
/// bracket was found at `pos`, or a match result otherwise.
function matchBrackets(state, pos, dir, config = {}) {
    let maxScanDistance = config.maxScanDistance || DefaultScanDist, brackets = config.brackets || DefaultBrackets;
    let tree = language.syntaxTree(state), sub = tree.resolve(pos, dir), matches;
    if (matches = matchingNodes(sub.type, dir, brackets))
        return matchMarkedBrackets(state, pos, dir, sub, matches, brackets);
    else
        return matchPlainBrackets(state, pos, dir, tree, sub.type, maxScanDistance, brackets);
}
function matchMarkedBrackets(_state, _pos, dir, token, matching, brackets) {
    let parent = token.parent, firstToken = { from: token.from, to: token.to };
    let depth = 0, cursor = parent === null || parent === void 0 ? void 0 : parent.cursor;
    if (cursor && (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to)))
        do {
            if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {
                if (depth == 0 && matching.indexOf(cursor.type.name) > -1) {
                    return { start: firstToken, end: { from: cursor.from, to: cursor.to }, matched: true };
                }
                else if (matchingNodes(cursor.type, dir, brackets)) {
                    depth++;
                }
                else if (matchingNodes(cursor.type, -dir, brackets)) {
                    depth--;
                    if (depth == 0)
                        return { start: firstToken, end: { from: cursor.from, to: cursor.to }, matched: false };
                }
            }
        } while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());
    return { start: firstToken, matched: false };
}
function matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {
    let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);
    let bracket = brackets.indexOf(startCh);
    if (bracket < 0 || (bracket % 2 == 0) != (dir > 0))
        return null;
    let startToken = { from: dir < 0 ? pos - 1 : pos, to: dir > 0 ? pos + 1 : pos };
    let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0), depth = 0;
    for (let distance = 0; !(iter.next()).done && distance <= maxScanDistance;) {
        let text = iter.value;
        if (dir < 0)
            distance += text.length;
        let basePos = pos + distance * dir;
        for (let pos = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos != end; pos += dir) {
            let found = brackets.indexOf(text[pos]);
            if (found < 0 || tree.resolve(basePos + pos, 1).type != tokenType)
                continue;
            if ((found % 2 == 0) == (dir > 0)) {
                depth++;
            }
            else if (depth == 1) { // Closing
                return { start: startToken, end: { from: basePos + pos, to: basePos + pos + 1 }, matched: (found >> 1) == (bracket >> 1) };
            }
            else {
                depth--;
            }
        }
        if (dir > 0)
            distance += text.length;
    }
    return iter.done ? { start: startToken, matched: false } : null;
}

exports.bracketMatching = bracketMatching;
exports.matchBrackets = matchBrackets;

},{"@codemirror/language":10,"@codemirror/state":17,"@codemirror/view":20,"lezer-tree":23}],13:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var view = require('@codemirror/view');
var state = require('@codemirror/state');

const panelConfig = state.Facet.define({
    combine(configs) {
        let topContainer, bottomContainer;
        for (let c of configs) {
            topContainer = topContainer || c.topContainer;
            bottomContainer = bottomContainer || c.bottomContainer;
        }
        return { topContainer, bottomContainer };
    }
});
/**
Configures the panel-managing extension.
*/
function panels(config) {
    return config ? [panelConfig.of(config)] : [];
}
/**
Get the active panel created by the given constructor, if any.
This can be useful when you need access to your panels' DOM
structure.
*/
function getPanel(view, panel) {
    let plugin = view.plugin(panelPlugin);
    let index = plugin ? plugin.specs.indexOf(panel) : -1;
    return index > -1 ? plugin.panels[index] : null;
}
const panelPlugin = view.ViewPlugin.fromClass(class {
    constructor(view) {
        this.input = view.state.facet(showPanel);
        this.specs = this.input.filter(s => s);
        this.panels = this.specs.map(spec => spec(view));
        let conf = view.state.facet(panelConfig);
        this.top = new PanelGroup(view, true, conf.topContainer);
        this.bottom = new PanelGroup(view, false, conf.bottomContainer);
        this.top.sync(this.panels.filter(p => p.top));
        this.bottom.sync(this.panels.filter(p => !p.top));
        for (let p of this.panels) {
            p.dom.classList.add("cm-panel");
            // FIXME drop on next breaking release
            if (p.class)
                p.dom.classList.add(p.class);
            if (p.mount)
                p.mount();
        }
    }
    update(update) {
        let conf = update.state.facet(panelConfig);
        if (this.top.container != conf.topContainer) {
            this.top.sync([]);
            this.top = new PanelGroup(update.view, true, conf.topContainer);
        }
        if (this.bottom.container != conf.bottomContainer) {
            this.bottom.sync([]);
            this.bottom = new PanelGroup(update.view, false, conf.bottomContainer);
        }
        this.top.syncClasses();
        this.bottom.syncClasses();
        let input = update.state.facet(showPanel);
        if (input != this.input) {
            let specs = input.filter(x => x);
            let panels = [], top = [], bottom = [], mount = [];
            for (let spec of specs) {
                let known = this.specs.indexOf(spec), panel;
                if (known < 0) {
                    panel = spec(update.view);
                    mount.push(panel);
                }
                else {
                    panel = this.panels[known];
                    if (panel.update)
                        panel.update(update);
                }
                panels.push(panel);
                (panel.top ? top : bottom).push(panel);
            }
            this.specs = specs;
            this.panels = panels;
            this.top.sync(top);
            this.bottom.sync(bottom);
            for (let p of mount) {
                p.dom.classList.add("cm-panel");
                // FIXME drop on next breaking release
                if (p.class)
                    p.dom.classList.add(p.class);
                if (p.mount)
                    p.mount();
            }
        }
        else {
            for (let p of this.panels)
                if (p.update)
                    p.update(update);
        }
    }
    destroy() {
        this.top.sync([]);
        this.bottom.sync([]);
    }
}, {
    provide: view.PluginField.scrollMargins.from(value => ({ top: value.top.scrollMargin(), bottom: value.bottom.scrollMargin() }))
});
class PanelGroup {
    constructor(view, top, container) {
        this.view = view;
        this.top = top;
        this.container = container;
        this.dom = undefined;
        this.classes = "";
        this.panels = [];
        this.syncClasses();
    }
    sync(panels) {
        this.panels = panels;
        this.syncDOM();
    }
    syncDOM() {
        if (this.panels.length == 0) {
            if (this.dom) {
                this.dom.remove();
                this.dom = undefined;
            }
            return;
        }
        if (!this.dom) {
            this.dom = document.createElement("div");
            this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom";
            this.dom.style[this.top ? "top" : "bottom"] = "0";
            let parent = this.container || this.view.dom;
            parent.insertBefore(this.dom, this.top ? parent.firstChild : null);
        }
        let curDOM = this.dom.firstChild;
        for (let panel of this.panels) {
            if (panel.dom.parentNode == this.dom) {
                while (curDOM != panel.dom)
                    curDOM = rm(curDOM);
                curDOM = curDOM.nextSibling;
            }
            else {
                this.dom.insertBefore(panel.dom, curDOM);
            }
        }
        while (curDOM)
            curDOM = rm(curDOM);
    }
    scrollMargin() {
        return !this.dom || this.container ? 0
            : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - this.view.scrollDOM.getBoundingClientRect().top
                : this.view.scrollDOM.getBoundingClientRect().bottom - this.dom.getBoundingClientRect().top);
    }
    syncClasses() {
        if (!this.container || this.classes == this.view.themeClasses)
            return;
        for (let cls of this.classes.split(" "))
            if (cls)
                this.container.classList.remove(cls);
        for (let cls of (this.classes = this.view.themeClasses).split(" "))
            if (cls)
                this.container.classList.add(cls);
    }
}
function rm(node) {
    let next = node.nextSibling;
    node.remove();
    return next;
}
const baseTheme = view.EditorView.baseTheme({
    ".cm-panels": {
        boxSizing: "border-box",
        position: "sticky",
        left: 0,
        right: 0
    },
    "&light .cm-panels": {
        backgroundColor: "#f5f5f5",
        color: "black"
    },
    "&light .cm-panels-top": {
        borderBottom: "1px solid #ddd"
    },
    "&light .cm-panels-bottom": {
        borderTop: "1px solid #ddd"
    },
    "&dark .cm-panels": {
        backgroundColor: "#333338",
        color: "white"
    }
});
/**
Opening a panel is done by providing a constructor function for
the panel through this facet. (The panel is closed again when its
constructor is no longer provided.) Values of `null` are ignored.
*/
const showPanel = state.Facet.define({
    enables: [panelPlugin, baseTheme]
});

exports.getPanel = getPanel;
exports.panels = panels;
exports.showPanel = showPanel;

},{"@codemirror/state":17,"@codemirror/view":20}],14:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var state = require('@codemirror/state');

/// Each range is associated with a value, which must inherit from
/// this class.
class RangeValue {
    /// Compare this value with another value. The default
    /// implementation compares by identity.
    eq(other) { return this == other; }
    /// Create a [range](#rangeset.Range) with this value.
    range(from, to = from) { return new Range(from, to, this); }
}
RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;
RangeValue.prototype.point = false;
RangeValue.prototype.mapMode = state.MapMode.TrackDel;
/// A range associates a value with a range of positions.
class Range {
    /// @internal
    constructor(
    /// The range's start position.
    from, 
    /// Its end position.
    to, 
    /// The value associated with this range.
    value) {
        this.from = from;
        this.to = to;
        this.value = value;
    }
}
function cmpRange(a, b) {
    return a.from - b.from || a.value.startSide - b.value.startSide;
}
class Chunk {
    constructor(from, to, value, 
    // Chunks are marked with the largest point that occurs
    // in them (or -1 for no points), so that scans that are
    // only interested in points (such as the
    // heightmap-related logic) can skip range-only chunks.
    maxPoint) {
        this.from = from;
        this.to = to;
        this.value = value;
        this.maxPoint = maxPoint;
    }
    get length() { return this.to[this.to.length - 1]; }
    // With side == -1, return the first index where to >= pos. When
    // side == 1, the first index where from > pos.
    findIndex(pos, end, side = end * 1000000000 /* Far */, startAt = 0) {
        if (pos <= 0)
            return startAt;
        let arr = end < 0 ? this.to : this.from;
        for (let lo = startAt, hi = arr.length;;) {
            if (lo == hi)
                return lo;
            let mid = (lo + hi) >> 1;
            let diff = arr[mid] - pos || (end < 0 ? this.value[mid].startSide : this.value[mid].endSide) - side;
            if (mid == lo)
                return diff >= 0 ? lo : hi;
            if (diff >= 0)
                hi = mid;
            else
                lo = mid + 1;
        }
    }
    between(offset, from, to, f) {
        for (let i = this.findIndex(from, -1), e = this.findIndex(to, 1, undefined, i); i < e; i++)
            if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false)
                return false;
    }
    map(offset, changes) {
        let value = [], from = [], to = [], newPos = -1, maxPoint = -1;
        for (let i = 0; i < this.value.length; i++) {
            let val = this.value[i], curFrom = this.from[i] + offset, curTo = this.to[i] + offset, newFrom, newTo;
            if (curFrom == curTo) {
                let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);
                if (mapped == null)
                    continue;
                newFrom = newTo = mapped;
            }
            else {
                newFrom = changes.mapPos(curFrom, val.startSide);
                newTo = changes.mapPos(curTo, val.endSide);
                if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)
                    continue;
            }
            if ((newTo - newFrom || val.endSide - val.startSide) < 0)
                continue;
            if (newPos < 0)
                newPos = newFrom;
            if (val.point)
                maxPoint = Math.max(maxPoint, newTo - newFrom);
            value.push(val);
            from.push(newFrom - newPos);
            to.push(newTo - newPos);
        }
        return { mapped: value.length ? new Chunk(from, to, value, maxPoint) : null, pos: newPos };
    }
}
/// A range set stores a collection of [ranges](#rangeset.Range) in a
/// way that makes them efficient to [map](#rangeset.RangeSet.map) and
/// [update](#rangeset.RangeSet.update). This is an immutable data
/// structure.
class RangeSet {
    /// @internal
    constructor(
    /// @internal
    chunkPos, 
    /// @internal
    chunk, 
    /// @internal
    nextLayer = RangeSet.empty, 
    /// @internal
    maxPoint) {
        this.chunkPos = chunkPos;
        this.chunk = chunk;
        this.nextLayer = nextLayer;
        this.maxPoint = maxPoint;
    }
    /// @internal
    get length() {
        let last = this.chunk.length - 1;
        return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);
    }
    /// The number of ranges in the set.
    get size() {
        if (this == RangeSet.empty)
            return 0;
        let size = this.nextLayer.size;
        for (let chunk of this.chunk)
            size += chunk.value.length;
        return size;
    }
    /// @internal
    chunkEnd(index) {
        return this.chunkPos[index] + this.chunk[index].length;
    }
    /// Update the range set, optionally adding new ranges or filtering
    /// out existing ones.
    ///
    /// (The extra type parameter is just there as a kludge to work
    /// around TypeScript variance issues that prevented `RangeSet<X>`
    /// from being a subtype of `RangeSet<Y>` when `X` is a subtype of
    /// `Y`.)
    update(updateSpec) {
        let { add = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;
        let filter = updateSpec.filter;
        if (add.length == 0 && !filter)
            return this;
        if (sort)
            add.slice().sort(cmpRange);
        if (this == RangeSet.empty)
            return add.length ? RangeSet.of(add) : this;
        let cur = new LayerCursor(this, null, -1).goto(0), i = 0, spill = [];
        let builder = new RangeSetBuilder();
        while (cur.value || i < add.length) {
            if (i < add.length && (cur.from - add[i].from || cur.startSide - add[i].value.startSide) >= 0) {
                let range = add[i++];
                if (!builder.addInner(range.from, range.to, range.value))
                    spill.push(range);
            }
            else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length &&
                (i == add.length || this.chunkEnd(cur.chunkIndex) < add[i].from) &&
                (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) &&
                builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {
                cur.nextChunk();
            }
            else {
                if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value)) {
                    if (!builder.addInner(cur.from, cur.to, cur.value))
                        spill.push(new Range(cur.from, cur.to, cur.value));
                }
                cur.next();
            }
        }
        return builder.finishInner(this.nextLayer == RangeSet.empty && !spill.length ? RangeSet.empty
            : this.nextLayer.update({ add: spill, filter, filterFrom, filterTo }));
    }
    /// Map this range set through a set of changes, return the new set.
    map(changes) {
        if (changes.length == 0 || this == RangeSet.empty)
            return this;
        let chunks = [], chunkPos = [], maxPoint = -1;
        for (let i = 0; i < this.chunk.length; i++) {
            let start = this.chunkPos[i], chunk = this.chunk[i];
            let touch = changes.touchesRange(start, start + chunk.length);
            if (touch === false) {
                maxPoint = Math.max(maxPoint, chunk.maxPoint);
                chunks.push(chunk);
                chunkPos.push(changes.mapPos(start));
            }
            else if (touch === true) {
                let { mapped, pos } = chunk.map(start, changes);
                if (mapped) {
                    maxPoint = Math.max(maxPoint, mapped.maxPoint);
                    chunks.push(mapped);
                    chunkPos.push(pos);
                }
            }
        }
        let next = this.nextLayer.map(changes);
        return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next, maxPoint);
    }
    /// Iterate over the ranges that touch the region `from` to `to`,
    /// calling `f` for each. There is no guarantee that the ranges will
    /// be reported in any specific order. When the callback returns
    /// `false`, iteration stops.
    between(from, to, f) {
        if (this == RangeSet.empty)
            return;
        for (let i = 0; i < this.chunk.length; i++) {
            let start = this.chunkPos[i], chunk = this.chunk[i];
            if (to >= start && from <= start + chunk.length &&
                chunk.between(start, from - start, to - start, f) === false)
                return;
        }
        this.nextLayer.between(from, to, f);
    }
    /// Iterate over the ranges in this set, in order, including all
    /// ranges that end at or after `from`.
    iter(from = 0) {
        return HeapCursor.from([this]).goto(from);
    }
    /// Iterate over the ranges in a collection of sets, in order,
    /// starting from `from`.
    static iter(sets, from = 0) {
        return HeapCursor.from(sets).goto(from);
    }
    /// Iterate over two groups of sets, calling methods on `comparator`
    /// to notify it of possible differences.
    static compare(oldSets, newSets, 
    /// This indicates how the underlying data changed between these
    /// ranges, and is needed to synchronize the iteration. `from` and
    /// `to` are coordinates in the _new_ space, after these changes.
    textDiff, comparator, 
    /// Can be used to ignore all non-point ranges, and points below
    /// the given size. When -1, all ranges are compared.
    minPointSize = -1) {
        let a = oldSets.filter(set => set.maxPoint >= 500 /* BigPointSize */ ||
            set != RangeSet.empty && newSets.indexOf(set) < 0 && set.maxPoint >= minPointSize);
        let b = newSets.filter(set => set.maxPoint >= 500 /* BigPointSize */ ||
            set != RangeSet.empty && oldSets.indexOf(set) < 0 && set.maxPoint >= minPointSize);
        let sharedChunks = findSharedChunks(a, b);
        let sideA = new SpanCursor(a, sharedChunks, minPointSize);
        let sideB = new SpanCursor(b, sharedChunks, minPointSize);
        textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));
        if (textDiff.empty && textDiff.length == 0)
            compare(sideA, 0, sideB, 0, 0, comparator);
    }
    /// Iterate over a group of range sets at the same time, notifying
    /// the iterator about the ranges covering every given piece of
    /// content. Returns the open count (see
    /// [`SpanIterator.span`](#rangeset.SpanIterator.span)) at the end
    /// of the iteration.
    static spans(sets, from, to, iterator, 
    /// When given and greater than -1, only points of at least this
    /// size are taken into account.
    minPointSize = -1) {
        let cursor = new SpanCursor(sets, null, minPointSize).goto(from), pos = from;
        let open = cursor.openStart;
        for (;;) {
            let curTo = Math.min(cursor.to, to);
            if (cursor.point) {
                iterator.point(pos, curTo, cursor.point, cursor.activeForPoint(cursor.to), open);
                open = cursor.openEnd(curTo) + (cursor.to > curTo ? 1 : 0);
            }
            else if (curTo > pos) {
                iterator.span(pos, curTo, cursor.active, open);
                open = cursor.openEnd(curTo);
            }
            if (cursor.to > to)
                break;
            pos = cursor.to;
            cursor.next();
        }
        return open;
    }
    /// Create a range set for the given range or array of ranges. By
    /// default, this expects the ranges to be _sorted_ (by start
    /// position and, if two start at the same position,
    /// `value.startSide`). You can pass `true` as second argument to
    /// cause the method to sort them.
    static of(ranges, sort = false) {
        let build = new RangeSetBuilder();
        for (let range of ranges instanceof Range ? [ranges] : sort ? ranges.slice().sort(cmpRange) : ranges)
            build.add(range.from, range.to, range.value);
        return build.finish();
    }
}
/// The empty set of ranges.
RangeSet.empty = new RangeSet([], [], null, -1);
RangeSet.empty.nextLayer = RangeSet.empty;
/// A range set builder is a data structure that helps build up a
/// [range set](#rangeset.RangeSet) directly, without first allocating
/// an array of [`Range`](#rangeset.Range) objects.
class RangeSetBuilder {
    /// Create an empty builder.
    constructor() {
        this.chunks = [];
        this.chunkPos = [];
        this.chunkStart = -1;
        this.last = null;
        this.lastFrom = -1000000000 /* Far */;
        this.lastTo = -1000000000 /* Far */;
        this.from = [];
        this.to = [];
        this.value = [];
        this.maxPoint = -1;
        this.setMaxPoint = -1;
        this.nextLayer = null;
    }
    finishChunk(newArrays) {
        this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));
        this.chunkPos.push(this.chunkStart);
        this.chunkStart = -1;
        this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);
        this.maxPoint = -1;
        if (newArrays) {
            this.from = [];
            this.to = [];
            this.value = [];
        }
    }
    /// Add a range. Ranges should be added in sorted (by `from` and
    /// `value.startSide`) order.
    add(from, to, value) {
        if (!this.addInner(from, to, value))
            (this.nextLayer || (this.nextLayer = new RangeSetBuilder)).add(from, to, value);
    }
    /// @internal
    addInner(from, to, value) {
        let diff = from - this.lastTo || value.startSide - this.last.endSide;
        if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0)
            throw new Error("Ranges must be added sorted by `from` position and `startSide`");
        if (diff < 0)
            return false;
        if (this.from.length == 250 /* ChunkSize */)
            this.finishChunk(true);
        if (this.chunkStart < 0)
            this.chunkStart = from;
        this.from.push(from - this.chunkStart);
        this.to.push(to - this.chunkStart);
        this.last = value;
        this.lastFrom = from;
        this.lastTo = to;
        this.value.push(value);
        if (value.point)
            this.maxPoint = Math.max(this.maxPoint, to - from);
        return true;
    }
    /// @internal
    addChunk(from, chunk) {
        if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)
            return false;
        if (this.from.length)
            this.finishChunk(true);
        this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);
        this.chunks.push(chunk);
        this.chunkPos.push(from);
        let last = chunk.value.length - 1;
        this.last = chunk.value[last];
        this.lastFrom = chunk.from[last] + from;
        this.lastTo = chunk.to[last] + from;
        return true;
    }
    /// Finish the range set. Returns the new set. The builder can't be
    /// used anymore after this has been called.
    finish() { return this.finishInner(RangeSet.empty); }
    /// @internal
    finishInner(next) {
        if (this.from.length)
            this.finishChunk(false);
        if (this.chunks.length == 0)
            return next;
        let result = new RangeSet(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);
        this.from = null; // Make sure further `add` calls produce errors
        return result;
    }
}
function findSharedChunks(a, b) {
    let inA = new Map();
    for (let set of a)
        for (let i = 0; i < set.chunk.length; i++)
            if (set.chunk[i].maxPoint < 500 /* BigPointSize */)
                inA.set(set.chunk[i], set.chunkPos[i]);
    let shared = new Set();
    for (let set of b)
        for (let i = 0; i < set.chunk.length; i++)
            if (inA.get(set.chunk[i]) == set.chunkPos[i])
                shared.add(set.chunk[i]);
    return shared;
}
class LayerCursor {
    constructor(layer, skip, minPoint, rank = 0) {
        this.layer = layer;
        this.skip = skip;
        this.minPoint = minPoint;
        this.rank = rank;
    }
    get startSide() { return this.value ? this.value.startSide : 0; }
    get endSide() { return this.value ? this.value.endSide : 0; }
    goto(pos, side = -1000000000 /* Far */) {
        this.chunkIndex = this.rangeIndex = 0;
        this.gotoInner(pos, side, false);
        return this;
    }
    gotoInner(pos, side, forward) {
        while (this.chunkIndex < this.layer.chunk.length) {
            let next = this.layer.chunk[this.chunkIndex];
            if (!(this.skip && this.skip.has(next) ||
                this.layer.chunkEnd(this.chunkIndex) < pos ||
                next.maxPoint < this.minPoint))
                break;
            this.chunkIndex++;
            forward = false;
        }
        let rangeIndex = this.chunkIndex == this.layer.chunk.length ? 0
            : this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], -1, side);
        if (!forward || this.rangeIndex < rangeIndex)
            this.rangeIndex = rangeIndex;
        this.next();
    }
    forward(pos, side) {
        if ((this.to - pos || this.endSide - side) < 0)
            this.gotoInner(pos, side, true);
    }
    next() {
        for (;;) {
            if (this.chunkIndex == this.layer.chunk.length) {
                this.from = this.to = 1000000000 /* Far */;
                this.value = null;
                break;
            }
            else {
                let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];
                let from = chunkPos + chunk.from[this.rangeIndex];
                this.from = from;
                this.to = chunkPos + chunk.to[this.rangeIndex];
                this.value = chunk.value[this.rangeIndex];
                if (++this.rangeIndex == chunk.value.length) {
                    this.chunkIndex++;
                    if (this.skip) {
                        while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))
                            this.chunkIndex++;
                    }
                    this.rangeIndex = 0;
                }
                if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
                    break;
            }
        }
    }
    nextChunk() {
        this.chunkIndex++;
        this.rangeIndex = 0;
        this.next();
    }
    compare(other) {
        return this.from - other.from || this.startSide - other.startSide || this.to - other.to || this.endSide - other.endSide;
    }
}
class HeapCursor {
    constructor(heap) {
        this.heap = heap;
    }
    static from(sets, skip = null, minPoint = -1) {
        let heap = [];
        for (let i = 0; i < sets.length; i++) {
            for (let cur = sets[i]; cur != RangeSet.empty; cur = cur.nextLayer) {
                if (cur.maxPoint >= minPoint)
                    heap.push(new LayerCursor(cur, skip, minPoint, i));
            }
        }
        return heap.length == 1 ? heap[0] : new HeapCursor(heap);
    }
    get startSide() { return this.value ? this.value.startSide : 0; }
    goto(pos, side = -1000000000 /* Far */) {
        for (let cur of this.heap)
            cur.goto(pos, side);
        for (let i = this.heap.length >> 1; i >= 0; i--)
            heapBubble(this.heap, i);
        this.next();
        return this;
    }
    forward(pos, side) {
        for (let cur of this.heap)
            cur.forward(pos, side);
        for (let i = this.heap.length >> 1; i >= 0; i--)
            heapBubble(this.heap, i);
        if ((this.to - pos || this.value.endSide - side) < 0)
            this.next();
    }
    next() {
        if (this.heap.length == 0) {
            this.from = this.to = 1000000000 /* Far */;
            this.value = null;
            this.rank = -1;
        }
        else {
            let top = this.heap[0];
            this.from = top.from;
            this.to = top.to;
            this.value = top.value;
            this.rank = top.rank;
            if (top.value)
                top.next();
            heapBubble(this.heap, 0);
        }
    }
}
function heapBubble(heap, index) {
    for (let cur = heap[index];;) {
        let childIndex = (index << 1) + 1;
        if (childIndex >= heap.length)
            break;
        let child = heap[childIndex];
        if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {
            child = heap[childIndex + 1];
            childIndex++;
        }
        if (cur.compare(child) < 0)
            break;
        heap[childIndex] = cur;
        heap[index] = child;
        index = childIndex;
    }
}
class SpanCursor {
    constructor(sets, skip, minPoint) {
        this.minPoint = minPoint;
        this.active = [];
        this.activeTo = [];
        this.activeRank = [];
        this.minActive = -1;
        // A currently active point range, if any
        this.point = null;
        this.pointFrom = 0;
        this.pointRank = 0;
        this.to = -1000000000 /* Far */;
        this.endSide = 0;
        this.openStart = -1;
        this.cursor = HeapCursor.from(sets, skip, minPoint);
    }
    goto(pos, side = -1000000000 /* Far */) {
        this.cursor.goto(pos, side);
        this.active.length = this.activeTo.length = this.activeRank.length = 0;
        this.minActive = -1;
        this.to = pos;
        this.endSide = side;
        this.openStart = -1;
        this.next();
        return this;
    }
    forward(pos, side) {
        while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)
            this.removeActive(this.minActive);
        this.cursor.forward(pos, side);
    }
    removeActive(index) {
        remove(this.active, index);
        remove(this.activeTo, index);
        remove(this.activeRank, index);
        this.minActive = findMinIndex(this.active, this.activeTo);
    }
    addActive(trackOpen) {
        let i = 0, { value, to, rank } = this.cursor;
        while (i < this.activeRank.length && this.activeRank[i] <= rank)
            i++;
        insert(this.active, i, value);
        insert(this.activeTo, i, to);
        insert(this.activeRank, i, rank);
        if (trackOpen)
            insert(trackOpen, i, this.cursor.from);
        this.minActive = findMinIndex(this.active, this.activeTo);
    }
    // After calling this, if `this.point` != null, the next range is a
    // point. Otherwise, it's a regular range, covered by `this.active`.
    next() {
        let from = this.to;
        this.point = null;
        let trackOpen = this.openStart < 0 ? [] : null, trackExtra = 0;
        for (;;) {
            let a = this.minActive;
            if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {
                if (this.activeTo[a] > from) {
                    this.to = this.activeTo[a];
                    this.endSide = this.active[a].endSide;
                    break;
                }
                this.removeActive(a);
                if (trackOpen)
                    remove(trackOpen, a);
            }
            else if (!this.cursor.value) {
                this.to = this.endSide = 1000000000 /* Far */;
                break;
            }
            else if (this.cursor.from > from) {
                this.to = this.cursor.from;
                this.endSide = this.cursor.startSide;
                break;
            }
            else {
                let nextVal = this.cursor.value;
                if (!nextVal.point) { // Opening a range
                    this.addActive(trackOpen);
                    this.cursor.next();
                }
                else { // New point
                    this.point = nextVal;
                    this.pointFrom = this.cursor.from;
                    this.pointRank = this.cursor.rank;
                    this.to = this.cursor.to;
                    this.endSide = nextVal.endSide;
                    if (this.cursor.from < from)
                        trackExtra = 1;
                    this.cursor.next();
                    if (this.to > from)
                        this.forward(this.to, this.endSide);
                    break;
                }
            }
        }
        if (trackOpen) {
            let openStart = 0;
            while (openStart < trackOpen.length && trackOpen[openStart] < from)
                openStart++;
            this.openStart = openStart + trackExtra;
        }
    }
    activeForPoint(to) {
        if (!this.active.length)
            return this.active;
        let active = [];
        for (let i = 0; i < this.active.length; i++) {
            if (this.activeRank[i] > this.pointRank)
                break;
            if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide > this.point.endSide)
                active.push(this.active[i]);
        }
        return active;
    }
    openEnd(to) {
        let open = 0;
        while (open < this.activeTo.length && this.activeTo[open] > to)
            open++;
        return open;
    }
}
function compare(a, startA, b, startB, length, comparator) {
    a.goto(startA);
    b.goto(startB);
    let endB = startB + length;
    let pos = startB, dPos = startB - startA;
    for (;;) {
        let diff = (a.to + dPos) - b.to || a.endSide - b.endSide;
        let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);
        if (a.point || b.point) {
            if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point))))
                comparator.comparePoint(pos, clipEnd, a.point, b.point);
        }
        else {
            if (clipEnd > pos && !sameValues(a.active, b.active))
                comparator.compareRange(pos, clipEnd, a.active, b.active);
        }
        if (end > endB)
            break;
        pos = end;
        if (diff <= 0)
            a.next();
        if (diff >= 0)
            b.next();
    }
}
function sameValues(a, b) {
    if (a.length != b.length)
        return false;
    for (let i = 0; i < a.length; i++)
        if (a[i] != b[i] && !a[i].eq(b[i]))
            return false;
    return true;
}
function remove(array, index) {
    for (let i = index, e = array.length - 1; i < e; i++)
        array[i] = array[i + 1];
    array.pop();
}
function insert(array, index, value) {
    for (let i = array.length - 1; i >= index; i--)
        array[i + 1] = array[i];
    array[index] = value;
}
function findMinIndex(value, array) {
    let found = -1, foundPos = 1000000000 /* Far */;
    for (let i = 0; i < array.length; i++)
        if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {
            found = i;
            foundPos = array[i];
        }
    return found;
}

exports.Range = Range;
exports.RangeSet = RangeSet;
exports.RangeSetBuilder = RangeSetBuilder;
exports.RangeValue = RangeValue;

},{"@codemirror/state":17}],15:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var state = require('@codemirror/state');
var view = require('@codemirror/view');
var text = require('@codemirror/text');

// Don't compute precise column positions for line offsets above this
// (since it could get expensive). Assume offset==column for them.
const MaxOff = 2000;
function rectangleFor(state$1, a, b) {
    let startLine = Math.min(a.line, b.line), endLine = Math.max(a.line, b.line);
    let ranges = [];
    if (a.off > MaxOff || b.off > MaxOff || a.col < 0 || b.col < 0) {
        let startOff = Math.min(a.off, b.off), endOff = Math.max(a.off, b.off);
        for (let i = startLine; i <= endLine; i++) {
            let line = state$1.doc.line(i);
            if (line.length <= endOff)
                ranges.push(state.EditorSelection.range(line.from + startOff, line.to + endOff));
        }
    }
    else {
        let startCol = Math.min(a.col, b.col), endCol = Math.max(a.col, b.col);
        for (let i = startLine; i <= endLine; i++) {
            let line = state$1.doc.line(i), str = line.length > MaxOff ? line.text.slice(0, 2 * endCol) : line.text;
            let start = text.findColumn(str, 0, startCol, state$1.tabSize), end = text.findColumn(str, 0, endCol, state$1.tabSize);
            if (!start.leftOver)
                ranges.push(state.EditorSelection.range(line.from + start.offset, line.from + end.offset));
        }
    }
    return ranges;
}
function absoluteColumn(view, x) {
    let ref = view.coordsAtPos(view.viewport.from);
    return ref ? Math.round(Math.abs((ref.left - x) / view.defaultCharacterWidth)) : -1;
}
function getPos(view, event) {
    let offset = view.posAtCoords({ x: event.clientX, y: event.clientY });
    if (offset == null)
        return null;
    let line = view.state.doc.lineAt(offset), off = offset - line.from;
    let col = off > MaxOff ? -1
        : off == line.length ? absoluteColumn(view, event.clientX)
            : text.countColumn(line.text.slice(0, offset - line.from), 0, view.state.tabSize);
    return { line: line.number, col, off };
}
function rectangleSelectionStyle(view, event) {
    let start = getPos(view, event), startSel = view.state.selection;
    if (!start)
        return null;
    return {
        update(update) {
            if (update.docChanged) {
                let newStart = update.changes.mapPos(update.startState.doc.line(start.line).from);
                let newLine = update.state.doc.lineAt(newStart);
                start = { line: newLine.number, col: start.col, off: Math.min(start.off, newLine.length) };
                startSel = startSel.map(update.changes);
            }
        },
        get(event, _extend, multiple) {
            let cur = getPos(view, event);
            if (!cur)
                return startSel;
            let ranges = rectangleFor(view.state, start, cur);
            if (!ranges.length)
                return startSel;
            if (multiple)
                return state.EditorSelection.create(ranges.concat(startSel.ranges));
            else
                return state.EditorSelection.create(ranges);
        }
    };
}
/// Create an extension that enables rectangular selections. By
/// default, it will react to left mouse drag with the Alt key held
/// down. When such a selection occurs, the text within the rectangle
/// that was dragged over will be selected, as one selection
/// [range](#state.SelectionRange) per line.
function rectangularSelection(options) {
    let filter = (options === null || options === void 0 ? void 0 : options.eventFilter) || (e => e.altKey && e.button == 0);
    return view.EditorView.mouseSelectionStyle.of((view, event) => filter(event) ? rectangleSelectionStyle(view, event) : null);
}

exports.rectangularSelection = rectangularSelection;

},{"@codemirror/state":17,"@codemirror/text":18,"@codemirror/view":20}],16:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var view = require('@codemirror/view');
var state = require('@codemirror/state');
var panel = require('@codemirror/panel');
var rangeset = require('@codemirror/rangeset');
var elt = require('crelt');
var text = require('@codemirror/text');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var elt__default = /*#__PURE__*/_interopDefaultLegacy(elt);

const basicNormalize = typeof String.prototype.normalize == "function"
    ? x => x.normalize("NFKD") : x => x;
/**
A search cursor provides an iterator over text matches in a
document.
*/
class SearchCursor {
    /**
    Create a text cursor. The query is the search string, `from` to
    `to` provides the region to search.
    
    When `normalize` is given, it will be called, on both the query
    string and the content it is matched against, before comparing.
    You can, for example, create a case-insensitive search by
    passing `s => s.toLowerCase()`.
    
    Text is always normalized with
    [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
    (when supported).
    */
    constructor(text, query, from = 0, to = text.length, normalize) {
        /**
        The current match (only holds a meaningful value after
        [`next`](https://codemirror.net/6/docs/ref/#search.SearchCursor.next) has been called and when
        `done` is false).
        */
        this.value = { from: 0, to: 0 };
        /**
        Whether the end of the iterated region has been reached.
        */
        this.done = false;
        this.matches = [];
        this.buffer = "";
        this.bufferPos = 0;
        this.iter = text.iterRange(from, to);
        this.bufferStart = from;
        this.normalize = normalize ? x => normalize(basicNormalize(x)) : basicNormalize;
        this.query = this.normalize(query);
    }
    peek() {
        if (this.bufferPos == this.buffer.length) {
            this.bufferStart += this.buffer.length;
            this.iter.next();
            if (this.iter.done)
                return -1;
            this.bufferPos = 0;
            this.buffer = this.iter.value;
        }
        return text.codePointAt(this.buffer, this.bufferPos);
    }
    /**
    Look for the next match. Updates the iterator's
    [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
    [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
    at least once before using the cursor.
    */
    next() {
        while (this.matches.length)
            this.matches.pop();
        return this.nextOverlapping();
    }
    /**
    The `next` method will ignore matches that partially overlap a
    previous match. This method behaves like `next`, but includes
    such matches.
    */
    nextOverlapping() {
        for (;;) {
            let next = this.peek();
            if (next < 0) {
                this.done = true;
                return this;
            }
            let str = text.fromCodePoint(next), start = this.bufferStart + this.bufferPos;
            this.bufferPos += text.codePointSize(next);
            let norm = this.normalize(str);
            for (let i = 0, pos = start;; i++) {
                let code = norm.charCodeAt(i);
                let match = this.match(code, pos);
                if (match) {
                    this.value = match;
                    return this;
                }
                if (i == norm.length - 1)
                    break;
                if (pos == start && i < str.length && str.charCodeAt(i) == code)
                    pos++;
            }
        }
    }
    match(code, pos) {
        let match = null;
        for (let i = 0; i < this.matches.length; i += 2) {
            let index = this.matches[i], keep = false;
            if (this.query.charCodeAt(index) == code) {
                if (index == this.query.length - 1) {
                    match = { from: this.matches[i + 1], to: pos + 1 };
                }
                else {
                    this.matches[i]++;
                    keep = true;
                }
            }
            if (!keep) {
                this.matches.splice(i, 2);
                i -= 2;
            }
        }
        if (this.query.charCodeAt(0) == code) {
            if (this.query.length == 1)
                match = { from: pos, to: pos + 1 };
            else
                this.matches.push(1, pos);
        }
        return match;
    }
}

const empty = { from: -1, to: -1, match: /.*/.exec("") };
const baseFlags = "gm" + (/x/.unicode == null ? "" : "u");
class RegExpCursor {
    constructor(text, query, options, from = 0, to = text.length) {
        this.to = to;
        this.curLine = "";
        this.done = false;
        this.value = empty;
        if (/\\[sWDnr]|\n|\r|\[\^/.test(query))
            return new MultilineRegExpCursor(text, query, options, from, to);
        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
        this.iter = text.iter();
        let startLine = text.lineAt(from);
        this.curLineStart = startLine.from;
        this.matchPos = from;
        this.getLine(this.curLineStart);
    }
    getLine(skip) {
        this.iter.next(skip);
        if (this.iter.lineBreak) {
            this.curLine = "";
        }
        else {
            this.curLine = this.iter.value;
            if (this.curLineStart + this.curLine.length > this.to)
                this.curLine = this.curLine.slice(0, this.to - this.curLineStart);
            this.iter.next();
        }
    }
    nextLine() {
        this.curLineStart = this.curLineStart + this.curLine.length + 1;
        if (this.curLineStart > this.to)
            this.curLine = "";
        else
            this.getLine(0);
    }
    next() {
        for (let off = this.matchPos - this.curLineStart;;) {
            this.re.lastIndex = off;
            let match = this.matchPos <= this.to && this.re.exec(this.curLine);
            if (match) {
                let from = this.curLineStart + match.index, to = from + match[0].length;
                this.matchPos = to + (from == to ? 1 : 0);
                if (from == this.curLine.length)
                    this.nextLine();
                if (from < to || from > this.value.to) {
                    this.value = { from, to, match };
                    return this;
                }
                off = this.matchPos - this.curLineStart;
            }
            else if (this.curLineStart + this.curLine.length < this.to) {
                this.nextLine();
                off = 0;
            }
            else {
                this.done = true;
                return this;
            }
        }
    }
}
const flattened = new WeakMap();
// Reusable (partially) flattened document strings
class FlattenedDoc {
    constructor(from, text) {
        this.from = from;
        this.text = text;
    }
    get to() { return this.from + this.text.length; }
    static get(doc, from, to) {
        let cached = flattened.get(doc);
        if (!cached || cached.from >= to || cached.to <= from) {
            let flat = new FlattenedDoc(from, doc.sliceString(from, to));
            flattened.set(doc, flat);
            return flat;
        }
        if (cached.from == from && cached.to == to)
            return cached;
        let { text, from: cachedFrom } = cached;
        if (cachedFrom > from) {
            text = doc.sliceString(from, cachedFrom) + text;
            cachedFrom = from;
        }
        if (cached.to < to)
            text += doc.sliceString(cached.to, to);
        flattened.set(doc, new FlattenedDoc(cachedFrom, text));
        return new FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));
    }
}
class MultilineRegExpCursor {
    constructor(text, query, options, from, to) {
        this.text = text;
        this.to = to;
        this.done = false;
        this.value = empty;
        this.matchPos = from;
        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
        this.flat = FlattenedDoc.get(text, from, this.chunkEnd(from + 5000 /* Base */));
    }
    chunkEnd(pos) {
        return pos >= this.to ? this.to : this.text.lineAt(pos).to;
    }
    next() {
        for (;;) {
            let off = this.re.lastIndex = this.matchPos - this.flat.from;
            let match = this.re.exec(this.flat.text);
            // Skip empty matches directly after the last match
            if (match && !match[0] && match.index == off) {
                this.re.lastIndex = off + 1;
                match = this.re.exec(this.flat.text);
            }
            // If a match goes almost to the end of a noncomplete chunk, try
            // again, since it'll likely be able to match more
            if (match && this.flat.to < this.to && match.index + match[0].length > this.flat.text.length - 10)
                match = null;
            if (match) {
                let from = this.flat.from + match.index, to = from + match[0].length;
                this.value = { from, to, match };
                this.matchPos = to + (from == to ? 1 : 0);
                return this;
            }
            else {
                if (this.flat.to == this.to) {
                    this.done = true;
                    return this;
                }
                // Grow the flattened doc
                this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
            }
        }
    }
}
function validRegExp(source) {
    try {
        new RegExp(source, baseFlags);
        return true;
    }
    catch (_a) {
        return false;
    }
}

function createLineDialog(view) {
    let input = elt__default['default']("input", { class: "cm-textfield", name: "line" });
    let dom = elt__default['default']("form", {
        class: "cm-gotoLine",
        onkeydown: (event) => {
            if (event.keyCode == 27) { // Escape
                event.preventDefault();
                view.dispatch({ effects: dialogEffect.of(false) });
                view.focus();
            }
            else if (event.keyCode == 13) { // Enter
                event.preventDefault();
                go();
            }
        },
        onsubmit: (event) => {
            event.preventDefault();
            go();
        }
    }, elt__default['default']("label", view.state.phrase("Go to line"), ": ", input), " ", elt__default['default']("button", { class: "cm-button", type: "submit" }, view.state.phrase("go")));
    function go() {
        let match = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(input.value);
        if (!match)
            return;
        let { state: state$1 } = view, startLine = state$1.doc.lineAt(state$1.selection.main.head);
        let [, sign, ln, cl, percent] = match;
        let col = cl ? +cl.slice(1) : 0;
        let line = ln ? +ln : startLine.number;
        if (ln && percent) {
            let pc = line / 100;
            if (sign)
                pc = pc * (sign == "-" ? -1 : 1) + (startLine.number / state$1.doc.lines);
            line = Math.round(state$1.doc.lines * pc);
        }
        else if (ln && sign) {
            line = line * (sign == "-" ? -1 : 1) + startLine.number;
        }
        let docLine = state$1.doc.line(Math.max(1, Math.min(state$1.doc.lines, line)));
        view.dispatch({
            effects: dialogEffect.of(false),
            selection: state.EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length))),
            scrollIntoView: true
        });
        view.focus();
    }
    return { dom, pos: -10 };
}
const dialogEffect = state.StateEffect.define();
const dialogField = state.StateField.define({
    create() { return true; },
    update(value, tr) {
        for (let e of tr.effects)
            if (e.is(dialogEffect))
                value = e.value;
        return value;
    },
    provide: f => panel.showPanel.from(f, val => val ? createLineDialog : null)
});
/**
Command that shows a dialog asking the user for a line number, and
when a valid position is provided, moves the cursor to that line.

Supports line numbers, relative line offsets prefixed with `+` or
`-`, document percentages suffixed with `%`, and an optional
column position by adding `:` and a second number after the line
number.

The dialog can be styled with the `panel.gotoLine` theme
selector.
*/
const gotoLine = view => {
    let panel$1 = panel.getPanel(view, createLineDialog);
    if (!panel$1) {
        let effects = [dialogEffect.of(true)];
        if (view.state.field(dialogField, false) == null)
            effects.push(state.StateEffect.appendConfig.of([dialogField, baseTheme$1]));
        view.dispatch({ effects });
        panel$1 = panel.getPanel(view, createLineDialog);
    }
    if (panel$1)
        panel$1.dom.querySelector("input").focus();
    return true;
};
const baseTheme$1 = view.EditorView.baseTheme({
    ".cm-panel.cm-gotoLine": {
        padding: "2px 6px 4px",
        "& label": { fontSize: "80%" }
    }
});

const defaultHighlightOptions = {
    highlightWordAroundCursor: false,
    minSelectionLength: 1,
    maxMatches: 100
};
const highlightConfig = state.Facet.define({
    combine(options) {
        return state.combineConfig(options, defaultHighlightOptions, {
            highlightWordAroundCursor: (a, b) => a || b,
            minSelectionLength: Math.min,
            maxMatches: Math.min
        });
    }
});
/**
This extension highlights text that matches the selection. It uses
the `"cm-selectionMatch"` class for the highlighting. When
`highlightWordAroundCursor` is enabled, the word at the cursor
itself will be highlighted with `"cm-selectionMatch-main"`.
*/
function highlightSelectionMatches(options) {
    let ext = [defaultTheme, matchHighlighter];
    if (options)
        ext.push(highlightConfig.of(options));
    return ext;
}
function wordAt(doc, pos, check) {
    let line = doc.lineAt(pos);
    let from = pos - line.from, to = pos - line.from;
    while (from > 0) {
        let prev = text.findClusterBreak(line.text, from, false);
        if (check(line.text.slice(prev, from)) != state.CharCategory.Word)
            break;
        from = prev;
    }
    while (to < line.length) {
        let next = text.findClusterBreak(line.text, to);
        if (check(line.text.slice(to, next)) != state.CharCategory.Word)
            break;
        to = next;
    }
    return from == to ? null : line.text.slice(from, to);
}
const matchDeco = view.Decoration.mark({ class: "cm-selectionMatch" });
const mainMatchDeco = view.Decoration.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
const matchHighlighter = view.ViewPlugin.fromClass(class {
    constructor(view) {
        this.decorations = this.getDeco(view);
    }
    update(update) {
        if (update.selectionSet || update.docChanged || update.viewportChanged)
            this.decorations = this.getDeco(update.view);
    }
    getDeco(view$1) {
        let conf = view$1.state.facet(highlightConfig);
        let { state: state$1 } = view$1, sel = state$1.selection;
        if (sel.ranges.length > 1)
            return view.Decoration.none;
        let range = sel.main, query, check = null;
        if (range.empty) {
            if (!conf.highlightWordAroundCursor)
                return view.Decoration.none;
            check = state$1.charCategorizer(range.head);
            query = wordAt(state$1.doc, range.head, check);
            if (!query)
                return view.Decoration.none;
        }
        else {
            let len = range.to - range.from;
            if (len < conf.minSelectionLength || len > 200)
                return view.Decoration.none;
            query = state$1.sliceDoc(range.from, range.to).trim();
            if (!query)
                return view.Decoration.none;
        }
        let deco = [];
        for (let part of view$1.visibleRanges) {
            let cursor = new SearchCursor(state$1.doc, query, part.from, part.to);
            while (!cursor.nextOverlapping().done) {
                let { from, to } = cursor.value;
                if (!check || ((from == 0 || check(state$1.sliceDoc(from - 1, from)) != state.CharCategory.Word) &&
                    (to == state$1.doc.length || check(state$1.sliceDoc(to, to + 1)) != state.CharCategory.Word))) {
                    if (check && from <= range.from && to >= range.to)
                        deco.push(mainMatchDeco.range(from, to));
                    else if (from >= range.to || to <= range.from)
                        deco.push(matchDeco.range(from, to));
                    if (deco.length > conf.maxMatches)
                        return view.Decoration.none;
                }
            }
        }
        return view.Decoration.set(deco);
    }
}, {
    decorations: v => v.decorations
});
const defaultTheme = view.EditorView.baseTheme({
    ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
    ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
});

class Query {
    constructor(search, replace, caseInsensitive) {
        this.search = search;
        this.replace = replace;
        this.caseInsensitive = caseInsensitive;
    }
    eq(other) {
        return this.search == other.search && this.replace == other.replace &&
            this.caseInsensitive == other.caseInsensitive && this.constructor == other.constructor;
    }
}
class StringQuery extends Query {
    constructor(search, replace, caseInsensitive) {
        super(search, replace, caseInsensitive);
        this.unquoted = search.replace(/\\([nrt\\])/g, (_, ch) => ch == "n" ? "\n" : ch == "r" ? "\r" : ch == "t" ? "\t" : "\\");
    }
    cursor(doc, from = 0, to = doc.length) {
        return new SearchCursor(doc, this.unquoted, from, to, this.caseInsensitive ? x => x.toLowerCase() : undefined);
    }
    nextMatch(doc, curFrom, curTo) {
        let cursor = this.cursor(doc, curTo).nextOverlapping();
        if (cursor.done)
            cursor = this.cursor(doc, 0, curFrom).nextOverlapping();
        return cursor.done ? null : cursor.value;
    }
    // Searching in reverse is, rather than implementing inverted search
    // cursor, done by scanning chunk after chunk forward.
    prevMatchInRange(doc, from, to) {
        for (let pos = to;;) {
            let start = Math.max(from, pos - 10000 /* ChunkSize */ - this.unquoted.length);
            let cursor = this.cursor(doc, start, pos), range = null;
            while (!cursor.nextOverlapping().done)
                range = cursor.value;
            if (range)
                return range;
            if (start == from)
                return null;
            pos -= 10000 /* ChunkSize */;
        }
    }
    prevMatch(doc, curFrom, curTo) {
        return this.prevMatchInRange(doc, 0, curFrom) ||
            this.prevMatchInRange(doc, curTo, doc.length);
    }
    getReplacement(_result) { return this.replace; }
    matchAll(doc, limit) {
        let cursor = this.cursor(doc), ranges = [];
        while (!cursor.next().done) {
            if (ranges.length >= limit)
                return null;
            ranges.push(cursor.value);
        }
        return ranges;
    }
    highlight(doc, from, to, add) {
        let cursor = this.cursor(doc, Math.max(0, from - this.unquoted.length), Math.min(to + this.unquoted.length, doc.length));
        while (!cursor.next().done)
            add(cursor.value.from, cursor.value.to);
    }
    get valid() { return !!this.search; }
}
class RegExpQuery extends Query {
    constructor(search, replace, caseInsensitive) {
        super(search, replace, caseInsensitive);
        this.valid = !!search && validRegExp(search);
    }
    cursor(doc, from = 0, to = doc.length) {
        return new RegExpCursor(doc, this.search, this.caseInsensitive ? { ignoreCase: true } : undefined, from, to);
    }
    nextMatch(doc, curFrom, curTo) {
        let cursor = this.cursor(doc, curTo).next();
        if (cursor.done)
            cursor = this.cursor(doc, 0, curFrom).next();
        return cursor.done ? null : cursor.value;
    }
    prevMatchInRange(doc, from, to) {
        for (let size = 1;; size++) {
            let start = Math.max(from, to - size * 10000 /* ChunkSize */);
            let cursor = this.cursor(doc, start, to), range = null;
            while (!cursor.next().done)
                range = cursor.value;
            if (range && (start == from || range.from > start + 10))
                return range;
            if (start == from)
                return null;
        }
    }
    prevMatch(doc, curFrom, curTo) {
        return this.prevMatchInRange(doc, 0, curFrom) ||
            this.prevMatchInRange(doc, curTo, doc.length);
    }
    getReplacement(result) {
        return this.replace.replace(/\$([$&\d+])/g, (m, i) => i == "$" ? "$"
            : i == "&" ? result.match[0]
                : i != "0" && +i < result.match.length ? result.match[i]
                    : m);
    }
    matchAll(doc, limit) {
        let cursor = this.cursor(doc), ranges = [];
        while (!cursor.next().done) {
            if (ranges.length >= limit)
                return null;
            ranges.push(cursor.value);
        }
        return ranges;
    }
    highlight(doc, from, to, add) {
        let cursor = this.cursor(doc, Math.max(0, from - 250 /* HighlightMargin */), Math.min(to + 250 /* HighlightMargin */, doc.length));
        while (!cursor.next().done)
            add(cursor.value.from, cursor.value.to);
    }
}
const setQuery = state.StateEffect.define();
const togglePanel = state.StateEffect.define();
const searchState = state.StateField.define({
    create() {
        return new SearchState(new StringQuery("", "", false), null);
    },
    update(value, tr) {
        for (let effect of tr.effects) {
            if (effect.is(setQuery))
                value = new SearchState(effect.value, value.panel);
            else if (effect.is(togglePanel))
                value = new SearchState(value.query, effect.value ? createSearchPanel : null);
        }
        return value;
    },
    provide: f => panel.showPanel.from(f, val => val.panel)
});
class SearchState {
    constructor(query, panel) {
        this.query = query;
        this.panel = panel;
    }
}
const matchMark = view.Decoration.mark({ class: "cm-searchMatch" }), selectedMatchMark = view.Decoration.mark({ class: "cm-searchMatch cm-searchMatch-selected" });
const searchHighlighter = view.ViewPlugin.fromClass(class {
    constructor(view) {
        this.view = view;
        this.decorations = this.highlight(view.state.field(searchState));
    }
    update(update) {
        let state = update.state.field(searchState);
        if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet)
            this.decorations = this.highlight(state);
    }
    highlight({ query, panel }) {
        if (!panel || !query.valid)
            return view.Decoration.none;
        let { view: view$1 } = this;
        let builder = new rangeset.RangeSetBuilder();
        for (let i = 0, ranges = view$1.visibleRanges, l = ranges.length; i < l; i++) {
            let { from, to } = ranges[i];
            while (i < l - 1 && to > ranges[i + 1].from - 2 * 250 /* HighlightMargin */)
                to = ranges[++i].to;
            query.highlight(view$1.state.doc, from, to, (from, to) => {
                let selected = view$1.state.selection.ranges.some(r => r.from == from && r.to == to);
                builder.add(from, to, selected ? selectedMatchMark : matchMark);
            });
        }
        return builder.finish();
    }
}, {
    decorations: v => v.decorations
});
function searchCommand(f) {
    return view => {
        let state = view.state.field(searchState, false);
        return state && state.query.valid ? f(view, state) : openSearchPanel(view);
    };
}
/**
Open the search panel if it isn't already open, and move the
selection to the first match after the current main selection.
Will wrap around to the start of the document when it reaches the
end.
*/
const findNext = searchCommand((view, { query }) => {
    let { from, to } = view.state.selection.main;
    let next = query.nextMatch(view.state.doc, from, to);
    if (!next || next.from == from && next.to == to)
        return false;
    view.dispatch({
        selection: { anchor: next.from, head: next.to },
        scrollIntoView: true,
        effects: announceMatch(view, next)
    });
    return true;
});
/**
Move the selection to the previous instance of the search query,
before the current main selection. Will wrap past the start
of the document to start searching at the end again.
*/
const findPrevious = searchCommand((view, { query }) => {
    let { state } = view, { from, to } = state.selection.main;
    let range = query.prevMatch(state.doc, from, to);
    if (!range)
        return false;
    view.dispatch({
        selection: { anchor: range.from, head: range.to },
        scrollIntoView: true,
        effects: announceMatch(view, range)
    });
    return true;
});
/**
Select all instances of the search query.
*/
const selectMatches = searchCommand((view, { query }) => {
    let ranges = query.matchAll(view.state.doc, 1000);
    if (!ranges || !ranges.length)
        return false;
    view.dispatch({
        selection: state.EditorSelection.create(ranges.map(r => state.EditorSelection.range(r.from, r.to)))
    });
    return true;
});
/**
Select all instances of the currently selected text.
*/
const selectSelectionMatches = ({ state: state$1, dispatch }) => {
    let sel = state$1.selection;
    if (sel.ranges.length > 1 || sel.main.empty)
        return false;
    let { from, to } = sel.main;
    let ranges = [], main = 0;
    for (let cur = new SearchCursor(state$1.doc, state$1.sliceDoc(from, to)); !cur.next().done;) {
        if (ranges.length > 1000)
            return false;
        if (cur.value.from == from)
            main = ranges.length;
        ranges.push(state.EditorSelection.range(cur.value.from, cur.value.to));
    }
    dispatch(state$1.update({ selection: state.EditorSelection.create(ranges, main) }));
    return true;
};
/**
Replace the current match of the search query.
*/
const replaceNext = searchCommand((view, { query }) => {
    let { state } = view, { from, to } = state.selection.main;
    let next = query.nextMatch(state.doc, from, from);
    if (!next)
        return false;
    let changes = [], selection, replacement;
    if (next.from == from && next.to == to) {
        replacement = state.toText(query.getReplacement(next));
        changes.push({ from: next.from, to: next.to, insert: replacement });
        next = query.nextMatch(state.doc, next.from, next.to);
    }
    if (next) {
        let off = changes.length == 0 || changes[0].from >= next.to ? 0 : next.to - next.from - replacement.length;
        selection = { anchor: next.from - off, head: next.to - off };
    }
    view.dispatch({
        changes, selection,
        scrollIntoView: !!selection,
        effects: next ? announceMatch(view, next) : undefined
    });
    return true;
});
/**
Replace all instances of the search query with the given
replacement.
*/
const replaceAll = searchCommand((view, { query }) => {
    let changes = query.matchAll(view.state.doc, 1e9).map(match => {
        let { from, to } = match;
        return { from, to, insert: query.getReplacement(match) };
    });
    if (!changes.length)
        return false;
    view.dispatch({ changes });
    return true;
});
function createSearchPanel(view) {
    let { query } = view.state.field(searchState);
    return {
        dom: buildPanel({
            view,
            query,
            updateQuery(q) {
                if (!query.eq(q)) {
                    query = q;
                    view.dispatch({ effects: setQuery.of(query) });
                }
            }
        }),
        mount() {
            this.dom.querySelector("[name=search]").select();
        },
        pos: 80
    };
}
/**
Make sure the search panel is open and focused.
*/
const openSearchPanel = view => {
    let state$1 = view.state.field(searchState, false);
    if (state$1 && state$1.panel) {
        let panel$1 = panel.getPanel(view, createSearchPanel);
        if (!panel$1)
            return false;
        panel$1.dom.querySelector("[name=search]").focus();
    }
    else {
        view.dispatch({ effects: [togglePanel.of(true), ...state$1 ? [] : [state.StateEffect.appendConfig.of(searchExtensions)]] });
    }
    return true;
};
/**
Close the search panel.
*/
const closeSearchPanel = view => {
    let state = view.state.field(searchState, false);
    if (!state || !state.panel)
        return false;
    let panel$1 = panel.getPanel(view, createSearchPanel);
    if (panel$1 && panel$1.dom.contains(view.root.activeElement))
        view.focus();
    view.dispatch({ effects: togglePanel.of(false) });
    return true;
};
/**
Default search-related key bindings.

 - Mod-f: [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel)
 - F3, Mod-g: [`findNext`](https://codemirror.net/6/docs/ref/#search.findNext)
 - Shift-F3, Shift-Mod-g: [`findPrevious`](https://codemirror.net/6/docs/ref/#search.findPrevious)
 - Alt-g: [`gotoLine`](https://codemirror.net/6/docs/ref/#search.gotoLine)
*/
const searchKeymap = [
    { key: "Mod-f", run: openSearchPanel, scope: "editor search-panel" },
    { key: "F3", run: findNext, shift: findPrevious, scope: "editor search-panel" },
    { key: "Mod-g", run: findNext, shift: findPrevious, scope: "editor search-panel" },
    { key: "Escape", run: closeSearchPanel, scope: "editor search-panel" },
    { key: "Mod-Shift-l", run: selectSelectionMatches },
    { key: "Alt-g", run: gotoLine }
];
function buildPanel(conf) {
    function phrase(phrase) { return conf.view.state.phrase(phrase); }
    let searchField = elt__default['default']("input", {
        value: conf.query.search,
        placeholder: phrase("Find"),
        "aria-label": phrase("Find"),
        class: "cm-textfield",
        name: "search",
        onchange: update,
        onkeyup: update
    });
    let replaceField = elt__default['default']("input", {
        value: conf.query.replace,
        placeholder: phrase("Replace"),
        "aria-label": phrase("Replace"),
        class: "cm-textfield",
        name: "replace",
        onchange: update,
        onkeyup: update
    });
    let caseField = elt__default['default']("input", {
        type: "checkbox",
        name: "case",
        checked: !conf.query.caseInsensitive,
        onchange: update
    });
    let reField = elt__default['default']("input", {
        type: "checkbox",
        name: "re",
        checked: conf.query instanceof RegExpQuery,
        onchange: update
    });
    function update() {
        conf.updateQuery(new (reField.checked ? RegExpQuery : StringQuery)(searchField.value, replaceField.value, !caseField.checked));
    }
    function keydown(e) {
        if (view.runScopeHandlers(conf.view, e, "search-panel")) {
            e.preventDefault();
        }
        else if (e.keyCode == 13 && e.target == searchField) {
            e.preventDefault();
            (e.shiftKey ? findPrevious : findNext)(conf.view);
        }
        else if (e.keyCode == 13 && e.target == replaceField) {
            e.preventDefault();
            replaceNext(conf.view);
        }
    }
    function button(name, onclick, content) {
        return elt__default['default']("button", { class: "cm-button", name, onclick }, content);
    }
    let panel = elt__default['default']("div", { onkeydown: keydown, class: "cm-search" }, [
        searchField,
        button("next", () => findNext(conf.view), [phrase("next")]),
        button("prev", () => findPrevious(conf.view), [phrase("previous")]),
        button("select", () => selectMatches(conf.view), [phrase("all")]),
        elt__default['default']("label", null, [caseField, phrase("match case")]),
        elt__default['default']("label", null, [reField, phrase("regexp")]),
        elt__default['default']("br"),
        replaceField,
        button("replace", () => replaceNext(conf.view), [phrase("replace")]),
        button("replaceAll", () => replaceAll(conf.view), [phrase("replace all")]),
        elt__default['default']("button", { name: "close", onclick: () => closeSearchPanel(conf.view), "aria-label": phrase("close") }, ["√ó"])
    ]);
    return panel;
}
const AnnounceMargin = 30;
const Break = /[\s\.,:;?!]/;
function announceMatch(view$1, { from, to }) {
    let lineStart = view$1.state.doc.lineAt(from).from, lineEnd = view$1.state.doc.lineAt(to).to;
    let start = Math.max(lineStart, from - AnnounceMargin), end = Math.min(lineEnd, to + AnnounceMargin);
    let text = view$1.state.sliceDoc(start, end);
    if (start != lineStart) {
        for (let i = 0; i < AnnounceMargin; i++)
            if (!Break.test(text[i + 1]) && Break.test(text[i])) {
                text = text.slice(i);
                break;
            }
    }
    if (end != lineEnd) {
        for (let i = text.length - 1; i > text.length - AnnounceMargin; i--)
            if (!Break.test(text[i - 1]) && Break.test(text[i])) {
                text = text.slice(0, i);
                break;
            }
    }
    return view.EditorView.announce.of(`${view$1.state.phrase("current match")}. ${text} ${view$1.state.phrase("on line")} ${view$1.state.doc.lineAt(from).number}`);
}
const baseTheme = view.EditorView.baseTheme({
    ".cm-panel.cm-search": {
        padding: "2px 6px 4px",
        position: "relative",
        "& [name=close]": {
            position: "absolute",
            top: "0",
            right: "4px",
            backgroundColor: "inherit",
            border: "none",
            font: "inherit",
            padding: 0,
            margin: 0
        },
        "& input, & button, & label": {
            margin: ".2em .6em .2em 0"
        },
        "& input[type=checkbox]": {
            marginRight: ".2em"
        },
        "& label": {
            fontSize: "80%"
        }
    },
    "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
    "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
    "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
    "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
});
const searchExtensions = [
    searchState,
    state.Prec.override(searchHighlighter),
    baseTheme
];

exports.RegExpCursor = RegExpCursor;
exports.SearchCursor = SearchCursor;
exports.closeSearchPanel = closeSearchPanel;
exports.findNext = findNext;
exports.findPrevious = findPrevious;
exports.gotoLine = gotoLine;
exports.highlightSelectionMatches = highlightSelectionMatches;
exports.openSearchPanel = openSearchPanel;
exports.replaceAll = replaceAll;
exports.replaceNext = replaceNext;
exports.searchKeymap = searchKeymap;
exports.selectMatches = selectMatches;
exports.selectSelectionMatches = selectSelectionMatches;

},{"@codemirror/panel":13,"@codemirror/rangeset":14,"@codemirror/state":17,"@codemirror/text":18,"@codemirror/view":20,"crelt":22}],17:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var text = require('@codemirror/text');

const DefaultSplit = /\r\n?|\n/;
/**
Distinguishes different ways in which positions can be mapped.
*/
exports.MapMode = void 0;
(function (MapMode) {
    /**
    Map a position to a valid new position, even when its context
    was deleted.
    */
    MapMode[MapMode["Simple"] = 0] = "Simple";
    /**
    Return null if deletion happens across the position.
    */
    MapMode[MapMode["TrackDel"] = 1] = "TrackDel";
    /**
    Return null if the character _before_ the position is deleted.
    */
    MapMode[MapMode["TrackBefore"] = 2] = "TrackBefore";
    /**
    Return null if the character _after_ the position is deleted.
    */
    MapMode[MapMode["TrackAfter"] = 3] = "TrackAfter";
})(exports.MapMode || (exports.MapMode = {}));
/**
A change description is a variant of [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet)
that doesn't store the inserted text. As such, it can't be
applied, but is cheaper to store and manipulate.
*/
class ChangeDesc {
    // Sections are encoded as pairs of integers. The first is the
    // length in the current document, and the second is -1 for
    // unaffected sections, and the length of the replacement content
    // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
    // 0), and a replacement two positive numbers.
    /**
    @internal
    */
    constructor(
    /**
    @internal
    */
    sections) {
        this.sections = sections;
    }
    /**
    The length of the document before the change.
    */
    get length() {
        let result = 0;
        for (let i = 0; i < this.sections.length; i += 2)
            result += this.sections[i];
        return result;
    }
    /**
    The length of the document after the change.
    */
    get newLength() {
        let result = 0;
        for (let i = 0; i < this.sections.length; i += 2) {
            let ins = this.sections[i + 1];
            result += ins < 0 ? this.sections[i] : ins;
        }
        return result;
    }
    /**
    False when there are actual changes in this set.
    */
    get empty() { return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0; }
    /**
    Iterate over the unchanged parts left by these changes.
    */
    iterGaps(f) {
        for (let i = 0, posA = 0, posB = 0; i < this.sections.length;) {
            let len = this.sections[i++], ins = this.sections[i++];
            if (ins < 0) {
                f(posA, posB, len);
                posB += len;
            }
            else {
                posB += ins;
            }
            posA += len;
        }
    }
    /**
    Iterate over the ranges changed by these changes. (See
    [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
    variant that also provides you with the inserted text.)
    
    When `individual` is true, adjacent changes (which are kept
    separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
    reported separately.
    */
    iterChangedRanges(f, individual = false) {
        iterChanges(this, f, individual);
    }
    /**
    Get a description of the inverted form of these changes.
    */
    get invertedDesc() {
        let sections = [];
        for (let i = 0; i < this.sections.length;) {
            let len = this.sections[i++], ins = this.sections[i++];
            if (ins < 0)
                sections.push(len, ins);
            else
                sections.push(ins, len);
        }
        return new ChangeDesc(sections);
    }
    /**
    Compute the combined effect of applying another set of changes
    after this one. The length of the document after this set should
    match the length before `other`.
    */
    composeDesc(other) { return this.empty ? other : other.empty ? this : composeSets(this, other); }
    /**
    Map this description, which should start with the same document
    as `other`, over another set of changes, so that it can be
    applied after it. When `before` is true, map as if the changes
    in `other` happened before the ones in `this`.
    */
    mapDesc(other, before = false) { return other.empty ? this : mapSet(this, other, before); }
    mapPos(pos, assoc = -1, mode = exports.MapMode.Simple) {
        let posA = 0, posB = 0;
        for (let i = 0; i < this.sections.length;) {
            let len = this.sections[i++], ins = this.sections[i++], endA = posA + len;
            if (ins < 0) {
                if (endA > pos)
                    return posB + (pos - posA);
                posB += len;
            }
            else {
                if (mode != exports.MapMode.Simple && endA >= pos &&
                    (mode == exports.MapMode.TrackDel && posA < pos && endA > pos ||
                        mode == exports.MapMode.TrackBefore && posA < pos ||
                        mode == exports.MapMode.TrackAfter && endA > pos))
                    return null;
                if (endA > pos || endA == pos && assoc < 0 && !len)
                    return pos == posA || assoc < 0 ? posB : posB + ins;
                posB += ins;
            }
            posA = endA;
        }
        if (pos > posA)
            throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);
        return posB;
    }
    /**
    Check whether these changes touch a given range. When one of the
    changes entirely covers the range, the string `"cover"` is
    returned.
    */
    touchesRange(from, to = from) {
        for (let i = 0, pos = 0; i < this.sections.length && pos <= to;) {
            let len = this.sections[i++], ins = this.sections[i++], end = pos + len;
            if (ins >= 0 && pos <= to && end >= from)
                return pos < from && end > to ? "cover" : true;
            pos = end;
        }
        return false;
    }
    /**
    @internal
    */
    toString() {
        let result = "";
        for (let i = 0; i < this.sections.length;) {
            let len = this.sections[i++], ins = this.sections[i++];
            result += (result ? " " : "") + len + (ins >= 0 ? ":" + ins : "");
        }
        return result;
    }
    /**
    Serialize this change desc to a JSON-representable value.
    */
    toJSON() { return this.sections; }
    /**
    Create a change desc from its JSON representation (as produced
    by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
    */
    static fromJSON(json) {
        if (!Array.isArray(json) || json.length % 2 || json.some(a => typeof a != "number"))
            throw new RangeError("Invalid JSON representation of ChangeDesc");
        return new ChangeDesc(json);
    }
}
/**
A change set represents a group of modifications to a document. It
stores the document length, and can only be applied to documents
with exactly that length.
*/
class ChangeSet extends ChangeDesc {
    /**
    @internal
    */
    constructor(sections, 
    /**
    @internal
    */
    inserted) {
        super(sections);
        this.inserted = inserted;
    }
    /**
    Apply the changes to a document, returning the modified
    document.
    */
    apply(doc) {
        if (this.length != doc.length)
            throw new RangeError("Applying change set to a document with the wrong length");
        iterChanges(this, (fromA, toA, fromB, _toB, text) => doc = doc.replace(fromB, fromB + (toA - fromA), text), false);
        return doc;
    }
    mapDesc(other, before = false) { return mapSet(this, other, before, true); }
    /**
    Given the document as it existed _before_ the changes, return a
    change set that represents the inverse of this set, which could
    be used to go from the document created by the changes back to
    the document as it existed before the changes.
    */
    invert(doc) {
        let sections = this.sections.slice(), inserted = [];
        for (let i = 0, pos = 0; i < sections.length; i += 2) {
            let len = sections[i], ins = sections[i + 1];
            if (ins >= 0) {
                sections[i] = ins;
                sections[i + 1] = len;
                let index = i >> 1;
                while (inserted.length < index)
                    inserted.push(text.Text.empty);
                inserted.push(len ? doc.slice(pos, pos + len) : text.Text.empty);
            }
            pos += len;
        }
        return new ChangeSet(sections, inserted);
    }
    /**
    Combine two subsequent change sets into a single set. `other`
    must start in the document produced by `this`. If `this` goes
    `docA` ‚Üí `docB` and `other` represents `docB` ‚Üí `docC`, the
    returned value will represent the change `docA` ‚Üí `docC`.
    */
    compose(other) { return this.empty ? other : other.empty ? this : composeSets(this, other, true); }
    /**
    Given another change set starting in the same document, maps this
    change set over the other, producing a new change set that can be
    applied to the document produced by applying `other`. When
    `before` is `true`, order changes as if `this` comes before
    `other`, otherwise (the default) treat `other` as coming first.
    
    Given two changes `A` and `B`, `A.compose(B.map(A))` and
    `B.compose(A.map(B, true))` will produce the same document. This
    provides a basic form of [operational
    transformation](https://en.wikipedia.org/wiki/Operational_transformation),
    and can be used for collaborative editing.
    */
    map(other, before = false) { return other.empty ? this : mapSet(this, other, before, true); }
    /**
    Iterate over the changed ranges in the document, calling `f` for
    each.
    
    When `individual` is true, adjacent changes are reported
    separately.
    */
    iterChanges(f, individual = false) {
        iterChanges(this, f, individual);
    }
    /**
    Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
    set.
    */
    get desc() { return new ChangeDesc(this.sections); }
    /**
    @internal
    */
    filter(ranges) {
        let resultSections = [], resultInserted = [], filteredSections = [];
        let iter = new SectionIter(this);
        done: for (let i = 0, pos = 0;;) {
            let next = i == ranges.length ? 1e9 : ranges[i++];
            while (pos < next || pos == next && iter.len == 0) {
                if (iter.done)
                    break done;
                let len = Math.min(iter.len, next - pos);
                addSection(filteredSections, len, -1);
                let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;
                addSection(resultSections, len, ins);
                if (ins > 0)
                    addInsert(resultInserted, resultSections, iter.text);
                iter.forward(len);
                pos += len;
            }
            let end = ranges[i++];
            while (pos < end) {
                if (iter.done)
                    break done;
                let len = Math.min(iter.len, end - pos);
                addSection(resultSections, len, -1);
                addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);
                iter.forward(len);
                pos += len;
            }
        }
        return { changes: new ChangeSet(resultSections, resultInserted),
            filtered: new ChangeDesc(filteredSections) };
    }
    /**
    Serialize this change set to a JSON-representable value.
    */
    toJSON() {
        let parts = [];
        for (let i = 0; i < this.sections.length; i += 2) {
            let len = this.sections[i], ins = this.sections[i + 1];
            if (ins < 0)
                parts.push(len);
            else if (ins == 0)
                parts.push([len]);
            else
                parts.push([len].concat(this.inserted[i >> 1].toJSON()));
        }
        return parts;
    }
    /**
    Create a change set for the given changes, for a document of the
    given length, using `lineSep` as line separator.
    */
    static of(changes, length, lineSep) {
        let sections = [], inserted = [], pos = 0;
        let total = null;
        function flush(force = false) {
            if (!force && !sections.length)
                return;
            if (pos < length)
                addSection(sections, length - pos, -1);
            let set = new ChangeSet(sections, inserted);
            total = total ? total.compose(set.map(total)) : set;
            sections = [];
            inserted = [];
            pos = 0;
        }
        function process(spec) {
            if (Array.isArray(spec)) {
                for (let sub of spec)
                    process(sub);
            }
            else if (spec instanceof ChangeSet) {
                if (spec.length != length)
                    throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);
                flush();
                total = total ? total.compose(spec.map(total)) : spec;
            }
            else {
                let { from, to = from, insert } = spec;
                if (from > to || from < 0 || to > length)
                    throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length})`);
                let insText = !insert ? text.Text.empty : typeof insert == "string" ? text.Text.of(insert.split(lineSep || DefaultSplit)) : insert;
                let insLen = insText.length;
                if (from == to && insLen == 0)
                    return;
                if (from < pos)
                    flush();
                if (from > pos)
                    addSection(sections, from - pos, -1);
                addSection(sections, to - from, insLen);
                addInsert(inserted, sections, insText);
                pos = to;
            }
        }
        process(changes);
        flush(!total);
        return total;
    }
    /**
    Create an empty changeset of the given length.
    */
    static empty(length) {
        return new ChangeSet(length ? [length, -1] : [], []);
    }
    /**
    Create a changeset from its JSON representation (as produced by
    [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
    */
    static fromJSON(json) {
        if (!Array.isArray(json))
            throw new RangeError("Invalid JSON representation of ChangeSet");
        let sections = [], inserted = [];
        for (let i = 0; i < json.length; i++) {
            let part = json[i];
            if (typeof part == "number") {
                sections.push(part, -1);
            }
            else if (!Array.isArray(part) || typeof part[0] != "number" || part.some((e, i) => i && typeof e != "string")) {
                throw new RangeError("Invalid JSON representation of ChangeSet");
            }
            else if (part.length == 1) {
                sections.push(part[0], 0);
            }
            else {
                while (inserted.length < i)
                    inserted.push(text.Text.empty);
                inserted[i] = text.Text.of(part.slice(1));
                sections.push(part[0], inserted[i].length);
            }
        }
        return new ChangeSet(sections, inserted);
    }
}
function addSection(sections, len, ins, forceJoin = false) {
    if (len == 0 && ins <= 0)
        return;
    let last = sections.length - 2;
    if (last >= 0 && ins <= 0 && ins == sections[last + 1])
        sections[last] += len;
    else if (len == 0 && sections[last] == 0)
        sections[last + 1] += ins;
    else if (forceJoin) {
        sections[last] += len;
        sections[last + 1] += ins;
    }
    else
        sections.push(len, ins);
}
function addInsert(values, sections, value) {
    if (value.length == 0)
        return;
    let index = (sections.length - 2) >> 1;
    if (index < values.length) {
        values[values.length - 1] = values[values.length - 1].append(value);
    }
    else {
        while (values.length < index)
            values.push(text.Text.empty);
        values.push(value);
    }
}
function iterChanges(desc, f, individual) {
    let inserted = desc.inserted;
    for (let posA = 0, posB = 0, i = 0; i < desc.sections.length;) {
        let len = desc.sections[i++], ins = desc.sections[i++];
        if (ins < 0) {
            posA += len;
            posB += len;
        }
        else {
            let endA = posA, endB = posB, text$1 = text.Text.empty;
            for (;;) {
                endA += len;
                endB += ins;
                if (ins && inserted)
                    text$1 = text$1.append(inserted[(i - 2) >> 1]);
                if (individual || i == desc.sections.length || desc.sections[i + 1] < 0)
                    break;
                len = desc.sections[i++];
                ins = desc.sections[i++];
            }
            f(posA, endA, posB, endB, text$1);
            posA = endA;
            posB = endB;
        }
    }
}
function mapSet(setA, setB, before, mkSet = false) {
    let sections = [], insert = mkSet ? [] : null;
    let a = new SectionIter(setA), b = new SectionIter(setB);
    for (let posA = 0, posB = 0;;) {
        if (a.ins == -1) {
            posA += a.len;
            a.next();
        }
        else if (b.ins == -1 && posB < posA) {
            let skip = Math.min(b.len, posA - posB);
            b.forward(skip);
            addSection(sections, skip, -1);
            posB += skip;
        }
        else if (b.ins >= 0 && (a.done || posB < posA || posB == posA && (b.len < a.len || b.len == a.len && !before))) {
            addSection(sections, b.ins, -1);
            while (posA > posB && !a.done && posA + a.len < posB + b.len) {
                posA += a.len;
                a.next();
            }
            posB += b.len;
            b.next();
        }
        else if (a.ins >= 0) {
            let len = 0, end = posA + a.len;
            for (;;) {
                if (b.ins >= 0 && posB > posA && posB + b.len < end) {
                    len += b.ins;
                    posB += b.len;
                    b.next();
                }
                else if (b.ins == -1 && posB < end) {
                    let skip = Math.min(b.len, end - posB);
                    len += skip;
                    b.forward(skip);
                    posB += skip;
                }
                else {
                    break;
                }
            }
            addSection(sections, len, a.ins);
            if (insert)
                addInsert(insert, sections, a.text);
            posA = end;
            a.next();
        }
        else if (a.done && b.done) {
            return insert ? new ChangeSet(sections, insert) : new ChangeDesc(sections);
        }
        else {
            throw new Error("Mismatched change set lengths");
        }
    }
}
function composeSets(setA, setB, mkSet = false) {
    let sections = [];
    let insert = mkSet ? [] : null;
    let a = new SectionIter(setA), b = new SectionIter(setB);
    for (let open = false;;) {
        if (a.done && b.done) {
            return insert ? new ChangeSet(sections, insert) : new ChangeDesc(sections);
        }
        else if (a.ins == 0) { // Deletion in A
            addSection(sections, a.len, 0, open);
            a.next();
        }
        else if (b.len == 0 && !b.done) { // Insertion in B
            addSection(sections, 0, b.ins, open);
            if (insert)
                addInsert(insert, sections, b.text);
            b.next();
        }
        else if (a.done || b.done) {
            throw new Error("Mismatched change set lengths");
        }
        else {
            let len = Math.min(a.len2, b.len), sectionLen = sections.length;
            if (a.ins == -1) {
                let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;
                addSection(sections, len, insB, open);
                if (insert && insB)
                    addInsert(insert, sections, b.text);
            }
            else if (b.ins == -1) {
                addSection(sections, a.off ? 0 : a.len, len, open);
                if (insert)
                    addInsert(insert, sections, a.textBit(len));
            }
            else {
                addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);
                if (insert && !b.off)
                    addInsert(insert, sections, b.text);
            }
            open = (a.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);
            a.forward2(len);
            b.forward(len);
        }
    }
}
class SectionIter {
    constructor(set) {
        this.set = set;
        this.i = 0;
        this.next();
    }
    next() {
        let { sections } = this.set;
        if (this.i < sections.length) {
            this.len = sections[this.i++];
            this.ins = sections[this.i++];
        }
        else {
            this.len = 0;
            this.ins = -2;
        }
        this.off = 0;
    }
    get done() { return this.ins == -2; }
    get len2() { return this.ins < 0 ? this.len : this.ins; }
    get text() {
        let { inserted } = this.set, index = (this.i - 2) >> 1;
        return index >= inserted.length ? text.Text.empty : inserted[index];
    }
    textBit(len) {
        let { inserted } = this.set, index = (this.i - 2) >> 1;
        return index >= inserted.length && !len ? text.Text.empty
            : inserted[index].slice(this.off, len == null ? undefined : this.off + len);
    }
    forward(len) {
        if (len == this.len)
            this.next();
        else {
            this.len -= len;
            this.off += len;
        }
    }
    forward2(len) {
        if (this.ins == -1)
            this.forward(len);
        else if (len == this.ins)
            this.next();
        else {
            this.ins -= len;
            this.off += len;
        }
    }
}

/**
A single selection range. When
[`allowMultipleSelections`](https://codemirror.net/6/docs/ref/#state.EditorState^allowMultipleSelections)
is enabled, a [selection](https://codemirror.net/6/docs/ref/#state.EditorSelection) may hold
multiple ranges. By default, selections hold exactly one range.
*/
class SelectionRange {
    /**
    @internal
    */
    constructor(
    /**
    The lower boundary of the range.
    */
    from, 
    /**
    The upper boundary of the range.
    */
    to, flags) {
        this.from = from;
        this.to = to;
        this.flags = flags;
    }
    /**
    The anchor of the range‚Äîthe side that doesn't move when you
    extend it.
    */
    get anchor() { return this.flags & 16 /* Inverted */ ? this.to : this.from; }
    /**
    The head of the range, which is moved when the range is
    [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
    */
    get head() { return this.flags & 16 /* Inverted */ ? this.from : this.to; }
    /**
    True when `anchor` and `head` are at the same position.
    */
    get empty() { return this.from == this.to; }
    /**
    If this is a cursor that is explicitly associated with the
    character on one of its sides, this returns the side. -1 means
    the character before its position, 1 the character after, and 0
    means no association.
    */
    get assoc() { return this.flags & 4 /* AssocBefore */ ? -1 : this.flags & 8 /* AssocAfter */ ? 1 : 0; }
    /**
    The bidirectional text level associated with this cursor, if
    any.
    */
    get bidiLevel() {
        let level = this.flags & 3 /* BidiLevelMask */;
        return level == 3 ? null : level;
    }
    /**
    The goal column (stored vertical offset) associated with a
    cursor. This is used to preserve the vertical position when
    [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
    lines of different length.
    */
    get goalColumn() {
        let value = this.flags >> 5 /* GoalColumnOffset */;
        return value == 33554431 /* NoGoalColumn */ ? undefined : value;
    }
    /**
    Map this range through a change, producing a valid range in the
    updated document.
    */
    map(change, assoc = -1) {
        let from = change.mapPos(this.from, assoc), to = change.mapPos(this.to, assoc);
        return from == this.from && to == this.to ? this : new SelectionRange(from, to, this.flags);
    }
    /**
    Extend this range to cover at least `from` to `to`.
    */
    extend(from, to = from) {
        if (from <= this.anchor && to >= this.anchor)
            return EditorSelection.range(from, to);
        let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;
        return EditorSelection.range(this.anchor, head);
    }
    /**
    Compare this range to another range.
    */
    eq(other) {
        return this.anchor == other.anchor && this.head == other.head;
    }
    /**
    Return a JSON-serializable object representing the range.
    */
    toJSON() { return { anchor: this.anchor, head: this.head }; }
    /**
    Convert a JSON representation of a range to a `SelectionRange`
    instance.
    */
    static fromJSON(json) {
        if (!json || typeof json.anchor != "number" || typeof json.head != "number")
            throw new RangeError("Invalid JSON representation for SelectionRange");
        return EditorSelection.range(json.anchor, json.head);
    }
}
/**
An editor selection holds one or more selection ranges.
*/
class EditorSelection {
    /**
    @internal
    */
    constructor(
    /**
    The ranges in the selection, sorted by position. Ranges cannot
    overlap (but they may touch, if they aren't empty).
    */
    ranges, 
    /**
    The index of the _main_ range in the selection (which is
    usually the range that was added last).
    */
    mainIndex = 0) {
        this.ranges = ranges;
        this.mainIndex = mainIndex;
    }
    /**
    Map a selection through a change. Used to adjust the selection
    position for changes.
    */
    map(change, assoc = -1) {
        if (change.empty)
            return this;
        return EditorSelection.create(this.ranges.map(r => r.map(change, assoc)), this.mainIndex);
    }
    /**
    Compare this selection to another selection.
    */
    eq(other) {
        if (this.ranges.length != other.ranges.length ||
            this.mainIndex != other.mainIndex)
            return false;
        for (let i = 0; i < this.ranges.length; i++)
            if (!this.ranges[i].eq(other.ranges[i]))
                return false;
        return true;
    }
    /**
    Get the primary selection range. Usually, you should make sure
    your code applies to _all_ ranges, by using methods like
    [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
    */
    get main() { return this.ranges[this.mainIndex]; }
    /**
    Make sure the selection only has one range. Returns a selection
    holding only the main range from this selection.
    */
    asSingle() {
        return this.ranges.length == 1 ? this : new EditorSelection([this.main]);
    }
    /**
    Extend this selection with an extra range.
    */
    addRange(range, main = true) {
        return EditorSelection.create([range].concat(this.ranges), main ? 0 : this.mainIndex + 1);
    }
    /**
    Replace a given range with another range, and then normalize the
    selection to merge and sort ranges if necessary.
    */
    replaceRange(range, which = this.mainIndex) {
        let ranges = this.ranges.slice();
        ranges[which] = range;
        return EditorSelection.create(ranges, this.mainIndex);
    }
    /**
    Convert this selection to an object that can be serialized to
    JSON.
    */
    toJSON() {
        return { ranges: this.ranges.map(r => r.toJSON()), main: this.mainIndex };
    }
    /**
    Create a selection from a JSON representation.
    */
    static fromJSON(json) {
        if (!json || !Array.isArray(json.ranges) || typeof json.main != "number" || json.main >= json.ranges.length)
            throw new RangeError("Invalid JSON representation for EditorSelection");
        return new EditorSelection(json.ranges.map((r) => SelectionRange.fromJSON(r)), json.main);
    }
    /**
    Create a selection holding a single range.
    */
    static single(anchor, head = anchor) {
        return new EditorSelection([EditorSelection.range(anchor, head)], 0);
    }
    /**
    Sort and merge the given set of ranges, creating a valid
    selection.
    */
    static create(ranges, mainIndex = 0) {
        if (ranges.length == 0)
            throw new RangeError("A selection needs at least one range");
        for (let pos = 0, i = 0; i < ranges.length; i++) {
            let range = ranges[i];
            if (range.empty ? range.from <= pos : range.from < pos)
                return normalized(ranges.slice(), mainIndex);
            pos = range.to;
        }
        return new EditorSelection(ranges, mainIndex);
    }
    /**
    Create a cursor selection range at the given position. You can
    safely ignore the optional arguments in most situations.
    */
    static cursor(pos, assoc = 0, bidiLevel, goalColumn) {
        return new SelectionRange(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 4 /* AssocBefore */ : 8 /* AssocAfter */) |
            (bidiLevel == null ? 3 : Math.min(2, bidiLevel)) |
            ((goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431 /* NoGoalColumn */) << 5 /* GoalColumnOffset */));
    }
    /**
    Create a selection range.
    */
    static range(anchor, head, goalColumn) {
        let goal = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431 /* NoGoalColumn */) << 5 /* GoalColumnOffset */;
        return head < anchor ? new SelectionRange(head, anchor, 16 /* Inverted */ | goal) : new SelectionRange(anchor, head, goal);
    }
}
function normalized(ranges, mainIndex = 0) {
    let main = ranges[mainIndex];
    ranges.sort((a, b) => a.from - b.from);
    mainIndex = ranges.indexOf(main);
    for (let i = 1; i < ranges.length; i++) {
        let range = ranges[i], prev = ranges[i - 1];
        if (range.empty ? range.from <= prev.to : range.from < prev.to) {
            let from = prev.from, to = Math.max(range.to, prev.to);
            if (i <= mainIndex)
                mainIndex--;
            ranges.splice(--i, 2, range.anchor > range.head ? EditorSelection.range(to, from) : EditorSelection.range(from, to));
        }
    }
    return new EditorSelection(ranges, mainIndex);
}
function checkSelection(selection, docLength) {
    for (let range of selection.ranges)
        if (range.to > docLength)
            throw new RangeError("Selection points outside of document");
}

let nextID = 0;
/**
A facet is a labeled value that is associated with an editor
state. It takes inputs from any number of extensions, and combines
those into a single output value.

Examples of facets are the [theme](https://codemirror.net/6/docs/ref/#view.EditorView^theme) styles
associated with an editor or the [tab
size](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) (which is reduced to a single
value, using the input with the hightest precedence).
*/
class Facet {
    constructor(
    /**
    @internal
    */
    combine, 
    /**
    @internal
    */
    compareInput, 
    /**
    @internal
    */
    compare, isStatic, 
    /**
    @internal
    */
    extensions) {
        this.combine = combine;
        this.compareInput = compareInput;
        this.compare = compare;
        this.isStatic = isStatic;
        this.extensions = extensions;
        /**
        @internal
        */
        this.id = nextID++;
        this.default = combine([]);
    }
    /**
    Define a new facet.
    */
    static define(config = {}) {
        return new Facet(config.combine || ((a) => a), config.compareInput || ((a, b) => a === b), config.compare || (!config.combine ? sameArray : (a, b) => a === b), !!config.static, config.enables);
    }
    /**
    Returns an extension that adds the given value for this facet.
    */
    of(value) {
        return new FacetProvider([], this, 0 /* Static */, value);
    }
    /**
    Create an extension that computes a value for the facet from a
    state. You must take care to declare the parts of the state that
    this value depends on, since your function is only called again
    for a new state when one of those parts changed.
    
    In most cases, you'll want to use the
    [`provide`](https://codemirror.net/6/docs/ref/#state.StateField^define^config.provide) option when
    defining a field instead.
    */
    compute(deps, get) {
        if (this.isStatic)
            throw new Error("Can't compute a static facet");
        return new FacetProvider(deps, this, 1 /* Single */, get);
    }
    /**
    Create an extension that computes zero or more values for this
    facet from a state.
    */
    computeN(deps, get) {
        if (this.isStatic)
            throw new Error("Can't compute a static facet");
        return new FacetProvider(deps, this, 2 /* Multi */, get);
    }
    from(field, get) {
        if (!get)
            get = x => x;
        return this.compute([field], state => get(state.field(field)));
    }
}
function sameArray(a, b) {
    return a == b || a.length == b.length && a.every((e, i) => e === b[i]);
}
class FacetProvider {
    constructor(dependencies, facet, type, value) {
        this.dependencies = dependencies;
        this.facet = facet;
        this.type = type;
        this.value = value;
        this.id = nextID++;
    }
    dynamicSlot(addresses) {
        var _a;
        let getter = this.value;
        let compare = this.facet.compareInput;
        let idx = addresses[this.id] >> 1, multi = this.type == 2 /* Multi */;
        let depDoc = false, depSel = false, depAddrs = [];
        for (let dep of this.dependencies) {
            if (dep == "doc")
                depDoc = true;
            else if (dep == "selection")
                depSel = true;
            else if ((((_a = addresses[dep.id]) !== null && _a !== void 0 ? _a : 1) & 1) == 0)
                depAddrs.push(addresses[dep.id]);
        }
        return (state, tr) => {
            if (!tr || tr.reconfigured) {
                state.values[idx] = getter(state);
                return 1 /* Changed */;
            }
            else {
                let depChanged = (depDoc && tr.docChanged) || (depSel && (tr.docChanged || tr.selection)) ||
                    depAddrs.some(addr => (ensureAddr(state, addr) & 1 /* Changed */) > 0);
                if (!depChanged)
                    return 0;
                let newVal = getter(state), oldVal = tr.startState.values[idx];
                if (multi ? compareArray(newVal, oldVal, compare) : compare(newVal, oldVal))
                    return 0;
                state.values[idx] = newVal;
                return 1 /* Changed */;
            }
        };
    }
}
function compareArray(a, b, compare) {
    if (a.length != b.length)
        return false;
    for (let i = 0; i < a.length; i++)
        if (!compare(a[i], b[i]))
            return false;
    return true;
}
function dynamicFacetSlot(addresses, facet, providers) {
    let providerAddrs = providers.map(p => addresses[p.id]);
    let providerTypes = providers.map(p => p.type);
    let dynamic = providerAddrs.filter(p => !(p & 1));
    let idx = addresses[facet.id] >> 1;
    return (state, tr) => {
        let oldAddr = !tr ? null : tr.reconfigured ? tr.startState.config.address[facet.id] : idx << 1;
        let changed = oldAddr == null;
        for (let dynAddr of dynamic) {
            if (ensureAddr(state, dynAddr) & 1 /* Changed */)
                changed = true;
        }
        if (!changed)
            return 0;
        let values = [];
        for (let i = 0; i < providerAddrs.length; i++) {
            let value = getAddr(state, providerAddrs[i]);
            if (providerTypes[i] == 2 /* Multi */)
                for (let val of value)
                    values.push(val);
            else
                values.push(value);
        }
        let newVal = facet.combine(values);
        if (oldAddr != null && facet.compare(newVal, getAddr(tr.startState, oldAddr)))
            return 0;
        state.values[idx] = newVal;
        return 1 /* Changed */;
    };
}
function maybeIndex(state, id) {
    let found = state.config.address[id];
    return found == null ? null : found >> 1;
}
const initField = Facet.define({ static: true });
/**
Fields can store additional information in an editor state, and
keep it in sync with the rest of the state.
*/
class StateField {
    constructor(
    /**
    @internal
    */
    id, createF, updateF, compareF, 
    /**
    @internal
    */
    spec) {
        this.id = id;
        this.createF = createF;
        this.updateF = updateF;
        this.compareF = compareF;
        this.spec = spec;
        /**
        @internal
        */
        this.provides = undefined;
    }
    /**
    Define a state field.
    */
    static define(config) {
        let field = new StateField(nextID++, config.create, config.update, config.compare || ((a, b) => a === b), config);
        if (config.provide)
            field.provides = config.provide(field);
        return field;
    }
    create(state) {
        let init = state.facet(initField).find(i => i.field == this);
        return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);
    }
    /**
    @internal
    */
    slot(addresses) {
        let idx = addresses[this.id] >> 1;
        return (state, tr) => {
            if (!tr) {
                state.values[idx] = this.create(state);
                return 1 /* Changed */;
            }
            let oldVal, changed = 0;
            if (tr.reconfigured) {
                let oldIdx = maybeIndex(tr.startState, this.id);
                oldVal = oldIdx == null ? this.create(tr.startState) : tr.startState.values[oldIdx];
                changed = 1 /* Changed */;
            }
            else {
                oldVal = tr.startState.values[idx];
            }
            let value = this.updateF(oldVal, tr);
            if (!changed && !this.compareF(oldVal, value))
                changed = 1 /* Changed */;
            if (changed)
                state.values[idx] = value;
            return changed;
        };
    }
    /**
    Returns an extension that enables this field and overrides the
    way it is initialized. Can be useful when you need to provide a
    non-default starting value for the field.
    */
    init(create) {
        return [this, initField.of({ field: this, create })];
    }
    /**
    State field instances can be used as
    [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
    given state.
    */
    get extension() { return this; }
}
const Prec_ = { fallback: 3, default: 2, extend: 1, override: 0 };
function prec(value) {
    return (ext) => new PrecExtension(ext, value);
}
/**
By default extensions are registered in the order they are found
in the flattened form of nested array that was provided.
Individual extension values can be assigned a precedence to
override this. Extensions that do not have a precedence set get
the precedence of the nearest parent with a precedence, or
[`default`](https://codemirror.net/6/docs/ref/#state.Prec.default) if there is no such parent. The
final ordering of extensions is determined by first sorting by
precedence and then by order within each precedence.
*/
const Prec = {
    /**
    A precedence below the default precedence, which will cause
    default-precedence extensions to override it even if they are
    specified later in the extension ordering.
    */
    fallback: prec(Prec_.fallback),
    /**
    The regular default precedence.
    */
    default: prec(Prec_.default),
    /**
    A higher-than-default precedence.
    */
    extend: prec(Prec_.extend),
    /**
    Precedence above the `default` and `extend` precedences.
    */
    override: prec(Prec_.override)
};
class PrecExtension {
    constructor(inner, prec) {
        this.inner = inner;
        this.prec = prec;
    }
}
/**
Extension compartments can be used to make a configuration
dynamic. By [wrapping](https://codemirror.net/6/docs/ref/#state.Compartment.of) part of your
configuration in a compartment, you can later
[replace](https://codemirror.net/6/docs/ref/#state.Compartment.reconfigure) that part through a
transaction.
*/
class Compartment {
    /**
    Create an instance of this compartment to add to your [state
    configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
    */
    of(ext) { return new CompartmentInstance(this, ext); }
    /**
    Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
    reconfigures this compartment.
    */
    reconfigure(content) {
        return Compartment.reconfigure.of({ compartment: this, extension: content });
    }
    /**
    Get the current content of the compartment in the state, or
    `undefined` if it isn't present.
    */
    get(state) {
        return state.config.compartments.get(this);
    }
}
class CompartmentInstance {
    constructor(compartment, inner) {
        this.compartment = compartment;
        this.inner = inner;
    }
}
class Configuration {
    constructor(base, compartments, dynamicSlots, address, staticValues) {
        this.base = base;
        this.compartments = compartments;
        this.dynamicSlots = dynamicSlots;
        this.address = address;
        this.staticValues = staticValues;
        this.statusTemplate = [];
        while (this.statusTemplate.length < dynamicSlots.length)
            this.statusTemplate.push(0 /* Uninitialized */);
    }
    staticFacet(facet) {
        let addr = this.address[facet.id];
        return addr == null ? facet.default : this.staticValues[addr >> 1];
    }
    static resolve(base, compartments, oldState) {
        let fields = [];
        let facets = Object.create(null);
        let newCompartments = new Map();
        for (let ext of flatten(base, compartments, newCompartments)) {
            if (ext instanceof StateField)
                fields.push(ext);
            else
                (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);
        }
        let address = Object.create(null);
        let staticValues = [];
        let dynamicSlots = [];
        for (let field of fields) {
            address[field.id] = dynamicSlots.length << 1;
            dynamicSlots.push(a => field.slot(a));
        }
        for (let id in facets) {
            let providers = facets[id], facet = providers[0].facet;
            if (providers.every(p => p.type == 0 /* Static */)) {
                address[facet.id] = (staticValues.length << 1) | 1;
                let value = facet.combine(providers.map(p => p.value));
                let oldAddr = oldState ? oldState.config.address[facet.id] : null;
                if (oldAddr != null) {
                    let oldVal = getAddr(oldState, oldAddr);
                    if (facet.compare(value, oldVal))
                        value = oldVal;
                }
                staticValues.push(value);
            }
            else {
                for (let p of providers) {
                    if (p.type == 0 /* Static */) {
                        address[p.id] = (staticValues.length << 1) | 1;
                        staticValues.push(p.value);
                    }
                    else {
                        address[p.id] = dynamicSlots.length << 1;
                        dynamicSlots.push(a => p.dynamicSlot(a));
                    }
                }
                address[facet.id] = dynamicSlots.length << 1;
                dynamicSlots.push(a => dynamicFacetSlot(a, facet, providers));
            }
        }
        return new Configuration(base, newCompartments, dynamicSlots.map(f => f(address)), address, staticValues);
    }
}
function flatten(extension, compartments, newCompartments) {
    let result = [[], [], [], []];
    let seen = new Map();
    function inner(ext, prec) {
        let known = seen.get(ext);
        if (known != null) {
            if (known >= prec)
                return;
            let found = result[known].indexOf(ext);
            if (found > -1)
                result[known].splice(found, 1);
            if (ext instanceof CompartmentInstance)
                newCompartments.delete(ext.compartment);
        }
        seen.set(ext, prec);
        if (Array.isArray(ext)) {
            for (let e of ext)
                inner(e, prec);
        }
        else if (ext instanceof CompartmentInstance) {
            if (newCompartments.has(ext.compartment))
                throw new RangeError(`Duplicate use of compartment in extensions`);
            let content = compartments.get(ext.compartment) || ext.inner;
            newCompartments.set(ext.compartment, content);
            inner(content, prec);
        }
        else if (ext instanceof PrecExtension) {
            inner(ext.inner, ext.prec);
        }
        else if (ext instanceof StateField) {
            result[prec].push(ext);
            if (ext.provides)
                inner(ext.provides, prec);
        }
        else if (ext instanceof FacetProvider) {
            result[prec].push(ext);
            if (ext.facet.extensions)
                inner(ext.facet.extensions, prec);
        }
        else {
            let content = ext.extension;
            if (!content)
                throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
            inner(content, prec);
        }
    }
    inner(extension, Prec_.default);
    return result.reduce((a, b) => a.concat(b));
}
function ensureAddr(state, addr) {
    if (addr & 1)
        return 2 /* Computed */;
    let idx = addr >> 1;
    let status = state.status[idx];
    if (status == 4 /* Computing */)
        throw new Error("Cyclic dependency between fields and/or facets");
    if (status & 2 /* Computed */)
        return status;
    state.status[idx] = 4 /* Computing */;
    let changed = state.config.dynamicSlots[idx](state, state.applying);
    return state.status[idx] = 2 /* Computed */ | changed;
}
function getAddr(state, addr) {
    return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];
}

const languageData = Facet.define();
const allowMultipleSelections = Facet.define({
    combine: values => values.some(v => v),
    static: true
});
const lineSeparator = Facet.define({
    combine: values => values.length ? values[0] : undefined,
    static: true
});
const changeFilter = Facet.define();
const transactionFilter = Facet.define();
const transactionExtender = Facet.define();

/**
Annotations are tagged values that are used to add metadata to
transactions in an extensible way. They should be used to model
things that effect the entire transaction (such as its [time
stamp](https://codemirror.net/6/docs/ref/#state.Transaction^time) or information about its
[origin](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent)). For effects that happen
_alongside_ the other changes made by the transaction, [state
effects](https://codemirror.net/6/docs/ref/#state.StateEffect) are more appropriate.
*/
class Annotation {
    /**
    @internal
    */
    constructor(
    /**
    The annotation type.
    */
    type, 
    /**
    The value of this annotation.
    */
    value) {
        this.type = type;
        this.value = value;
    }
    /**
    Define a new type of annotation.
    */
    static define() { return new AnnotationType(); }
}
/**
Marker that identifies a type of [annotation](https://codemirror.net/6/docs/ref/#state.Annotation).
*/
class AnnotationType {
    /**
    Create an instance of this annotation.
    */
    of(value) { return new Annotation(this, value); }
}
/**
Representation of a type of state effect. Defined with
[`StateEffect.define`](https://codemirror.net/6/docs/ref/#state.StateEffect^define).
*/
class StateEffectType {
    /**
    @internal
    */
    constructor(
    // The `any` types in these function types are there to work
    // around TypeScript issue #37631, where the type guard on
    // `StateEffect.is` mysteriously stops working when these properly
    // have type `Value`.
    /**
    @internal
    */
    map) {
        this.map = map;
    }
    /**
    Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
    type.
    */
    of(value) { return new StateEffect(this, value); }
}
/**
State effects can be used to represent additional effects
associated with a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction.effects). They
are often useful to model changes to custom [state
fields](https://codemirror.net/6/docs/ref/#state.StateField), when those changes aren't implicit in
document or selection changes.
*/
class StateEffect {
    /**
    @internal
    */
    constructor(
    /**
    @internal
    */
    type, 
    /**
    The value of this effect.
    */
    value) {
        this.type = type;
        this.value = value;
    }
    /**
    Map this effect through a position mapping. Will return
    `undefined` when that ends up deleting the effect.
    */
    map(mapping) {
        let mapped = this.type.map(this.value, mapping);
        return mapped === undefined ? undefined : mapped == this.value ? this : new StateEffect(this.type, mapped);
    }
    /**
    Tells you whether this effect object is of a given
    [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
    */
    is(type) { return this.type == type; }
    /**
    Define a new effect type. The type parameter indicates the type
    of values that his effect holds.
    */
    static define(spec = {}) {
        return new StateEffectType(spec.map || (v => v));
    }
    /**
    Map an array of effects through a change set.
    */
    static mapEffects(effects, mapping) {
        if (!effects.length)
            return effects;
        let result = [];
        for (let effect of effects) {
            let mapped = effect.map(mapping);
            if (mapped)
                result.push(mapped);
        }
        return result;
    }
}
/**
This effect can be used to reconfigure the root extensions of
the editor. Doing this will discard any extensions
[appended](https://codemirror.net/6/docs/ref/#state.StateEffect^appendConfig), but does not reset
the content of [reconfigured](https://codemirror.net/6/docs/ref/#state.Compartment.reconfigure)
compartments.
*/
StateEffect.reconfigure = StateEffect.define();
/**
Append extensions to the top-level configuration of the editor.
*/
StateEffect.appendConfig = StateEffect.define();
/**
Changes to the editor state are grouped into transactions.
Typically, a user action creates a single transaction, which may
contain any number of document changes, may change the selection,
or have other effects. Create a transaction by calling
[`EditorState.update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
*/
class Transaction {
    /**
    @internal
    */
    constructor(
    /**
    The state from which the transaction starts.
    */
    startState, 
    /**
    The document changes made by this transaction.
    */
    changes, 
    /**
    The selection set by this transaction, or undefined if it
    doesn't explicitly set a selection.
    */
    selection, 
    /**
    The effects added to the transaction.
    */
    effects, 
    /**
    @internal
    */
    annotations, 
    /**
    Whether the selection should be scrolled into view after this
    transaction is dispatched.
    */
    scrollIntoView) {
        this.startState = startState;
        this.changes = changes;
        this.selection = selection;
        this.effects = effects;
        this.annotations = annotations;
        this.scrollIntoView = scrollIntoView;
        /**
        @internal
        */
        this._doc = null;
        /**
        @internal
        */
        this._state = null;
        if (selection)
            checkSelection(selection, changes.newLength);
        if (!annotations.some((a) => a.type == Transaction.time))
            this.annotations = annotations.concat(Transaction.time.of(Date.now()));
    }
    /**
    The new document produced by the transaction. Contrary to
    [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
    force the entire new state to be computed right away, so it is
    recommended that [transaction
    filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
    when they need to look at the new document.
    */
    get newDoc() {
        return this._doc || (this._doc = this.changes.apply(this.startState.doc));
    }
    /**
    The new selection produced by the transaction. If
    [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
    this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
    current selection through the changes made by the transaction.
    */
    get newSelection() {
        return this.selection || this.startState.selection.map(this.changes);
    }
    /**
    The new state created by the transaction. Computed on demand
    (but retained for subsequent access), so itis recommended not to
    access it in [transaction
    filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
    */
    get state() {
        if (!this._state)
            this.startState.applyTransaction(this);
        return this._state;
    }
    /**
    Get the value of the given annotation type, if any.
    */
    annotation(type) {
        for (let ann of this.annotations)
            if (ann.type == type)
                return ann.value;
        return undefined;
    }
    /**
    Indicates whether the transaction changed the document.
    */
    get docChanged() { return !this.changes.empty; }
    /**
    Indicates whether this transaction reconfigures the state
    (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
    with a top-level configuration
    [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
    */
    get reconfigured() { return this.startState.config != this.state.config; }
}
/**
Annotation used to store transaction timestamps.
*/
Transaction.time = Annotation.define();
/**
Annotation used to associate a transaction with a user interface
event. The view will set this to...

 - `"input"` when the user types text
 - `"delete"` when the user deletes the selection or text near the selection
 - `"keyboardselection"` when moving the selection via the keyboard
 - `"pointerselection"` when moving the selection through the pointing device
 - `"paste"` when pasting content
 - `"cut"` when cutting
 - `"drop"` when content is inserted via drag-and-drop
*/
Transaction.userEvent = Annotation.define();
/**
Annotation indicating whether a transaction should be added to
the undo history or not.
*/
Transaction.addToHistory = Annotation.define();
/**
Annotation indicating (when present and true) that a transaction
represents a change made by some other actor, not the user. This
is used, for example, to tag other people's changes in
collaborative editing.
*/
Transaction.remote = Annotation.define();
function joinRanges(a, b) {
    let result = [];
    for (let iA = 0, iB = 0;;) {
        let from, to;
        if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {
            from = a[iA++];
            to = a[iA++];
        }
        else if (iB < b.length) {
            from = b[iB++];
            to = b[iB++];
        }
        else
            return result;
        if (!result.length || result[result.length - 1] < from)
            result.push(from, to);
        else if (result[result.length - 1] < to)
            result[result.length - 1] = to;
    }
}
function mergeTransaction(a, b, sequential) {
    var _a;
    let mapForA, mapForB, changes;
    if (sequential) {
        mapForA = b.changes;
        mapForB = ChangeSet.empty(b.changes.length);
        changes = a.changes.compose(b.changes);
    }
    else {
        mapForA = b.changes.map(a.changes);
        mapForB = a.changes.mapDesc(b.changes, true);
        changes = a.changes.compose(mapForA);
    }
    return {
        changes,
        selection: b.selection ? b.selection.map(mapForB) : (_a = a.selection) === null || _a === void 0 ? void 0 : _a.map(mapForA),
        effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),
        annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,
        scrollIntoView: a.scrollIntoView || b.scrollIntoView
    };
}
function resolveTransactionInner(state, spec, docSize) {
    let sel = spec.selection;
    return {
        changes: spec.changes instanceof ChangeSet ? spec.changes
            : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),
        selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),
        effects: asArray(spec.effects),
        annotations: asArray(spec.annotations),
        scrollIntoView: !!spec.scrollIntoView
    };
}
function resolveTransaction(state, specs, filter) {
    let s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);
    if (specs.length && specs[0].filter === false)
        filter = false;
    for (let i = 1; i < specs.length; i++) {
        if (specs[i].filter === false)
            filter = false;
        let seq = !!specs[i].sequential;
        s = mergeTransaction(s, resolveTransactionInner(state, specs[i], seq ? s.changes.newLength : state.doc.length), seq);
    }
    let tr = new Transaction(state, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);
    return extendTransaction(filter ? filterTransaction(tr) : tr);
}
// Finish a transaction by applying filters if necessary.
function filterTransaction(tr) {
    let state = tr.startState;
    // Change filters
    let result = true;
    for (let filter of state.facet(changeFilter)) {
        let value = filter(tr);
        if (value === false) {
            result = false;
            break;
        }
        if (Array.isArray(value))
            result = result === true ? value : joinRanges(result, value);
    }
    if (result !== true) {
        let changes, back;
        if (result === false) {
            back = tr.changes.invertedDesc;
            changes = ChangeSet.empty(state.doc.length);
        }
        else {
            let filtered = tr.changes.filter(result);
            changes = filtered.changes;
            back = filtered.filtered.invertedDesc;
        }
        tr = new Transaction(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);
    }
    // Transaction filters
    let filters = state.facet(transactionFilter);
    for (let i = filters.length - 1; i >= 0; i--) {
        let filtered = filters[i](tr);
        if (filtered instanceof Transaction)
            tr = filtered;
        else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction)
            tr = filtered[0];
        else
            tr = resolveTransaction(state, asArray(filtered), false);
    }
    return tr;
}
function extendTransaction(tr) {
    let state = tr.startState, extenders = state.facet(transactionExtender), spec = tr;
    for (let i = extenders.length - 1; i >= 0; i--) {
        let extension = extenders[i](tr);
        if (extension && Object.keys(extension).length)
            spec = mergeTransaction(tr, resolveTransactionInner(state, extension, tr.changes.newLength), true);
    }
    return spec == tr ? tr : new Transaction(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);
}
const none = [];
function asArray(value) {
    return value == null ? none : Array.isArray(value) ? value : [value];
}

/**
The categories produced by a [character
categorizer](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer). These are used
do things like selecting by word.
*/
exports.CharCategory = void 0;
(function (CharCategory) {
    /**
    Word characters.
    */
    CharCategory[CharCategory["Word"] = 0] = "Word";
    /**
    Whitespace.
    */
    CharCategory[CharCategory["Space"] = 1] = "Space";
    /**
    Anything else.
    */
    CharCategory[CharCategory["Other"] = 2] = "Other";
})(exports.CharCategory || (exports.CharCategory = {}));
const nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let wordChar;
try {
    wordChar = new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
}
catch (_) { }
function hasWordChar(str) {
    if (wordChar)
        return wordChar.test(str);
    for (let i = 0; i < str.length; i++) {
        let ch = str[i];
        if (/\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch)))
            return true;
    }
    return false;
}
function makeCategorizer(wordChars) {
    return (char) => {
        if (!/\S/.test(char))
            return exports.CharCategory.Space;
        if (hasWordChar(char))
            return exports.CharCategory.Word;
        for (let i = 0; i < wordChars.length; i++)
            if (char.indexOf(wordChars[i]) > -1)
                return exports.CharCategory.Word;
        return exports.CharCategory.Other;
    };
}

/**
The editor state class is a persistent (immutable) data structure.
To update a state, you [create](https://codemirror.net/6/docs/ref/#state.EditorState.update) a
[transaction](https://codemirror.net/6/docs/ref/#state.Transaction), which produces a _new_ state
instance, without modifying the original object.

As such, _never_ mutate properties of a state directly. That'll
just break things.
*/
class EditorState {
    /**
    @internal
    */
    constructor(
    /**
    @internal
    */
    config, 
    /**
    The current document.
    */
    doc, 
    /**
    The current selection.
    */
    selection, tr = null) {
        this.config = config;
        this.doc = doc;
        this.selection = selection;
        /**
        @internal
        */
        this.applying = null;
        this.status = config.statusTemplate.slice();
        if (tr && tr.startState.config == config) {
            this.values = tr.startState.values.slice();
        }
        else {
            this.values = config.dynamicSlots.map(_ => null);
            // Copy over old values for shared facets/fields if this is a reconfigure
            if (tr)
                for (let id in config.address) {
                    let cur = config.address[id], prev = tr.startState.config.address[id];
                    if (prev != null && (cur & 1) == 0)
                        this.values[cur >> 1] = getAddr(tr.startState, prev);
                }
        }
        this.applying = tr;
        // Fill in the computed state immediately, so that further queries
        // for it made during the update return this state
        if (tr)
            tr._state = this;
        for (let i = 0; i < this.config.dynamicSlots.length; i++)
            ensureAddr(this, i << 1);
        this.applying = null;
    }
    field(field, require = true) {
        let addr = this.config.address[field.id];
        if (addr == null) {
            if (require)
                throw new RangeError("Field is not present in this state");
            return undefined;
        }
        ensureAddr(this, addr);
        return getAddr(this, addr);
    }
    /**
    Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
    state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
    can be passed. Unless
    [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
    [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
    are assumed to start in the _current_ document (not the document
    produced by previous specs), and its
    [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
    [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
    to the document created by its _own_ changes. The resulting
    transaction contains the combined effect of all the different
    specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
    specs take precedence over earlier ones.
    */
    update(...specs) {
        return resolveTransaction(this, specs, true);
    }
    /**
    @internal
    */
    applyTransaction(tr) {
        let conf = this.config, { base, compartments } = conf;
        for (let effect of tr.effects) {
            if (effect.is(Compartment.reconfigure)) {
                if (conf) {
                    compartments = new Map;
                    conf.compartments.forEach((val, key) => compartments.set(key, val));
                    conf = null;
                }
                compartments.set(effect.value.compartment, effect.value.extension);
            }
            else if (effect.is(StateEffect.reconfigure)) {
                conf = null;
                base = effect.value;
            }
            else if (effect.is(StateEffect.appendConfig)) {
                conf = null;
                base = asArray(base).concat(effect.value);
            }
        }
        new EditorState(conf || Configuration.resolve(base, compartments, this), tr.newDoc, tr.newSelection, tr);
    }
    /**
    Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
    replaces every selection range with the given content.
    */
    replaceSelection(text) {
        if (typeof text == "string")
            text = this.toText(text);
        return this.changeByRange(range => ({ changes: { from: range.from, to: range.to, insert: text },
            range: EditorSelection.cursor(range.from + text.length) }));
    }
    /**
    Create a set of changes and a new selection by running the given
    function for each range in the active selection. The function
    can return an optional set of changes (in the coordinate space
    of the start document), plus an updated range (in the coordinate
    space of the document produced by the call's own changes). This
    method will merge all the changes and ranges into a single
    changeset and selection, and return it as a [transaction
    spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
    [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
    */
    changeByRange(f) {
        let sel = this.selection;
        let result1 = f(sel.ranges[0]);
        let changes = this.changes(result1.changes), ranges = [result1.range];
        let effects = asArray(result1.effects);
        for (let i = 1; i < sel.ranges.length; i++) {
            let result = f(sel.ranges[i]);
            let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);
            for (let j = 0; j < i; j++)
                ranges[j] = ranges[j].map(newMapped);
            let mapBy = changes.mapDesc(newChanges, true);
            ranges.push(result.range.map(mapBy));
            changes = changes.compose(newMapped);
            effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));
        }
        return {
            changes,
            selection: EditorSelection.create(ranges, sel.mainIndex),
            effects
        };
    }
    /**
    Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
    description, taking the state's document length and line
    separator into account.
    */
    changes(spec = []) {
        if (spec instanceof ChangeSet)
            return spec;
        return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));
    }
    /**
    Using the state's [line
    separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
    [`Text`](https://codemirror.net/6/docs/ref/#text.Text) instance from the given string.
    */
    toText(string) {
        return text.Text.of(string.split(this.facet(EditorState.lineSeparator) || DefaultSplit));
    }
    /**
    Return the given range of the document as a string.
    */
    sliceDoc(from = 0, to = this.doc.length) {
        return this.doc.sliceString(from, to, this.lineBreak);
    }
    /**
    Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
    */
    facet(facet) {
        let addr = this.config.address[facet.id];
        if (addr == null)
            return facet.default;
        ensureAddr(this, addr);
        return getAddr(this, addr);
    }
    /**
    Convert this state to a JSON-serializable object. When custom
    fields should be serialized, you can pass them in as an object
    mapping property names (in the resulting object, which should
    not use `doc` or `selection`) to fields.
    */
    toJSON(fields) {
        let result = {
            doc: this.sliceDoc(),
            selection: this.selection.toJSON()
        };
        if (fields)
            for (let prop in fields) {
                let value = fields[prop];
                if (value instanceof StateField)
                    result[prop] = value.spec.toJSON(this.field(fields[prop]), this);
            }
        return result;
    }
    /**
    Deserialize a state from its JSON representation. When custom
    fields should be deserialized, pass the same object you passed
    to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
    third argument.
    */
    static fromJSON(json, config = {}, fields) {
        if (!json || typeof json.doc != "string")
            throw new RangeError("Invalid JSON representation for EditorState");
        let fieldInit = [];
        if (fields)
            for (let prop in fields) {
                let field = fields[prop], value = json[prop];
                fieldInit.push(field.init(state => field.spec.fromJSON(value, state)));
            }
        return EditorState.create({
            doc: json.doc,
            selection: EditorSelection.fromJSON(json.selection),
            extensions: config.extensions ? fieldInit.concat([config.extensions]) : fieldInit
        });
    }
    /**
    Create a new state. You'll usually only need this when
    initializing an editor‚Äîupdated states are created by applying
    transactions.
    */
    static create(config = {}) {
        let configuration = Configuration.resolve(config.extensions || [], new Map);
        let doc = config.doc instanceof text.Text ? config.doc
            : text.Text.of((config.doc || "").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));
        let selection = !config.selection ? EditorSelection.single(0)
            : config.selection instanceof EditorSelection ? config.selection
                : EditorSelection.single(config.selection.anchor, config.selection.head);
        checkSelection(selection, doc.length);
        if (!configuration.staticFacet(allowMultipleSelections))
            selection = selection.asSingle();
        return new EditorState(configuration, doc, selection);
    }
    /**
    The size (in columns) of a tab in the document, determined by
    the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
    */
    get tabSize() { return this.facet(EditorState.tabSize); }
    /**
    Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
    string for this state.
    */
    get lineBreak() { return this.facet(EditorState.lineSeparator) || "\n"; }
    /**
    Look up a translation for the given phrase (via the
    [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
    original string if no translation is found.
    */
    phrase(phrase) {
        for (let map of this.facet(EditorState.phrases))
            if (Object.prototype.hasOwnProperty.call(map, phrase))
                return map[phrase];
        return phrase;
    }
    /**
    Find the values for a given language data field, provided by the
    the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
    */
    languageDataAt(name, pos) {
        let values = [];
        for (let provider of this.facet(languageData)) {
            for (let result of provider(this, pos)) {
                if (Object.prototype.hasOwnProperty.call(result, name))
                    values.push(result[name]);
            }
        }
        return values;
    }
    /**
    Return a function that can categorize strings (expected to
    represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#text.findClusterBreak))
    into one of:
    
     - Word (contains an alphanumeric character or a character
       explicitly listed in the local language's `"wordChars"`
       language data, which should be a string)
     - Space (contains only whitespace)
     - Other (anything else)
    */
    charCategorizer(at) {
        return makeCategorizer(this.languageDataAt("wordChars", at).join(""));
    }
    /**
    Find the word at the given position, meaning the range
    containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
    around it. If no word characters are adjacent to the position,
    this returns null.
    */
    wordAt(pos) {
        let { text: text$1, from, length } = this.doc.lineAt(pos);
        let cat = this.charCategorizer(pos);
        let start = pos - from, end = pos - from;
        while (start > 0) {
            let prev = text.findClusterBreak(text$1, start, false);
            if (cat(text$1.slice(prev, start)) != exports.CharCategory.Word)
                break;
            start = prev;
        }
        while (end < length) {
            let next = text.findClusterBreak(text$1, end);
            if (cat(text$1.slice(end, next)) != exports.CharCategory.Word)
                break;
            end = next;
        }
        return start == end ? EditorSelection.range(start + from, end + from) : null;
    }
}
/**
A facet that, when enabled, causes the editor to allow multiple
ranges to be selected. Be careful though, because by default the
editor relies on the native DOM selection, which cannot handle
multiple selections. An extension like
[`drawSelection`](https://codemirror.net/6/docs/ref/#view.drawSelection) can be used to make
secondary selections visible to the user.
*/
EditorState.allowMultipleSelections = allowMultipleSelections;
/**
Configures the tab size to use in this state. The first
(highest-precedence) value of the facet is used. If no value is
given, this defaults to 4.
*/
EditorState.tabSize = Facet.define({
    combine: values => values.length ? values[0] : 4
});
/**
The line separator to use. By default, any of `"\n"`, `"\r\n"`
and `"\r"` is treated as a separator when splitting lines, and
lines are joined with `"\n"`.

When you configure a value here, only that precise separator
will be used, allowing you to round-trip documents through the
editor without normalizing line separators.
*/
EditorState.lineSeparator = lineSeparator;
/**
Registers translation phrases. The
[`phrase`](https://codemirror.net/6/docs/ref/#state.EditorState.phrase) method will look through
all objects registered with this facet to find translations for
its argument.
*/
EditorState.phrases = Facet.define();
/**
A facet used to register [language
data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt) providers.
*/
EditorState.languageData = languageData;
/**
Facet used to register change filters, which are called for each
transaction (unless explicitly
[disabled](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter)), and can suppress
part of the transaction's changes.

Such a function can return `true` to indicate that it doesn't
want to do anything, `false` to completely stop the changes in
the transaction, or a set of ranges in which changes should be
suppressed. Such ranges are represented as an array of numbers,
with each pair of two number indicating the start and end of a
range. So for example `[10, 20, 100, 110]` suppresses changes
between 10 and 20, and between 100 and 110.
*/
EditorState.changeFilter = changeFilter;
/**
Facet used to register a hook that gets a chance to update or
replace transaction specs before they are applied. This will
only be applied for transactions that don't have
[`filter`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter) set to `false`. You
can either return a single (possibly the input transaction), or
an array of specs (which will be combined in the same way as the
arguments to [`EditorState.update`](https://codemirror.net/6/docs/ref/#state.EditorState.update)).

When possible, it is recommended to avoid accessing
[`Transaction.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state) in a filter,
since it will force creation of a state that will then be
discarded again, if the transaction is actually filtered.

(This functionality should be used with care. Indiscriminately
modifying transaction is likely to break something or degrade
the user experience.)
*/
EditorState.transactionFilter = transactionFilter;
/**
This is a more limited form of
[`transactionFilter`](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter),
which can only add
[annotations](https://codemirror.net/6/docs/ref/#state.TransactionSpec.annotations) and
[effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects). _But_, this type
of filter runs even the transaction has disabled regular
[filtering](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter), making it suitable
for effects that don't need to touch the changes or selection,
but do want to process every transaction.

Extenders run _after_ filters, when both are applied.
*/
EditorState.transactionExtender = transactionExtender;
Compartment.reconfigure = StateEffect.define();

/**
Utility function for combining behaviors to fill in a config
object from an array of provided configs. Will, by default, error
when a field gets two values that aren't `===`-equal, but you can
provide combine functions per field to do something else.
*/
function combineConfig(configs, defaults, // Should hold only the optional properties of Config, but I haven't managed to express that
combine = {}) {
    let result = {};
    for (let config of configs)
        for (let key of Object.keys(config)) {
            let value = config[key], current = result[key];
            if (current === undefined)
                result[key] = value;
            else if (current === value || value === undefined) ; // No conflict
            else if (Object.hasOwnProperty.call(combine, key))
                result[key] = combine[key](current, value);
            else
                throw new Error("Config merge conflict for field " + key);
        }
    for (let key in defaults)
        if (result[key] === undefined)
            result[key] = defaults[key];
    return result;
}

Object.defineProperty(exports, 'Text', {
    enumerable: true,
    get: function () {
        return text.Text;
    }
});
exports.Annotation = Annotation;
exports.AnnotationType = AnnotationType;
exports.ChangeDesc = ChangeDesc;
exports.ChangeSet = ChangeSet;
exports.Compartment = Compartment;
exports.EditorSelection = EditorSelection;
exports.EditorState = EditorState;
exports.Facet = Facet;
exports.Prec = Prec;
exports.SelectionRange = SelectionRange;
exports.StateEffect = StateEffect;
exports.StateEffectType = StateEffectType;
exports.StateField = StateField;
exports.Transaction = Transaction;
exports.combineConfig = combineConfig;

},{"@codemirror/text":18}],18:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

// Compressed representation of the Grapheme_Cluster_Break=Extend
// information from
// http://www.unicode.org/Public/13.0.0/ucd/auxiliary/GraphemeBreakProperty.txt.
// Each pair of elements represents a range, as an offet from the
// previous range and a length. Numbers are in base-36, with the empty
// string being a shorthand for 1.
let extend = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map(s => s ? parseInt(s, 36) : 1);
// Convert offsets into absolute values
for (let i = 1; i < extend.length; i++)
    extend[i] += extend[i - 1];
function isExtendingChar(code) {
    for (let i = 1; i < extend.length; i += 2)
        if (extend[i] > code)
            return extend[i - 1] <= code;
    return false;
}
function isRegionalIndicator(code) {
    return code >= 0x1F1E6 && code <= 0x1F1FF;
}
const ZWJ = 0x200d;
/// Returns a next grapheme cluster break _after_ (not equal to)
/// `pos`, if `forward` is true, or before otherwise. Returns `pos`
/// itself if no further cluster break is available in the string.
/// Moves across surrogate pairs, extending characters, characters
/// joined with zero-width joiners, and flag emoji.
function findClusterBreak(str, pos, forward = true) {
    return (forward ? nextClusterBreak : prevClusterBreak)(str, pos);
}
function nextClusterBreak(str, pos) {
    if (pos == str.length)
        return pos;
    // If pos is in the middle of a surrogate pair, move to its start
    if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1)))
        pos--;
    let prev = codePointAt(str, pos);
    pos += codePointSize(prev);
    while (pos < str.length) {
        let next = codePointAt(str, pos);
        if (prev == ZWJ || next == ZWJ || isExtendingChar(next)) {
            pos += codePointSize(next);
            prev = next;
        }
        else if (isRegionalIndicator(next)) {
            let countBefore = 0, i = pos - 2;
            while (i >= 0 && isRegionalIndicator(codePointAt(str, i))) {
                countBefore++;
                i -= 2;
            }
            if (countBefore % 2 == 0)
                break;
            else
                pos += 2;
        }
        else {
            break;
        }
    }
    return pos;
}
function prevClusterBreak(str, pos) {
    while (pos > 0) {
        let found = nextClusterBreak(str, pos - 2);
        if (found < pos)
            return found;
        pos--;
    }
    return 0;
}
function surrogateLow(ch) { return ch >= 0xDC00 && ch < 0xE000; }
function surrogateHigh(ch) { return ch >= 0xD800 && ch < 0xDC00; }
/// Find the code point at the given position in a string (like the
/// [`codePointAt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt)
/// string method).
function codePointAt(str, pos) {
    let code0 = str.charCodeAt(pos);
    if (!surrogateHigh(code0) || pos + 1 == str.length)
        return code0;
    let code1 = str.charCodeAt(pos + 1);
    if (!surrogateLow(code1))
        return code0;
    return ((code0 - 0xd800) << 10) + (code1 - 0xdc00) + 0x10000;
}
/// Given a Unicode codepoint, return the JavaScript string that
/// respresents it (like
/// [`String.fromCodePoint`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint)).
function fromCodePoint(code) {
    if (code <= 0xffff)
        return String.fromCharCode(code);
    code -= 0x10000;
    return String.fromCharCode((code >> 10) + 0xd800, (code & 1023) + 0xdc00);
}
/// The first character that takes up two positions in a JavaScript
/// string. It is often useful to compare with this after calling
/// `codePointAt`, to figure out whether your character takes up 1 or
/// 2 index positions.
function codePointSize(code) { return code < 0x10000 ? 1 : 2; }

/// Count the column position at the given offset into the string,
/// taking extending characters and tab size into account.
function countColumn(string, n, tabSize) {
    for (let i = 0; i < string.length;) {
        if (string.charCodeAt(i) == 9) {
            n += tabSize - (n % tabSize);
            i++;
        }
        else {
            n++;
            i = findClusterBreak(string, i);
        }
    }
    return n;
}
/// Find the offset that corresponds to the given column position in a
/// string, taking extending characters and tab size into account.
function findColumn(string, n, col, tabSize) {
    for (let i = 0; i < string.length;) {
        if (n >= col)
            return { offset: i, leftOver: 0 };
        n += string.charCodeAt(i) == 9 ? tabSize - (n % tabSize) : 1;
        i = findClusterBreak(string, i);
    }
    return { offset: string.length, leftOver: col - n };
}

/// The data structure for documents.
class Text {
    /// @internal
    constructor() { }
    /// Get the line description around the given position.
    lineAt(pos) {
        if (pos < 0 || pos > this.length)
            throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);
        return this.lineInner(pos, false, 1, 0);
    }
    /// Get the description for the given (1-based) line number.
    line(n) {
        if (n < 1 || n > this.lines)
            throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);
        return this.lineInner(n, true, 1, 0);
    }
    /// Replace a range of the text with the given content.
    replace(from, to, text) {
        let parts = [];
        this.decompose(0, from, parts, 2 /* To */);
        if (text.length)
            text.decompose(0, text.length, parts, 1 /* From */ | 2 /* To */);
        this.decompose(to, this.length, parts, 1 /* From */);
        return TextNode.from(parts, this.length - (to - from) + text.length);
    }
    /// Append another document to this one.
    append(other) {
        return this.replace(this.length, this.length, other);
    }
    /// Retrieve the text between the given points.
    slice(from, to = this.length) {
        let parts = [];
        this.decompose(from, to, parts, 0);
        return TextNode.from(parts, to - from);
    }
    /// Test whether this text is equal to another instance.
    eq(other) {
        if (other == this)
            return true;
        if (other.length != this.length || other.lines != this.lines)
            return false;
        let a = new RawTextCursor(this), b = new RawTextCursor(other);
        for (;;) {
            a.next();
            b.next();
            if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value)
                return false;
            if (a.done)
                return true;
        }
    }
    /// Iterate over the text. When `dir` is `-1`, iteration happens
    /// from end to start. This will return lines and the breaks between
    /// them as separate strings, and for long lines, might split lines
    /// themselves into multiple chunks as well.
    iter(dir = 1) { return new RawTextCursor(this, dir); }
    /// Iterate over a range of the text. When `from` > `to`, the
    /// iterator will run in reverse.
    iterRange(from, to = this.length) { return new PartialTextCursor(this, from, to); }
    /// @internal
    toString() { return this.sliceString(0); }
    /// Convert the document to an array of lines (which can be
    /// deserialized again via [`Text.of`](#text.Text^of)).
    toJSON() {
        let lines = [];
        this.flatten(lines);
        return lines;
    }
    /// Create a `Text` instance for the given array of lines.
    static of(text) {
        if (text.length == 0)
            throw new RangeError("A document must have at least one line");
        if (text.length == 1 && !text[0])
            return Text.empty;
        return text.length <= 32 /* Branch */ ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));
    }
}
if (typeof Symbol != "undefined")
    Text.prototype[Symbol.iterator] = function () { return this.iter(); };
// Leaves store an array of line strings. There are always line breaks
// between these strings. Leaves are limited in size and have to be
// contained in TextNode instances for bigger documents.
class TextLeaf extends Text {
    constructor(text, length = textLength(text)) {
        super();
        this.text = text;
        this.length = length;
    }
    get lines() { return this.text.length; }
    get children() { return null; }
    lineInner(target, isLine, line, offset) {
        for (let i = 0;; i++) {
            let string = this.text[i], end = offset + string.length;
            if ((isLine ? line : end) >= target)
                return new Line(offset, end, line, string);
            offset = end + 1;
            line++;
        }
    }
    decompose(from, to, target, open) {
        let text = from <= 0 && to >= this.length ? this
            : new TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));
        if (open & 1 /* From */) {
            let prev = target.pop();
            let joined = appendText(text.text, prev.text.slice(), 0, text.length);
            if (joined.length <= 32 /* Branch */) {
                target.push(new TextLeaf(joined, prev.length + text.length));
            }
            else {
                let mid = joined.length >> 1;
                target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));
            }
        }
        else {
            target.push(text);
        }
    }
    replace(from, to, text) {
        if (!(text instanceof TextLeaf))
            return super.replace(from, to, text);
        let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to);
        let newLen = this.length + text.length - (to - from);
        if (lines.length <= 32 /* Branch */)
            return new TextLeaf(lines, newLen);
        return TextNode.from(TextLeaf.split(lines, []), newLen);
    }
    sliceString(from, to = this.length, lineSep = "\n") {
        let result = "";
        for (let pos = 0, i = 0; pos <= to && i < this.text.length; i++) {
            let line = this.text[i], end = pos + line.length;
            if (pos > from && i)
                result += lineSep;
            if (from < end && to > pos)
                result += line.slice(Math.max(0, from - pos), to - pos);
            pos = end + 1;
        }
        return result;
    }
    flatten(target) {
        for (let line of this.text)
            target.push(line);
    }
    static split(text, target) {
        let part = [], len = -1;
        for (let line of text) {
            part.push(line);
            len += line.length + 1;
            if (part.length == 32 /* Branch */) {
                target.push(new TextLeaf(part, len));
                part = [];
                len = -1;
            }
        }
        if (len > -1)
            target.push(new TextLeaf(part, len));
        return target;
    }
}
// Nodes provide the tree structure of the `Text` type. They store a
// number of other nodes or leaves, taking care to balance themselves
// on changes. There are implied line breaks _between_ the children of
// a node (but not before the first or after the last child).
class TextNode extends Text {
    constructor(children, length) {
        super();
        this.children = children;
        this.length = length;
        this.lines = 0;
        for (let child of children)
            this.lines += child.lines;
    }
    lineInner(target, isLine, line, offset) {
        for (let i = 0;; i++) {
            let child = this.children[i], end = offset + child.length, endLine = line + child.lines - 1;
            if ((isLine ? endLine : end) >= target)
                return child.lineInner(target, isLine, line, offset);
            offset = end + 1;
            line = endLine + 1;
        }
    }
    decompose(from, to, target, open) {
        for (let i = 0, pos = 0; pos <= to && i < this.children.length; i++) {
            let child = this.children[i], end = pos + child.length;
            if (from <= end && to >= pos) {
                let childOpen = open & ((pos <= from ? 1 /* From */ : 0) | (end >= to ? 2 /* To */ : 0));
                if (pos >= from && end <= to && !childOpen)
                    target.push(child);
                else
                    child.decompose(from - pos, to - pos, target, childOpen);
            }
            pos = end + 1;
        }
    }
    replace(from, to, text) {
        if (text.lines < this.lines)
            for (let i = 0, pos = 0; i < this.children.length; i++) {
                let child = this.children[i], end = pos + child.length;
                // Fast path: if the change only affects one child and the
                // child's size remains in the acceptable range, only update
                // that child
                if (from >= pos && to <= end) {
                    let updated = child.replace(from - pos, to - pos, text);
                    let totalLines = this.lines - child.lines + updated.lines;
                    if (updated.lines < (totalLines >> (5 /* BranchShift */ - 1)) &&
                        updated.lines > (totalLines >> (5 /* BranchShift */ + 1))) {
                        let copy = this.children.slice();
                        copy[i] = updated;
                        return new TextNode(copy, this.length - (to - from) + text.length);
                    }
                    return super.replace(pos, end, updated);
                }
                pos = end + 1;
            }
        return super.replace(from, to, text);
    }
    sliceString(from, to = this.length, lineSep = "\n") {
        let result = "";
        for (let i = 0, pos = 0; i < this.children.length && pos <= to; i++) {
            let child = this.children[i], end = pos + child.length;
            if (pos > from && i)
                result += lineSep;
            if (from < end && to > pos)
                result += child.sliceString(from - pos, to - pos, lineSep);
            pos = end + 1;
        }
        return result;
    }
    flatten(target) {
        for (let child of this.children)
            child.flatten(target);
    }
    static from(children, length = children.reduce((l, ch) => l + ch.length + 1, -1)) {
        let lines = 0;
        for (let ch of children)
            lines += ch.lines;
        if (lines < 32 /* Branch */) {
            let flat = [];
            for (let ch of children)
                ch.flatten(flat);
            return new TextLeaf(flat, length);
        }
        let chunk = Math.max(32 /* Branch */, lines >> 5 /* BranchShift */), maxChunk = chunk << 1, minChunk = chunk >> 1;
        let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];
        function add(child) {
            let last;
            if (child.lines > maxChunk && child instanceof TextNode) {
                for (let node of child.children)
                    add(node);
            }
            else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {
                flush();
                chunked.push(child);
            }
            else if (child instanceof TextLeaf && currentLines &&
                (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf &&
                child.lines + last.lines <= 32 /* Branch */) {
                currentLines += child.lines;
                currentLen += child.length + 1;
                currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);
            }
            else {
                if (currentLines + child.lines > chunk)
                    flush();
                currentLines += child.lines;
                currentLen += child.length + 1;
                currentChunk.push(child);
            }
        }
        function flush() {
            if (currentLines == 0)
                return;
            chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));
            currentLen = -1;
            currentLines = currentChunk.length = 0;
        }
        for (let child of children)
            add(child);
        flush();
        return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);
    }
}
Text.empty = new TextLeaf([""], 0);
function textLength(text) {
    let length = -1;
    for (let line of text)
        length += line.length + 1;
    return length;
}
function appendText(text, target, from = 0, to = 1e9) {
    for (let pos = 0, i = 0, first = true; i < text.length && pos <= to; i++) {
        let line = text[i], end = pos + line.length;
        if (end >= from) {
            if (end > to)
                line = line.slice(0, to - pos);
            if (pos < from)
                line = line.slice(from - pos);
            if (first) {
                target[target.length - 1] += line;
                first = false;
            }
            else
                target.push(line);
        }
        pos = end + 1;
    }
    return target;
}
function sliceText(text, from, to) {
    return appendText(text, [""], from, to);
}
class RawTextCursor {
    constructor(text, dir = 1) {
        this.dir = dir;
        this.done = false;
        this.lineBreak = false;
        this.value = "";
        this.nodes = [text];
        this.offsets = [dir > 0 ? 0 : text instanceof TextLeaf ? text.text.length : text.children.length];
    }
    next(skip = 0) {
        for (;;) {
            let last = this.nodes.length - 1;
            if (last < 0) {
                this.done = true;
                this.value = "";
                this.lineBreak = false;
                return this;
            }
            let top = this.nodes[last], offset = this.offsets[last];
            let size = top instanceof TextLeaf ? top.text.length : top.children.length;
            if (offset == (this.dir > 0 ? size : 0)) {
                this.nodes.pop();
                this.offsets.pop();
            }
            else if (!this.lineBreak && offset != (this.dir > 0 ? 0 : size)) {
                // Internal offset with lineBreak == false means we have to
                // count the line break at this position
                this.lineBreak = true;
                if (skip == 0) {
                    this.value = "\n";
                    return this;
                }
                skip--;
            }
            else if (top instanceof TextLeaf) {
                // Move to the next string
                let next = top.text[offset - (this.dir < 0 ? 1 : 0)];
                this.offsets[last] = (offset += this.dir);
                this.lineBreak = false;
                if (next.length > Math.max(0, skip)) {
                    this.value = skip == 0 ? next : this.dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);
                    return this;
                }
                skip -= next.length;
            }
            else {
                let next = top.children[this.dir > 0 ? offset : offset - 1];
                this.offsets[last] = offset + this.dir;
                this.lineBreak = false;
                if (skip > next.length) {
                    skip -= next.length;
                }
                else {
                    this.nodes.push(next);
                    this.offsets.push(this.dir > 0 ? 0 : next instanceof TextLeaf ? next.text.length : next.children.length);
                }
            }
        }
    }
}
class PartialTextCursor {
    constructor(text, start, end) {
        this.value = "";
        this.cursor = new RawTextCursor(text, start > end ? -1 : 1);
        if (start > end) {
            this.skip = text.length - start;
            this.limit = start - end;
        }
        else {
            this.skip = start;
            this.limit = end - start;
        }
    }
    next(skip = 0) {
        if (this.limit <= 0) {
            this.limit = -1;
        }
        else {
            let { value, lineBreak, done } = this.cursor.next(this.skip + skip);
            this.skip = 0;
            this.value = value;
            let len = lineBreak ? 1 : value.length;
            if (len > this.limit)
                this.value = this.cursor.dir > 0 ? value.slice(0, this.limit) : value.slice(len - this.limit);
            if (done || this.value.length == 0)
                this.limit = -1;
            else
                this.limit -= this.value.length;
        }
        return this;
    }
    get lineBreak() { return this.cursor.lineBreak; }
    get done() { return this.limit < 0; }
}
/// This type describes a line in the document. It is created
/// on-demand when lines are [queried](#text.Text.lineAt).
class Line {
    /// @internal
    constructor(
    /// The position of the start of the line.
    from, 
    /// The position at the end of the line (_before_ the line break,
    /// or at the end of document for the last line).
    to, 
    /// This line's line number (1-based).
    number, 
    /// The line's content.
    text) {
        this.from = from;
        this.to = to;
        this.number = number;
        this.text = text;
    }
    /// The length of the line (not including any line break after it).
    get length() { return this.to - this.from; }
}

exports.Line = Line;
exports.Text = Text;
exports.codePointAt = codePointAt;
exports.codePointSize = codePointSize;
exports.countColumn = countColumn;
exports.findClusterBreak = findClusterBreak;
exports.findColumn = findColumn;
exports.fromCodePoint = fromCodePoint;

},{}],19:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var view = require('@codemirror/view');
var state = require('@codemirror/state');

const ios = typeof navigator != "undefined" &&
    !/Edge\/(\d+)/.exec(navigator.userAgent) && /Apple Computer/.test(navigator.vendor) &&
    (/Mobile\/\w+/.test(navigator.userAgent) || navigator.maxTouchPoints > 2);
const Outside = "-10000px";
const tooltipPlugin = view.ViewPlugin.fromClass(class {
    constructor(view) {
        this.view = view;
        this.inView = true;
        this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this };
        this.input = view.state.facet(showTooltip);
        this.tooltips = this.input.filter(t => t);
        this.tooltipViews = this.tooltips.map(tp => this.createTooltip(tp));
    }
    update(update) {
        let input = update.state.facet(showTooltip);
        if (input == this.input) {
            for (let t of this.tooltipViews)
                if (t.update)
                    t.update(update);
        }
        else {
            let tooltips = input.filter(x => x);
            let views = [];
            for (let i = 0; i < tooltips.length; i++) {
                let tip = tooltips[i], known = -1;
                if (!tip)
                    continue;
                for (let i = 0; i < this.tooltips.length; i++) {
                    let other = this.tooltips[i];
                    if (other && other.create == tip.create)
                        known = i;
                }
                if (known < 0) {
                    views[i] = this.createTooltip(tip);
                }
                else {
                    let tooltipView = views[i] = this.tooltipViews[known];
                    if (tooltipView.update)
                        tooltipView.update(update);
                }
            }
            for (let t of this.tooltipViews)
                if (views.indexOf(t) < 0)
                    t.dom.remove();
            this.input = input;
            this.tooltips = tooltips;
            this.tooltipViews = views;
            this.maybeMeasure();
        }
    }
    createTooltip(tooltip) {
        let tooltipView = tooltip.create(this.view);
        tooltipView.dom.classList.add("cm-tooltip");
        // FIXME drop this on the next breaking release
        if (tooltip.class)
            tooltipView.dom.classList.add(tooltip.class);
        tooltipView.dom.style.top = Outside;
        this.view.dom.appendChild(tooltipView.dom);
        if (tooltipView.mount)
            tooltipView.mount(this.view);
        return tooltipView;
    }
    destroy() {
        for (let { dom } of this.tooltipViews)
            dom.remove();
    }
    readMeasure() {
        return {
            editor: this.view.dom.getBoundingClientRect(),
            pos: this.tooltips.map(t => this.view.coordsAtPos(t.pos)),
            size: this.tooltipViews.map(({ dom }) => dom.getBoundingClientRect()),
            innerWidth: window.innerWidth,
            innerHeight: window.innerHeight
        };
    }
    writeMeasure(measured) {
        let { editor } = measured;
        for (let i = 0; i < this.tooltipViews.length; i++) {
            let tooltip = this.tooltips[i], tView = this.tooltipViews[i], { dom } = tView;
            let pos = measured.pos[i], size = measured.size[i];
            // Hide tooltips that are outside of the editor.
            if (!pos || pos.bottom <= editor.top || pos.top >= editor.bottom || pos.right <= editor.left || pos.left >= editor.right) {
                dom.style.top = Outside;
                continue;
            }
            let width = size.right - size.left, height = size.bottom - size.top;
            let left = this.view.textDirection == view.Direction.LTR ? Math.min(pos.left, measured.innerWidth - width)
                : Math.max(0, pos.left - width);
            let above = !!tooltip.above;
            if (!tooltip.strictSide &&
                (above ? pos.top - (size.bottom - size.top) < 0 : pos.bottom + (size.bottom - size.top) > measured.innerHeight))
                above = !above;
            if (ios) {
                dom.style.top = ((above ? pos.top - height : pos.bottom) - editor.top) + "px";
                dom.style.left = (left - editor.left) + "px";
                dom.style.position = "absolute";
            }
            else {
                dom.style.top = (above ? pos.top - height : pos.bottom) + "px";
                dom.style.left = left + "px";
            }
            dom.classList.toggle("cm-tooltip-above", above);
            dom.classList.toggle("cm-tooltip-below", !above);
            if (tView.positioned)
                tView.positioned();
        }
    }
    maybeMeasure() {
        if (this.tooltips.length) {
            if (this.view.inView || this.inView)
                this.view.requestMeasure(this.measureReq);
            this.inView = this.view.inView;
        }
    }
}, {
    eventHandlers: {
        scroll() { this.maybeMeasure(); }
    }
});
const baseTheme = view.EditorView.baseTheme({
    ".cm-tooltip": {
        position: "fixed",
        zIndex: 100
    },
    "&light .cm-tooltip": {
        border: "1px solid #ddd",
        backgroundColor: "#f5f5f5"
    },
    "&dark .cm-tooltip": {
        backgroundColor: "#333338",
        color: "white"
    }
});
// FIXME backward-compat shim. Delete on next major version.
/**
@internal
*/
function tooltips() {
    return [];
}
/**
Behavior by which an extension can provide a tooltip to be shown.
*/
const showTooltip = state.Facet.define({
    enables: [tooltipPlugin, baseTheme]
});
const HoverTime = 750, HoverMaxDist = 6;
class HoverPlugin {
    constructor(view, source, field, setHover) {
        this.view = view;
        this.source = source;
        this.field = field;
        this.setHover = setHover;
        this.lastMouseMove = null;
        this.hoverTimeout = -1;
        this.restartTimeout = -1;
        this.pending = null;
        this.checkHover = this.checkHover.bind(this);
        view.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this));
        view.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
    }
    update() {
        if (this.pending) {
            this.pending = null;
            clearTimeout(this.restartTimeout);
            this.restartTimeout = setTimeout(() => this.startHover(), 20);
        }
    }
    get active() {
        return this.view.state.field(this.field);
    }
    checkHover() {
        this.hoverTimeout = -1;
        if (this.active)
            return;
        let now = Date.now(), lastMove = this.lastMouseMove;
        if (now - lastMove.timeStamp < HoverTime)
            this.hoverTimeout = setTimeout(this.checkHover, HoverTime - (now - lastMove.timeStamp));
        else
            this.startHover();
    }
    startHover() {
        var _a;
        clearTimeout(this.restartTimeout);
        let lastMove = this.lastMouseMove;
        let coords = { x: lastMove.clientX, y: lastMove.clientY };
        let pos = this.view.contentDOM.contains(lastMove.target)
            ? this.view.posAtCoords(coords) : null;
        if (pos == null)
            return;
        let posCoords = this.view.coordsAtPos(pos);
        if (posCoords == null || coords.y < posCoords.top || coords.y > posCoords.bottom ||
            coords.x < posCoords.left - this.view.defaultCharacterWidth ||
            coords.x > posCoords.right + this.view.defaultCharacterWidth)
            return;
        let bidi = this.view.bidiSpans(this.view.state.doc.lineAt(pos)).find(s => s.from <= pos && s.to >= pos);
        let rtl = bidi && bidi.dir == view.Direction.RTL ? -1 : 1;
        let open = this.source(this.view, pos, (coords.x < posCoords.left ? -rtl : rtl));
        if ((_a = open) === null || _a === void 0 ? void 0 : _a.then) {
            let pending = this.pending = { pos };
            open.then(result => {
                if (this.pending == pending) {
                    this.pending = null;
                    if (result)
                        this.view.dispatch({ effects: this.setHover.of(result) });
                }
            }, e => view.logException(this.view.state, e, "hover tooltip"));
        }
        else if (open) {
            this.view.dispatch({ effects: this.setHover.of(open) });
        }
    }
    mousemove(event) {
        var _a;
        this.lastMouseMove = event;
        if (this.hoverTimeout < 0)
            this.hoverTimeout = setTimeout(this.checkHover, HoverTime);
        let tooltip = this.active;
        if (tooltip && !isInTooltip(event.target) || this.pending) {
            let { pos } = tooltip || this.pending, end = (_a = tooltip === null || tooltip === void 0 ? void 0 : tooltip.end) !== null && _a !== void 0 ? _a : pos;
            if ((pos == end ? this.view.posAtCoords({ x: event.clientX, y: event.clientY }) != pos
                : !isOverRange(this.view, pos, end, event.clientX, event.clientY, HoverMaxDist))) {
                this.view.dispatch({ effects: this.setHover.of(null) });
                this.pending = null;
            }
        }
    }
    mouseleave() {
        clearTimeout(this.hoverTimeout);
        this.hoverTimeout = -1;
        if (this.active)
            this.view.dispatch({ effects: this.setHover.of(null) });
    }
    destroy() {
        clearTimeout(this.hoverTimeout);
        this.view.dom.removeEventListener("mouseleave", this.mouseleave);
        this.view.dom.removeEventListener("mousemove", this.mousemove);
    }
}
function isInTooltip(elt) {
    for (let cur = elt; cur; cur = cur.parentNode)
        if (cur.nodeType == 1 && cur.classList.contains("cm-tooltip"))
            return true;
    return false;
}
function isOverRange(view, from, to, x, y, margin) {
    let range = document.createRange();
    let fromDOM = view.domAtPos(from), toDOM = view.domAtPos(to);
    range.setEnd(toDOM.node, toDOM.offset);
    range.setStart(fromDOM.node, fromDOM.offset);
    let rects = range.getClientRects();
    range.detach();
    for (let i = 0; i < rects.length; i++) {
        let rect = rects[i];
        let dist = Math.max(rect.top - y, y - rect.bottom, rect.left - x, x - rect.right);
        if (dist <= margin)
            return true;
    }
    return false;
}
/**
Enable a hover tooltip, which shows up when the pointer hovers
over ranges of text. The callback is called when the mouse hovers
over the document text. It should, if there is a tooltip
associated with position `pos` return the tooltip description
(either directly or in a promise). The `side` argument indicates
on which side of the position the pointer is‚Äîit will be -1 if the
pointer is before the position, 1 if after the position.
*/
function hoverTooltip(source, options = {}) {
    const setHover = state.StateEffect.define();
    const hoverState = state.StateField.define({
        create() { return null; },
        update(value, tr) {
            if (value && (options.hideOnChange && (tr.docChanged || tr.selection)))
                return null;
            for (let effect of tr.effects)
                if (effect.is(setHover))
                    return effect.value;
            if (value && tr.docChanged) {
                let newPos = tr.changes.mapPos(value.pos, -1, state.MapMode.TrackDel);
                if (newPos == null)
                    return null;
                let copy = Object.assign(Object.create(null), value);
                copy.pos = newPos;
                if (value.end != null)
                    copy.end = tr.changes.mapPos(value.end);
                return copy;
            }
            return value;
        },
        provide: f => showTooltip.from(f)
    });
    return [
        hoverState,
        view.ViewPlugin.define(view => new HoverPlugin(view, source, hoverState, setHover))
    ];
}

exports.hoverTooltip = hoverTooltip;
exports.showTooltip = showTooltip;
exports.tooltips = tooltips;

},{"@codemirror/state":17,"@codemirror/view":20}],20:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var state = require('@codemirror/state');
var styleMod = require('style-mod');
var rangeset = require('@codemirror/rangeset');
var text = require('@codemirror/text');
var w3cKeyname = require('w3c-keyname');

let [nav, doc] = typeof navigator != "undefined"
    ? [navigator, document]
    : [{ userAgent: "", vendor: "", platform: "" }, { documentElement: { style: {} } }];
const ie_edge = /Edge\/(\d+)/.exec(nav.userAgent);
const ie_upto10 = /MSIE \d/.test(nav.userAgent);
const ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent);
const ie = !!(ie_upto10 || ie_11up || ie_edge);
const gecko = !ie && /gecko\/(\d+)/i.test(nav.userAgent);
const chrome = !ie && /Chrome\/(\d+)/.exec(nav.userAgent);
const webkit = "webkitFontSmoothing" in doc.documentElement.style;
const safari = !ie && /Apple Computer/.test(nav.vendor);
var browser = {
    mac: /Mac/.test(nav.platform),
    ie,
    ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,
    gecko,
    gecko_version: gecko ? +(/Firefox\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
    chrome: !!chrome,
    chrome_version: chrome ? +chrome[1] : 0,
    ios: safari && (/Mobile\/\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2),
    android: /Android\b/.test(nav.userAgent),
    webkit,
    safari,
    webkit_version: webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
    tabSize: doc.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};

function getSelection(root) {
    return (root.getSelection ? root.getSelection() : document.getSelection());
}
// Work around Chrome issue https://bugs.chromium.org/p/chromium/issues/detail?id=447523
// (isCollapsed inappropriately returns true in shadow dom)
function selectionCollapsed(domSel) {
    let collapsed = domSel.isCollapsed;
    if (collapsed && browser.chrome && domSel.rangeCount && !domSel.getRangeAt(0).collapsed)
        collapsed = false;
    return collapsed;
}
function contains(dom, node) {
    return node ? dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;
}
function hasSelection(dom, selection) {
    if (!selection.anchorNode)
        return false;
    try {
        // Firefox will raise 'permission denied' errors when accessing
        // properties of `sel.anchorNode` when it's in a generated CSS
        // element.
        return contains(dom, selection.anchorNode);
    }
    catch (_) {
        return false;
    }
}
function clientRectsFor(dom) {
    if (dom.nodeType == 3)
        return textRange(dom, 0, dom.nodeValue.length).getClientRects();
    else if (dom.nodeType == 1)
        return dom.getClientRects();
    else
        return [];
}
// Scans forward and backward through DOM positions equivalent to the
// given one to see if the two are in the same place (i.e. after a
// text node vs at the end of that text node)
function isEquivalentPosition(node, off, targetNode, targetOff) {
    return targetNode ? (scanFor(node, off, targetNode, targetOff, -1) ||
        scanFor(node, off, targetNode, targetOff, 1)) : false;
}
function domIndex(node) {
    for (var index = 0;; index++) {
        node = node.previousSibling;
        if (!node)
            return index;
    }
}
function scanFor(node, off, targetNode, targetOff, dir) {
    for (;;) {
        if (node == targetNode && off == targetOff)
            return true;
        if (off == (dir < 0 ? 0 : maxOffset(node))) {
            if (node.nodeName == "DIV")
                return false;
            let parent = node.parentNode;
            if (!parent || parent.nodeType != 1)
                return false;
            off = domIndex(node) + (dir < 0 ? 0 : 1);
            node = parent;
        }
        else if (node.nodeType == 1) {
            node = node.childNodes[off + (dir < 0 ? -1 : 0)];
            off = dir < 0 ? maxOffset(node) : 0;
        }
        else {
            return false;
        }
    }
}
function maxOffset(node) {
    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
const Rect0 = { left: 0, right: 0, top: 0, bottom: 0 };
function flattenRect(rect, left) {
    let x = left ? rect.left : rect.right;
    return { left: x, right: x, top: rect.top, bottom: rect.bottom };
}
function windowRect(win) {
    return { left: 0, right: win.innerWidth,
        top: 0, bottom: win.innerHeight };
}
const ScrollSpace = 5;
function scrollRectIntoView(dom, rect) {
    let doc = dom.ownerDocument, win = doc.defaultView;
    for (let cur = dom.parentNode; cur;) {
        if (cur.nodeType == 1) { // Element
            let bounding, top = cur == document.body;
            if (top) {
                bounding = windowRect(win);
            }
            else {
                if (cur.scrollHeight <= cur.clientHeight && cur.scrollWidth <= cur.clientWidth) {
                    cur = cur.parentNode;
                    continue;
                }
                let rect = cur.getBoundingClientRect();
                // Make sure scrollbar width isn't included in the rectangle
                bounding = { left: rect.left, right: rect.left + cur.clientWidth,
                    top: rect.top, bottom: rect.top + cur.clientHeight };
            }
            let moveX = 0, moveY = 0;
            if (rect.top < bounding.top)
                moveY = -(bounding.top - rect.top + ScrollSpace);
            else if (rect.bottom > bounding.bottom)
                moveY = rect.bottom - bounding.bottom + ScrollSpace;
            if (rect.left < bounding.left)
                moveX = -(bounding.left - rect.left + ScrollSpace);
            else if (rect.right > bounding.right)
                moveX = rect.right - bounding.right + ScrollSpace;
            if (moveX || moveY) {
                if (top) {
                    win.scrollBy(moveX, moveY);
                }
                else {
                    if (moveY) {
                        let start = cur.scrollTop;
                        cur.scrollTop += moveY;
                        moveY = cur.scrollTop - start;
                    }
                    if (moveX) {
                        let start = cur.scrollLeft;
                        cur.scrollLeft += moveX;
                        moveX = cur.scrollLeft - start;
                    }
                    rect = { left: rect.left - moveX, top: rect.top - moveY,
                        right: rect.right - moveX, bottom: rect.bottom - moveY };
                }
            }
            if (top)
                break;
            cur = cur.parentNode;
        }
        else if (cur.nodeType == 11) { // A shadow root
            cur = cur.host;
        }
        else {
            break;
        }
    }
}
class DOMSelection {
    constructor() {
        this.anchorNode = null;
        this.anchorOffset = 0;
        this.focusNode = null;
        this.focusOffset = 0;
    }
    eq(domSel) {
        return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset &&
            this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;
    }
    set(domSel) {
        this.anchorNode = domSel.anchorNode;
        this.anchorOffset = domSel.anchorOffset;
        this.focusNode = domSel.focusNode;
        this.focusOffset = domSel.focusOffset;
    }
}
let preventScrollSupported = null;
// Feature-detects support for .focus({preventScroll: true}), and uses
// a fallback kludge when not supported.
function focusPreventScroll(dom) {
    if (dom.setActive)
        return dom.setActive(); // in IE
    if (preventScrollSupported)
        return dom.focus(preventScrollSupported);
    let stack = [];
    for (let cur = dom; cur; cur = cur.parentNode) {
        stack.push(cur, cur.scrollTop, cur.scrollLeft);
        if (cur == cur.ownerDocument)
            break;
    }
    dom.focus(preventScrollSupported == null ? {
        get preventScroll() {
            preventScrollSupported = { preventScroll: true };
            return true;
        }
    } : undefined);
    if (!preventScrollSupported) {
        preventScrollSupported = false;
        for (let i = 0; i < stack.length;) {
            let elt = stack[i++], top = stack[i++], left = stack[i++];
            if (elt.scrollTop != top)
                elt.scrollTop = top;
            if (elt.scrollLeft != left)
                elt.scrollLeft = left;
        }
    }
}
let scratchRange;
function textRange(node, from, to = from) {
    let range = scratchRange || (scratchRange = document.createRange());
    range.setEnd(node, to);
    range.setStart(node, from);
    return range;
}

class DOMPos {
    constructor(node, offset, precise = true) {
        this.node = node;
        this.offset = offset;
        this.precise = precise;
    }
    static before(dom, precise) { return new DOMPos(dom.parentNode, domIndex(dom), precise); }
    static after(dom, precise) { return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise); }
}
const none$3 = [];
class ContentView {
    constructor() {
        this.parent = null;
        this.dom = null;
        this.dirty = 2 /* Node */;
    }
    get editorView() {
        if (!this.parent)
            throw new Error("Accessing view in orphan content view");
        return this.parent.editorView;
    }
    get overrideDOMText() { return null; }
    get posAtStart() {
        return this.parent ? this.parent.posBefore(this) : 0;
    }
    get posAtEnd() {
        return this.posAtStart + this.length;
    }
    posBefore(view) {
        let pos = this.posAtStart;
        for (let child of this.children) {
            if (child == view)
                return pos;
            pos += child.length + child.breakAfter;
        }
        throw new RangeError("Invalid child in posBefore");
    }
    posAfter(view) {
        return this.posBefore(view) + view.length;
    }
    // Will return a rectangle directly before (when side < 0), after
    // (side > 0) or directly on (when the browser supports it) the
    // given position.
    coordsAt(_pos, _side) { return null; }
    sync(track) {
        if (this.dirty & 2 /* Node */) {
            let parent = this.dom, pos = null;
            for (let child of this.children) {
                if (child.dirty) {
                    let next = pos ? pos.nextSibling : parent.firstChild;
                    if (next && !child.dom && !ContentView.get(next))
                        child.reuseDOM(next);
                    child.sync(track);
                    child.dirty = 0 /* Not */;
                }
                if (track && track.node == parent && pos != child.dom)
                    track.written = true;
                syncNodeInto(parent, pos, child.dom);
                pos = child.dom;
            }
            let next = pos ? pos.nextSibling : parent.firstChild;
            if (next && track && track.node == parent)
                track.written = true;
            while (next)
                next = rm(next);
        }
        else if (this.dirty & 1 /* Child */) {
            for (let child of this.children)
                if (child.dirty) {
                    child.sync(track);
                    child.dirty = 0 /* Not */;
                }
        }
    }
    reuseDOM(_dom) { return false; }
    localPosFromDOM(node, offset) {
        let after;
        if (node == this.dom) {
            after = this.dom.childNodes[offset];
        }
        else {
            let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;
            for (;;) {
                let parent = node.parentNode;
                if (parent == this.dom)
                    break;
                if (bias == 0 && parent.firstChild != parent.lastChild) {
                    if (node == parent.firstChild)
                        bias = -1;
                    else
                        bias = 1;
                }
                node = parent;
            }
            if (bias < 0)
                after = node;
            else
                after = node.nextSibling;
        }
        if (after == this.dom.firstChild)
            return 0;
        while (after && !ContentView.get(after))
            after = after.nextSibling;
        if (!after)
            return this.length;
        for (let i = 0, pos = 0;; i++) {
            let child = this.children[i];
            if (child.dom == after)
                return pos;
            pos += child.length + child.breakAfter;
        }
    }
    domBoundsAround(from, to, offset = 0) {
        let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;
        for (let i = 0, pos = offset; i < this.children.length; i++) {
            let child = this.children[i], end = pos + child.length;
            if (pos < from && end > to)
                return child.domBoundsAround(from, to, pos);
            if (end >= from && fromI == -1) {
                fromI = i;
                fromStart = pos;
            }
            if (end >= to && end != pos && toI == -1) {
                toI = i;
                toEnd = end;
                break;
            }
            pos = end + child.breakAfter;
        }
        return { from: fromStart, to: toEnd < 0 ? offset + this.length : toEnd, startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild, endDOM: toI < this.children.length - 1 && toI >= 0 ? this.children[toI + 1].dom : null };
    }
    markDirty(andParent = false) {
        if (this.dirty & 2 /* Node */)
            return;
        this.dirty |= 2 /* Node */;
        this.markParentsDirty(andParent);
    }
    markParentsDirty(childList) {
        for (let parent = this.parent; parent; parent = parent.parent) {
            if (childList)
                parent.dirty |= 2 /* Node */;
            if (parent.dirty & 1 /* Child */)
                return;
            parent.dirty |= 1 /* Child */;
            childList = false;
        }
    }
    setParent(parent) {
        if (this.parent != parent) {
            this.parent = parent;
            if (this.dirty)
                this.markParentsDirty(true);
        }
    }
    setDOM(dom) {
        this.dom = dom;
        dom.cmView = this;
    }
    get rootView() {
        for (let v = this;;) {
            let parent = v.parent;
            if (!parent)
                return v;
            v = parent;
        }
    }
    replaceChildren(from, to, children = none$3) {
        this.markDirty();
        for (let i = from; i < to; i++)
            this.children[i].parent = null;
        this.children.splice(from, to - from, ...children);
        for (let i = 0; i < children.length; i++)
            children[i].setParent(this);
    }
    ignoreMutation(_rec) { return false; }
    ignoreEvent(_event) { return false; }
    childCursor(pos = this.length) {
        return new ChildCursor(this.children, pos, this.children.length);
    }
    childPos(pos, bias = 1) {
        return this.childCursor().findPos(pos, bias);
    }
    toString() {
        let name = this.constructor.name.replace("View", "");
        return name + (this.children.length ? "(" + this.children.join() + ")" :
            this.length ? "[" + (name == "Text" ? this.text : this.length) + "]" : "") +
            (this.breakAfter ? "#" : "");
    }
    static get(node) { return node.cmView; }
}
ContentView.prototype.breakAfter = 0;
// Remove a DOM node and return its next sibling.
function rm(dom) {
    let next = dom.nextSibling;
    dom.parentNode.removeChild(dom);
    return next;
}
function syncNodeInto(parent, after, dom) {
    let next = after ? after.nextSibling : parent.firstChild;
    if (dom.parentNode == parent)
        while (next != dom)
            next = rm(next);
    else
        parent.insertBefore(dom, next);
}
class ChildCursor {
    constructor(children, pos, i) {
        this.children = children;
        this.pos = pos;
        this.i = i;
        this.off = 0;
    }
    findPos(pos, bias = 1) {
        for (;;) {
            if (pos > this.pos || pos == this.pos &&
                (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {
                this.off = pos - this.pos;
                return this;
            }
            let next = this.children[--this.i];
            this.pos -= next.length + next.breakAfter;
        }
    }
}

const none$2 = [];
class InlineView extends ContentView {
    /**
    Return true when this view is equivalent to `other` and can take
    on its role.
    */
    become(_other) { return false; }
    // When this is a zero-length view with a side, this should return a
    // negative number to indicate it is before its position, or a
    // positive number when after its position.
    getSide() { return 0; }
}
InlineView.prototype.children = none$2;
const MaxJoinLen = 256;
class TextView extends InlineView {
    constructor(text) {
        super();
        this.text = text;
    }
    get length() { return this.text.length; }
    createDOM(textDOM) {
        this.setDOM(textDOM || document.createTextNode(this.text));
    }
    sync(track) {
        if (!this.dom)
            this.createDOM();
        if (this.dom.nodeValue != this.text) {
            if (track && track.node == this.dom)
                track.written = true;
            this.dom.nodeValue = this.text;
        }
    }
    reuseDOM(dom) {
        if (dom.nodeType != 3)
            return false;
        this.createDOM(dom);
        return true;
    }
    merge(from, to, source) {
        if (source && (!(source instanceof TextView) || this.length - (to - from) + source.length > MaxJoinLen))
            return false;
        this.text = this.text.slice(0, from) + (source ? source.text : "") + this.text.slice(to);
        this.markDirty();
        return true;
    }
    slice(from) {
        return new TextView(this.text.slice(from));
    }
    localPosFromDOM(node, offset) {
        return node == this.dom ? offset : offset ? this.text.length : 0;
    }
    domAtPos(pos) { return new DOMPos(this.dom, pos); }
    domBoundsAround(_from, _to, offset) {
        return { from: offset, to: offset + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
    }
    coordsAt(pos, side) {
        return textCoords(this.dom, pos, side);
    }
}
class MarkView extends InlineView {
    constructor(mark, children = [], length = 0) {
        super();
        this.mark = mark;
        this.children = children;
        this.length = length;
        for (let ch of children)
            ch.setParent(this);
    }
    createDOM() {
        let dom = document.createElement(this.mark.tagName);
        if (this.mark.class)
            dom.className = this.mark.class;
        if (this.mark.attrs)
            for (let name in this.mark.attrs)
                dom.setAttribute(name, this.mark.attrs[name]);
        this.setDOM(dom);
    }
    sync(track) {
        if (!this.dom)
            this.createDOM();
        super.sync(track);
    }
    merge(from, to, source, openStart, openEnd) {
        if (source && (!(source instanceof MarkView && source.mark.eq(this.mark)) ||
            (from && openStart <= 0) || (to < this.length && openEnd <= 0)))
            return false;
        mergeInlineChildren(this, from, to, source ? source.children : none$2, openStart - 1, openEnd - 1);
        this.markDirty();
        return true;
    }
    slice(from) {
        return new MarkView(this.mark, sliceInlineChildren(this.children, from), this.length - from);
    }
    domAtPos(pos) {
        return inlineDOMAtPos(this.dom, this.children, pos);
    }
    coordsAt(pos, side) {
        return coordsInChildren(this, pos, side);
    }
}
function textCoords(text, pos, side) {
    let length = text.nodeValue.length;
    if (pos > length)
        pos = length;
    let from = pos, to = pos, flatten = 0;
    if (pos == 0 && side < 0 || pos == length && side >= 0) {
        if (!(browser.chrome || browser.gecko)) { // These browsers reliably return valid rectangles for empty ranges
            if (pos) {
                from--;
                flatten = 1;
            } // FIXME this is wrong in RTL text
            else {
                to++;
                flatten = -1;
            }
        }
    }
    else {
        if (side < 0)
            from--;
        else
            to++;
    }
    let rects = textRange(text, from, to).getClientRects();
    if (!rects.length)
        return Rect0;
    let rect = rects[(flatten ? flatten < 0 : side >= 0) ? 0 : rects.length - 1];
    if (browser.safari && !flatten && rect.width == 0)
        rect = Array.prototype.find.call(rects, r => r.width) || rect;
    return flatten ? flattenRect(rect, flatten < 0) : rect;
}
// Also used for collapsed ranges that don't have a placeholder widget!
class WidgetView extends InlineView {
    constructor(widget, length, side) {
        super();
        this.widget = widget;
        this.length = length;
        this.side = side;
    }
    static create(widget, length, side) {
        return new (widget.customView || WidgetView)(widget, length, side);
    }
    slice(from) { return WidgetView.create(this.widget, this.length - from, this.side); }
    sync() {
        if (!this.dom || !this.widget.updateDOM(this.dom)) {
            this.setDOM(this.widget.toDOM(this.editorView));
            this.dom.contentEditable = "false";
        }
    }
    getSide() { return this.side; }
    merge(from, to, source, openStart, openEnd) {
        if (source && (!(source instanceof WidgetView) || !this.widget.compare(source.widget) ||
            from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
            return false;
        this.length = from + (source ? source.length : 0) + (this.length - to);
        return true;
    }
    become(other) {
        if (other.length == this.length && other instanceof WidgetView && other.side == this.side) {
            if (this.widget.constructor == other.widget.constructor) {
                if (!this.widget.eq(other.widget))
                    this.markDirty(true);
                this.widget = other.widget;
                return true;
            }
        }
        return false;
    }
    ignoreMutation() { return true; }
    ignoreEvent(event) { return this.widget.ignoreEvent(event); }
    get overrideDOMText() {
        if (this.length == 0)
            return text.Text.empty;
        let top = this;
        while (top.parent)
            top = top.parent;
        let view = top.editorView, text$1 = view && view.state.doc, start = this.posAtStart;
        return text$1 ? text$1.slice(start, start + this.length) : text.Text.empty;
    }
    domAtPos(pos) {
        return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
    }
    domBoundsAround() { return null; }
    coordsAt(pos, side) {
        let rects = this.dom.getClientRects(), rect = null;
        if (!rects.length)
            return Rect0;
        for (let i = pos > 0 ? rects.length - 1 : 0;; i += (pos > 0 ? -1 : 1)) {
            rect = rects[i];
            if (pos > 0 ? i == 0 : i == rects.length - 1 || rect.top < rect.bottom)
                break;
        }
        return (pos == 0 && side > 0 || pos == this.length && side <= 0) ? rect : flattenRect(rect, pos == 0);
    }
}
class CompositionView extends WidgetView {
    domAtPos(pos) { return new DOMPos(this.widget.text, pos); }
    sync() { if (!this.dom)
        this.setDOM(this.widget.toDOM()); }
    localPosFromDOM(node, offset) {
        return !offset ? 0 : node.nodeType == 3 ? Math.min(offset, this.length) : this.length;
    }
    ignoreMutation() { return false; }
    get overrideDOMText() { return null; }
    coordsAt(pos, side) { return textCoords(this.widget.text, pos, side); }
}
function mergeInlineChildren(parent, from, to, elts, openStart, openEnd) {
    let cur = parent.childCursor();
    let { i: toI, off: toOff } = cur.findPos(to, 1);
    let { i: fromI, off: fromOff } = cur.findPos(from, -1);
    let dLen = from - to;
    for (let view of elts)
        dLen += view.length;
    parent.length += dLen;
    let { children } = parent;
    // Both from and to point into the same text view
    if (fromI == toI && fromOff) {
        let start = children[fromI];
        // Maybe just update that view and be done
        if (elts.length == 1 && start.merge(fromOff, toOff, elts[0], openStart, openEnd))
            return;
        if (elts.length == 0) {
            start.merge(fromOff, toOff, null, openStart, openEnd);
            return;
        }
        // Otherwise split it, so that we don't have to worry about aliasing front/end afterwards
        let after = start.slice(toOff);
        if (after.merge(0, 0, elts[elts.length - 1], 0, openEnd))
            elts[elts.length - 1] = after;
        else
            elts.push(after);
        toI++;
        openEnd = toOff = 0;
    }
    // Make sure start and end positions fall on node boundaries
    // (fromOff/toOff are no longer used after this), and that if the
    // start or end of the elts can be merged with adjacent nodes,
    // this is done
    if (toOff) {
        let end = children[toI];
        if (elts.length && end.merge(0, toOff, elts[elts.length - 1], 0, openEnd)) {
            elts.pop();
            openEnd = 0;
        }
        else {
            end.merge(0, toOff, null, 0, 0);
        }
    }
    else if (toI < children.length && elts.length &&
        children[toI].merge(0, 0, elts[elts.length - 1], 0, openEnd)) {
        elts.pop();
        openEnd = 0;
    }
    if (fromOff) {
        let start = children[fromI];
        if (elts.length && start.merge(fromOff, start.length, elts[0], openStart, 0)) {
            elts.shift();
            openStart = 0;
        }
        else {
            start.merge(fromOff, start.length, null, 0, 0);
        }
        fromI++;
    }
    else if (fromI && elts.length) {
        let end = children[fromI - 1];
        if (end.merge(end.length, end.length, elts[0], openStart, 0)) {
            elts.shift();
            openStart = 0;
        }
    }
    // Then try to merge any mergeable nodes at the start and end of
    // the changed range
    while (fromI < toI && elts.length && children[toI - 1].become(elts[elts.length - 1])) {
        elts.pop();
        toI--;
        openEnd = 0;
    }
    while (fromI < toI && elts.length && children[fromI].become(elts[0])) {
        elts.shift();
        fromI++;
        openStart = 0;
    }
    if (!elts.length && fromI && toI < children.length && openStart && openEnd &&
        children[toI].merge(0, 0, children[fromI - 1], openStart, openEnd))
        fromI--;
    // And if anything remains, splice the child array to insert the new elts
    if (elts.length || fromI != toI)
        parent.replaceChildren(fromI, toI, elts);
}
function sliceInlineChildren(children, from) {
    let result = [], off = 0;
    for (let elt of children) {
        let end = off + elt.length;
        if (end > from)
            result.push(off < from ? elt.slice(from - off) : elt);
        off = end;
    }
    return result;
}
function inlineDOMAtPos(dom, children, pos) {
    let i = 0;
    for (let off = 0; i < children.length; i++) {
        let child = children[i], end = off + child.length;
        if (end == off && child.getSide() <= 0)
            continue;
        if (pos > off && pos < end && child.dom.parentNode == dom)
            return child.domAtPos(pos - off);
        if (pos <= off)
            break;
        off = end;
    }
    for (; i > 0; i--) {
        let before = children[i - 1].dom;
        if (before.parentNode == dom)
            return DOMPos.after(before);
    }
    return new DOMPos(dom, 0);
}
// Assumes `view`, if a mark view, has precisely 1 child.
function joinInlineInto(parent, view, open) {
    let last, { children } = parent;
    if (open > 0 && view instanceof MarkView && children.length &&
        (last = children[children.length - 1]) instanceof MarkView && last.mark.eq(view.mark)) {
        joinInlineInto(last, view.children[0], open - 1);
    }
    else {
        children.push(view);
        view.setParent(parent);
    }
    parent.length += view.length;
}
function coordsInChildren(view, pos, side) {
    for (let off = 0, i = 0; i < view.children.length; i++) {
        let child = view.children[i], end = off + child.length;
        if (end == off && child.getSide() <= 0)
            continue;
        if (side <= 0 || end == view.length ? end >= pos : end > pos)
            return child.coordsAt(pos - off, side);
        off = end;
    }
    return (view.dom.lastChild || view.dom).getBoundingClientRect();
}

function combineAttrs(source, target) {
    for (let name in source) {
        if (name == "class" && target.class)
            target.class += " " + source.class;
        else if (name == "style" && target.style)
            target.style += ";" + source.style;
        else
            target[name] = source[name];
    }
    return target;
}
function attrsEq(a, b) {
    if (a == b)
        return true;
    if (!a || !b)
        return false;
    let keysA = Object.keys(a), keysB = Object.keys(b);
    if (keysA.length != keysB.length)
        return false;
    for (let key of keysA) {
        if (keysB.indexOf(key) == -1 || a[key] !== b[key])
            return false;
    }
    return true;
}
function updateAttrs(dom, prev, attrs) {
    if (prev)
        for (let name in prev)
            if (!(attrs && name in attrs))
                dom.removeAttribute(name);
    if (attrs)
        for (let name in attrs)
            if (!(prev && prev[name] == attrs[name]))
                dom.setAttribute(name, attrs[name]);
}

/**
Widgets added to the content are described by subclasses of this
class. Using a description object like that makes it possible to
delay creating of the DOM structure for a widget until it is
needed, and to avoid redrawing widgets even when the decorations
that define them are recreated.
*/
class WidgetType {
    /**
    Compare this instance to another instance of the same type.
    (TypeScript can't express this, but only instances of the same
    specific class will be passed to this method.) This is used to
    avoid redrawing widgets when they are replaced by a new
    decoration of the same type. The default implementation just
    returns `false`, which will cause new instances of the widget to
    always be redrawn.
    */
    eq(_widget) { return false; }
    /**
    Update a DOM element created by a widget of the same type (but
    different, non-`eq` content) to reflect this widget. May return
    true to indicate that it could update, false to indicate it
    couldn't (in which case the widget will be redrawn). The default
    implementation just returns false.
    */
    updateDOM(_dom) { return false; }
    /**
    @internal
    */
    compare(other) {
        return this == other || this.constructor == other.constructor && this.eq(other);
    }
    /**
    The estimated height this widget will have, to be used when
    estimating the height of content that hasn't been drawn. May
    return -1 to indicate you don't know. The default implementation
    returns -1.
    */
    get estimatedHeight() { return -1; }
    /**
    Can be used to configure which kinds of events inside the widget
    should be ignored by the editor. The default is to ignore all
    events.
    */
    ignoreEvent(_event) { return true; }
    /**
    / @internal
    */
    get customView() { return null; }
}
/**
The different types of blocks that can occur in an editor view.
*/
exports.BlockType = void 0;
(function (BlockType) {
    /**
    A line of text.
    */
    BlockType[BlockType["Text"] = 0] = "Text";
    /**
    A block widget associated with the position after it.
    */
    BlockType[BlockType["WidgetBefore"] = 1] = "WidgetBefore";
    /**
    A block widget associated with the position before it.
    */
    BlockType[BlockType["WidgetAfter"] = 2] = "WidgetAfter";
    /**
    A block widget [replacing](https://codemirror.net/6/docs/ref/#view.Decoration^replace) a range of content.
    */
    BlockType[BlockType["WidgetRange"] = 3] = "WidgetRange";
})(exports.BlockType || (exports.BlockType = {}));
/**
A decoration provides information on how to draw or style a piece
of content. You'll usually use it wrapped in a
[`Range`](https://codemirror.net/6/docs/ref/#rangeset.Range), which adds a start and end position.
*/
class Decoration extends rangeset.RangeValue {
    /**
    @internal
    */
    constructor(
    /**
    @internal
    */
    startSide, 
    /**
    @internal
    */
    endSide, 
    /**
    @internal
    */
    widget, 
    /**
    The config object used to create this decoration. You can
    include additional properties in there to store metadata about
    your decoration.
    */
    spec) {
        super();
        this.startSide = startSide;
        this.endSide = endSide;
        this.widget = widget;
        this.spec = spec;
    }
    /**
    @internal
    */
    get heightRelevant() { return false; }
    /**
    Create a mark decoration, which influences the styling of the
    content in its range. Nested mark decorations will cause nested
    DOM elements to be created. Nesting order is determined by
    precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations) or
    (below the facet-provided decorations) [view
    plugin](https://codemirror.net/6/docs/ref/#view.PluginSpec.decorations). Such elements are split
    on line boundaries and on the boundaries of higher-precedence
    decorations.
    */
    static mark(spec) {
        return new MarkDecoration(spec);
    }
    /**
    Create a widget decoration, which adds an element at the given
    position.
    */
    static widget(spec) {
        let side = spec.side || 0;
        if (spec.block)
            side += (200000000 /* BigBlock */ + 1) * (side > 0 ? 1 : -1);
        return new PointDecoration(spec, side, side, !!spec.block, spec.widget || null, false);
    }
    /**
    Create a replace decoration which replaces the given range with
    a widget, or simply hides it.
    */
    static replace(spec) {
        let block = !!spec.block;
        let { start, end } = getInclusive(spec);
        let startSide = block ? -200000000 /* BigBlock */ * (start ? 2 : 1) : 100000000 /* BigInline */ * (start ? -1 : 1);
        let endSide = block ? 200000000 /* BigBlock */ * (end ? 2 : 1) : 100000000 /* BigInline */ * (end ? 1 : -1);
        return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);
    }
    /**
    Create a line decoration, which can add DOM attributes to the
    line starting at the given position.
    */
    static line(spec) {
        return new LineDecoration(spec);
    }
    /**
    Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
    decorated range or ranges. If the ranges aren't already sorted,
    pass `true` for `sort` to make the library sort them for you.
    */
    static set(of, sort = false) {
        return rangeset.RangeSet.of(of, sort);
    }
    /**
    @internal
    */
    hasHeight() { return this.widget ? this.widget.estimatedHeight > -1 : false; }
}
/**
The empty set of decorations.
*/
Decoration.none = rangeset.RangeSet.empty;
class MarkDecoration extends Decoration {
    constructor(spec) {
        let { start, end } = getInclusive(spec);
        super(100000000 /* BigInline */ * (start ? -1 : 1), 100000000 /* BigInline */ * (end ? 1 : -1), null, spec);
        this.tagName = spec.tagName || "span";
        this.class = spec.class || "";
        this.attrs = spec.attributes || null;
    }
    eq(other) {
        return this == other ||
            other instanceof MarkDecoration &&
                this.tagName == other.tagName &&
                this.class == other.class &&
                attrsEq(this.attrs, other.attrs);
    }
    range(from, to = from) {
        if (from >= to)
            throw new RangeError("Mark decorations may not be empty");
        return super.range(from, to);
    }
}
MarkDecoration.prototype.point = false;
class LineDecoration extends Decoration {
    constructor(spec) {
        super(-100000000 /* BigInline */, -100000000 /* BigInline */, null, spec);
    }
    eq(other) {
        return other instanceof LineDecoration && attrsEq(this.spec.attributes, other.spec.attributes);
    }
    range(from, to = from) {
        if (to != from)
            throw new RangeError("Line decoration ranges must be zero-length");
        return super.range(from, to);
    }
}
LineDecoration.prototype.mapMode = state.MapMode.TrackBefore;
LineDecoration.prototype.point = true;
class PointDecoration extends Decoration {
    constructor(spec, startSide, endSide, block, widget, isReplace) {
        super(startSide, endSide, widget, spec);
        this.block = block;
        this.isReplace = isReplace;
        this.mapMode = !block ? state.MapMode.TrackDel : startSide < 0 ? state.MapMode.TrackBefore : state.MapMode.TrackAfter;
    }
    // Only relevant when this.block == true
    get type() {
        return this.startSide < this.endSide ? exports.BlockType.WidgetRange
            : this.startSide < 0 ? exports.BlockType.WidgetBefore : exports.BlockType.WidgetAfter;
    }
    get heightRelevant() { return this.block || !!this.widget && this.widget.estimatedHeight >= 5; }
    eq(other) {
        return other instanceof PointDecoration &&
            widgetsEq(this.widget, other.widget) &&
            this.block == other.block &&
            this.startSide == other.startSide && this.endSide == other.endSide;
    }
    range(from, to = from) {
        if (this.isReplace && (from > to || (from == to && this.startSide > 0 && this.endSide < 0)))
            throw new RangeError("Invalid range for replacement decoration");
        if (!this.isReplace && to != from)
            throw new RangeError("Widget decorations can only have zero-length ranges");
        return super.range(from, to);
    }
}
PointDecoration.prototype.point = true;
function getInclusive(spec) {
    let { inclusiveStart: start, inclusiveEnd: end } = spec;
    if (start == null)
        start = spec.inclusive;
    if (end == null)
        end = spec.inclusive;
    return { start: start || false, end: end || false };
}
function widgetsEq(a, b) {
    return a == b || !!(a && b && a.compare(b));
}
function addRange(from, to, ranges, margin = 0) {
    let last = ranges.length - 1;
    if (last >= 0 && ranges[last] + margin > from)
        ranges[last] = Math.max(ranges[last], to);
    else
        ranges.push(from, to);
}

class LineView extends ContentView {
    constructor() {
        super(...arguments);
        this.children = [];
        this.length = 0;
        this.prevAttrs = undefined;
        this.attrs = null;
        this.breakAfter = 0;
    }
    // Consumes source
    merge(from, to, source, takeDeco, openStart, openEnd) {
        if (source) {
            if (!(source instanceof LineView))
                return false;
            if (!this.dom)
                source.transferDOM(this); // Reuse source.dom when appropriate
        }
        if (takeDeco)
            this.setDeco(source ? source.attrs : null);
        mergeInlineChildren(this, from, to, source ? source.children : none$1, openStart, openEnd);
        return true;
    }
    split(at) {
        let end = new LineView;
        end.breakAfter = this.breakAfter;
        if (this.length == 0)
            return end;
        let { i, off } = this.childPos(at);
        if (off) {
            end.append(this.children[i].slice(off), 0);
            this.children[i].merge(off, this.children[i].length, null, 0, 0);
            i++;
        }
        for (let j = i; j < this.children.length; j++)
            end.append(this.children[j], 0);
        while (i > 0 && this.children[i - 1].length == 0) {
            this.children[i - 1].parent = null;
            i--;
        }
        this.children.length = i;
        this.markDirty();
        this.length = at;
        return end;
    }
    transferDOM(other) {
        if (!this.dom)
            return;
        other.setDOM(this.dom);
        other.prevAttrs = this.prevAttrs === undefined ? this.attrs : this.prevAttrs;
        this.prevAttrs = undefined;
        this.dom = null;
    }
    setDeco(attrs) {
        if (!attrsEq(this.attrs, attrs)) {
            if (this.dom) {
                this.prevAttrs = this.attrs;
                this.markDirty();
            }
            this.attrs = attrs;
        }
    }
    // Only called when building a line view in ContentBuilder
    append(child, openStart) {
        joinInlineInto(this, child, openStart);
    }
    // Only called when building a line view in ContentBuilder
    addLineDeco(deco) {
        let attrs = deco.spec.attributes;
        if (attrs)
            this.attrs = combineAttrs(attrs, this.attrs || {});
    }
    domAtPos(pos) {
        return inlineDOMAtPos(this.dom, this.children, pos);
    }
    sync(track) {
        if (!this.dom) {
            this.setDOM(document.createElement("div"));
            this.dom.className = "cm-line";
            this.prevAttrs = this.attrs ? null : undefined;
        }
        if (this.prevAttrs !== undefined) {
            updateAttrs(this.dom, this.prevAttrs, this.attrs);
            this.dom.classList.add("cm-line");
            this.prevAttrs = undefined;
        }
        super.sync(track);
        let last = this.dom.lastChild;
        if (!last || (last.nodeName != "BR" && (ContentView.get(last) instanceof WidgetView))) {
            let hack = document.createElement("BR");
            hack.cmIgnore = true;
            this.dom.appendChild(hack);
        }
    }
    measureTextSize() {
        if (this.children.length == 0 || this.length > 20)
            return null;
        let totalWidth = 0;
        for (let child of this.children) {
            if (!(child instanceof TextView))
                return null;
            let rects = clientRectsFor(child.dom);
            if (rects.length != 1)
                return null;
            totalWidth += rects[0].width;
        }
        return { lineHeight: this.dom.getBoundingClientRect().height, charWidth: totalWidth / this.length };
    }
    coordsAt(pos, side) {
        return coordsInChildren(this, pos, side);
    }
    match(_other) { return false; }
    get type() { return exports.BlockType.Text; }
    static find(docView, pos) {
        for (let i = 0, off = 0;; i++) {
            let block = docView.children[i], end = off + block.length;
            if (end >= pos) {
                if (block instanceof LineView)
                    return block;
                if (block.length)
                    return null;
            }
            off = end + block.breakAfter;
        }
    }
}
const none$1 = [];
class BlockWidgetView extends ContentView {
    constructor(widget, length, type) {
        super();
        this.widget = widget;
        this.length = length;
        this.type = type;
        this.breakAfter = 0;
    }
    merge(from, to, source, _takeDeco, openStart, openEnd) {
        if (source && (!(source instanceof BlockWidgetView) || !this.widget.compare(source.widget) ||
            from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
            return false;
        this.length = from + (source ? source.length : 0) + (this.length - to);
        return true;
    }
    domAtPos(pos) {
        return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
    }
    split(at) {
        let len = this.length - at;
        this.length = at;
        return new BlockWidgetView(this.widget, len, this.type);
    }
    get children() { return none$1; }
    sync() {
        if (!this.dom || !this.widget.updateDOM(this.dom)) {
            this.setDOM(this.widget.toDOM(this.editorView));
            this.dom.contentEditable = "false";
        }
    }
    get overrideDOMText() {
        return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : state.Text.empty;
    }
    domBoundsAround() { return null; }
    match(other) {
        if (other instanceof BlockWidgetView && other.type == this.type &&
            other.widget.constructor == this.widget.constructor) {
            if (!other.widget.eq(this.widget))
                this.markDirty(true);
            this.widget = other.widget;
            this.length = other.length;
            this.breakAfter = other.breakAfter;
            return true;
        }
        return false;
    }
    ignoreMutation() { return true; }
    ignoreEvent(event) { return this.widget.ignoreEvent(event); }
}

class ContentBuilder {
    constructor(doc, pos, end) {
        this.doc = doc;
        this.pos = pos;
        this.end = end;
        this.content = [];
        this.curLine = null;
        this.breakAtStart = 0;
        this.openStart = -1;
        this.openEnd = -1;
        this.text = "";
        this.textOff = 0;
        this.cursor = doc.iter();
        this.skip = pos;
    }
    posCovered() {
        if (this.content.length == 0)
            return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
        let last = this.content[this.content.length - 1];
        return !last.breakAfter && !(last instanceof BlockWidgetView && last.type == exports.BlockType.WidgetBefore);
    }
    getLine() {
        if (!this.curLine)
            this.content.push(this.curLine = new LineView);
        return this.curLine;
    }
    addWidget(view) {
        this.curLine = null;
        this.content.push(view);
    }
    finish() {
        if (!this.posCovered())
            this.getLine();
    }
    wrapMarks(view, active) {
        for (let i = active.length - 1; i >= 0; i--)
            view = new MarkView(active[i], [view], view.length);
        return view;
    }
    buildText(length, active, openStart) {
        while (length > 0) {
            if (this.textOff == this.text.length) {
                let { value, lineBreak, done } = this.cursor.next(this.skip);
                this.skip = 0;
                if (done)
                    throw new Error("Ran out of text content when drawing inline views");
                if (lineBreak) {
                    if (!this.posCovered())
                        this.getLine();
                    if (this.content.length)
                        this.content[this.content.length - 1].breakAfter = 1;
                    else
                        this.breakAtStart = 1;
                    this.curLine = null;
                    length--;
                    continue;
                }
                else {
                    this.text = value;
                    this.textOff = 0;
                }
            }
            let take = Math.min(this.text.length - this.textOff, length, 512 /* Chunk */);
            this.getLine().append(this.wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);
            this.textOff += take;
            length -= take;
            openStart = 0;
        }
    }
    span(from, to, active, openStart) {
        this.buildText(to - from, active, openStart);
        this.pos = to;
        if (this.openStart < 0)
            this.openStart = openStart;
    }
    point(from, to, deco, active, openStart) {
        let len = to - from;
        if (deco instanceof PointDecoration) {
            if (deco.block) {
                let { type } = deco;
                if (type == exports.BlockType.WidgetAfter && !this.posCovered())
                    this.getLine();
                this.addWidget(new BlockWidgetView(deco.widget || new NullWidget("div"), len, type));
            }
            else {
                let widget = this.wrapMarks(WidgetView.create(deco.widget || new NullWidget("span"), len, deco.startSide), active);
                this.getLine().append(widget, openStart);
            }
        }
        else if (this.doc.lineAt(this.pos).from == this.pos) { // Line decoration
            this.getLine().addLineDeco(deco);
        }
        if (len) {
            // Advance the iterator past the replaced content
            if (this.textOff + len <= this.text.length) {
                this.textOff += len;
            }
            else {
                this.skip += len - (this.text.length - this.textOff);
                this.text = "";
                this.textOff = 0;
            }
            this.pos = to;
        }
        if (this.openStart < 0)
            this.openStart = openStart;
    }
    static build(text, from, to, decorations) {
        let builder = new ContentBuilder(text, from, to);
        builder.openEnd = rangeset.RangeSet.spans(decorations, from, to, builder);
        if (builder.openStart < 0)
            builder.openStart = builder.openEnd;
        builder.finish();
        return builder;
    }
}
class NullWidget extends WidgetType {
    constructor(tag) {
        super();
        this.tag = tag;
    }
    eq(other) { return other.tag == this.tag; }
    toDOM() { return document.createElement(this.tag); }
    updateDOM(elt) { return elt.nodeName.toLowerCase() == this.tag; }
}

const none = [];
const clickAddsSelectionRange = state.Facet.define();
const dragMovesSelection$1 = state.Facet.define();
const mouseSelectionStyle = state.Facet.define();
const exceptionSink = state.Facet.define();
const updateListener = state.Facet.define();
const inputHandler = state.Facet.define();
/**
Log or report an unhandled exception in client code. Should
probably only be used by extension code that allows client code to
provide functions, and calls those functions in a context where an
exception can't be propagated to calling code in a reasonable way
(for example when in an event handler).

Either calls a handler registered with
[`EditorView.exceptionSink`](https://codemirror.net/6/docs/ref/#view.EditorView^exceptionSink),
`window.onerror`, if defined, or `console.error` (in which case
it'll pass `context`, when given, as first argument).
*/
function logException(state, exception, context) {
    let handler = state.facet(exceptionSink);
    if (handler.length)
        handler[0](exception);
    else if (window.onerror)
        window.onerror(String(exception), context, undefined, undefined, exception);
    else if (context)
        console.error(context + ":", exception);
    else
        console.error(exception);
}
const editable = state.Facet.define({ combine: values => values.length ? values[0] : true });
/**
Used to [declare](https://codemirror.net/6/docs/ref/#view.PluginSpec.provide) which
[fields](https://codemirror.net/6/docs/ref/#view.PluginValue) a [view plugin](https://codemirror.net/6/docs/ref/#view.ViewPlugin)
provides.
*/
class PluginFieldProvider {
    /**
    @internal
    */
    constructor(
    /**
    @internal
    */
    field, 
    /**
    @internal
    */
    get) {
        this.field = field;
        this.get = get;
    }
}
/**
Plugin fields are a mechanism for allowing plugins to provide
values that can be retrieved through the
[`pluginField`](https://codemirror.net/6/docs/ref/#view.EditorView.pluginField) view method.
*/
class PluginField {
    /**
    Create a [provider](https://codemirror.net/6/docs/ref/#view.PluginFieldProvider) for this field,
    to use with a plugin's [provide](https://codemirror.net/6/docs/ref/#view.PluginSpec.provide)
    option.
    */
    from(get) {
        return new PluginFieldProvider(this, get);
    }
    /**
    Define a new plugin field.
    */
    static define() { return new PluginField(); }
}
/**
This field can be used by plugins to provide
[decorations](https://codemirror.net/6/docs/ref/#view.Decoration).

**Note**: For reasons of data flow (plugins are only updated
after the viewport is computed), decorations produced by plugins
are _not_ taken into account when predicting the vertical layout
structure of the editor. Thus, things like large widgets or big
replacements (i.e. code folding) should be provided through the
state-level [`decorations` facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations),
not this plugin field. Specifically, replacing decorations that
cross line boundaries will break if provided through a plugin.
*/
PluginField.decorations = PluginField.define();
/**
Plugins can provide additional scroll margins (space around the
sides of the scrolling element that should be considered
invisible) through this field. This can be useful when the
plugin introduces elements that cover part of that element (for
example a horizontally fixed gutter).
*/
PluginField.scrollMargins = PluginField.define();
let nextPluginID = 0;
const viewPlugin = state.Facet.define();
/**
View plugins associate stateful values with a view. They can
influence the way the content is drawn, and are notified of things
that happen in the view.
*/
class ViewPlugin {
    constructor(
    /**
    @internal
    */
    id, 
    /**
    @internal
    */
    create, 
    /**
    @internal
    */
    fields) {
        this.id = id;
        this.create = create;
        this.fields = fields;
        this.extension = viewPlugin.of(this);
    }
    /**
    Define a plugin from a constructor function that creates the
    plugin's value, given an editor view.
    */
    static define(create, spec) {
        let { eventHandlers, provide, decorations } = spec || {};
        let fields = [];
        if (provide)
            for (let provider of Array.isArray(provide) ? provide : [provide])
                fields.push(provider);
        if (eventHandlers)
            fields.push(domEventHandlers.from((value) => ({ plugin: value, handlers: eventHandlers })));
        if (decorations)
            fields.push(PluginField.decorations.from(decorations));
        return new ViewPlugin(nextPluginID++, create, fields);
    }
    /**
    Create a plugin for a class whose constructor takes a single
    editor view as argument.
    */
    static fromClass(cls, spec) {
        return ViewPlugin.define(view => new cls(view), spec);
    }
}
const domEventHandlers = PluginField.define();
class PluginInstance {
    constructor(spec) {
        this.spec = spec;
        // When starting an update, all plugins have this field set to the
        // update object, indicating they need to be updated. When finished
        // updating, it is set to `false`. Retrieving a plugin that needs to
        // be updated with `view.plugin` forces an eager update.
        this.mustUpdate = null;
        // This is null when the plugin is initially created, but
        // initialized on the first update.
        this.value = null;
    }
    takeField(type, target) {
        for (let { field, get } of this.spec.fields)
            if (field == type)
                target.push(get(this.value));
    }
    update(view) {
        if (!this.value) {
            try {
                this.value = this.spec.create(view);
            }
            catch (e) {
                logException(view.state, e, "CodeMirror plugin crashed");
                return PluginInstance.dummy;
            }
        }
        else if (this.mustUpdate) {
            let update = this.mustUpdate;
            this.mustUpdate = null;
            if (!this.value.update)
                return this;
            try {
                this.value.update(update);
            }
            catch (e) {
                logException(update.state, e, "CodeMirror plugin crashed");
                if (this.value.destroy)
                    try {
                        this.value.destroy();
                    }
                    catch (_) { }
                return PluginInstance.dummy;
            }
        }
        return this;
    }
    destroy(view) {
        var _a;
        if ((_a = this.value) === null || _a === void 0 ? void 0 : _a.destroy) {
            try {
                this.value.destroy();
            }
            catch (e) {
                logException(view.state, e, "CodeMirror plugin crashed");
            }
        }
    }
}
PluginInstance.dummy = new PluginInstance(ViewPlugin.define(() => ({})));
const editorAttributes = state.Facet.define({
    combine: values => values.reduce((a, b) => combineAttrs(b, a), {})
});
const contentAttributes = state.Facet.define({
    combine: values => values.reduce((a, b) => combineAttrs(b, a), {})
});
// Provide decorations
const decorations = state.Facet.define();
const styleModule = state.Facet.define();
class ChangedRange {
    constructor(fromA, toA, fromB, toB) {
        this.fromA = fromA;
        this.toA = toA;
        this.fromB = fromB;
        this.toB = toB;
    }
    join(other) {
        return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));
    }
    addToSet(set) {
        let i = set.length, me = this;
        for (; i > 0; i--) {
            let range = set[i - 1];
            if (range.fromA > me.toA)
                continue;
            if (range.toA < me.fromA)
                break;
            me = me.join(range);
            set.splice(i - 1, 1);
        }
        set.splice(i, 0, me);
        return set;
    }
    static extendWithRanges(diff, ranges) {
        if (ranges.length == 0)
            return diff;
        let result = [];
        for (let dI = 0, rI = 0, posA = 0, posB = 0;; dI++) {
            let next = dI == diff.length ? null : diff[dI], off = posA - posB;
            let end = next ? next.fromB : 1e9;
            while (rI < ranges.length && ranges[rI] < end) {
                let from = ranges[rI], to = ranges[rI + 1];
                let fromB = Math.max(posB, from), toB = Math.min(end, to);
                if (fromB <= toB)
                    new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);
                if (to > end)
                    break;
                else
                    rI += 2;
            }
            if (!next)
                return result;
            new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);
            posA = next.toA;
            posB = next.toB;
        }
    }
}
/**
View [plugins](https://codemirror.net/6/docs/ref/#view.ViewPlugin) are given instances of this
class, which describe what happened, whenever the view is updated.
*/
class ViewUpdate {
    /**
    @internal
    */
    constructor(
    /**
    The editor view that the update is associated with.
    */
    view, 
    /**
    The new editor state.
    */
    state$1, 
    /**
    The transactions involved in the update. May be empty.
    */
    transactions = none) {
        this.view = view;
        this.state = state$1;
        this.transactions = transactions;
        /**
        @internal
        */
        this.flags = 0;
        this.startState = view.state;
        this.changes = state.ChangeSet.empty(this.startState.doc.length);
        for (let tr of transactions)
            this.changes = this.changes.compose(tr.changes);
        let changedRanges = [];
        this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));
        this.changedRanges = changedRanges;
        let focus = view.hasFocus;
        if (focus != view.inputState.notifiedFocused) {
            view.inputState.notifiedFocused = focus;
            this.flags |= 1 /* Focus */;
        }
        if (this.docChanged)
            this.flags |= 2 /* Height */;
    }
    /**
    Tells you whether the viewport changed in this update.
    */
    get viewportChanged() {
        return (this.flags & 4 /* Viewport */) > 0;
    }
    /**
    Indicates whether the line height in the editor changed in this update.
    */
    get heightChanged() {
        return (this.flags & 2 /* Height */) > 0;
    }
    /**
    Returns true when the document changed or the size of the editor
    or the lines or characters within it has changed.
    */
    get geometryChanged() {
        return this.docChanged || (this.flags & (16 /* Geometry */ | 2 /* Height */)) > 0;
    }
    /**
    True when this update indicates a focus change.
    */
    get focusChanged() {
        return (this.flags & 1 /* Focus */) > 0;
    }
    /**
    Whether the document changed in this update.
    */
    get docChanged() {
        return this.transactions.some(tr => tr.docChanged);
    }
    /**
    Whether the selection was explicitly set in this update.
    */
    get selectionSet() {
        return this.transactions.some(tr => tr.selection);
    }
    /**
    @internal
    */
    get empty() { return this.flags == 0 && this.transactions.length == 0; }
}

class DocView extends ContentView {
    constructor(view) {
        super();
        this.view = view;
        this.compositionDeco = Decoration.none;
        this.decorations = [];
        // Track a minimum width for the editor. When measuring sizes in
        // checkLayout, this is updated to point at the width of a given
        // element and its extent in the document. When a change happens in
        // that range, these are reset. That way, once we've seen a
        // line/element of a given length, we keep the editor wide enough to
        // fit at least that element, until it is changed, at which point we
        // forget it again.
        this.minWidth = 0;
        this.minWidthFrom = 0;
        this.minWidthTo = 0;
        // Track whether the DOM selection was set in a lossy way, so that
        // we don't mess it up when reading it back it
        this.impreciseAnchor = null;
        this.impreciseHead = null;
        this.setDOM(view.contentDOM);
        this.children = [new LineView];
        this.children[0].setParent(this);
        this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], this.updateDeco(), 0);
    }
    get root() { return this.view.root; }
    get editorView() { return this.view; }
    get length() { return this.view.state.doc.length; }
    // Update the document view to a given state. scrollIntoView can be
    // used as a hint to compute a new viewport that includes that
    // position, if we know the editor is going to scroll that position
    // into view.
    update(update) {
        let changedRanges = update.changedRanges;
        if (this.minWidth > 0 && changedRanges.length) {
            if (!changedRanges.every(({ fromA, toA }) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {
                this.minWidth = 0;
            }
            else {
                this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);
                this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);
            }
        }
        if (this.view.inputState.composing < 0)
            this.compositionDeco = Decoration.none;
        else if (update.transactions.length)
            this.compositionDeco = computeCompositionDeco(this.view, update.changes);
        // When the DOM nodes around the selection are moved to another
        // parent, Chrome sometimes reports a different selection through
        // getSelection than the one that it actually shows to the user.
        // This forces a selection update when lines are joined to work
        // around that. Issue #54
        let forceSelection = (browser.ie || browser.chrome) && !this.compositionDeco.size && update &&
            update.state.doc.lines != update.startState.doc.lines;
        let prevDeco = this.decorations, deco = this.updateDeco();
        let decoDiff = findChangedDeco(prevDeco, deco, update.changes);
        changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);
        let pointerSel = update.transactions.some(tr => tr.annotation(state.Transaction.userEvent) == "pointerselection");
        if (this.dirty == 0 /* Not */ && changedRanges.length == 0 &&
            !(update.flags & (4 /* Viewport */ | 8 /* LineGaps */)) &&
            update.state.selection.main.from >= this.view.viewport.from &&
            update.state.selection.main.to <= this.view.viewport.to) {
            this.updateSelection(forceSelection, pointerSel);
            return false;
        }
        else {
            this.updateInner(changedRanges, deco, update.startState.doc.length, forceSelection, pointerSel);
            return true;
        }
    }
    // Used both by update and checkLayout do perform the actual DOM
    // update
    updateInner(changes, deco, oldLength, forceSelection = false, pointerSel = false) {
        this.updateChildren(changes, deco, oldLength);
        this.view.observer.ignore(() => {
            // Lock the height during redrawing, since Chrome sometimes
            // messes with the scroll position during DOM mutation (though
            // no relayout is triggered and I cannot imagine how it can
            // recompute the scroll position without a layout)
            this.dom.style.height = this.view.viewState.domHeight + "px";
            this.dom.style.minWidth = this.minWidth ? this.minWidth + "px" : "";
            // Chrome will sometimes, when DOM mutations occur directly
            // around the selection, get confused and report a different
            // selection from the one it displays (issue #218). This tries
            // to detect that situation.
            let track = browser.chrome ? { node: getSelection(this.view.root).focusNode, written: false } : undefined;
            this.sync(track);
            this.dirty = 0 /* Not */;
            if (track === null || track === void 0 ? void 0 : track.written)
                forceSelection = true;
            this.updateSelection(forceSelection, pointerSel);
            this.dom.style.height = "";
        });
    }
    updateChildren(changes, deco, oldLength) {
        let cursor = this.childCursor(oldLength);
        for (let i = changes.length - 1;; i--) {
            let next = i >= 0 ? changes[i] : null;
            if (!next)
                break;
            let { fromA, toA, fromB, toB } = next;
            let { content, breakAtStart, openStart, openEnd } = ContentBuilder.build(this.view.state.doc, fromB, toB, deco);
            let { i: toI, off: toOff } = cursor.findPos(toA, 1);
            let { i: fromI, off: fromOff } = cursor.findPos(fromA, -1);
            this.replaceRange(fromI, fromOff, toI, toOff, content, breakAtStart, openStart, openEnd);
        }
    }
    replaceRange(fromI, fromOff, toI, toOff, content, breakAtStart, openStart, openEnd) {
        let before = this.children[fromI], last = content.length ? content[content.length - 1] : null;
        let breakAtEnd = last ? last.breakAfter : breakAtStart;
        // Change within a single line
        if (fromI == toI && !breakAtStart && !breakAtEnd && content.length < 2 &&
            before.merge(fromOff, toOff, content.length ? last : null, fromOff == 0, openStart, openEnd))
            return;
        let after = this.children[toI];
        // Make sure the end of the line after the update is preserved in `after`
        if (toOff < after.length || after.children.length && after.children[after.children.length - 1].length == 0) {
            // If we're splitting a line, separate part of the start line to
            // avoid that being mangled when updating the start line.
            if (fromI == toI) {
                after = after.split(toOff);
                toOff = 0;
            }
            // If the element after the replacement should be merged with
            // the last replacing element, update `content`
            if (!breakAtEnd && last && after.merge(0, toOff, last, true, 0, openEnd)) {
                content[content.length - 1] = after;
            }
            else {
                // Remove the start of the after element, if necessary, and
                // add it to `content`.
                if (toOff || after.children.length && after.children[0].length == 0)
                    after.merge(0, toOff, null, false, 0, openEnd);
                content.push(after);
            }
        }
        else if (after.breakAfter) {
            // The element at `toI` is entirely covered by this range.
            // Preserve its line break, if any.
            if (last)
                last.breakAfter = 1;
            else
                breakAtStart = 1;
        }
        // Since we've handled the next element from the current elements
        // now, make sure `toI` points after that.
        toI++;
        before.breakAfter = breakAtStart;
        if (fromOff > 0) {
            if (!breakAtStart && content.length && before.merge(fromOff, before.length, content[0], false, openStart, 0)) {
                before.breakAfter = content.shift().breakAfter;
            }
            else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {
                before.merge(fromOff, before.length, null, false, openStart, 0);
            }
            fromI++;
        }
        // Try to merge widgets on the boundaries of the replacement
        while (fromI < toI && content.length) {
            if (this.children[toI - 1].match(content[content.length - 1]))
                toI--, content.pop();
            else if (this.children[fromI].match(content[0]))
                fromI++, content.shift();
            else
                break;
        }
        if (fromI < toI || content.length)
            this.replaceChildren(fromI, toI, content);
    }
    // Sync the DOM selection to this.state.selection
    updateSelection(force = false, fromPointer = false) {
        if (!(fromPointer || this.mayControlSelection()))
            return;
        let main = this.view.state.selection.main;
        // FIXME need to handle the case where the selection falls inside a block range
        let anchor = this.domAtPos(main.anchor);
        let head = main.empty ? anchor : this.domAtPos(main.head);
        if (browser.gecko && main.empty && betweenUneditable(anchor)) {
            let dummy = document.createTextNode("");
            this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));
            anchor = head = new DOMPos(dummy, 0);
            force = true;
        }
        let domSel = getSelection(this.root);
        // If the selection is already here, or in an equivalent position, don't touch it
        if (force || !domSel.focusNode ||
            (browser.gecko && main.empty && nextToUneditable(domSel.focusNode, domSel.focusOffset)) ||
            !isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) ||
            !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) {
            this.view.observer.ignore(() => {
                if (main.empty) {
                    // Work around https://bugzilla.mozilla.org/show_bug.cgi?id=1612076
                    if (browser.gecko) {
                        let nextTo = nextToUneditable(anchor.node, anchor.offset);
                        if (nextTo && nextTo != (1 /* Before */ | 2 /* After */)) {
                            let text = nearbyTextNode(anchor.node, anchor.offset, nextTo == 1 /* Before */ ? 1 : -1);
                            if (text)
                                anchor = new DOMPos(text, nextTo == 1 /* Before */ ? 0 : text.nodeValue.length);
                        }
                    }
                    domSel.collapse(anchor.node, anchor.offset);
                    if (main.bidiLevel != null && domSel.cursorBidiLevel != null)
                        domSel.cursorBidiLevel = main.bidiLevel;
                }
                else if (domSel.extend) {
                    // Selection.extend can be used to create an 'inverted' selection
                    // (one where the focus is before the anchor), but not all
                    // browsers support it yet.
                    domSel.collapse(anchor.node, anchor.offset);
                    domSel.extend(head.node, head.offset);
                }
                else {
                    // Primitive (IE) way
                    let range = document.createRange();
                    if (main.anchor > main.head)
                        [anchor, head] = [head, anchor];
                    range.setEnd(head.node, head.offset);
                    range.setStart(anchor.node, anchor.offset);
                    domSel.removeAllRanges();
                    domSel.addRange(range);
                }
            });
        }
        this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);
        this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);
    }
    enforceCursorAssoc() {
        let cursor = this.view.state.selection.main;
        let sel = getSelection(this.root);
        if (!cursor.empty || !cursor.assoc || !sel.modify)
            return;
        let line = LineView.find(this, cursor.head); // FIXME provide view-line-range finding helper
        if (!line)
            return;
        let lineStart = line.posAtStart;
        if (cursor.head == lineStart || cursor.head == lineStart + line.length)
            return;
        let before = this.coordsAt(cursor.head, -1), after = this.coordsAt(cursor.head, 1);
        if (!before || !after || before.bottom > after.top)
            return;
        let dom = this.domAtPos(cursor.head + cursor.assoc);
        sel.collapse(dom.node, dom.offset);
        sel.modify("move", cursor.assoc < 0 ? "forward" : "backward", "lineboundary");
    }
    mayControlSelection() {
        return this.view.state.facet(editable) ? this.root.activeElement == this.dom : hasSelection(this.dom, getSelection(this.root));
    }
    nearest(dom) {
        for (let cur = dom; cur;) {
            let domView = ContentView.get(cur);
            if (domView && domView.rootView == this)
                return domView;
            cur = cur.parentNode;
        }
        return null;
    }
    posFromDOM(node, offset) {
        let view = this.nearest(node);
        if (!view)
            throw new RangeError("Trying to find position for a DOM position outside of the document");
        return view.localPosFromDOM(node, offset) + view.posAtStart;
    }
    domAtPos(pos) {
        let { i, off } = this.childCursor().findPos(pos, -1);
        for (; i < this.children.length - 1;) {
            let child = this.children[i];
            if (off < child.length || child instanceof LineView)
                break;
            i++;
            off = 0;
        }
        return this.children[i].domAtPos(off);
    }
    coordsAt(pos, side) {
        for (let off = this.length, i = this.children.length - 1;; i--) {
            let child = this.children[i], start = off - child.breakAfter - child.length;
            if (pos > start || pos == start && (child.type == exports.BlockType.Text || !i || this.children[i - 1].breakAfter))
                return child.coordsAt(pos - start, side);
            off = start;
        }
    }
    measureVisibleLineHeights() {
        let result = [], { from, to } = this.view.viewState.viewport;
        let minWidth = Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;
        for (let pos = 0, i = 0; i < this.children.length; i++) {
            let child = this.children[i], end = pos + child.length;
            if (end > to)
                break;
            if (pos >= from) {
                result.push(child.dom.getBoundingClientRect().height);
                let width = child.dom.scrollWidth;
                if (width > minWidth) {
                    this.minWidth = minWidth = width;
                    this.minWidthFrom = pos;
                    this.minWidthTo = end;
                }
            }
            pos = end + child.breakAfter;
        }
        return result;
    }
    measureTextSize() {
        for (let child of this.children) {
            if (child instanceof LineView) {
                let measure = child.measureTextSize();
                if (measure)
                    return measure;
            }
        }
        // If no workable line exists, force a layout of a measurable element
        let dummy = document.createElement("div"), lineHeight, charWidth;
        dummy.className = "cm-line";
        dummy.textContent = "abc def ghi jkl mno pqr stu";
        this.view.observer.ignore(() => {
            this.dom.appendChild(dummy);
            let rect = clientRectsFor(dummy.firstChild)[0];
            lineHeight = dummy.getBoundingClientRect().height;
            charWidth = rect ? rect.width / 27 : 7;
            dummy.remove();
        });
        return { lineHeight, charWidth };
    }
    childCursor(pos = this.length) {
        // Move back to start of last element when possible, so that
        // `ChildCursor.findPos` doesn't have to deal with the edge case
        // of being after the last element.
        let i = this.children.length;
        if (i)
            pos -= this.children[--i].length;
        return new ChildCursor(this.children, pos, i);
    }
    computeBlockGapDeco() {
        let deco = [], vs = this.view.viewState;
        for (let pos = 0, i = 0;; i++) {
            let next = i == vs.viewports.length ? null : vs.viewports[i];
            let end = next ? next.from - 1 : this.length;
            if (end > pos) {
                let height = vs.lineAt(end, 0).bottom - vs.lineAt(pos, 0).top;
                deco.push(Decoration.replace({ widget: new BlockGapWidget(height), block: true, inclusive: true }).range(pos, end));
            }
            if (!next)
                break;
            pos = next.to + 1;
        }
        return Decoration.set(deco);
    }
    updateDeco() {
        return this.decorations = [
            this.computeBlockGapDeco(),
            this.view.viewState.lineGapDeco,
            this.compositionDeco,
            ...this.view.state.facet(decorations),
            ...this.view.pluginField(PluginField.decorations)
        ];
    }
    scrollPosIntoView(pos, side) {
        let rect = this.coordsAt(pos, side);
        if (!rect)
            return;
        let mLeft = 0, mRight = 0, mTop = 0, mBottom = 0;
        for (let margins of this.view.pluginField(PluginField.scrollMargins))
            if (margins) {
                let { left, right, top, bottom } = margins;
                if (left != null)
                    mLeft = Math.max(mLeft, left);
                if (right != null)
                    mRight = Math.max(mRight, right);
                if (top != null)
                    mTop = Math.max(mTop, top);
                if (bottom != null)
                    mBottom = Math.max(mBottom, bottom);
            }
        scrollRectIntoView(this.dom, {
            left: rect.left - mLeft, top: rect.top - mTop,
            right: rect.right + mRight, bottom: rect.bottom + mBottom
        });
    }
}
function betweenUneditable(pos) {
    return pos.node.nodeType == 1 && pos.node.firstChild &&
        (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == "false") &&
        (pos.offset < pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == "false");
}
class BlockGapWidget extends WidgetType {
    constructor(height) {
        super();
        this.height = height;
    }
    toDOM() {
        let elt = document.createElement("div");
        this.updateDOM(elt);
        return elt;
    }
    eq(other) { return other.height == this.height; }
    updateDOM(elt) {
        elt.style.height = this.height + "px";
        return true;
    }
    get estimatedHeight() { return this.height; }
}
function computeCompositionDeco(view, changes) {
    let sel = getSelection(view.root);
    let textNode = sel.focusNode && nearbyTextNode(sel.focusNode, sel.focusOffset, 0);
    if (!textNode)
        return Decoration.none;
    let cView = view.docView.nearest(textNode);
    let from, to, topNode = textNode;
    if (cView instanceof InlineView) {
        while (cView.parent instanceof InlineView)
            cView = cView.parent;
        from = cView.posAtStart;
        to = from + cView.length;
        topNode = cView.dom;
    }
    else if (cView instanceof LineView) {
        while (topNode.parentNode != cView.dom)
            topNode = topNode.parentNode;
        let prev = topNode.previousSibling;
        while (prev && !ContentView.get(prev))
            prev = prev.previousSibling;
        from = to = prev ? ContentView.get(prev).posAtEnd : cView.posAtStart;
    }
    else {
        return Decoration.none;
    }
    let newFrom = changes.mapPos(from, 1), newTo = Math.max(newFrom, changes.mapPos(to, -1));
    let text = textNode.nodeValue, { state } = view;
    if (newTo - newFrom < text.length) {
        if (state.sliceDoc(newFrom, Math.min(state.doc.length, newFrom + text.length)) == text)
            newTo = newFrom + text.length;
        else if (state.sliceDoc(Math.max(0, newTo - text.length), newTo) == text)
            newFrom = newTo - text.length;
        else
            return Decoration.none;
    }
    else if (state.sliceDoc(newFrom, newTo) != text) {
        return Decoration.none;
    }
    return Decoration.set(Decoration.replace({ widget: new CompositionWidget(topNode, textNode) }).range(newFrom, newTo));
}
class CompositionWidget extends WidgetType {
    constructor(top, text) {
        super();
        this.top = top;
        this.text = text;
    }
    eq(other) { return this.top == other.top && this.text == other.text; }
    toDOM() { return this.top; }
    ignoreEvent() { return false; }
    get customView() { return CompositionView; }
}
function nearbyTextNode(node, offset, side) {
    for (;;) {
        if (node.nodeType == 3)
            return node;
        if (node.nodeType == 1 && offset > 0 && side <= 0) {
            node = node.childNodes[offset - 1];
            offset = maxOffset(node);
        }
        else if (node.nodeType == 1 && offset < node.childNodes.length && side >= 0) {
            node = node.childNodes[offset];
            offset = 0;
        }
        else {
            return null;
        }
    }
}
function nextToUneditable(node, offset) {
    if (node.nodeType != 1)
        return 0;
    return (offset && node.childNodes[offset - 1].contentEditable == "false" ? 1 /* Before */ : 0) |
        (offset < node.childNodes.length && node.childNodes[offset].contentEditable == "false" ? 2 /* After */ : 0);
}
class DecorationComparator$1 {
    constructor() {
        this.changes = [];
    }
    compareRange(from, to) { addRange(from, to, this.changes); }
    comparePoint(from, to) { addRange(from, to, this.changes); }
}
function findChangedDeco(a, b, diff) {
    let comp = new DecorationComparator$1;
    rangeset.RangeSet.compare(a, b, diff, comp);
    return comp.changes;
}

/**
Used to indicate [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
*/
exports.Direction = void 0;
(function (Direction) {
    // (These are chosen to match the base levels, in bidi algorithm
    // terms, of spans in that direction.)
    /**
    Left-to-right.
    */
    Direction[Direction["LTR"] = 0] = "LTR";
    /**
    Right-to-left.
    */
    Direction[Direction["RTL"] = 1] = "RTL";
})(exports.Direction || (exports.Direction = {}));
const LTR = exports.Direction.LTR, RTL = exports.Direction.RTL;
// Decode a string with each type encoded as log2(type)
function dec(str) {
    let result = [];
    for (let i = 0; i < str.length; i++)
        result.push(1 << +str[i]);
    return result;
}
// Character types for codepoints 0 to 0xf8
const LowTypes = dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008");
// Character types for codepoints 0x600 to 0x6f9
const ArabicTypes = dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333");
const Brackets = Object.create(null), BracketStack = [];
// There's a lot more in
// https://www.unicode.org/Public/UCD/latest/ucd/BidiBrackets.txt,
// which are left out to keep code size down.
for (let p of ["()", "[]", "{}"]) {
    let l = p.charCodeAt(0), r = p.charCodeAt(1);
    Brackets[l] = r;
    Brackets[r] = -l;
}
function charType(ch) {
    return ch <= 0xf7 ? LowTypes[ch] :
        0x590 <= ch && ch <= 0x5f4 ? 2 /* R */ :
            0x600 <= ch && ch <= 0x6f9 ? ArabicTypes[ch - 0x600] :
                0x6ee <= ch && ch <= 0x8ac ? 4 /* AL */ :
                    0x2000 <= ch && ch <= 0x200b ? 256 /* NI */ :
                        ch == 0x200c ? 256 /* NI */ : 1 /* L */;
}
const BidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
/**
Represents a contiguous range of text that has a single direction
(as in left-to-right or right-to-left).
*/
class BidiSpan {
    /**
    @internal
    */
    constructor(
    /**
    The start of the span (relative to the start of the line).
    */
    from, 
    /**
    The end of the span.
    */
    to, 
    /**
    The ["bidi
    level"](https://unicode.org/reports/tr9/#Basic_Display_Algorithm)
    of the span (in this context, 0 means
    left-to-right, 1 means right-to-left, 2 means left-to-right
    number inside right-to-left text).
    */
    level) {
        this.from = from;
        this.to = to;
        this.level = level;
    }
    /**
    The direction of this span.
    */
    get dir() { return this.level % 2 ? RTL : LTR; }
    /**
    @internal
    */
    side(end, dir) { return (this.dir == dir) == end ? this.to : this.from; }
    /**
    @internal
    */
    static find(order, index, level, assoc) {
        let maybe = -1;
        for (let i = 0; i < order.length; i++) {
            let span = order[i];
            if (span.from <= index && span.to >= index) {
                if (span.level == level)
                    return i;
                // When multiple spans match, if assoc != 0, take the one that
                // covers that side, otherwise take the one with the minimum
                // level.
                if (maybe < 0 || (assoc != 0 ? (assoc < 0 ? span.from < index : span.to > index) : order[maybe].level > span.level))
                    maybe = i;
            }
        }
        if (maybe < 0)
            throw new RangeError("Index out of range");
        return maybe;
    }
}
// Reused array of character types
const types = [];
function computeOrder(line, direction) {
    let len = line.length, outerType = direction == LTR ? 1 /* L */ : 2 /* R */, oppositeType = direction == LTR ? 2 /* R */ : 1 /* L */;
    if (!line || outerType == 1 /* L */ && !BidiRE.test(line))
        return trivialOrder(len);
    // W1. Examine each non-spacing mark (NSM) in the level run, and
    // change the type of the NSM to the type of the previous
    // character. If the NSM is at the start of the level run, it will
    // get the type of sor.
    // W2. Search backwards from each instance of a European number
    // until the first strong type (R, L, AL, or sor) is found. If an
    // AL is found, change the type of the European number to Arabic
    // number.
    // W3. Change all ALs to R.
    // (Left after this: L, R, EN, AN, ET, CS, NI)
    for (let i = 0, prev = outerType, prevStrong = outerType; i < len; i++) {
        let type = charType(line.charCodeAt(i));
        if (type == 512 /* NSM */)
            type = prev;
        else if (type == 8 /* EN */ && prevStrong == 4 /* AL */)
            type = 16 /* AN */;
        types[i] = type == 4 /* AL */ ? 2 /* R */ : type;
        if (type & 7 /* Strong */)
            prevStrong = type;
        prev = type;
    }
    // W5. A sequence of European terminators adjacent to European
    // numbers changes to all European numbers.
    // W6. Otherwise, separators and terminators change to Other
    // Neutral.
    // W7. Search backwards from each instance of a European number
    // until the first strong type (R, L, or sor) is found. If an L is
    // found, then change the type of the European number to L.
    // (Left after this: L, R, EN+AN, NI)
    for (let i = 0, prev = outerType, prevStrong = outerType; i < len; i++) {
        let type = types[i];
        if (type == 128 /* CS */) {
            if (i < len - 1 && prev == types[i + 1] && (prev & 24 /* Num */))
                type = types[i] = prev;
            else
                types[i] = 256 /* NI */;
        }
        else if (type == 64 /* ET */) {
            let end = i + 1;
            while (end < len && types[end] == 64 /* ET */)
                end++;
            let replace = (i && prev == 8 /* EN */) || (end < len && types[end] == 8 /* EN */) ? (prevStrong == 1 /* L */ ? 1 /* L */ : 8 /* EN */) : 256 /* NI */;
            for (let j = i; j < end; j++)
                types[j] = replace;
            i = end - 1;
        }
        else if (type == 8 /* EN */ && prevStrong == 1 /* L */) {
            types[i] = 1 /* L */;
        }
        prev = type;
        if (type & 7 /* Strong */)
            prevStrong = type;
    }
    // N0. Process bracket pairs in an isolating run sequence
    // sequentially in the logical order of the text positions of the
    // opening paired brackets using the logic given below. Within this
    // scope, bidirectional types EN and AN are treated as R.
    for (let i = 0, sI = 0, context = 0, ch, br, type; i < len; i++) {
        // Keeps [startIndex, type, strongSeen] triples for each open
        // bracket on BracketStack.
        if (br = Brackets[ch = line.charCodeAt(i)]) {
            if (br < 0) { // Closing bracket
                for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
                    if (BracketStack[sJ + 1] == -br) {
                        let flags = BracketStack[sJ + 2];
                        let type = (flags & 2 /* EmbedInside */) ? outerType :
                            !(flags & 4 /* OppositeInside */) ? 0 :
                                (flags & 1 /* OppositeBefore */) ? oppositeType : outerType;
                        if (type)
                            types[i] = types[BracketStack[sJ]] = type;
                        sI = sJ;
                        break;
                    }
                }
            }
            else if (BracketStack.length == 189 /* MaxDepth */) {
                break;
            }
            else {
                BracketStack[sI++] = i;
                BracketStack[sI++] = ch;
                BracketStack[sI++] = context;
            }
        }
        else if ((type = types[i]) == 2 /* R */ || type == 1 /* L */) {
            let embed = type == outerType;
            context = embed ? 0 : 1 /* OppositeBefore */;
            for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
                let cur = BracketStack[sJ + 2];
                if (cur & 2 /* EmbedInside */)
                    break;
                if (embed) {
                    BracketStack[sJ + 2] |= 2 /* EmbedInside */;
                }
                else {
                    if (cur & 4 /* OppositeInside */)
                        break;
                    BracketStack[sJ + 2] |= 4 /* OppositeInside */;
                }
            }
        }
    }
    // N1. A sequence of neutrals takes the direction of the
    // surrounding strong text if the text on both sides has the same
    // direction. European and Arabic numbers act as if they were R in
    // terms of their influence on neutrals. Start-of-level-run (sor)
    // and end-of-level-run (eor) are used at level run boundaries.
    // N2. Any remaining neutrals take the embedding direction.
    // (Left after this: L, R, EN+AN)
    for (let i = 0; i < len; i++) {
        if (types[i] == 256 /* NI */) {
            let end = i + 1;
            while (end < len && types[end] == 256 /* NI */)
                end++;
            let beforeL = (i ? types[i - 1] : outerType) == 1 /* L */;
            let afterL = (end < len ? types[end] : outerType) == 1 /* L */;
            let replace = beforeL == afterL ? (beforeL ? 1 /* L */ : 2 /* R */) : outerType;
            for (let j = i; j < end; j++)
                types[j] = replace;
            i = end - 1;
        }
    }
    // Here we depart from the documented algorithm, in order to avoid
    // building up an actual levels array. Since there are only three
    // levels (0, 1, 2) in an implementation that doesn't take
    // explicit embedding into account, we can build up the order on
    // the fly, without following the level-based algorithm.
    let order = [];
    if (outerType == 1 /* L */) {
        for (let i = 0; i < len;) {
            let start = i, rtl = types[i++] != 1 /* L */;
            while (i < len && rtl == (types[i] != 1 /* L */))
                i++;
            if (rtl) {
                for (let j = i; j > start;) {
                    let end = j, l = types[--j] != 2 /* R */;
                    while (j > start && l == (types[j - 1] != 2 /* R */))
                        j--;
                    order.push(new BidiSpan(j, end, l ? 2 : 1));
                }
            }
            else {
                order.push(new BidiSpan(start, i, 0));
            }
        }
    }
    else {
        for (let i = 0; i < len;) {
            let start = i, rtl = types[i++] == 2 /* R */;
            while (i < len && rtl == (types[i] == 2 /* R */))
                i++;
            order.push(new BidiSpan(start, i, rtl ? 1 : 2));
        }
    }
    return order;
}
function trivialOrder(length) {
    return [new BidiSpan(0, length, 0)];
}
let movedOver = "";
function moveVisually(line, order, dir, start, forward) {
    var _a;
    let startIndex = start.head - line.from, spanI = -1;
    if (startIndex == 0) {
        if (!forward || !line.length)
            return null;
        if (order[0].level != dir) {
            startIndex = order[0].side(false, dir);
            spanI = 0;
        }
    }
    else if (startIndex == line.length) {
        if (forward)
            return null;
        let last = order[order.length - 1];
        if (last.level != dir) {
            startIndex = last.side(true, dir);
            spanI = order.length - 1;
        }
    }
    if (spanI < 0)
        spanI = BidiSpan.find(order, startIndex, (_a = start.bidiLevel) !== null && _a !== void 0 ? _a : -1, start.assoc);
    let span = order[spanI];
    // End of span. (But not end of line--that was checked for above.)
    if (startIndex == span.side(forward, dir)) {
        span = order[spanI += forward ? 1 : -1];
        startIndex = span.side(!forward, dir);
    }
    let indexForward = forward == (span.dir == dir);
    let nextIndex = text.findClusterBreak(line.text, startIndex, indexForward);
    movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));
    if (nextIndex != span.side(forward, dir))
        return state.EditorSelection.cursor(nextIndex + line.from, indexForward ? -1 : 1, span.level);
    let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];
    if (!nextSpan && span.level != dir)
        return state.EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1, dir);
    if (nextSpan && nextSpan.level < span.level)
        return state.EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, forward ? 1 : -1, nextSpan.level);
    return state.EditorSelection.cursor(nextIndex + line.from, forward ? -1 : 1, span.level);
}

function groupAt(state$1, pos, bias = 1) {
    let categorize = state$1.charCategorizer(pos);
    let line = state$1.doc.lineAt(pos), linePos = pos - line.from;
    if (line.length == 0)
        return state.EditorSelection.cursor(pos);
    if (linePos == 0)
        bias = 1;
    else if (linePos == line.length)
        bias = -1;
    let from = linePos, to = linePos;
    if (bias < 0)
        from = text.findClusterBreak(line.text, linePos, false);
    else
        to = text.findClusterBreak(line.text, linePos);
    let cat = categorize(line.text.slice(from, to));
    while (from > 0) {
        let prev = text.findClusterBreak(line.text, from, false);
        if (categorize(line.text.slice(prev, from)) != cat)
            break;
        from = prev;
    }
    while (to < line.length) {
        let next = text.findClusterBreak(line.text, to);
        if (categorize(line.text.slice(to, next)) != cat)
            break;
        to = next;
    }
    return state.EditorSelection.range(from + line.from, to + line.from);
}
// Search the DOM for the {node, offset} position closest to the given
// coordinates. Very inefficient and crude, but can usually be avoided
// by calling caret(Position|Range)FromPoint instead.
// FIXME holding arrow-up/down at the end of the viewport is a rather
// common use case that will repeatedly trigger this code. Maybe
// introduce some element of binary search after all?
function getdx(x, rect) {
    return rect.left > x ? rect.left - x : Math.max(0, x - rect.right);
}
function getdy(y, rect) {
    return rect.top > y ? rect.top - y : Math.max(0, y - rect.bottom);
}
function yOverlap(a, b) {
    return a.top < b.bottom - 1 && a.bottom > b.top + 1;
}
function upTop(rect, top) {
    return top < rect.top ? { top, left: rect.left, right: rect.right, bottom: rect.bottom } : rect;
}
function upBot(rect, bottom) {
    return bottom > rect.bottom ? { top: rect.top, left: rect.left, right: rect.right, bottom } : rect;
}
function domPosAtCoords(parent, x, y) {
    let closest, closestRect, closestX, closestY;
    let above, below, aboveRect, belowRect;
    for (let child = parent.firstChild; child; child = child.nextSibling) {
        let rects = clientRectsFor(child);
        for (let i = 0; i < rects.length; i++) {
            let rect = rects[i];
            if (closestRect && yOverlap(closestRect, rect))
                rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);
            let dx = getdx(x, rect), dy = getdy(y, rect);
            if (dx == 0 && dy == 0)
                return child.nodeType == 3 ? domPosInText(child, x, y) : domPosAtCoords(child, x, y);
            if (!closest || closestY > dy || closestY == dy && closestX > dx) {
                closest = child;
                closestRect = rect;
                closestX = dx;
                closestY = dy;
            }
            if (dx == 0) {
                if (y > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {
                    above = child;
                    aboveRect = rect;
                }
                else if (y < rect.top && (!belowRect || belowRect.top > rect.top)) {
                    below = child;
                    belowRect = rect;
                }
            }
            else if (aboveRect && yOverlap(aboveRect, rect)) {
                aboveRect = upBot(aboveRect, rect.bottom);
            }
            else if (belowRect && yOverlap(belowRect, rect)) {
                belowRect = upTop(belowRect, rect.top);
            }
        }
    }
    if (aboveRect && aboveRect.bottom >= y) {
        closest = above;
        closestRect = aboveRect;
    }
    else if (belowRect && belowRect.top <= y) {
        closest = below;
        closestRect = belowRect;
    }
    if (!closest)
        return { node: parent, offset: 0 };
    let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));
    if (closest.nodeType == 3)
        return domPosInText(closest, clipX, y);
    if (!closestX && closest.contentEditable == "true")
        return domPosAtCoords(closest, clipX, y);
    let offset = Array.prototype.indexOf.call(parent.childNodes, closest) +
        (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);
    return { node: parent, offset };
}
function domPosInText(node, x, y) {
    let len = node.nodeValue.length;
    let closestOffset = -1, closestDY = 1e9, generalSide = 0;
    for (let i = 0; i < len; i++) {
        let rects = textRange(node, i, i + 1).getClientRects();
        for (let j = 0; j < rects.length; j++) {
            let rect = rects[j];
            if (rect.top == rect.bottom)
                continue;
            if (!generalSide)
                generalSide = x - rect.left;
            let dy = (rect.top > y ? rect.top - y : y - rect.bottom) - 1;
            if (rect.left - 1 <= x && rect.right + 1 >= x && dy < closestDY) {
                let right = x >= (rect.left + rect.right) / 2, after = right;
                if (browser.chrome || browser.gecko) {
                    // Check for RTL on browsers that support getting client
                    // rects for empty ranges.
                    let rectBefore = textRange(node, i).getBoundingClientRect();
                    if (rectBefore.left == rect.right)
                        after = !right;
                }
                if (dy <= 0)
                    return { node, offset: i + (after ? 1 : 0) };
                closestOffset = i + (after ? 1 : 0);
                closestDY = dy;
            }
        }
    }
    return { node, offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0 };
}
function posAtCoords(view, { x, y }, bias = -1) {
    let content = view.contentDOM.getBoundingClientRect(), block;
    let halfLine = view.defaultLineHeight / 2;
    for (let bounced = false;;) {
        block = view.blockAtHeight(y, content.top);
        if (block.top > y || block.bottom < y) {
            bias = block.top > y ? -1 : 1;
            y = Math.min(block.bottom - halfLine, Math.max(block.top + halfLine, y));
            if (bounced)
                return -1;
            else
                bounced = true;
        }
        if (block.type == exports.BlockType.Text)
            break;
        y = bias > 0 ? block.bottom + halfLine : block.top - halfLine;
    }
    let lineStart = block.from;
    // If this is outside of the rendered viewport, we can't determine a position
    if (lineStart < view.viewport.from)
        return view.viewport.from == 0 ? 0 : null;
    if (lineStart > view.viewport.to)
        return view.viewport.to == view.state.doc.length ? view.state.doc.length : null;
    // Clip x to the viewport sides
    x = Math.max(content.left + 1, Math.min(content.right - 1, x));
    let root = view.root, element = root.elementFromPoint(x, y);
    // There's visible editor content under the point, so we can try
    // using caret(Position|Range)FromPoint as a shortcut
    let node, offset = -1;
    if (element && view.contentDOM.contains(element) && !(view.docView.nearest(element) instanceof WidgetView)) {
        if (root.caretPositionFromPoint) {
            let pos = root.caretPositionFromPoint(x, y);
            if (pos)
                ({ offsetNode: node, offset } = pos);
        }
        else if (root.caretRangeFromPoint) {
            let range = root.caretRangeFromPoint(x, y);
            if (range) {
                ({ startContainer: node, startOffset: offset } = range);
                if (browser.safari && isSuspiciousCaretResult(node, offset, x))
                    node = undefined;
            }
        }
    }
    // No luck, do our own (potentially expensive) search
    if (!node || !view.docView.dom.contains(node)) {
        let line = LineView.find(view.docView, lineStart);
        ({ node, offset } = domPosAtCoords(line.dom, x, y));
    }
    return view.docView.posFromDOM(node, offset);
}
// In case of a high line height, Safari's caretRangeFromPoint treats
// the space between lines as belonging to the last character of the
// line before. This is used to detect such a result so that it can be
// ignored (issue #401).
function isSuspiciousCaretResult(node, offset, x) {
    let len;
    if (node.nodeType != 3 || offset != (len = node.nodeValue.length))
        return false;
    for (let next = node.nextSibling; next; next = node.nextSibling)
        if (next.nodeType != 1 || next.nodeName != "BR")
            return false;
    return textRange(node, len - 1, len).getBoundingClientRect().left > x;
}
function moveToLineBoundary(view, start, forward, includeWrap) {
    let line = view.state.doc.lineAt(start.head);
    let coords = !includeWrap || !view.lineWrapping ? null
        : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);
    if (coords) {
        let editorRect = view.dom.getBoundingClientRect();
        let pos = view.posAtCoords({ x: forward == (view.textDirection == exports.Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,
            y: (coords.top + coords.bottom) / 2 });
        if (pos != null)
            return state.EditorSelection.cursor(pos, forward ? -1 : 1);
    }
    let lineView = LineView.find(view.docView, start.head);
    let end = lineView ? (forward ? lineView.posAtEnd : lineView.posAtStart) : (forward ? line.to : line.from);
    return state.EditorSelection.cursor(end, forward ? -1 : 1);
}
function moveByChar(view, start, forward, by) {
    let line = view.state.doc.lineAt(start.head), spans = view.bidiSpans(line);
    for (let cur = start, check = null;;) {
        let next = moveVisually(line, spans, view.textDirection, cur, forward), char = movedOver;
        if (!next) {
            if (line.number == (forward ? view.state.doc.lines : 1))
                return cur;
            char = "\n";
            line = view.state.doc.line(line.number + (forward ? 1 : -1));
            spans = view.bidiSpans(line);
            next = state.EditorSelection.cursor(forward ? line.from : line.to);
        }
        if (!check) {
            if (!by)
                return next;
            check = by(char);
        }
        else if (!check(char)) {
            return cur;
        }
        cur = next;
    }
}
function byGroup(view, pos, start) {
    let categorize = view.state.charCategorizer(pos);
    let cat = categorize(start);
    return (next) => {
        let nextCat = categorize(next);
        if (cat == state.CharCategory.Space)
            cat = nextCat;
        return cat == nextCat;
    };
}
function moveVertically(view, start, forward, distance) {
    var _a;
    let startPos = start.head, dir = forward ? 1 : -1;
    if (startPos == (forward ? view.state.doc.length : 0))
        return state.EditorSelection.cursor(startPos);
    let startCoords = view.coordsAtPos(startPos);
    if (startCoords) {
        let rect = view.dom.getBoundingClientRect();
        let goal = (_a = start.goalColumn) !== null && _a !== void 0 ? _a : startCoords.left - rect.left;
        let resolvedGoal = rect.left + goal;
        let dist = distance !== null && distance !== void 0 ? distance : (view.defaultLineHeight >> 1);
        for (let startY = dir < 0 ? startCoords.top : startCoords.bottom, extra = 0; extra < 50; extra += 10) {
            let pos = posAtCoords(view, { x: resolvedGoal, y: startY + (dist + extra) * dir }, dir);
            if (pos == null)
                break;
            if (pos != startPos)
                return state.EditorSelection.cursor(pos, undefined, undefined, goal);
        }
    }
    // Outside of the drawn viewport, use a crude column-based approach
    let { doc } = view.state, line = doc.lineAt(startPos), tabSize = view.state.tabSize;
    let goal = start.goalColumn, goalCol = 0;
    if (goal == null) {
        for (const iter = doc.iterRange(line.from, startPos); !iter.next().done;)
            goalCol = text.countColumn(iter.value, goalCol, tabSize);
        goal = goalCol * view.defaultCharacterWidth;
    }
    else {
        goalCol = Math.round(goal / view.defaultCharacterWidth);
    }
    if (dir < 0 && line.from == 0)
        return state.EditorSelection.cursor(0);
    else if (dir > 0 && line.to == doc.length)
        return state.EditorSelection.cursor(line.to);
    let otherLine = doc.line(line.number + dir);
    let result = otherLine.from;
    let seen = 0;
    for (const iter = doc.iterRange(otherLine.from, otherLine.to); seen >= goalCol && !iter.next().done;) {
        const { offset, leftOver } = text.findColumn(iter.value, seen, goalCol, tabSize);
        seen = goalCol - leftOver;
        result += offset;
    }
    return state.EditorSelection.cursor(result, undefined, undefined, goal);
}

// This will also be where dragging info and such goes
class InputState {
    constructor(view) {
        this.lastKeyCode = 0;
        this.lastKeyTime = 0;
        this.lastIOSEnter = 0;
        this.lastIOSBackspace = 0;
        this.lastSelectionOrigin = null;
        this.lastSelectionTime = 0;
        this.lastEscPress = 0;
        this.scrollHandlers = [];
        this.registeredEvents = [];
        this.customHandlers = [];
        // -1 means not in a composition. Otherwise, this counts the number
        // of changes made during the composition. The count is used to
        // avoid treating the start state of the composition, before any
        // changes have been made, as part of the composition.
        this.composing = -1;
        this.compositionEndedAt = 0;
        this.mouseSelection = null;
        for (let type in handlers) {
            let handler = handlers[type];
            view.contentDOM.addEventListener(type, (event) => {
                if (type == "keydown" && this.keydown(view, event))
                    return;
                if (!eventBelongsToEditor(view, event) || this.ignoreDuringComposition(event))
                    return;
                if (this.mustFlushObserver(event))
                    view.observer.forceFlush();
                if (this.runCustomHandlers(type, view, event))
                    event.preventDefault();
                else
                    handler(view, event);
            });
            this.registeredEvents.push(type);
        }
        this.notifiedFocused = view.hasFocus;
        this.ensureHandlers(view);
    }
    setSelectionOrigin(origin) {
        this.lastSelectionOrigin = origin;
        this.lastSelectionTime = Date.now();
    }
    ensureHandlers(view) {
        let handlers = this.customHandlers = view.pluginField(domEventHandlers);
        for (let set of handlers) {
            for (let type in set.handlers)
                if (this.registeredEvents.indexOf(type) < 0 && type != "scroll") {
                    this.registeredEvents.push(type);
                    view.contentDOM.addEventListener(type, (event) => {
                        if (!eventBelongsToEditor(view, event))
                            return;
                        if (this.runCustomHandlers(type, view, event))
                            event.preventDefault();
                    });
                }
        }
    }
    runCustomHandlers(type, view, event) {
        for (let set of this.customHandlers) {
            let handler = set.handlers[type], handled = false;
            if (handler) {
                try {
                    handled = handler.call(set.plugin, event, view);
                }
                catch (e) {
                    logException(view.state, e);
                }
                if (handled || event.defaultPrevented) {
                    // Chrome for Android often applies a bunch of nonsensical
                    // DOM changes after an enter press, even when
                    // preventDefault-ed. This tries to ignore those.
                    if (browser.android && type == "keydown" && event.keyCode == 13)
                        view.observer.flushSoon();
                    return true;
                }
            }
        }
        return false;
    }
    runScrollHandlers(view, event) {
        for (let set of this.customHandlers) {
            let handler = set.handlers.scroll;
            if (handler) {
                try {
                    handler.call(set.plugin, event, view);
                }
                catch (e) {
                    logException(view.state, e);
                }
            }
        }
    }
    keydown(view, event) {
        // Must always run, even if a custom handler handled the event
        this.lastKeyCode = event.keyCode;
        this.lastKeyTime = Date.now();
        if (this.screenKeyEvent(view, event))
            return;
        // Prevent the default behavior of Enter on iOS makes the
        // virtual keyboard get stuck in the wrong (lowercase)
        // state. So we let it go through, and then, in
        // applyDOMChange, notify key handlers of it and reset to
        // the state they produce.
        if (browser.ios && (event.keyCode == 13 || event.keyCode == 8) &&
            !(event.ctrlKey || event.altKey || event.metaKey) && !event.synthetic) {
            this[event.keyCode == 13 ? "lastIOSEnter" : "lastIOSBackspace"] = Date.now();
            return true;
        }
        return false;
    }
    ignoreDuringComposition(event) {
        if (!/^key/.test(event.type))
            return false;
        if (this.composing > 0)
            return true;
        // See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.
        // On some input method editors (IMEs), the Enter key is used to
        // confirm character selection. On Safari, when Enter is pressed,
        // compositionend and keydown events are sometimes emitted in the
        // wrong order. The key event should still be ignored, even when
        // it happens after the compositionend event.
        if (browser.safari && event.timeStamp - this.compositionEndedAt < 500) {
            this.compositionEndedAt = 0;
            return true;
        }
        return false;
    }
    screenKeyEvent(view, event) {
        let protectedTab = event.keyCode == 9 && Date.now() < this.lastEscPress + 2000;
        if (event.keyCode == 27)
            this.lastEscPress = Date.now();
        else if (modifierCodes.indexOf(event.keyCode) < 0)
            this.lastEscPress = 0;
        return protectedTab;
    }
    mustFlushObserver(event) {
        return (event.type == "keydown" && event.keyCode != 229) ||
            event.type == "compositionend" && !browser.ios;
    }
    startMouseSelection(view, event, style) {
        if (this.mouseSelection)
            this.mouseSelection.destroy();
        this.mouseSelection = new MouseSelection(this, view, event, style);
    }
    update(update) {
        if (this.mouseSelection)
            this.mouseSelection.update(update);
        this.lastKeyCode = this.lastSelectionTime = 0;
    }
    destroy() {
        if (this.mouseSelection)
            this.mouseSelection.destroy();
    }
}
// Key codes for modifier keys
const modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];
class MouseSelection {
    constructor(inputState, view, startEvent, style) {
        this.inputState = inputState;
        this.view = view;
        this.startEvent = startEvent;
        this.style = style;
        let doc = view.contentDOM.ownerDocument;
        doc.addEventListener("mousemove", this.move = this.move.bind(this));
        doc.addEventListener("mouseup", this.up = this.up.bind(this));
        this.extend = startEvent.shiftKey;
        this.multiple = view.state.facet(state.EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);
        this.dragMove = dragMovesSelection(view, startEvent);
        this.dragging = isInPrimarySelection(view, startEvent) ? null : false;
        // When clicking outside of the selection, immediately apply the
        // effect of starting the selection
        if (this.dragging === false) {
            startEvent.preventDefault();
            this.select(startEvent);
        }
    }
    move(event) {
        if (event.buttons == 0)
            return this.destroy();
        if (this.dragging !== false)
            return;
        this.select(event);
    }
    up(event) {
        if (this.dragging == null)
            this.select(this.startEvent);
        if (!this.dragging)
            event.preventDefault();
        this.destroy();
    }
    destroy() {
        let doc = this.view.contentDOM.ownerDocument;
        doc.removeEventListener("mousemove", this.move);
        doc.removeEventListener("mouseup", this.up);
        this.inputState.mouseSelection = null;
    }
    select(event) {
        let selection = this.style.get(event, this.extend, this.multiple);
        if (!selection.eq(this.view.state.selection) || selection.main.assoc != this.view.state.selection.main.assoc)
            this.view.dispatch({
                selection,
                annotations: state.Transaction.userEvent.of("pointerselection"),
                scrollIntoView: true
            });
    }
    update(update) {
        if (update.docChanged && this.dragging)
            this.dragging = this.dragging.map(update.changes);
        this.style.update(update);
    }
}
function addsSelectionRange(view, event) {
    let facet = view.state.facet(clickAddsSelectionRange);
    return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;
}
function dragMovesSelection(view, event) {
    let facet = view.state.facet(dragMovesSelection$1);
    return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;
}
function isInPrimarySelection(view, event) {
    let { main } = view.state.selection;
    if (main.empty)
        return false;
    // On boundary clicks, check whether the coordinates are inside the
    // selection's client rectangles
    let sel = getSelection(view.root);
    if (sel.rangeCount == 0)
        return true;
    let rects = sel.getRangeAt(0).getClientRects();
    for (let i = 0; i < rects.length; i++) {
        let rect = rects[i];
        if (rect.left <= event.clientX && rect.right >= event.clientX &&
            rect.top <= event.clientY && rect.bottom >= event.clientY)
            return true;
    }
    return false;
}
function eventBelongsToEditor(view, event) {
    if (!event.bubbles)
        return true;
    if (event.defaultPrevented)
        return false;
    for (let node = event.target, cView; node != view.contentDOM; node = node.parentNode)
        if (!node || node.nodeType == 11 || ((cView = ContentView.get(node)) && cView.ignoreEvent(event)))
            return false;
    return true;
}
const handlers = Object.create(null);
// This is very crude, but unfortunately both these browsers _pretend_
// that they have a clipboard API‚Äîall the objects and methods are
// there, they just don't work, and they are hard to test.
const brokenClipboardAPI = (browser.ie && browser.ie_version < 15) ||
    (browser.ios && browser.webkit_version < 604);
function capturePaste(view) {
    let parent = view.dom.parentNode;
    if (!parent)
        return;
    let target = parent.appendChild(document.createElement("textarea"));
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.focus();
    setTimeout(() => {
        view.focus();
        target.remove();
        doPaste(view, target.value);
    }, 50);
}
function doPaste(view, input) {
    let { state: state$1 } = view, changes, i = 1, text = state$1.toText(input);
    let byLine = text.lines == state$1.selection.ranges.length;
    let linewise = lastLinewiseCopy && state$1.selection.ranges.every(r => r.empty) && lastLinewiseCopy == text.toString();
    if (linewise) {
        let lastLine = -1;
        changes = state$1.changeByRange(range => {
            let line = state$1.doc.lineAt(range.from);
            if (line.from == lastLine)
                return { range };
            lastLine = line.from;
            let insert = state$1.toText((byLine ? text.line(i++).text : input) + state$1.lineBreak);
            return { changes: { from: line.from, insert },
                range: state.EditorSelection.cursor(range.from + insert.length) };
        });
    }
    else if (byLine) {
        changes = state$1.changeByRange(range => {
            let line = text.line(i++);
            return { changes: { from: range.from, to: range.to, insert: line.text },
                range: state.EditorSelection.cursor(range.from + line.length) };
        });
    }
    else {
        changes = state$1.replaceSelection(text);
    }
    view.dispatch(changes, {
        annotations: state.Transaction.userEvent.of("paste"),
        scrollIntoView: true
    });
}
handlers.keydown = (view, event) => {
    view.inputState.setSelectionOrigin("keyboardselection");
};
let lastTouch = 0;
function mouseLikeTouchEvent(e) {
    return e.touches.length == 1 && e.touches[0].radiusX <= 1 && e.touches[0].radiusY <= 1;
}
handlers.touchstart = (view, e) => {
    if (!mouseLikeTouchEvent(e))
        lastTouch = Date.now();
    view.inputState.setSelectionOrigin("pointerselection");
};
handlers.touchmove = view => {
    view.inputState.setSelectionOrigin("pointerselection");
};
handlers.mousedown = (view, event) => {
    view.observer.flush();
    if (lastTouch > Date.now() - 2000)
        return; // Ignore touch interaction
    let style = null;
    for (let makeStyle of view.state.facet(mouseSelectionStyle)) {
        style = makeStyle(view, event);
        if (style)
            break;
    }
    if (!style && event.button == 0)
        style = basicMouseSelection(view, event);
    if (style) {
        if (view.root.activeElement != view.contentDOM)
            view.observer.ignore(() => focusPreventScroll(view.contentDOM));
        view.inputState.startMouseSelection(view, event, style);
    }
};
function rangeForClick(view, pos, bias, type) {
    if (type == 1) { // Single click
        return state.EditorSelection.cursor(pos, bias);
    }
    else if (type == 2) { // Double click
        return groupAt(view.state, pos, bias);
    }
    else { // Triple click
        let visual = LineView.find(view.docView, pos), line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);
        let from = visual ? visual.posAtStart : line.from, to = visual ? visual.posAtEnd : line.to;
        if (to < view.state.doc.length && to == line.to)
            to++;
        return state.EditorSelection.range(from, to);
    }
}
let insideY = (y, rect) => y >= rect.top && y <= rect.bottom;
let inside = (x, y, rect) => insideY(y, rect) && x >= rect.left && x <= rect.right;
// Try to determine, for the given coordinates, associated with the
// given position, whether they are related to the element before or
// the element after the position.
function findPositionSide(view, pos, x, y) {
    let line = LineView.find(view.docView, pos);
    if (!line)
        return 1;
    let off = pos - line.posAtStart;
    // Line boundaries point into the line
    if (off == 0)
        return 1;
    if (off == line.length)
        return -1;
    // Positions on top of an element point at that element
    let before = line.coordsAt(off, -1);
    if (before && inside(x, y, before))
        return -1;
    let after = line.coordsAt(off, 1);
    if (after && inside(x, y, after))
        return 1;
    // This is probably a line wrap point. Pick before if the point is
    // beside it.
    return before && insideY(y, before) ? -1 : 1;
}
function queryPos(view, event) {
    let pos = view.posAtCoords({ x: event.clientX, y: event.clientY });
    if (pos == null)
        return null;
    return { pos, bias: findPositionSide(view, pos, event.clientX, event.clientY) };
}
const BadMouseDetail = browser.ie && browser.ie_version <= 11;
let lastMouseDown = null, lastMouseDownCount = 0;
function getClickType(event) {
    if (!BadMouseDetail)
        return event.detail;
    let last = lastMouseDown;
    lastMouseDown = event;
    return lastMouseDownCount = !last || (last.timeStamp > Date.now() - 400 && Math.abs(last.clientX - event.clientX) < 2 &&
        Math.abs(last.clientY - event.clientY) < 2) ? (lastMouseDownCount + 1) % 3 : 1;
}
function basicMouseSelection(view, event) {
    let start = queryPos(view, event), type = getClickType(event);
    let startSel = view.state.selection;
    let last = start, lastEvent = event;
    return {
        update(update) {
            if (update.changes) {
                if (start)
                    start.pos = update.changes.mapPos(start.pos);
                startSel = startSel.map(update.changes);
            }
        },
        get(event, extend, multiple) {
            let cur;
            if (event.clientX == lastEvent.clientX && event.clientY == lastEvent.clientY)
                cur = last;
            else {
                cur = last = queryPos(view, event);
                lastEvent = event;
            }
            if (!cur || !start)
                return startSel;
            let range = rangeForClick(view, cur.pos, cur.bias, type);
            if (start.pos != cur.pos && !extend) {
                let startRange = rangeForClick(view, start.pos, start.bias, type);
                let from = Math.min(startRange.from, range.from), to = Math.max(startRange.to, range.to);
                range = from < range.from ? state.EditorSelection.range(from, to) : state.EditorSelection.range(to, from);
            }
            if (extend)
                return startSel.replaceRange(startSel.main.extend(range.from, range.to));
            else if (multiple)
                return startSel.addRange(range);
            else
                return state.EditorSelection.create([range]);
        }
    };
}
handlers.dragstart = (view, event) => {
    let { selection: { main } } = view.state;
    let { mouseSelection } = view.inputState;
    if (mouseSelection)
        mouseSelection.dragging = main;
    if (event.dataTransfer) {
        event.dataTransfer.setData("Text", view.state.sliceDoc(main.from, main.to));
        event.dataTransfer.effectAllowed = "copyMove";
    }
};
handlers.drop = (view, event) => {
    if (!event.dataTransfer || !view.state.facet(editable))
        return;
    let dropPos = view.posAtCoords({ x: event.clientX, y: event.clientY });
    let text = event.dataTransfer.getData("Text");
    if (dropPos == null || !text)
        return;
    event.preventDefault();
    let { mouseSelection } = view.inputState;
    let del = mouseSelection && mouseSelection.dragging && mouseSelection.dragMove ?
        { from: mouseSelection.dragging.from, to: mouseSelection.dragging.to } : null;
    let ins = { from: dropPos, insert: text };
    let changes = view.state.changes(del ? [del, ins] : ins);
    view.focus();
    view.dispatch({
        changes,
        selection: { anchor: changes.mapPos(dropPos, -1), head: changes.mapPos(dropPos, 1) },
        annotations: state.Transaction.userEvent.of("drop")
    });
};
handlers.paste = (view, event) => {
    if (!view.state.facet(editable))
        return;
    view.observer.flush();
    let data = brokenClipboardAPI ? null : event.clipboardData;
    let text = data && data.getData("text/plain");
    if (text) {
        doPaste(view, text);
        event.preventDefault();
    }
    else {
        capturePaste(view);
    }
};
function captureCopy(view, text) {
    // The extra wrapper is somehow necessary on IE/Edge to prevent the
    // content from being mangled when it is put onto the clipboard
    let parent = view.dom.parentNode;
    if (!parent)
        return;
    let target = parent.appendChild(document.createElement("textarea"));
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.value = text;
    target.focus();
    target.selectionEnd = text.length;
    target.selectionStart = 0;
    setTimeout(() => {
        target.remove();
        view.focus();
    }, 50);
}
function copiedRange(state) {
    let content = [], ranges = [], linewise = false;
    for (let range of state.selection.ranges)
        if (!range.empty) {
            content.push(state.sliceDoc(range.from, range.to));
            ranges.push(range);
        }
    if (!content.length) {
        // Nothing selected, do a line-wise copy
        let upto = -1;
        for (let { from } of state.selection.ranges) {
            let line = state.doc.lineAt(from);
            if (line.number > upto) {
                content.push(line.text);
                ranges.push({ from: line.from, to: Math.min(state.doc.length, line.to + 1) });
            }
            upto = line.number;
        }
        linewise = true;
    }
    return { text: content.join(state.lineBreak), ranges, linewise };
}
let lastLinewiseCopy = null;
handlers.copy = handlers.cut = (view, event) => {
    let { text, ranges, linewise } = copiedRange(view.state);
    if (!text)
        return;
    lastLinewiseCopy = linewise ? text : null;
    let data = brokenClipboardAPI ? null : event.clipboardData;
    if (data) {
        event.preventDefault();
        data.clearData();
        data.setData("text/plain", text);
    }
    else {
        captureCopy(view, text);
    }
    if (event.type == "cut" && view.state.facet(editable))
        view.dispatch({
            changes: ranges,
            scrollIntoView: true,
            annotations: state.Transaction.userEvent.of("cut")
        });
};
handlers.focus = handlers.blur = view => {
    setTimeout(() => {
        if (view.hasFocus != view.inputState.notifiedFocused)
            view.update([]);
    }, 10);
};
handlers.beforeprint = view => {
    view.viewState.printing = true;
    view.requestMeasure();
    setTimeout(() => {
        view.viewState.printing = false;
        view.requestMeasure();
    }, 2000);
};
function forceClearComposition(view) {
    if (view.docView.compositionDeco.size)
        view.update([]);
}
handlers.compositionstart = handlers.compositionupdate = view => {
    if (view.inputState.composing < 0) {
        if (view.docView.compositionDeco.size) {
            view.observer.flush();
            forceClearComposition(view);
        }
        // FIXME possibly set a timeout to clear it again on Android
        view.inputState.composing = 0;
    }
};
handlers.compositionend = view => {
    view.inputState.composing = -1;
    view.inputState.compositionEndedAt = Date.now();
    setTimeout(() => {
        if (view.inputState.composing < 0)
            forceClearComposition(view);
    }, 50);
};

const wrappingWhiteSpace = ["pre-wrap", "normal", "pre-line"];
class HeightOracle {
    constructor() {
        this.doc = text.Text.empty;
        this.lineWrapping = false;
        this.direction = exports.Direction.LTR;
        this.heightSamples = {};
        this.lineHeight = 14;
        this.charWidth = 7;
        this.lineLength = 30;
        // Used to track, during updateHeight, if any actual heights changed
        this.heightChanged = false;
    }
    heightForGap(from, to) {
        let lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;
        if (this.lineWrapping)
            lines += Math.ceil(((to - from) - (lines * this.lineLength * 0.5)) / this.lineLength);
        return this.lineHeight * lines;
    }
    heightForLine(length) {
        if (!this.lineWrapping)
            return this.lineHeight;
        let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / (this.lineLength - 5)));
        return lines * this.lineHeight;
    }
    setDoc(doc) { this.doc = doc; return this; }
    mustRefresh(lineHeights, whiteSpace, direction) {
        let newHeight = false;
        for (let i = 0; i < lineHeights.length; i++) {
            let h = lineHeights[i];
            if (h < 0) {
                i++;
            }
            else if (!this.heightSamples[Math.floor(h * 10)]) { // Round to .1 pixels
                newHeight = true;
                this.heightSamples[Math.floor(h * 10)] = true;
            }
        }
        return newHeight || (wrappingWhiteSpace.indexOf(whiteSpace) > -1) != this.lineWrapping || this.direction != direction;
    }
    refresh(whiteSpace, direction, lineHeight, charWidth, lineLength, knownHeights) {
        let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;
        let changed = Math.round(lineHeight) != Math.round(this.lineHeight) ||
            this.lineWrapping != lineWrapping ||
            this.direction != direction;
        this.lineWrapping = lineWrapping;
        this.direction = direction;
        this.lineHeight = lineHeight;
        this.charWidth = charWidth;
        this.lineLength = lineLength;
        if (changed) {
            this.heightSamples = {};
            for (let i = 0; i < knownHeights.length; i++) {
                let h = knownHeights[i];
                if (h < 0)
                    i++;
                else
                    this.heightSamples[Math.floor(h * 10)] = true;
            }
        }
        return changed;
    }
}
// This object is used by `updateHeight` to make DOM measurements
// arrive at the right nides. The `heights` array is a sequence of
// block heights, starting from position `from`.
class MeasuredHeights {
    constructor(from, heights) {
        this.from = from;
        this.heights = heights;
        this.index = 0;
    }
    get more() { return this.index < this.heights.length; }
}
/**
Record used to represent information about a block-level element
in the editor view.
*/
class BlockInfo {
    /**
    @internal
    */
    constructor(
    /**
    The start of the element in the document.
    */
    from, 
    /**
    The length of the element.
    */
    length, 
    /**
    The top position of the element.
    */
    top, 
    /**
    Its height.
    */
    height, 
    /**
    The type of element this is. When querying lines, this may be
    an array of all the blocks that make up the line.
    */
    type) {
        this.from = from;
        this.length = length;
        this.top = top;
        this.height = height;
        this.type = type;
    }
    /**
    The end of the element as a document position.
    */
    get to() { return this.from + this.length; }
    /**
    The bottom position of the element.
    */
    get bottom() { return this.top + this.height; }
    /**
    @internal
    */
    join(other) {
        let detail = (Array.isArray(this.type) ? this.type : [this])
            .concat(Array.isArray(other.type) ? other.type : [other]);
        return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, detail);
    }
}
var QueryType;
(function (QueryType) {
    QueryType[QueryType["ByPos"] = 0] = "ByPos";
    QueryType[QueryType["ByHeight"] = 1] = "ByHeight";
    QueryType[QueryType["ByPosNoHeight"] = 2] = "ByPosNoHeight";
})(QueryType || (QueryType = {}));
const Epsilon = 1e-4;
class HeightMap {
    constructor(length, // The number of characters covered
    height, // Height of this part of the document
    flags = 2 /* Outdated */) {
        this.length = length;
        this.height = height;
        this.flags = flags;
    }
    get outdated() { return (this.flags & 2 /* Outdated */) > 0; }
    set outdated(value) { this.flags = (value ? 2 /* Outdated */ : 0) | (this.flags & ~2 /* Outdated */); }
    setHeight(oracle, height) {
        if (this.height != height) {
            if (Math.abs(this.height - height) > Epsilon)
                oracle.heightChanged = true;
            this.height = height;
        }
    }
    // Base case is to replace a leaf node, which simply builds a tree
    // from the new nodes and returns that (HeightMapBranch and
    // HeightMapGap override this to actually use from/to)
    replace(_from, _to, nodes) {
        return HeightMap.of(nodes);
    }
    // Again, these are base cases, and are overridden for branch and gap nodes.
    decomposeLeft(_to, result) { result.push(this); }
    decomposeRight(_from, result) { result.push(this); }
    applyChanges(decorations, oldDoc, oracle, changes) {
        let me = this;
        for (let i = changes.length - 1; i >= 0; i--) {
            let { fromA, toA, fromB, toB } = changes[i];
            let start = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);
            let end = start.to >= toA ? start : me.lineAt(toA, QueryType.ByPosNoHeight, oldDoc, 0, 0);
            toB += end.to - toA;
            toA = end.to;
            while (i > 0 && start.from <= changes[i - 1].toA) {
                fromA = changes[i - 1].fromA;
                fromB = changes[i - 1].fromB;
                i--;
                if (fromA < start.from)
                    start = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);
            }
            fromB += start.from - fromA;
            fromA = start.from;
            let nodes = NodeBuilder.build(oracle, decorations, fromB, toB);
            me = me.replace(fromA, toA, nodes);
        }
        return me.updateHeight(oracle, 0);
    }
    static empty() { return new HeightMapText(0, 0); }
    // nodes uses null values to indicate the position of line breaks.
    // There are never line breaks at the start or end of the array, or
    // two line breaks next to each other, and the array isn't allowed
    // to be empty (same restrictions as return value from the builder).
    static of(nodes) {
        if (nodes.length == 1)
            return nodes[0];
        let i = 0, j = nodes.length, before = 0, after = 0;
        for (;;) {
            if (i == j) {
                if (before > after * 2) {
                    let split = nodes[i - 1];
                    if (split.break)
                        nodes.splice(--i, 1, split.left, null, split.right);
                    else
                        nodes.splice(--i, 1, split.left, split.right);
                    j += 1 + split.break;
                    before -= split.size;
                }
                else if (after > before * 2) {
                    let split = nodes[j];
                    if (split.break)
                        nodes.splice(j, 1, split.left, null, split.right);
                    else
                        nodes.splice(j, 1, split.left, split.right);
                    j += 2 + split.break;
                    after -= split.size;
                }
                else {
                    break;
                }
            }
            else if (before < after) {
                let next = nodes[i++];
                if (next)
                    before += next.size;
            }
            else {
                let next = nodes[--j];
                if (next)
                    after += next.size;
            }
        }
        let brk = 0;
        if (nodes[i - 1] == null) {
            brk = 1;
            i--;
        }
        else if (nodes[i] == null) {
            brk = 1;
            j++;
        }
        return new HeightMapBranch(HeightMap.of(nodes.slice(0, i)), brk, HeightMap.of(nodes.slice(j)));
    }
}
HeightMap.prototype.size = 1;
class HeightMapBlock extends HeightMap {
    constructor(length, height, type) {
        super(length, height);
        this.type = type;
    }
    blockAt(_height, _doc, top, offset) {
        return new BlockInfo(offset, this.length, top, this.height, this.type);
    }
    lineAt(_value, _type, doc, top, offset) {
        return this.blockAt(0, doc, top, offset);
    }
    forEachLine(_from, _to, doc, top, offset, f) {
        f(this.blockAt(0, doc, top, offset));
    }
    updateHeight(oracle, offset = 0, _force = false, measured) {
        if (measured && measured.from <= offset && measured.more)
            this.setHeight(oracle, measured.heights[measured.index++]);
        this.outdated = false;
        return this;
    }
    toString() { return `block(${this.length})`; }
}
class HeightMapText extends HeightMapBlock {
    constructor(length, height) {
        super(length, height, exports.BlockType.Text);
        this.collapsed = 0; // Amount of collapsed content in the line
        this.widgetHeight = 0; // Maximum inline widget height
    }
    replace(_from, _to, nodes) {
        let node = nodes[0];
        if (nodes.length == 1 && (node instanceof HeightMapText || node instanceof HeightMapGap && (node.flags & 4 /* SingleLine */)) &&
            Math.abs(this.length - node.length) < 10) {
            if (node instanceof HeightMapGap)
                node = new HeightMapText(node.length, this.height);
            else
                node.height = this.height;
            if (!this.outdated)
                node.outdated = false;
            return node;
        }
        else {
            return HeightMap.of(nodes);
        }
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
        if (measured && measured.from <= offset && measured.more)
            this.setHeight(oracle, measured.heights[measured.index++]);
        else if (force || this.outdated)
            this.setHeight(oracle, Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)));
        this.outdated = false;
        return this;
    }
    toString() {
        return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
    }
}
class HeightMapGap extends HeightMap {
    constructor(length) { super(length, 0); }
    lines(doc, offset) {
        let firstLine = doc.lineAt(offset).number, lastLine = doc.lineAt(offset + this.length).number;
        return { firstLine, lastLine, lineHeight: this.height / (lastLine - firstLine + 1) };
    }
    blockAt(height, doc, top, offset) {
        let { firstLine, lastLine, lineHeight } = this.lines(doc, offset);
        let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top) / lineHeight)));
        let { from, length } = doc.line(firstLine + line);
        return new BlockInfo(from, length, top + lineHeight * line, lineHeight, exports.BlockType.Text);
    }
    lineAt(value, type, doc, top, offset) {
        if (type == QueryType.ByHeight)
            return this.blockAt(value, doc, top, offset);
        if (type == QueryType.ByPosNoHeight) {
            let { from, to } = doc.lineAt(value);
            return new BlockInfo(from, to - from, 0, 0, exports.BlockType.Text);
        }
        let { firstLine, lineHeight } = this.lines(doc, offset);
        let { from, length, number } = doc.lineAt(value);
        return new BlockInfo(from, length, top + lineHeight * (number - firstLine), lineHeight, exports.BlockType.Text);
    }
    forEachLine(from, to, doc, top, offset, f) {
        let { firstLine, lineHeight } = this.lines(doc, offset);
        for (let pos = Math.max(from, offset), end = Math.min(offset + this.length, to); pos <= end;) {
            let line = doc.lineAt(pos);
            if (pos == from)
                top += lineHeight * (line.number - firstLine);
            f(new BlockInfo(line.from, line.length, top, lineHeight, exports.BlockType.Text));
            top += lineHeight;
            pos = line.to + 1;
        }
    }
    replace(from, to, nodes) {
        let after = this.length - to;
        if (after > 0) {
            let last = nodes[nodes.length - 1];
            if (last instanceof HeightMapGap)
                nodes[nodes.length - 1] = new HeightMapGap(last.length + after);
            else
                nodes.push(null, new HeightMapGap(after - 1));
        }
        if (from > 0) {
            let first = nodes[0];
            if (first instanceof HeightMapGap)
                nodes[0] = new HeightMapGap(from + first.length);
            else
                nodes.unshift(new HeightMapGap(from - 1), null);
        }
        return HeightMap.of(nodes);
    }
    decomposeLeft(to, result) {
        result.push(new HeightMapGap(to - 1), null);
    }
    decomposeRight(from, result) {
        result.push(null, new HeightMapGap(this.length - from - 1));
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
        let end = offset + this.length;
        if (measured && measured.from <= offset + this.length && measured.more) {
            // Fill in part of this gap with measured lines. We know there
            // can't be widgets or collapsed ranges in those lines, because
            // they would already have been added to the heightmap (gaps
            // only contain plain text).
            let nodes = [], pos = Math.max(offset, measured.from);
            if (measured.from > offset)
                nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));
            while (pos <= end && measured.more) {
                let len = oracle.doc.lineAt(pos).length;
                if (nodes.length)
                    nodes.push(null);
                let line = new HeightMapText(len, measured.heights[measured.index++]);
                line.outdated = false;
                nodes.push(line);
                pos += len + 1;
            }
            if (pos <= end)
                nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));
            oracle.heightChanged = true;
            return HeightMap.of(nodes);
        }
        else if (force || this.outdated) {
            this.setHeight(oracle, oracle.heightForGap(offset, offset + this.length));
            this.outdated = false;
        }
        return this;
    }
    toString() { return `gap(${this.length})`; }
}
class HeightMapBranch extends HeightMap {
    constructor(left, brk, right) {
        super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 /* Outdated */ : 0));
        this.left = left;
        this.right = right;
        this.size = left.size + right.size;
    }
    get break() { return this.flags & 1 /* Break */; }
    blockAt(height, doc, top, offset) {
        let mid = top + this.left.height;
        return height < mid || this.right.height == 0 ? this.left.blockAt(height, doc, top, offset)
            : this.right.blockAt(height, doc, mid, offset + this.left.length + this.break);
    }
    lineAt(value, type, doc, top, offset) {
        let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;
        let left = type == QueryType.ByHeight ? value < rightTop || this.right.height == 0 : value < rightOffset;
        let base = left ? this.left.lineAt(value, type, doc, top, offset)
            : this.right.lineAt(value, type, doc, rightTop, rightOffset);
        if (this.break || (left ? base.to < rightOffset : base.from > rightOffset))
            return base;
        let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;
        if (left)
            return base.join(this.right.lineAt(rightOffset, subQuery, doc, rightTop, rightOffset));
        else
            return this.left.lineAt(rightOffset, subQuery, doc, top, offset).join(base);
    }
    forEachLine(from, to, doc, top, offset, f) {
        let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;
        if (this.break) {
            if (from < rightOffset)
                this.left.forEachLine(from, to, doc, top, offset, f);
            if (to >= rightOffset)
                this.right.forEachLine(from, to, doc, rightTop, rightOffset, f);
        }
        else {
            let mid = this.lineAt(rightOffset, QueryType.ByPos, doc, top, offset);
            if (from < mid.from)
                this.left.forEachLine(from, mid.from - 1, doc, top, offset, f);
            if (mid.to >= from && mid.from <= to)
                f(mid);
            if (to > mid.to)
                this.right.forEachLine(mid.to + 1, to, doc, rightTop, rightOffset, f);
        }
    }
    replace(from, to, nodes) {
        let rightStart = this.left.length + this.break;
        if (to < rightStart)
            return this.balanced(this.left.replace(from, to, nodes), this.right);
        if (from > this.left.length)
            return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));
        let result = [];
        if (from > 0)
            this.decomposeLeft(from, result);
        let left = result.length;
        for (let node of nodes)
            result.push(node);
        if (from > 0)
            mergeGaps(result, left - 1);
        if (to < this.length) {
            let right = result.length;
            this.decomposeRight(to, result);
            mergeGaps(result, right);
        }
        return HeightMap.of(result);
    }
    decomposeLeft(to, result) {
        let left = this.left.length;
        if (to <= left)
            return this.left.decomposeLeft(to, result);
        result.push(this.left);
        if (this.break) {
            left++;
            if (to >= left)
                result.push(null);
        }
        if (to > left)
            this.right.decomposeLeft(to - left, result);
    }
    decomposeRight(from, result) {
        let left = this.left.length, right = left + this.break;
        if (from >= right)
            return this.right.decomposeRight(from - right, result);
        if (from < left)
            this.left.decomposeRight(from, result);
        if (this.break && from < right)
            result.push(null);
        result.push(this.right);
    }
    balanced(left, right) {
        if (left.size > 2 * right.size || right.size > 2 * left.size)
            return HeightMap.of(this.break ? [left, null, right] : [left, right]);
        this.left = left;
        this.right = right;
        this.height = left.height + right.height;
        this.outdated = left.outdated || right.outdated;
        this.size = left.size + right.size;
        this.length = left.length + this.break + right.length;
        return this;
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
        let { left, right } = this, rightStart = offset + left.length + this.break, rebalance = null;
        if (measured && measured.from <= offset + left.length && measured.more)
            rebalance = left = left.updateHeight(oracle, offset, force, measured);
        else
            left.updateHeight(oracle, offset, force);
        if (measured && measured.from <= rightStart + right.length && measured.more)
            rebalance = right = right.updateHeight(oracle, rightStart, force, measured);
        else
            right.updateHeight(oracle, rightStart, force);
        if (rebalance)
            return this.balanced(left, right);
        this.height = this.left.height + this.right.height;
        this.outdated = false;
        return this;
    }
    toString() { return this.left + (this.break ? " " : "-") + this.right; }
}
function mergeGaps(nodes, around) {
    let before, after;
    if (nodes[around] == null &&
        (before = nodes[around - 1]) instanceof HeightMapGap &&
        (after = nodes[around + 1]) instanceof HeightMapGap)
        nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));
}
const relevantWidgetHeight = 5;
class NodeBuilder {
    constructor(pos, oracle) {
        this.pos = pos;
        this.oracle = oracle;
        this.nodes = [];
        this.lineStart = -1;
        this.lineEnd = -1;
        this.covering = null;
        this.writtenTo = pos;
    }
    get isCovered() {
        return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
    }
    span(_from, to) {
        if (this.lineStart > -1) {
            let end = Math.min(to, this.lineEnd), last = this.nodes[this.nodes.length - 1];
            if (last instanceof HeightMapText)
                last.length += end - this.pos;
            else if (end > this.pos || !this.isCovered)
                this.nodes.push(new HeightMapText(end - this.pos, -1));
            this.writtenTo = end;
            if (to > end) {
                this.nodes.push(null);
                this.writtenTo++;
                this.lineStart = -1;
            }
        }
        this.pos = to;
    }
    point(from, to, deco) {
        if (from < to || deco.heightRelevant) {
            let height = deco.widget ? Math.max(0, deco.widget.estimatedHeight) : 0;
            let len = to - from;
            if (deco.block) {
                this.addBlock(new HeightMapBlock(len, height, deco.type));
            }
            else if (len || height >= relevantWidgetHeight) {
                this.addLineDeco(height, len);
            }
        }
        else if (to > from) {
            this.span(from, to);
        }
        if (this.lineEnd > -1 && this.lineEnd < this.pos)
            this.lineEnd = this.oracle.doc.lineAt(this.pos).to;
    }
    enterLine() {
        if (this.lineStart > -1)
            return;
        let { from, to } = this.oracle.doc.lineAt(this.pos);
        this.lineStart = from;
        this.lineEnd = to;
        if (this.writtenTo < from) {
            if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null)
                this.nodes.push(this.blankContent(this.writtenTo, from - 1));
            this.nodes.push(null);
        }
        if (this.pos > from)
            this.nodes.push(new HeightMapText(this.pos - from, -1));
        this.writtenTo = this.pos;
    }
    blankContent(from, to) {
        let gap = new HeightMapGap(to - from);
        if (this.oracle.doc.lineAt(from).to == to)
            gap.flags |= 4 /* SingleLine */;
        return gap;
    }
    ensureLine() {
        this.enterLine();
        let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
        if (last instanceof HeightMapText)
            return last;
        let line = new HeightMapText(0, -1);
        this.nodes.push(line);
        return line;
    }
    addBlock(block) {
        this.enterLine();
        if (block.type == exports.BlockType.WidgetAfter && !this.isCovered)
            this.ensureLine();
        this.nodes.push(block);
        this.writtenTo = this.pos = this.pos + block.length;
        if (block.type != exports.BlockType.WidgetBefore)
            this.covering = block;
    }
    addLineDeco(height, length) {
        let line = this.ensureLine();
        line.length += length;
        line.collapsed += length;
        line.widgetHeight = Math.max(line.widgetHeight, height);
        this.writtenTo = this.pos = this.pos + length;
    }
    finish(from) {
        let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
        if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered)
            this.nodes.push(new HeightMapText(0, -1));
        else if (this.writtenTo < this.pos || last == null)
            this.nodes.push(this.blankContent(this.writtenTo, this.pos));
        let pos = from;
        for (let node of this.nodes) {
            if (node instanceof HeightMapText)
                node.updateHeight(this.oracle, pos);
            pos += node ? node.length : 1;
        }
        return this.nodes;
    }
    // Always called with a region that on both sides either stretches
    // to a line break or the end of the document.
    // The returned array uses null to indicate line breaks, but never
    // starts or ends in a line break, or has multiple line breaks next
    // to each other.
    static build(oracle, decorations, from, to) {
        let builder = new NodeBuilder(from, oracle);
        rangeset.RangeSet.spans(decorations, from, to, builder, 0);
        return builder.finish(from);
    }
}
function heightRelevantDecoChanges(a, b, diff) {
    let comp = new DecorationComparator;
    rangeset.RangeSet.compare(a, b, diff, comp, 0);
    return comp.changes;
}
class DecorationComparator {
    constructor() {
        this.changes = [];
    }
    compareRange() { }
    comparePoint(from, to, a, b) {
        if (from < to || a && a.heightRelevant || b && b.heightRelevant)
            addRange(from, to, this.changes, 5);
    }
}

function visiblePixelRange(dom, paddingTop) {
    let rect = dom.getBoundingClientRect();
    let left = Math.max(0, rect.left), right = Math.min(innerWidth, rect.right);
    let top = Math.max(0, rect.top), bottom = Math.min(innerHeight, rect.bottom);
    for (let parent = dom.parentNode; parent;) { // (Cast to any because TypeScript is useless with Node types)
        if (parent.nodeType == 1) {
            if ((parent.scrollHeight > parent.clientHeight || parent.scrollWidth > parent.clientWidth) &&
                window.getComputedStyle(parent).overflow != "visible") {
                let parentRect = parent.getBoundingClientRect();
                left = Math.max(left, parentRect.left);
                right = Math.min(right, parentRect.right);
                top = Math.max(top, parentRect.top);
                bottom = Math.min(bottom, parentRect.bottom);
            }
            parent = parent.parentNode;
        }
        else if (parent.nodeType == 11) { // Shadow root
            parent = parent.host;
        }
        else {
            break;
        }
    }
    return { left: left - rect.left, right: right - rect.left,
        top: top - (rect.top + paddingTop), bottom: bottom - (rect.top + paddingTop) };
}
// Line gaps are placeholder widgets used to hide pieces of overlong
// lines within the viewport, as a kludge to keep the editor
// responsive when a ridiculously long line is loaded into it.
class LineGap {
    constructor(from, to, size) {
        this.from = from;
        this.to = to;
        this.size = size;
    }
    static same(a, b) {
        if (a.length != b.length)
            return false;
        for (let i = 0; i < a.length; i++) {
            let gA = a[i], gB = b[i];
            if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size)
                return false;
        }
        return true;
    }
    draw(wrapping) {
        return Decoration.replace({ widget: new LineGapWidget(this.size, wrapping) }).range(this.from, this.to);
    }
}
class LineGapWidget extends WidgetType {
    constructor(size, vertical) {
        super();
        this.size = size;
        this.vertical = vertical;
    }
    eq(other) { return other.size == this.size && other.vertical == this.vertical; }
    toDOM() {
        let elt = document.createElement("div");
        if (this.vertical) {
            elt.style.height = this.size + "px";
        }
        else {
            elt.style.width = this.size + "px";
            elt.style.height = "2px";
            elt.style.display = "inline-block";
        }
        return elt;
    }
    get estimatedHeight() { return this.vertical ? this.size : -1; }
}
class ViewState {
    constructor(state) {
        this.state = state;
        // These are contentDOM-local coordinates
        this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 };
        this.inView = true;
        this.paddingTop = 0;
        this.paddingBottom = 0;
        this.contentWidth = 0;
        this.heightOracle = new HeightOracle;
        // See VP.MaxDOMHeight
        this.scaler = IdScaler;
        this.scrollTo = null;
        // Briefly set to true when printing, to disable viewport limiting
        this.printing = false;
        this.visibleRanges = [];
        // Cursor 'assoc' is only significant when the cursor is on a line
        // wrap point, where it must stick to the character that it is
        // associated with. Since browsers don't provide a reasonable
        // interface to set or query this, when a selection is set that
        // might cause this to be signficant, this flag is set. The next
        // measure phase will check whether the cursor is on a line-wrapping
        // boundary and, if so, reset it to make sure it is positioned in
        // the right place.
        this.mustEnforceCursorAssoc = false;
        this.heightMap = HeightMap.empty().applyChanges(state.facet(decorations), text.Text.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);
        this.viewport = this.getViewport(0, null);
        this.updateForViewport();
        this.lineGaps = this.ensureLineGaps([]);
        this.lineGapDeco = Decoration.set(this.lineGaps.map(gap => gap.draw(false)));
        this.computeVisibleRanges();
    }
    updateForViewport() {
        let viewports = [this.viewport], { main } = this.state.selection;
        for (let i = 0; i <= 1; i++) {
            let pos = i ? main.head : main.anchor;
            if (!viewports.some(({ from, to }) => pos >= from && pos <= to)) {
                let { from, to } = this.lineAt(pos, 0);
                viewports.push(new Viewport(from, to));
            }
        }
        this.viewports = viewports.sort((a, b) => a.from - b.from);
        this.scaler = this.heightMap.height <= 7000000 /* MaxDOMHeight */ ? IdScaler :
            new BigScaler(this.heightOracle.doc, this.heightMap, this.viewports);
    }
    update(update, scrollTo = null) {
        let prev = this.state;
        this.state = update.state;
        let newDeco = this.state.facet(decorations);
        let contentChanges = update.changedRanges;
        let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(update.startState.facet(decorations), newDeco, update ? update.changes : state.ChangeSet.empty(this.state.doc.length)));
        let prevHeight = this.heightMap.height;
        this.heightMap = this.heightMap.applyChanges(newDeco, prev.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);
        if (this.heightMap.height != prevHeight)
            update.flags |= 2 /* Height */;
        let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;
        if (scrollTo && (scrollTo.head < viewport.from || scrollTo.head > viewport.to) || !this.viewportIsAppropriate(viewport))
            viewport = this.getViewport(0, scrollTo);
        if (!viewport.eq(this.viewport)) {
            this.viewport = viewport;
            update.flags |= 4 /* Viewport */;
        }
        this.updateForViewport();
        if (this.lineGaps.length || this.viewport.to - this.viewport.from > 15000 /* MinViewPort */)
            update.flags |= this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));
        this.computeVisibleRanges();
        if (scrollTo)
            this.scrollTo = scrollTo;
        if (!this.mustEnforceCursorAssoc && update.selectionSet && update.view.lineWrapping &&
            update.state.selection.main.empty && update.state.selection.main.assoc)
            this.mustEnforceCursorAssoc = true;
    }
    measure(docView, repeated) {
        let dom = docView.dom, whiteSpace = "", direction = exports.Direction.LTR;
        if (!repeated) {
            // Vertical padding
            let style = window.getComputedStyle(dom);
            whiteSpace = style.whiteSpace, direction = (style.direction == "rtl" ? exports.Direction.RTL : exports.Direction.LTR);
            this.paddingTop = parseInt(style.paddingTop) || 0;
            this.paddingBottom = parseInt(style.paddingBottom) || 0;
        }
        // Pixel viewport
        let pixelViewport = this.printing ? { top: -1e8, bottom: 1e8, left: -1e8, right: 1e8 } : visiblePixelRange(dom, this.paddingTop);
        let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;
        this.pixelViewport = pixelViewport;
        this.inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
        if (!this.inView)
            return 0;
        let lineHeights = docView.measureVisibleLineHeights();
        let refresh = false, bias = 0, result = 0, oracle = this.heightOracle;
        if (!repeated) {
            let contentWidth = docView.dom.clientWidth;
            if (oracle.mustRefresh(lineHeights, whiteSpace, direction) ||
                oracle.lineWrapping && Math.abs(contentWidth - this.contentWidth) > oracle.charWidth) {
                let { lineHeight, charWidth } = docView.measureTextSize();
                refresh = oracle.refresh(whiteSpace, direction, lineHeight, charWidth, contentWidth / charWidth, lineHeights);
                if (refresh) {
                    docView.minWidth = 0;
                    result |= 16 /* Geometry */;
                }
            }
            if (this.contentWidth != contentWidth) {
                this.contentWidth = contentWidth;
                result |= 16 /* Geometry */;
            }
            if (dTop > 0 && dBottom > 0)
                bias = Math.max(dTop, dBottom);
            else if (dTop < 0 && dBottom < 0)
                bias = Math.min(dTop, dBottom);
        }
        oracle.heightChanged = false;
        this.heightMap = this.heightMap.updateHeight(oracle, 0, refresh, new MeasuredHeights(this.viewport.from, lineHeights));
        if (oracle.heightChanged)
            result |= 2 /* Height */;
        if (!this.viewportIsAppropriate(this.viewport, bias) ||
            this.scrollTo && (this.scrollTo.head < this.viewport.from || this.scrollTo.head > this.viewport.to)) {
            let newVP = this.getViewport(bias, this.scrollTo);
            if (newVP.from != this.viewport.from || newVP.to != this.viewport.to) {
                this.viewport = newVP;
                result |= 4 /* Viewport */;
            }
        }
        this.updateForViewport();
        if (this.lineGaps.length || this.viewport.to - this.viewport.from > 15000 /* MinViewPort */)
            result |= this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps));
        this.computeVisibleRanges();
        if (this.mustEnforceCursorAssoc) {
            this.mustEnforceCursorAssoc = false;
            // This is done in the read stage, because moving the selection
            // to a line end is going to trigger a layout anyway, so it
            // can't be a pure write. It should be rare that it does any
            // writing.
            docView.enforceCursorAssoc();
        }
        return result;
    }
    get visibleTop() { return this.scaler.fromDOM(this.pixelViewport.top, 0); }
    get visibleBottom() { return this.scaler.fromDOM(this.pixelViewport.bottom, 0); }
    getViewport(bias, scrollTo) {
        // This will divide VP.Margin between the top and the
        // bottom, depending on the bias (the change in viewport position
        // since the last update). It'll hold a number between 0 and 1
        let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1000 /* Margin */ / 2));
        let map = this.heightMap, doc = this.state.doc, { visibleTop, visibleBottom } = this;
        let viewport = new Viewport(map.lineAt(visibleTop - marginTop * 1000 /* Margin */, QueryType.ByHeight, doc, 0, 0).from, map.lineAt(visibleBottom + (1 - marginTop) * 1000 /* Margin */, QueryType.ByHeight, doc, 0, 0).to);
        // If scrollTo is given, make sure the viewport includes that position
        if (scrollTo) {
            if (scrollTo.head < viewport.from) {
                let { top: newTop } = map.lineAt(scrollTo.head, QueryType.ByPos, doc, 0, 0);
                viewport = new Viewport(map.lineAt(newTop - 1000 /* Margin */ / 2, QueryType.ByHeight, doc, 0, 0).from, map.lineAt(newTop + (visibleBottom - visibleTop) + 1000 /* Margin */ / 2, QueryType.ByHeight, doc, 0, 0).to);
            }
            else if (scrollTo.head > viewport.to) {
                let { bottom: newBottom } = map.lineAt(scrollTo.head, QueryType.ByPos, doc, 0, 0);
                viewport = new Viewport(map.lineAt(newBottom - (visibleBottom - visibleTop) - 1000 /* Margin */ / 2, QueryType.ByHeight, doc, 0, 0).from, map.lineAt(newBottom + 1000 /* Margin */ / 2, QueryType.ByHeight, doc, 0, 0).to);
            }
        }
        return viewport;
    }
    mapViewport(viewport, changes) {
        let from = changes.mapPos(viewport.from, -1), to = changes.mapPos(viewport.to, 1);
        return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.state.doc, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.state.doc, 0, 0).to);
    }
    // Checks if a given viewport covers the visible part of the
    // document and not too much beyond that.
    viewportIsAppropriate({ from, to }, bias = 0) {
        let { top } = this.heightMap.lineAt(from, QueryType.ByPos, this.state.doc, 0, 0);
        let { bottom } = this.heightMap.lineAt(to, QueryType.ByPos, this.state.doc, 0, 0);
        let { visibleTop, visibleBottom } = this;
        return (from == 0 || top <= visibleTop - Math.max(10 /* MinCoverMargin */, Math.min(-bias, 250 /* MaxCoverMargin */))) &&
            (to == this.state.doc.length ||
                bottom >= visibleBottom + Math.max(10 /* MinCoverMargin */, Math.min(bias, 250 /* MaxCoverMargin */))) &&
            (top > visibleTop - 2 * 1000 /* Margin */ && bottom < visibleBottom + 2 * 1000 /* Margin */);
    }
    mapLineGaps(gaps, changes) {
        if (!gaps.length || changes.empty)
            return gaps;
        let mapped = [];
        for (let gap of gaps)
            if (!changes.touchesRange(gap.from, gap.to))
                mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size));
        return mapped;
    }
    // Computes positions in the viewport where the start or end of a
    // line should be hidden, trying to reuse existing line gaps when
    // appropriate to avoid unneccesary redraws.
    // Uses crude character-counting for the positioning and sizing,
    // since actual DOM coordinates aren't always available and
    // predictable. Relies on generous margins (see LG.Margin) to hide
    // the artifacts this might produce from the user.
    ensureLineGaps(current) {
        let gaps = [];
        // This won't work at all in predominantly right-to-left text.
        if (this.heightOracle.direction != exports.Direction.LTR)
            return gaps;
        this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.state.doc, 0, 0, line => {
            if (line.length < 10000 /* Margin */)
                return;
            let structure = lineStructure(line.from, line.to, this.state);
            if (structure.total < 10000 /* Margin */)
                return;
            let viewFrom, viewTo;
            if (this.heightOracle.lineWrapping) {
                if (line.from != this.viewport.from)
                    viewFrom = line.from;
                else
                    viewFrom = findPosition(structure, (this.visibleTop - line.top) / line.height);
                if (line.to != this.viewport.to)
                    viewTo = line.to;
                else
                    viewTo = findPosition(structure, (this.visibleBottom - line.top) / line.height);
            }
            else {
                let totalWidth = structure.total * this.heightOracle.charWidth;
                viewFrom = findPosition(structure, this.pixelViewport.left / totalWidth);
                viewTo = findPosition(structure, this.pixelViewport.right / totalWidth);
            }
            let sel = this.state.selection.main;
            // Make sure the gap doesn't cover a selection end
            if (sel.from <= viewFrom && sel.to >= line.from)
                viewFrom = sel.from;
            if (sel.from <= line.to && sel.to >= viewTo)
                viewTo = sel.to;
            let gapTo = viewFrom - 10000 /* Margin */, gapFrom = viewTo + 10000 /* Margin */;
            if (gapTo > line.from + 5000 /* HalfMargin */)
                gaps.push(find(current, gap => gap.from == line.from && gap.to > gapTo - 5000 /* HalfMargin */ && gap.to < gapTo + 5000 /* HalfMargin */) ||
                    new LineGap(line.from, gapTo, this.gapSize(line, gapTo, true, structure)));
            if (gapFrom < line.to - 5000 /* HalfMargin */)
                gaps.push(find(current, gap => gap.to == line.to && gap.from > gapFrom - 5000 /* HalfMargin */ &&
                    gap.from < gapFrom + 5000 /* HalfMargin */) ||
                    new LineGap(gapFrom, line.to, this.gapSize(line, gapFrom, false, structure)));
        });
        return gaps;
    }
    gapSize(line, pos, start, structure) {
        if (this.heightOracle.lineWrapping) {
            let height = line.height * findFraction(structure, pos);
            return start ? height : line.height - height;
        }
        else {
            let ratio = findFraction(structure, pos);
            return structure.total * this.heightOracle.charWidth * (start ? ratio : 1 - ratio);
        }
    }
    updateLineGaps(gaps) {
        if (!LineGap.same(gaps, this.lineGaps)) {
            this.lineGaps = gaps;
            this.lineGapDeco = Decoration.set(gaps.map(gap => gap.draw(this.heightOracle.lineWrapping)));
            return 8 /* LineGaps */;
        }
        return 0;
    }
    computeVisibleRanges() {
        let deco = this.state.facet(decorations);
        if (this.lineGaps.length)
            deco = deco.concat(this.lineGapDeco);
        let ranges = [];
        rangeset.RangeSet.spans(deco, this.viewport.from, this.viewport.to, {
            span(from, to) { ranges.push({ from, to }); },
            point() { }
        }, 20);
        this.visibleRanges = ranges;
    }
    lineAt(pos, editorTop) {
        editorTop += this.paddingTop;
        return scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.state.doc, editorTop, 0), this.scaler, editorTop);
    }
    lineAtHeight(height, editorTop) {
        editorTop += this.paddingTop;
        return scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height, editorTop), QueryType.ByHeight, this.state.doc, editorTop, 0), this.scaler, editorTop);
    }
    blockAtHeight(height, editorTop) {
        editorTop += this.paddingTop;
        return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height, editorTop), this.state.doc, editorTop, 0), this.scaler, editorTop);
    }
    forEachLine(from, to, f, editorTop) {
        editorTop += this.paddingTop;
        return this.heightMap.forEachLine(from, to, this.state.doc, editorTop, 0, this.scaler.scale == 1 ? f : b => f(scaleBlock(b, this.scaler, editorTop)));
    }
    get contentHeight() {
        return this.domHeight + this.paddingTop + this.paddingBottom;
    }
    get domHeight() {
        return this.scaler.toDOM(this.heightMap.height, this.paddingTop);
    }
}
/**
Indicates the range of the document that is in the visible
viewport.
*/
class Viewport {
    constructor(from, to) {
        this.from = from;
        this.to = to;
    }
    eq(b) { return this.from == b.from && this.to == b.to; }
}
function lineStructure(from, to, state) {
    let ranges = [], pos = from, total = 0;
    rangeset.RangeSet.spans(state.facet(decorations), from, to, {
        span() { },
        point(from, to) {
            if (from > pos) {
                ranges.push({ from: pos, to: from });
                total += from - pos;
            }
            pos = to;
        }
    }, 20); // We're only interested in collapsed ranges of a significant size
    if (pos < to) {
        ranges.push({ from: pos, to });
        total += to - pos;
    }
    return { total, ranges };
}
function findPosition({ total, ranges }, ratio) {
    if (ratio <= 0)
        return ranges[0].from;
    if (ratio >= 1)
        return ranges[ranges.length - 1].to;
    let dist = Math.floor(total * ratio);
    for (let i = 0;; i++) {
        let { from, to } = ranges[i], size = to - from;
        if (dist <= size)
            return from + dist;
        dist -= size;
    }
}
function findFraction(structure, pos) {
    let counted = 0;
    for (let { from, to } of structure.ranges) {
        if (pos <= to) {
            counted += pos - from;
            break;
        }
        counted += to - from;
    }
    return counted / structure.total;
}
function find(array, f) {
    for (let val of array)
        if (f(val))
            return val;
    return undefined;
}
// Don't scale when the document height is within the range of what
// the DOM can handle.
const IdScaler = {
    toDOM(n) { return n; },
    fromDOM(n) { return n; },
    scale: 1
};
// When the height is too big (> VP.MaxDOMHeight), scale down the
// regions outside the viewports so that the total height is
// VP.MaxDOMHeight.
class BigScaler {
    constructor(doc, heightMap, viewports) {
        let vpHeight = 0, base = 0, domBase = 0;
        this.viewports = viewports.map(({ from, to }) => {
            let top = heightMap.lineAt(from, QueryType.ByPos, doc, 0, 0).top;
            let bottom = heightMap.lineAt(to, QueryType.ByPos, doc, 0, 0).bottom;
            vpHeight += bottom - top;
            return { from, to, top, bottom, domTop: 0, domBottom: 0 };
        });
        this.scale = (7000000 /* MaxDOMHeight */ - vpHeight) / (heightMap.height - vpHeight);
        for (let obj of this.viewports) {
            obj.domTop = domBase + (obj.top - base) * this.scale;
            domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);
            base = obj.bottom;
        }
    }
    toDOM(n, top) {
        n -= top;
        for (let i = 0, base = 0, domBase = 0;; i++) {
            let vp = i < this.viewports.length ? this.viewports[i] : null;
            if (!vp || n < vp.top)
                return domBase + (n - base) * this.scale + top;
            if (n <= vp.bottom)
                return vp.domTop + (n - vp.top) + top;
            base = vp.bottom;
            domBase = vp.domBottom;
        }
    }
    fromDOM(n, top) {
        n -= top;
        for (let i = 0, base = 0, domBase = 0;; i++) {
            let vp = i < this.viewports.length ? this.viewports[i] : null;
            if (!vp || n < vp.domTop)
                return base + (n - domBase) / this.scale + top;
            if (n <= vp.domBottom)
                return vp.top + (n - vp.domTop) + top;
            base = vp.bottom;
            domBase = vp.domBottom;
        }
    }
}
function scaleBlock(block, scaler, top) {
    if (scaler.scale == 1)
        return block;
    let bTop = scaler.toDOM(block.top, top), bBottom = scaler.toDOM(block.bottom, top);
    return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block.type) ? block.type.map(b => scaleBlock(b, scaler, top)) : block.type);
}

const theme = state.Facet.define({ combine: strs => strs.join(" ") });
const darkTheme = state.Facet.define({ combine: values => values.indexOf(true) > -1 });
const baseThemeID = styleMod.StyleModule.newName(), baseLightID = styleMod.StyleModule.newName(), baseDarkID = styleMod.StyleModule.newName();
const lightDarkIDs = { "&light": "." + baseLightID, "&dark": "." + baseDarkID };
function buildTheme(main, spec, scopes) {
    return new styleMod.StyleModule(spec, {
        finish(sel) {
            return /&/.test(sel) ? sel.replace(/&\w*/, m => {
                if (m == "&")
                    return main;
                if (!scopes || !scopes[m])
                    throw new RangeError(`Unsupported selector: ${m}`);
                return scopes[m];
            }) : main + " " + sel;
        }
    });
}
const baseTheme = buildTheme("." + baseThemeID, {
    "&": {
        position: "relative !important",
        boxSizing: "border-box",
        "&.cm-focused": {
            // Provide a simple default outline to make sure a focused
            // editor is visually distinct. Can't leave the default behavior
            // because that will apply to the content element, which is
            // inside the scrollable container and doesn't include the
            // gutters. We also can't use an 'auto' outline, since those
            // are, for some reason, drawn behind the element content, which
            // will cause things like the active line background to cover
            // the outline (#297).
            outline: "1px dotted #212121"
        },
        display: "flex !important",
        flexDirection: "column"
    },
    ".cm-scroller": {
        display: "flex !important",
        alignItems: "flex-start !important",
        fontFamily: "monospace",
        lineHeight: 1.4,
        flexGrow: 2,
        overflowX: "auto",
        position: "relative",
        zIndex: 0
    },
    ".cm-content": {
        margin: 0,
        flexGrow: 2,
        minHeight: "100%",
        display: "block",
        whiteSpace: "pre",
        wordWrap: "normal",
        boxSizing: "border-box",
        padding: "4px 0",
        outline: "none"
    },
    ".cm-lineWrapping": {
        whiteSpace: "pre-wrap",
        overflowWrap: "anywhere"
    },
    "&light .cm-content": { caretColor: "black" },
    "&dark .cm-content": { caretColor: "white" },
    ".cm-line": {
        display: "block",
        padding: "0 2px 0 4px"
    },
    ".cm-selectionLayer": {
        zIndex: -1,
        contain: "size style"
    },
    ".cm-selectionBackground": {
        position: "absolute",
    },
    "&light .cm-selectionBackground": {
        background: "#d9d9d9"
    },
    "&dark .cm-selectionBackground": {
        background: "#222"
    },
    "&light.cm-focused .cm-selectionBackground": {
        background: "#d7d4f0"
    },
    "&dark.cm-focused .cm-selectionBackground": {
        background: "#233"
    },
    ".cm-cursorLayer": {
        zIndex: 100,
        contain: "size style",
        pointerEvents: "none"
    },
    "&.cm-focused .cm-cursorLayer": {
        animation: "steps(1) cm-blink 1.2s infinite"
    },
    // Two animations defined so that we can switch between them to
    // restart the animation without forcing another style
    // recomputation.
    "@keyframes cm-blink": { "0%": {}, "50%": { visibility: "hidden" }, "100%": {} },
    "@keyframes cm-blink2": { "0%": {}, "50%": { visibility: "hidden" }, "100%": {} },
    ".cm-cursor": {
        position: "absolute",
        borderLeft: "1.2px solid black",
        marginLeft: "-0.6px",
        pointerEvents: "none",
        display: "none"
    },
    "&dark .cm-cursor": {
        borderLeftColor: "#444"
    },
    "&.cm-focused .cm-cursor": {
        display: "block"
    },
    "&light .cm-activeLine": { backgroundColor: "#f3f9ff" },
    "&dark .cm-activeLine": { backgroundColor: "#223039" },
    "&light .cm-specialChar": { color: "red" },
    "&dark .cm-specialChar": { color: "#f78" },
    ".cm-tab": {
        display: "inline-block",
        overflow: "hidden",
        verticalAlign: "bottom"
    },
    ".cm-placeholder": {
        color: "#888",
        display: "inline-block"
    },
    ".cm-button": {
        verticalAlign: "middle",
        color: "inherit",
        fontSize: "70%",
        padding: ".2em 1em",
        borderRadius: "3px"
    },
    "&light .cm-button": {
        backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
        border: "1px solid #888",
        "&:active": {
            backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
        }
    },
    "&dark .cm-button": {
        backgroundImage: "linear-gradient(#393939, #111)",
        border: "1px solid #888",
        "&:active": {
            backgroundImage: "linear-gradient(#111, #333)"
        }
    },
    ".cm-textfield": {
        verticalAlign: "middle",
        color: "inherit",
        fontSize: "70%",
        border: "1px solid silver",
        padding: ".2em .5em"
    },
    "&light .cm-textfield": {
        backgroundColor: "white"
    },
    "&dark .cm-textfield": {
        border: "1px solid #555",
        backgroundColor: "inherit"
    }
}, lightDarkIDs);

const observeOptions = {
    childList: true,
    characterData: true,
    subtree: true,
    characterDataOldValue: true
};
// IE11 has very broken mutation observers, so we also listen to
// DOMCharacterDataModified there
const useCharData = browser.ie && browser.ie_version <= 11;
class DOMObserver {
    constructor(view, onChange, onScrollChanged) {
        this.view = view;
        this.onChange = onChange;
        this.onScrollChanged = onScrollChanged;
        this.active = false;
        this.ignoreSelection = new DOMSelection;
        this.delayedFlush = -1;
        this.queue = [];
        this.scrollTargets = [];
        this.intersection = null;
        this.intersecting = false;
        // Timeout for scheduling check of the parents that need scroll handlers
        this.parentCheck = -1;
        this.dom = view.contentDOM;
        this.observer = new MutationObserver(mutations => {
            for (let mut of mutations)
                this.queue.push(mut);
            // IE11 will sometimes (on typing over a selection or
            // backspacing out a single character text node) call the
            // observer callback before actually updating the DOM.
            //
            // Unrelatedly, iOS Safari will, when ending a composition,
            // sometimes first clear it, deliver the mutations, and then
            // reinsert the finished text. CodeMirror's handling of the
            // deletion will prevent the reinsertion from happening,
            // breaking composition.
            if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) &&
                mutations.some(m => m.type == "childList" && m.removedNodes.length ||
                    m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
                this.flushSoon();
            else
                this.flush();
        });
        if (useCharData)
            this.onCharData = (event) => {
                this.queue.push({ target: event.target,
                    type: "characterData",
                    oldValue: event.prevValue });
                this.flushSoon();
            };
        this.onSelectionChange = this.onSelectionChange.bind(this);
        this.start();
        this.onScroll = this.onScroll.bind(this);
        window.addEventListener("scroll", this.onScroll);
        if (typeof IntersectionObserver == "function") {
            this.intersection = new IntersectionObserver(entries => {
                if (this.parentCheck < 0)
                    this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1000);
                if (entries[entries.length - 1].intersectionRatio > 0 != this.intersecting) {
                    this.intersecting = !this.intersecting;
                    if (this.intersecting != this.view.inView)
                        this.onScrollChanged(document.createEvent("Event"));
                }
            }, {});
            this.intersection.observe(this.dom);
        }
        this.listenForScroll();
    }
    onScroll(e) {
        if (this.intersecting) {
            this.flush();
            this.onScrollChanged(e);
        }
    }
    onSelectionChange(event) {
        let { view } = this, sel = getSelection(view.root);
        if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(view.dom, sel))
            return;
        let context = sel.anchorNode && view.docView.nearest(sel.anchorNode);
        if (context && context.ignoreEvent(event))
            return;
        // Deletions on IE11 fire their events in the wrong order, giving
        // us a selection change event before the DOM changes are
        // reported.
        // (Selection.isCollapsed isn't reliable on IE)
        if (browser.ie && browser.ie_version <= 11 && !view.state.selection.main.empty &&
            sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
            this.flushSoon();
        else
            this.flush();
    }
    listenForScroll() {
        this.parentCheck = -1;
        let i = 0, changed = null;
        for (let dom = this.dom; dom;) {
            if (dom.nodeType == 1) {
                if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom)
                    i++;
                else if (!changed)
                    changed = this.scrollTargets.slice(0, i);
                if (changed)
                    changed.push(dom);
                dom = dom.parentNode;
            }
            else if (dom.nodeType == 11) { // Shadow root
                dom = dom.host;
            }
            else {
                break;
            }
        }
        if (i < this.scrollTargets.length && !changed)
            changed = this.scrollTargets.slice(0, i);
        if (changed) {
            for (let dom of this.scrollTargets)
                dom.removeEventListener("scroll", this.onScroll);
            for (let dom of this.scrollTargets = changed)
                dom.addEventListener("scroll", this.onScroll);
        }
    }
    ignore(f) {
        if (!this.active)
            return f();
        try {
            this.stop();
            return f();
        }
        finally {
            this.start();
            this.clear();
        }
    }
    start() {
        if (this.active)
            return;
        this.observer.observe(this.dom, observeOptions);
        this.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
        if (useCharData)
            this.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
        this.active = true;
    }
    stop() {
        if (!this.active)
            return;
        this.active = false;
        this.observer.disconnect();
        this.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
        if (useCharData)
            this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
    }
    clearSelection() {
        this.ignoreSelection.set(getSelection(this.view.root));
    }
    // Throw away any pending changes
    clear() {
        this.observer.takeRecords();
        this.queue.length = 0;
        this.clearSelection();
    }
    flushSoon() {
        if (this.delayedFlush < 0)
            this.delayedFlush = window.setTimeout(() => { this.delayedFlush = -1; this.flush(); }, 20);
    }
    forceFlush() {
        if (this.delayedFlush >= 0) {
            window.clearTimeout(this.delayedFlush);
            this.delayedFlush = -1;
            this.flush();
        }
    }
    // Apply pending changes, if any
    flush() {
        if (this.delayedFlush >= 0)
            return;
        let records = this.queue;
        for (let mut of this.observer.takeRecords())
            records.push(mut);
        if (records.length)
            this.queue = [];
        let selection = getSelection(this.view.root);
        let newSel = !this.ignoreSelection.eq(selection) && hasSelection(this.dom, selection);
        if (records.length == 0 && !newSel)
            return;
        let from = -1, to = -1, typeOver = false;
        for (let record of records) {
            let range = this.readMutation(record);
            if (!range)
                continue;
            if (range.typeOver)
                typeOver = true;
            if (from == -1) {
                ({ from, to } = range);
            }
            else {
                from = Math.min(range.from, from);
                to = Math.max(range.to, to);
            }
        }
        let startState = this.view.state;
        if (from > -1 || newSel)
            this.onChange(from, to, typeOver);
        if (this.view.state == startState) { // The view wasn't updated
            if (this.view.docView.dirty) {
                this.ignore(() => this.view.docView.sync());
                this.view.docView.dirty = 0 /* Not */;
            }
            this.view.docView.updateSelection();
        }
        this.clearSelection();
    }
    readMutation(rec) {
        let cView = this.view.docView.nearest(rec.target);
        if (!cView || cView.ignoreMutation(rec))
            return null;
        cView.markDirty();
        if (rec.type == "childList") {
            let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);
            let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);
            return { from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,
                to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd, typeOver: false };
        }
        else { // "characterData"
            return { from: cView.posAtStart, to: cView.posAtEnd, typeOver: rec.target.nodeValue == rec.oldValue };
        }
    }
    destroy() {
        this.stop();
        if (this.intersection)
            this.intersection.disconnect();
        for (let dom of this.scrollTargets)
            dom.removeEventListener("scroll", this.onScroll);
        window.removeEventListener("scroll", this.onScroll);
        clearTimeout(this.parentCheck);
    }
}
function findChild(cView, dom, dir) {
    while (dom) {
        let curView = ContentView.get(dom);
        if (curView && curView.parent == cView)
            return curView;
        let parent = dom.parentNode;
        dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;
    }
    return null;
}

function applyDOMChange(view, start, end, typeOver) {
    let change, newSel;
    let sel = view.state.selection.main, bounds;
    if (start > -1 && (bounds = view.docView.domBoundsAround(start, end, 0))) {
        let { from, to } = bounds;
        let selPoints = view.docView.impreciseHead || view.docView.impreciseAnchor ? [] : selectionPoints(view.contentDOM, view.root);
        let reader = new DOMReader(selPoints, view);
        reader.readRange(bounds.startDOM, bounds.endDOM);
        newSel = selectionFromPoints(selPoints, from);
        let preferredPos = sel.from, preferredSide = null;
        // Prefer anchoring to end when Backspace is pressed (or, on
        // Android, when something was deleted)
        if (view.inputState.lastKeyCode === 8 && view.inputState.lastKeyTime > Date.now() - 100 ||
            browser.android && reader.text.length < to - from) {
            preferredPos = sel.to;
            preferredSide = "end";
        }
        let diff = findDiff(view.state.sliceDoc(from, to), reader.text, preferredPos - from, preferredSide);
        if (diff)
            change = { from: from + diff.from, to: from + diff.toA,
                insert: view.state.toText(reader.text.slice(diff.from, diff.toB)) };
    }
    else if (view.hasFocus || !view.state.facet(editable)) {
        let domSel = getSelection(view.root);
        let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view.docView;
        let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset ||
            !contains(view.contentDOM, domSel.focusNode)
            ? view.state.selection.main.head
            : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
        let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset ||
            !contains(view.contentDOM, domSel.anchorNode)
            ? view.state.selection.main.anchor
            : selectionCollapsed(domSel) ? head : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
        if (head != sel.head || anchor != sel.anchor)
            newSel = state.EditorSelection.single(anchor, head);
    }
    if (!change && !newSel)
        return;
    // Heuristic to notice typing over a selected character
    if (!change && typeOver && !sel.empty && newSel && newSel.main.empty)
        change = { from: sel.from, to: sel.to, insert: view.state.doc.slice(sel.from, sel.to) };
    if (change) {
        let startState = view.state;
        // Android browsers don't fire reasonable key events for enter,
        // backspace, or delete. So this detects changes that look like
        // they're caused by those keys, and reinterprets them as key
        // events.
        if (browser.android &&
            ((change.from == sel.from && change.to == sel.to &&
                change.insert.length == 1 && change.insert.lines == 2 &&
                dispatchKey(view, "Enter", 13)) ||
                (change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 &&
                    dispatchKey(view, "Backspace", 8)) ||
                (change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 &&
                    dispatchKey(view, "Delete", 46))) ||
            browser.ios &&
                ((view.inputState.lastIOSEnter > Date.now() - 225 && change.insert.lines > 1 &&
                    dispatchKey(view, "Enter", 13)) ||
                    (view.inputState.lastIOSBackspace > Date.now() - 225 && !change.insert.length &&
                        dispatchKey(view, "Backspace", 8))))
            return;
        let text = change.insert.toString();
        if (view.state.facet(inputHandler).some(h => h(view, change.from, change.to, text)))
            return;
        if (view.inputState.composing >= 0)
            view.inputState.composing++;
        let tr;
        if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 &&
            (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length)) {
            let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : "";
            let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : "";
            tr = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, undefined, view.state.lineBreak) +
                after));
        }
        else {
            let changes = startState.changes(change);
            tr = {
                changes,
                selection: newSel && !startState.selection.main.eq(newSel.main) && newSel.main.to <= changes.newLength
                    ? startState.selection.replaceRange(newSel.main) : undefined
            };
        }
        view.dispatch(tr, { scrollIntoView: true, annotations: state.Transaction.userEvent.of("input") });
    }
    else if (newSel && !newSel.main.eq(sel)) {
        let scrollIntoView = false, annotations;
        if (view.inputState.lastSelectionTime > Date.now() - 50) {
            if (view.inputState.lastSelectionOrigin == "keyboardselection")
                scrollIntoView = true;
            else
                annotations = state.Transaction.userEvent.of(view.inputState.lastSelectionOrigin);
        }
        view.dispatch({ selection: newSel, scrollIntoView, annotations });
    }
}
function findDiff(a, b, preferredPos, preferredSide) {
    let minLen = Math.min(a.length, b.length);
    let from = 0;
    while (from < minLen && a.charCodeAt(from) == b.charCodeAt(from))
        from++;
    if (from == minLen && a.length == b.length)
        return null;
    let toA = a.length, toB = b.length;
    while (toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {
        toA--;
        toB--;
    }
    if (preferredSide == "end") {
        let adjust = Math.max(0, from - Math.min(toA, toB));
        preferredPos -= toA + adjust - from;
    }
    if (toA < from && a.length < b.length) {
        let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;
        from -= move;
        toB = from + (toB - toA);
        toA = from;
    }
    else if (toB < from) {
        let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;
        from -= move;
        toA = from + (toA - toB);
        toB = from;
    }
    return { from, toA, toB };
}
class DOMReader {
    constructor(points, view) {
        this.points = points;
        this.view = view;
        this.text = "";
        this.lineBreak = view.state.lineBreak;
    }
    readRange(start, end) {
        if (!start)
            return;
        let parent = start.parentNode;
        for (let cur = start;;) {
            this.findPointBefore(parent, cur);
            this.readNode(cur);
            let next = cur.nextSibling;
            if (next == end)
                break;
            let view = ContentView.get(cur), nextView = ContentView.get(next);
            if ((view ? view.breakAfter : isBlockElement(cur)) ||
                ((nextView ? nextView.breakAfter : isBlockElement(next)) && !(cur.nodeName == "BR" && !cur.cmIgnore)))
                this.text += this.lineBreak;
            cur = next;
        }
        this.findPointBefore(parent, end);
    }
    readNode(node) {
        if (node.cmIgnore)
            return;
        let view = ContentView.get(node);
        let fromView = view && view.overrideDOMText;
        let text;
        if (fromView != null)
            text = fromView.sliceString(0, undefined, this.lineBreak);
        else if (node.nodeType == 3)
            text = node.nodeValue;
        else if (node.nodeName == "BR")
            text = node.nextSibling ? this.lineBreak : "";
        else if (node.nodeType == 1)
            this.readRange(node.firstChild, null);
        if (text != null) {
            this.findPointIn(node, text.length);
            this.text += text;
            // Chrome inserts two newlines when pressing shift-enter at the
            // end of a line. This drops one of those.
            if (browser.chrome && this.view.inputState.lastKeyCode == 13 && !node.nextSibling && /\n\n$/.test(this.text))
                this.text = this.text.slice(0, -1);
        }
    }
    findPointBefore(node, next) {
        for (let point of this.points)
            if (point.node == node && node.childNodes[point.offset] == next)
                point.pos = this.text.length;
    }
    findPointIn(node, maxLen) {
        for (let point of this.points)
            if (point.node == node)
                point.pos = this.text.length + Math.min(point.offset, maxLen);
    }
}
function isBlockElement(node) {
    return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node.nodeName);
}
class DOMPoint {
    constructor(node, offset) {
        this.node = node;
        this.offset = offset;
        this.pos = -1;
    }
}
function selectionPoints(dom, root) {
    let result = [];
    if (root.activeElement != dom)
        return result;
    let { anchorNode, anchorOffset, focusNode, focusOffset } = getSelection(root);
    if (anchorNode) {
        result.push(new DOMPoint(anchorNode, anchorOffset));
        if (focusNode != anchorNode || focusOffset != anchorOffset)
            result.push(new DOMPoint(focusNode, focusOffset));
    }
    return result;
}
function selectionFromPoints(points, base) {
    if (points.length == 0)
        return null;
    let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;
    return anchor > -1 && head > -1 ? state.EditorSelection.single(anchor + base, head + base) : null;
}
function dispatchKey(view, name, code) {
    let options = { key: name, code: name, keyCode: code, which: code, cancelable: true };
    let down = new KeyboardEvent("keydown", options);
    down.synthetic = true;
    view.contentDOM.dispatchEvent(down);
    let up = new KeyboardEvent("keyup", options);
    up.synthetic = true;
    view.contentDOM.dispatchEvent(up);
    return down.defaultPrevented || up.defaultPrevented;
}

// The editor's update state machine looks something like this:
//
//     Idle ‚Üí Updating ‚áÜ Idle (unchecked) ‚Üí Measuring ‚Üí Idle
//                                         ‚Üë      ‚Üì
//                                         Updating (measure)
//
// The difference between 'Idle' and 'Idle (unchecked)' lies in
// whether a layout check has been scheduled. A regular update through
// the `update` method updates the DOM in a write-only fashion, and
// relies on a check (scheduled with `requestAnimationFrame`) to make
// sure everything is where it should be and the viewport covers the
// visible code. That check continues to measure and then optionally
// update until it reaches a coherent state.
/**
An editor view represents the editor's user interface. It holds
the editable DOM surface, and possibly other elements such as the
line number gutter. It handles events and dispatches state
transactions for editing actions.
*/
class EditorView {
    /**
    Construct a new view. You'll usually want to put `view.dom` into
    your document after creating a view, so that the user can see
    it.
    */
    constructor(
    /**
    Initialization options.
    */
    config = {}) {
        this.plugins = [];
        this.editorAttrs = {};
        this.contentAttrs = {};
        this.bidiCache = [];
        /**
        @internal
        */
        this.updateState = 2 /* Updating */;
        /**
        @internal
        */
        this.measureScheduled = -1;
        /**
        @internal
        */
        this.measureRequests = [];
        this.contentDOM = document.createElement("div");
        this.scrollDOM = document.createElement("div");
        this.scrollDOM.tabIndex = -1;
        this.scrollDOM.className = "cm-scroller";
        this.scrollDOM.appendChild(this.contentDOM);
        this.announceDOM = document.createElement("div");
        this.announceDOM.style.cssText = "position: absolute; top: -10000px";
        this.announceDOM.setAttribute("aria-live", "polite");
        this.dom = document.createElement("div");
        this.dom.appendChild(this.announceDOM);
        this.dom.appendChild(this.scrollDOM);
        this._dispatch = config.dispatch || ((tr) => this.update([tr]));
        this.dispatch = this.dispatch.bind(this);
        this.root = (config.root || document);
        this.viewState = new ViewState(config.state || state.EditorState.create());
        this.plugins = this.state.facet(viewPlugin).map(spec => new PluginInstance(spec).update(this));
        this.observer = new DOMObserver(this, (from, to, typeOver) => {
            applyDOMChange(this, from, to, typeOver);
        }, event => {
            this.inputState.runScrollHandlers(this, event);
            this.measure();
        });
        this.inputState = new InputState(this);
        this.docView = new DocView(this);
        this.mountStyles();
        this.updateAttrs();
        this.updateState = 0 /* Idle */;
        ensureGlobalHandler();
        this.requestMeasure();
        if (config.parent)
            config.parent.appendChild(this.dom);
    }
    /**
    The current editor state.
    */
    get state() { return this.viewState.state; }
    /**
    To be able to display large documents without consuming too much
    memory or overloading the browser, CodeMirror only draws the
    code that is visible (plus a margin around it) to the DOM. This
    property tells you the extent of the current drawn viewport, in
    document positions.
    */
    get viewport() { return this.viewState.viewport; }
    /**
    When there are, for example, large collapsed ranges in the
    viewport, its size can be a lot bigger than the actual visible
    content. Thus, if you are doing something like styling the
    content in the viewport, it is preferable to only do so for
    these ranges, which are the subset of the viewport that is
    actually drawn.
    */
    get visibleRanges() { return this.viewState.visibleRanges; }
    /**
    Returns false when the editor is entirely scrolled out of view
    or otherwise hidden.
    */
    get inView() { return this.viewState.inView; }
    /**
    Indicates whether the user is currently composing text via
    [IME](https://developer.mozilla.org/en-US/docs/Mozilla/IME_handling_guide).
    */
    get composing() { return this.inputState.composing > 0; }
    dispatch(...input) {
        this._dispatch(input.length == 1 && input[0] instanceof state.Transaction ? input[0]
            : this.state.update(...input));
    }
    /**
    Update the view for the given array of transactions. This will
    update the visible document and selection to match the state
    produced by the transactions, and notify view plugins of the
    change. You should usually call
    [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
    as a primitive.
    */
    update(transactions) {
        if (this.updateState != 0 /* Idle */)
            throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
        let redrawn = false, update;
        let state$1 = this.state;
        for (let tr of transactions) {
            if (tr.startState != state$1)
                throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
            state$1 = tr.state;
        }
        // When the phrases change, redraw the editor
        if (state$1.facet(state.EditorState.phrases) != this.state.facet(state.EditorState.phrases))
            return this.setState(state$1);
        update = new ViewUpdate(this, state$1, transactions);
        try {
            this.updateState = 2 /* Updating */;
            let scrollTo = transactions.some(tr => tr.scrollIntoView) ? state$1.selection.main : null;
            this.viewState.update(update, scrollTo);
            this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);
            if (!update.empty)
                this.updatePlugins(update);
            redrawn = this.docView.update(update);
            if (this.state.facet(styleModule) != this.styleModules)
                this.mountStyles();
            this.updateAttrs();
            this.showAnnouncements(transactions);
        }
        finally {
            this.updateState = 0 /* Idle */;
        }
        if (redrawn || scrollTo || this.viewState.mustEnforceCursorAssoc)
            this.requestMeasure();
        if (!update.empty)
            for (let listener of this.state.facet(updateListener))
                listener(update);
    }
    /**
    Reset the view to the given state. (This will cause the entire
    document to be redrawn and all view plugins to be reinitialized,
    so you should probably only use it when the new state isn't
    derived from the old state. Otherwise, use
    [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
    */
    setState(newState) {
        if (this.updateState != 0 /* Idle */)
            throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
        this.updateState = 2 /* Updating */;
        try {
            for (let plugin of this.plugins)
                plugin.destroy(this);
            this.viewState = new ViewState(newState);
            this.plugins = newState.facet(viewPlugin).map(spec => new PluginInstance(spec).update(this));
            this.docView = new DocView(this);
            this.inputState.ensureHandlers(this);
            this.mountStyles();
            this.updateAttrs();
            this.bidiCache = [];
        }
        finally {
            this.updateState = 0 /* Idle */;
        }
        this.requestMeasure();
    }
    updatePlugins(update) {
        let prevSpecs = update.startState.facet(viewPlugin), specs = update.state.facet(viewPlugin);
        if (prevSpecs != specs) {
            let newPlugins = [];
            for (let spec of specs) {
                let found = prevSpecs.indexOf(spec);
                if (found < 0) {
                    newPlugins.push(new PluginInstance(spec));
                }
                else {
                    let plugin = this.plugins[found];
                    plugin.mustUpdate = update;
                    newPlugins.push(plugin);
                }
            }
            for (let plugin of this.plugins)
                if (plugin.mustUpdate != update)
                    plugin.destroy(this);
            this.plugins = newPlugins;
            this.inputState.ensureHandlers(this);
        }
        else {
            for (let p of this.plugins)
                p.mustUpdate = update;
        }
        for (let i = 0; i < this.plugins.length; i++)
            this.plugins[i] = this.plugins[i].update(this);
    }
    /**
    @internal
    */
    measure() {
        if (this.measureScheduled > -1)
            cancelAnimationFrame(this.measureScheduled);
        this.measureScheduled = -1; // Prevent requestMeasure calls from scheduling another animation frame
        let updated = null;
        try {
            for (let i = 0;; i++) {
                this.updateState = 1 /* Measuring */;
                let changed = this.viewState.measure(this.docView, i > 0);
                let measuring = this.measureRequests;
                if (!changed && !measuring.length && this.viewState.scrollTo == null)
                    break;
                this.measureRequests = [];
                if (i > 5) {
                    console.warn("Viewport failed to stabilize");
                    break;
                }
                let measured = measuring.map(m => {
                    try {
                        return m.read(this);
                    }
                    catch (e) {
                        logException(this.state, e);
                        return BadMeasure;
                    }
                });
                let update = new ViewUpdate(this, this.state);
                update.flags |= changed;
                if (!updated)
                    updated = update;
                else
                    updated.flags |= changed;
                this.updateState = 2 /* Updating */;
                if (!update.empty)
                    this.updatePlugins(update);
                this.updateAttrs();
                if (changed)
                    this.docView.update(update);
                for (let i = 0; i < measuring.length; i++)
                    if (measured[i] != BadMeasure) {
                        try {
                            measuring[i].write(measured[i], this);
                        }
                        catch (e) {
                            logException(this.state, e);
                        }
                    }
                if (this.viewState.scrollTo) {
                    this.docView.scrollPosIntoView(this.viewState.scrollTo.head, this.viewState.scrollTo.assoc);
                    this.viewState.scrollTo = null;
                }
                if (!(changed & 4 /* Viewport */) && this.measureRequests.length == 0)
                    break;
            }
        }
        finally {
            this.updateState = 0 /* Idle */;
        }
        this.measureScheduled = -1;
        if (updated && !updated.empty)
            for (let listener of this.state.facet(updateListener))
                listener(updated);
    }
    /**
    Get the CSS classes for the currently active editor themes.
    */
    get themeClasses() {
        return baseThemeID + " " +
            (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + " " +
            this.state.facet(theme);
    }
    updateAttrs() {
        let editorAttrs = combineAttrs(this.state.facet(editorAttributes), {
            // FIXME drop cm-wrap in next major release
            class: "cm-editor cm-wrap" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
        });
        updateAttrs(this.dom, this.editorAttrs, editorAttrs);
        this.editorAttrs = editorAttrs;
        let contentAttrs = combineAttrs(this.state.facet(contentAttributes), {
            spellcheck: "false",
            contenteditable: String(this.state.facet(editable)),
            class: "cm-content",
            style: `${browser.tabSize}: ${this.state.tabSize}`,
            role: "textbox",
            "aria-multiline": "true"
        });
        updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);
        this.contentAttrs = contentAttrs;
    }
    showAnnouncements(trs) {
        let first = true;
        for (let tr of trs)
            for (let effect of tr.effects)
                if (effect.is(EditorView.announce)) {
                    if (first)
                        this.announceDOM.textContent = "";
                    first = false;
                    let div = this.announceDOM.appendChild(document.createElement("div"));
                    div.textContent = effect.value;
                }
    }
    mountStyles() {
        this.styleModules = this.state.facet(styleModule);
        styleMod.StyleModule.mount(this.root, this.styleModules.concat(baseTheme).reverse());
    }
    readMeasured() {
        if (this.updateState == 2 /* Updating */)
            throw new Error("Reading the editor layout isn't allowed during an update");
        if (this.updateState == 0 /* Idle */ && this.measureScheduled > -1)
            this.measure();
    }
    /**
    Make sure plugins get a chance to measure the DOM layout before
    the next frame. Calling this is preferable reading DOM layout
    directly from, for example, an event handler, because it'll make
    sure measuring and drawing done by other components is
    synchronized, avoiding unnecessary DOM layout computations.
    */
    requestMeasure(request) {
        if (this.measureScheduled < 0)
            this.measureScheduled = requestAnimationFrame(() => this.measure());
        if (request) {
            if (request.key != null)
                for (let i = 0; i < this.measureRequests.length; i++) {
                    if (this.measureRequests[i].key === request.key) {
                        this.measureRequests[i] = request;
                        return;
                    }
                }
            this.measureRequests.push(request);
        }
    }
    /**
    Collect all values provided by the active plugins for a given
    field.
    */
    pluginField(field) {
        let result = [];
        for (let plugin of this.plugins)
            plugin.update(this).takeField(field, result);
        return result;
    }
    /**
    Get the value of a specific plugin, if present. Note that
    plugins that crash can be dropped from a view, so even when you
    know you registered a given plugin, it is recommended to check
    the return value of this method.
    */
    plugin(plugin) {
        for (let inst of this.plugins)
            if (inst.spec == plugin)
                return inst.update(this).value;
        return null;
    }
    /**
    Find the line or block widget at the given vertical position.
    
    By default, this position is interpreted as a screen position,
    meaning `docTop` is set to the DOM top position of the editor
    content (forcing a layout). You can pass a different `docTop`
    value‚Äîfor example 0 to interpret `height` as a document-relative
    position, or a precomputed document top
    (`view.contentDOM.getBoundingClientRect().top`) to limit layout
    queries.
    */
    blockAtHeight(height, docTop) {
        this.readMeasured();
        return this.viewState.blockAtHeight(height, ensureTop(docTop, this.contentDOM));
    }
    /**
    Find information for the visual line (see
    [`visualLineAt`](https://codemirror.net/6/docs/ref/#view.EditorView.visualLineAt)) at the given
    vertical position. The resulting block info might hold another
    array of block info structs in its `type` field if this line
    consists of more than one block.
    
    Defaults to treating `height` as a screen position. See
    [`blockAtHeight`](https://codemirror.net/6/docs/ref/#view.EditorView.blockAtHeight) for the
    interpretation of the `docTop` parameter.
    */
    visualLineAtHeight(height, docTop) {
        this.readMeasured();
        return this.viewState.lineAtHeight(height, ensureTop(docTop, this.contentDOM));
    }
    /**
    Iterate over the height information of the visual lines in the
    viewport. The heights of lines are reported relative to the
    given document top, which defaults to the screen position of the
    document (forcing a layout).
    */
    viewportLines(f, docTop) {
        let { from, to } = this.viewport;
        this.viewState.forEachLine(from, to, f, ensureTop(docTop, this.contentDOM));
    }
    /**
    Find the extent and height of the visual line (the content shown
    in the editor as a line, which may be smaller than a document
    line when broken up by block widgets, or bigger than a document
    line when line breaks are covered by replaced decorations) at
    the given position.
    
    Vertical positions are computed relative to the `docTop`
    argument, which defaults to 0 for this method. You can pass
    `view.contentDOM.getBoundingClientRect().top` here to get screen
    coordinates.
    */
    visualLineAt(pos, docTop = 0) {
        return this.viewState.lineAt(pos, docTop);
    }
    /**
    The editor's total content height.
    */
    get contentHeight() {
        return this.viewState.contentHeight;
    }
    /**
    Move a cursor position by [grapheme
    cluster](https://codemirror.net/6/docs/ref/#text.findClusterBreak). `forward` determines whether
    the motion is away from the line start, or towards it. Motion in
    bidirectional text is in visual order, in the editor's [text
    direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). When the start
    position was the last one on the line, the returned position
    will be across the line break. If there is no further line, the
    original position is returned.
    
    By default, this method moves over a single cluster. The
    optional `by` argument can be used to move across more. It will
    be called with the first cluster as argument, and should return
    a predicate that determines, for each subsequent cluster,
    whether it should also be moved over.
    */
    moveByChar(start, forward, by) {
        return moveByChar(this, start, forward, by);
    }
    /**
    Move a cursor position across the next group of either
    [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
    non-whitespace characters.
    */
    moveByGroup(start, forward) {
        return moveByChar(this, start, forward, initial => byGroup(this, start.head, initial));
    }
    /**
    Move to the next line boundary in the given direction. If
    `includeWrap` is true, line wrapping is on, and there is a
    further wrap point on the current line, the wrap point will be
    returned. Otherwise this function will return the start or end
    of the line.
    */
    moveToLineBoundary(start, forward, includeWrap = true) {
        return moveToLineBoundary(this, start, forward, includeWrap);
    }
    /**
    Move a cursor position vertically. When `distance` isn't given,
    it defaults to moving to the next line (including wrapped
    lines). Otherwise, `distance` should provide a positive distance
    in pixels.
    
    When `start` has a
    [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
    motion will use that as a target horizontal position. Otherwise,
    the cursor's own horizontal position is used. The returned
    cursor will have its goal column set to whichever column was
    used.
    */
    moveVertically(start, forward, distance) {
        return moveVertically(this, start, forward, distance);
    }
    /**
    Scroll the given document position into view.
    */
    scrollPosIntoView(pos) {
        this.viewState.scrollTo = state.EditorSelection.cursor(pos);
        this.requestMeasure();
    }
    /**
    Find the DOM parent node and offset (child offset if `node` is
    an element, character offset when it is a text node) at the
    given document position.
    */
    domAtPos(pos) {
        return this.docView.domAtPos(pos);
    }
    /**
    Find the document position at the given DOM node. Can be useful
    for associating positions with DOM events. Will raise an error
    when `node` isn't part of the editor content.
    */
    posAtDOM(node, offset = 0) {
        return this.docView.posFromDOM(node, offset);
    }
    /**
    Get the document position at the given screen coordinates.
    Returns null if no valid position could be found.
    */
    posAtCoords(coords) {
        this.readMeasured();
        return posAtCoords(this, coords);
    }
    /**
    Get the screen coordinates at the given document position.
    `side` determines whether the coordinates are based on the
    element before (-1) or after (1) the position (if no element is
    available on the given side, the method will transparently use
    another strategy to get reasonable coordinates).
    */
    coordsAtPos(pos, side = 1) {
        this.readMeasured();
        let rect = this.docView.coordsAt(pos, side);
        if (!rect || rect.left == rect.right)
            return rect;
        let line = this.state.doc.lineAt(pos), order = this.bidiSpans(line);
        let span = order[BidiSpan.find(order, pos - line.from, -1, side)];
        return flattenRect(rect, (span.dir == exports.Direction.LTR) == (side > 0));
    }
    /**
    The default width of a character in the editor. May not
    accurately reflect the width of all characters (given variable
    width fonts or styling of invididual ranges).
    */
    get defaultCharacterWidth() { return this.viewState.heightOracle.charWidth; }
    /**
    The default height of a line in the editor. May not be accurate
    for all lines.
    */
    get defaultLineHeight() { return this.viewState.heightOracle.lineHeight; }
    /**
    The text direction
    ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
    CSS property) of the editor.
    */
    get textDirection() { return this.viewState.heightOracle.direction; }
    /**
    Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
    (as determined by the
    [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
    CSS property of its content element).
    */
    get lineWrapping() { return this.viewState.heightOracle.lineWrapping; }
    /**
    Returns the bidirectional text structure of the given line
    (which should be in the current document) as an array of span
    objects. The order of these spans matches the [text
    direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)‚Äîif that is
    left-to-right, the leftmost spans come first, otherwise the
    rightmost spans come first.
    */
    bidiSpans(line) {
        if (line.length > MaxBidiLine)
            return trivialOrder(line.length);
        let dir = this.textDirection;
        for (let entry of this.bidiCache)
            if (entry.from == line.from && entry.dir == dir)
                return entry.order;
        let order = computeOrder(line.text, this.textDirection);
        this.bidiCache.push(new CachedOrder(line.from, line.to, dir, order));
        return order;
    }
    /**
    Check whether the editor has focus.
    */
    get hasFocus() {
        return document.hasFocus() && this.root.activeElement == this.contentDOM;
    }
    /**
    Put focus on the editor.
    */
    focus() {
        this.observer.ignore(() => {
            focusPreventScroll(this.contentDOM);
            this.docView.updateSelection();
        });
    }
    /**
    Clean up this editor view, removing its element from the
    document, unregistering event handlers, and notifying
    plugins. The view instance can no longer be used after
    calling this.
    */
    destroy() {
        for (let plugin of this.plugins)
            plugin.destroy(this);
        this.inputState.destroy();
        this.dom.remove();
        this.observer.destroy();
        if (this.measureScheduled > -1)
            cancelAnimationFrame(this.measureScheduled);
    }
    /**
    Facet that can be used to add DOM event handlers. The value
    should be an object mapping event names to handler functions. The
    first such function to return true will be assumed to have handled
    that event, and no other handlers or built-in behavior will be
    activated for it.
    These are registered on the [content
    element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except for `scroll`
    handlers, which will be called any time the editor's [scroll
    element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of its parent nodes
    is scrolled.
    */
    static domEventHandlers(handlers) {
        return ViewPlugin.define(() => ({}), { eventHandlers: handlers });
    }
    /**
    Create a theme extension. The first argument can be a
    [`style-mod`](https://github.com/marijnh/style-mod#documentation)
    style spec providing the styles for the theme. These will be
    prefixed with a generated class for the style.
    
    Because the selectors will be prefixed with a scope class, rule
    that directly match the editor's [wrapper
    element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)‚Äîto which the scope class will be
    added‚Äîneed to be explicitly differentiated by adding an `&` to
    the selector for that element‚Äîfor example
    `&.cm-focused`.
    
    When `dark` is set to true, the theme will be marked as dark,
    which will cause the `&dark` rules from [base
    themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
    `&light` when a light theme is active).
    */
    static theme(spec, options) {
        let prefix = styleMod.StyleModule.newName();
        let result = [theme.of(prefix), styleModule.of(buildTheme(`.${prefix}`, spec))];
        if (options && options.dark)
            result.push(darkTheme.of(true));
        return result;
    }
    /**
    Create an extension that adds styles to the base theme. Like
    with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
    place of the editor wrapper element when directly targeting
    that. You can also use `&dark` or `&light` instead to only
    target editors with a dark or light theme.
    */
    static baseTheme(spec) {
        return state.Prec.fallback(styleModule.of(buildTheme("." + baseThemeID, spec, lightDarkIDs)));
    }
}
/**
Facet to add a [style
module](https://github.com/marijnh/style-mod#documentation) to
an editor view. The view will ensure that the module is
mounted in its [document
root](https://codemirror.net/6/docs/ref/#view.EditorView.constructor^config.root).
*/
EditorView.styleModule = styleModule;
/**
An input handler can override the way changes to the editable
DOM content are handled. Handlers are passed the document
positions between which the change was found, and the new
content. When one returns true, no further input handlers are
called and the default behavior is prevented.
*/
EditorView.inputHandler = inputHandler;
/**
Allows you to provide a function that should be called when the
library catches an exception from an extension (mostly from view
plugins, but may be used by other extensions to route exceptions
from user-code-provided callbacks). This is mostly useful for
debugging and logging. See [`logException`](https://codemirror.net/6/docs/ref/#view.logException).
*/
EditorView.exceptionSink = exceptionSink;
/**
A facet that can be used to register a function to be called
every time the view updates.
*/
EditorView.updateListener = updateListener;
/**
Facet that controls whether the editor content is editable. When
its highest-precedence value is `false`, editing is disabled,
and the content element will no longer have its
`contenteditable` attribute set to `true`. (Note that this
doesn't affect API calls that change the editor content, even
when those are bound to keys or buttons.)
*/
EditorView.editable = editable;
/**
Allows you to influence the way mouse selection happens. The
functions in this facet will be called for a `mousedown` event
on the editor, and can return an object that overrides the way a
selection is computed from that mouse click or drag.
*/
EditorView.mouseSelectionStyle = mouseSelectionStyle;
/**
Facet used to configure whether a given selection drag event
should move or copy the selection. The given predicate will be
called with the `mousedown` event, and can return `true` when
the drag should move the content.
*/
EditorView.dragMovesSelection = dragMovesSelection$1;
/**
Facet used to configure whether a given selecting click adds
a new range to the existing selection or replaces it entirely.
*/
EditorView.clickAddsSelectionRange = clickAddsSelectionRange;
/**
A facet that determines which [decorations](https://codemirror.net/6/docs/ref/#view.Decoration)
are shown in the view. See also [view
plugins](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), which have a separate
mechanism for providing decorations.
*/
EditorView.decorations = decorations;
/**
Facet that provides additional DOM attributes for the editor's
editable DOM element.
*/
EditorView.contentAttributes = contentAttributes;
/**
Facet that provides DOM attributes for the editor's outer
element.
*/
EditorView.editorAttributes = editorAttributes;
/**
An extension that enables line wrapping in the editor (by
setting CSS `white-space` to `pre-wrap` in the content).
*/
EditorView.lineWrapping = EditorView.contentAttributes.of({ "class": "cm-lineWrapping" });
/**
State effect used to include screen reader announcements in a
transaction. These will be added to the DOM in a visually hidden
element with `aria-live="polite"` set, and should be used to
describe effects that are visually obvious but may not be
noticed by screen reader users (such as moving to the next
search match).
*/
EditorView.announce = state.StateEffect.define();
// Maximum line length for which we compute accurate bidi info
const MaxBidiLine = 4096;
function ensureTop(given, dom) {
    return given == null ? dom.getBoundingClientRect().top : given;
}
let resizeDebounce = -1;
function ensureGlobalHandler() {
    window.addEventListener("resize", () => {
        if (resizeDebounce == -1)
            resizeDebounce = setTimeout(handleResize, 50);
    });
}
function handleResize() {
    resizeDebounce = -1;
    let found = document.querySelectorAll(".cm-content");
    for (let i = 0; i < found.length; i++) {
        let docView = ContentView.get(found[i]);
        if (docView)
            docView.editorView.requestMeasure();
    }
}
const BadMeasure = {};
class CachedOrder {
    constructor(from, to, dir, order) {
        this.from = from;
        this.to = to;
        this.dir = dir;
        this.order = order;
    }
    static update(cache, changes) {
        if (changes.empty)
            return cache;
        let result = [], lastDir = cache.length ? cache[cache.length - 1].dir : exports.Direction.LTR;
        for (let i = Math.max(0, cache.length - 10); i < cache.length; i++) {
            let entry = cache[i];
            if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to))
                result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.order));
        }
        return result;
    }
}

const currentPlatform = typeof navigator == "undefined" ? "key"
    : /Mac/.test(navigator.platform) ? "mac"
        : /Win/.test(navigator.platform) ? "win"
            : /Linux|X11/.test(navigator.platform) ? "linux"
                : "key";
function normalizeKeyName(name, platform) {
    const parts = name.split(/-(?!$)/);
    let result = parts[parts.length - 1];
    if (result == "Space")
        result = " ";
    let alt, ctrl, shift, meta;
    for (let i = 0; i < parts.length - 1; ++i) {
        const mod = parts[i];
        if (/^(cmd|meta|m)$/i.test(mod))
            meta = true;
        else if (/^a(lt)?$/i.test(mod))
            alt = true;
        else if (/^(c|ctrl|control)$/i.test(mod))
            ctrl = true;
        else if (/^s(hift)?$/i.test(mod))
            shift = true;
        else if (/^mod$/i.test(mod)) {
            if (platform == "mac")
                meta = true;
            else
                ctrl = true;
        }
        else
            throw new Error("Unrecognized modifier name: " + mod);
    }
    if (alt)
        result = "Alt-" + result;
    if (ctrl)
        result = "Ctrl-" + result;
    if (meta)
        result = "Meta-" + result;
    if (shift)
        result = "Shift-" + result;
    return result;
}
function modifiers(name, event, shift) {
    if (event.altKey)
        name = "Alt-" + name;
    if (event.ctrlKey)
        name = "Ctrl-" + name;
    if (event.metaKey)
        name = "Meta-" + name;
    if (shift !== false && event.shiftKey)
        name = "Shift-" + name;
    return name;
}
const handleKeyEvents = EditorView.domEventHandlers({
    keydown(event, view) {
        return runHandlers(getKeymap(view.state), event, view, "editor");
    }
});
/**
Facet used for registering keymaps.

You can add multiple keymaps to an editor. Their priorities
determine their precedence (the ones specified early or with high
priority get checked first). When a handler has returned `true`
for a given key, no further handlers are called.
*/
const keymap = state.Facet.define({ enables: handleKeyEvents });
const Keymaps = new WeakMap();
// This is hidden behind an indirection, rather than directly computed
// by the facet, to keep internal types out of the facet's type.
function getKeymap(state) {
    let bindings = state.facet(keymap);
    let map = Keymaps.get(bindings);
    if (!map)
        Keymaps.set(bindings, map = buildKeymap(bindings.reduce((a, b) => a.concat(b), [])));
    return map;
}
/**
Run the key handlers registered for a given scope. The event
object should be `"keydown"` event. Returns true if any of the
handlers handled it.
*/
function runScopeHandlers(view, event, scope) {
    return runHandlers(getKeymap(view.state), event, view, scope);
}
let storedPrefix = null;
const PrefixTimeout = 4000;
function buildKeymap(bindings, platform = currentPlatform) {
    let bound = Object.create(null);
    let isPrefix = Object.create(null);
    let checkPrefix = (name, is) => {
        let current = isPrefix[name];
        if (current == null)
            isPrefix[name] = is;
        else if (current != is)
            throw new Error("Key binding " + name + " is used both as a regular binding and as a multi-stroke prefix");
    };
    let add = (scope, key, command, preventDefault) => {
        let scopeObj = bound[scope] || (bound[scope] = Object.create(null));
        let parts = key.split(/ (?!$)/).map(k => normalizeKeyName(k, platform));
        for (let i = 1; i < parts.length; i++) {
            let prefix = parts.slice(0, i).join(" ");
            checkPrefix(prefix, true);
            if (!scopeObj[prefix])
                scopeObj[prefix] = {
                    preventDefault: true,
                    commands: [(view) => {
                            let ourObj = storedPrefix = { view, prefix, scope };
                            setTimeout(() => { if (storedPrefix == ourObj)
                                storedPrefix = null; }, PrefixTimeout);
                            return true;
                        }]
                };
        }
        let full = parts.join(" ");
        checkPrefix(full, false);
        let binding = scopeObj[full] || (scopeObj[full] = { preventDefault: false, commands: [] });
        binding.commands.push(command);
        if (preventDefault)
            binding.preventDefault = true;
    };
    for (let b of bindings) {
        let name = b[platform] || b.key;
        if (!name)
            continue;
        for (let scope of b.scope ? b.scope.split(" ") : ["editor"]) {
            add(scope, name, b.run, b.preventDefault);
            if (b.shift)
                add(scope, "Shift-" + name, b.shift, b.preventDefault);
        }
    }
    return bound;
}
function runHandlers(map, event, view, scope) {
    let name = w3cKeyname.keyName(event), isChar = name.length == 1 && name != " ";
    let prefix = "", fallthrough = false;
    if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {
        prefix = storedPrefix.prefix + " ";
        if (fallthrough = modifierCodes.indexOf(event.keyCode) < 0)
            storedPrefix = null;
    }
    let runFor = (binding) => {
        if (binding) {
            for (let cmd of binding.commands)
                if (cmd(view))
                    return true;
            if (binding.preventDefault)
                fallthrough = true;
        }
        return false;
    };
    let scopeObj = map[scope], baseName;
    if (scopeObj) {
        if (runFor(scopeObj[prefix + modifiers(name, event, !isChar)]))
            return true;
        if (isChar && (event.shiftKey || event.altKey || event.metaKey) &&
            (baseName = w3cKeyname.base[event.keyCode]) && baseName != name) {
            if (runFor(scopeObj[prefix + modifiers(baseName, event, true)]))
                return true;
        }
        else if (isChar && event.shiftKey) {
            if (runFor(scopeObj[prefix + modifiers(name, event, true)]))
                return true;
        }
    }
    return fallthrough;
}

const CanHidePrimary = !browser.ios; // FIXME test IE
const selectionConfig = state.Facet.define({
    combine(configs) {
        return state.combineConfig(configs, {
            cursorBlinkRate: 1200,
            drawRangeCursor: true
        }, {
            cursorBlinkRate: (a, b) => Math.min(a, b),
            drawRangeCursor: (a, b) => a || b
        });
    }
});
/**
Returns an extension that hides the browser's native selection and
cursor, replacing the selection with a background behind the text
(with the `cm-selectionBackground` class), and the
cursors with elements overlaid over the code (using
`cm-cursor-primary` and `cm-cursor-secondary`).

This allows the editor to display secondary selection ranges, and
tends to produce a type of selection more in line with that users
expect in a text editor (the native selection styling will often
leave gaps between lines and won't fill the horizontal space after
a line when the selection continues past it).

It does have a performance cost, in that it requires an extra DOM
layout cycle for many updates (the selection is drawn based on DOM
layout information that's only available after laying out the
content).
*/
function drawSelection(config = {}) {
    return [
        selectionConfig.of(config),
        drawSelectionPlugin,
        hideNativeSelection
    ];
}
class Piece {
    constructor(left, top, width, height, className) {
        this.left = left;
        this.top = top;
        this.width = width;
        this.height = height;
        this.className = className;
    }
    draw() {
        let elt = document.createElement("div");
        elt.className = this.className;
        this.adjust(elt);
        return elt;
    }
    adjust(elt) {
        elt.style.left = this.left + "px";
        elt.style.top = this.top + "px";
        if (this.width >= 0)
            elt.style.width = this.width + "px";
        elt.style.height = this.height + "px";
    }
    eq(p) {
        return this.left == p.left && this.top == p.top && this.width == p.width && this.height == p.height &&
            this.className == p.className;
    }
}
const drawSelectionPlugin = ViewPlugin.fromClass(class {
    constructor(view) {
        this.view = view;
        this.rangePieces = [];
        this.cursors = [];
        this.measureReq = { read: this.readPos.bind(this), write: this.drawSel.bind(this) };
        this.selectionLayer = view.scrollDOM.appendChild(document.createElement("div"));
        this.selectionLayer.className = "cm-selectionLayer";
        this.selectionLayer.setAttribute("aria-hidden", "true");
        this.cursorLayer = view.scrollDOM.appendChild(document.createElement("div"));
        this.cursorLayer.className = "cm-cursorLayer";
        this.cursorLayer.setAttribute("aria-hidden", "true");
        view.requestMeasure(this.measureReq);
        this.setBlinkRate();
    }
    setBlinkRate() {
        this.cursorLayer.style.animationDuration = this.view.state.facet(selectionConfig).cursorBlinkRate + "ms";
    }
    update(update) {
        let confChanged = update.startState.facet(selectionConfig) != update.state.facet(selectionConfig);
        if (confChanged || update.selectionSet || update.geometryChanged || update.viewportChanged)
            this.view.requestMeasure(this.measureReq);
        if (update.transactions.some(tr => tr.scrollIntoView))
            this.cursorLayer.style.animationName = this.cursorLayer.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink";
        if (confChanged)
            this.setBlinkRate();
    }
    readPos() {
        let { state } = this.view, conf = state.facet(selectionConfig);
        let rangePieces = state.selection.ranges.map(r => r.empty ? [] : measureRange(this.view, r)).reduce((a, b) => a.concat(b));
        let cursors = [];
        for (let r of state.selection.ranges) {
            let prim = r == state.selection.main;
            if (r.empty ? !prim || CanHidePrimary : conf.drawRangeCursor) {
                let piece = measureCursor(this.view, r, prim);
                if (piece)
                    cursors.push(piece);
            }
        }
        return { rangePieces, cursors };
    }
    drawSel({ rangePieces, cursors }) {
        if (rangePieces.length != this.rangePieces.length || rangePieces.some((p, i) => !p.eq(this.rangePieces[i]))) {
            this.selectionLayer.textContent = "";
            for (let p of rangePieces)
                this.selectionLayer.appendChild(p.draw());
            this.rangePieces = rangePieces;
        }
        if (cursors.length != this.cursors.length || cursors.some((c, i) => !c.eq(this.cursors[i]))) {
            let oldCursors = this.cursorLayer.children;
            if (oldCursors.length !== cursors.length) {
                this.cursorLayer.textContent = "";
                for (const c of cursors)
                    this.cursorLayer.appendChild(c.draw());
            }
            else {
                cursors.forEach((c, idx) => c.adjust(oldCursors[idx]));
            }
            this.cursors = cursors;
        }
    }
    destroy() {
        this.selectionLayer.remove();
        this.cursorLayer.remove();
    }
});
const themeSpec = {
    ".cm-line": {
        "& ::selection": { backgroundColor: "transparent !important" },
        "&::selection": { backgroundColor: "transparent !important" }
    }
};
if (CanHidePrimary)
    themeSpec[".cm-line"].caretColor = "transparent !important";
const hideNativeSelection = state.Prec.override(EditorView.theme(themeSpec));
function getBase(view) {
    let rect = view.scrollDOM.getBoundingClientRect();
    let left = view.textDirection == exports.Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth;
    return { left: left - view.scrollDOM.scrollLeft, top: rect.top - view.scrollDOM.scrollTop };
}
function wrappedLine(view, pos, inside) {
    let range = state.EditorSelection.cursor(pos);
    return { from: Math.max(inside.from, view.moveToLineBoundary(range, false, true).from),
        to: Math.min(inside.to, view.moveToLineBoundary(range, true, true).from) };
}
function measureRange(view, range) {
    if (range.to <= view.viewport.from || range.from >= view.viewport.to)
        return [];
    let from = Math.max(range.from, view.viewport.from), to = Math.min(range.to, view.viewport.to);
    let ltr = view.textDirection == exports.Direction.LTR;
    let content = view.contentDOM, contentRect = content.getBoundingClientRect(), base = getBase(view);
    let lineStyle = window.getComputedStyle(content.firstChild);
    let leftSide = contentRect.left + parseInt(lineStyle.paddingLeft);
    let rightSide = contentRect.right - parseInt(lineStyle.paddingRight);
    let visualStart = view.visualLineAt(from);
    let visualEnd = view.visualLineAt(to);
    if (view.lineWrapping) {
        visualStart = wrappedLine(view, from, visualStart);
        visualEnd = wrappedLine(view, to, visualEnd);
    }
    if (visualStart.from == visualEnd.from) {
        return pieces(drawForLine(range.from, range.to, visualStart));
    }
    else {
        let top = drawForLine(range.from, null, visualStart);
        let bottom = drawForLine(null, range.to, visualEnd);
        let between = [];
        if (visualStart.to < visualEnd.from - 1)
            between.push(piece(leftSide, top.bottom, rightSide, bottom.top));
        else if (top.bottom < bottom.top && bottom.top - top.bottom < 4)
            top.bottom = bottom.top = (top.bottom + bottom.top) / 2;
        return pieces(top).concat(between).concat(pieces(bottom));
    }
    function piece(left, top, right, bottom) {
        return new Piece(left - base.left, top - base.top, right - left, bottom - top, "cm-selectionBackground");
    }
    function pieces({ top, bottom, horizontal }) {
        let pieces = [];
        for (let i = 0; i < horizontal.length; i += 2)
            pieces.push(piece(horizontal[i], top, horizontal[i + 1], bottom));
        return pieces;
    }
    // Gets passed from/to in line-local positions
    function drawForLine(from, to, line) {
        let top = 1e9, bottom = -1e9, horizontal = [];
        function addSpan(from, fromOpen, to, toOpen, dir) {
            let fromCoords = view.coordsAtPos(from, from == line.to ? -1 : 1);
            let toCoords = view.coordsAtPos(to, to == line.from ? 1 : -1);
            top = Math.min(fromCoords.top, toCoords.top, top);
            bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);
            if (dir == exports.Direction.LTR)
                horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);
            else
                horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);
        }
        let start = from !== null && from !== void 0 ? from : line.from, end = to !== null && to !== void 0 ? to : line.to;
        // Split the range by visible range and document line
        for (let r of view.visibleRanges)
            if (r.to > start && r.from < end) {
                for (let pos = Math.max(r.from, start), endPos = Math.min(r.to, end);;) {
                    let docLine = view.state.doc.lineAt(pos);
                    for (let span of view.bidiSpans(docLine)) {
                        let spanFrom = span.from + docLine.from, spanTo = span.to + docLine.from;
                        if (spanFrom >= endPos)
                            break;
                        if (spanTo > pos)
                            addSpan(Math.max(spanFrom, pos), from == null && spanFrom <= start, Math.min(spanTo, endPos), to == null && spanTo >= end, span.dir);
                    }
                    pos = docLine.to + 1;
                    if (pos >= endPos)
                        break;
                }
            }
        if (horizontal.length == 0)
            addSpan(start, from == null, end, to == null, view.textDirection);
        return { top, bottom, horizontal };
    }
}
function measureCursor(view, cursor, primary) {
    let pos = view.coordsAtPos(cursor.head, cursor.assoc || 1);
    if (!pos)
        return null;
    let base = getBase(view);
    return new Piece(pos.left - base.left, pos.top - base.top, -1, pos.bottom - pos.top, primary ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary");
}

function iterMatches(doc, re, from, to, f) {
    re.lastIndex = 0;
    for (let cursor = doc.iterRange(from, to), pos = from, m; !cursor.next().done; pos += cursor.value.length) {
        if (!cursor.lineBreak)
            while (m = re.exec(cursor.value))
                f(pos + m.index, pos + m.index + m[0].length, m);
    }
}
/**
Helper class used to make it easier to maintain decorations on
visible code that matches a given regular expression. To be used
in a [view plugin](https://codemirror.net/6/docs/ref/#view.ViewPlugin). Instances of this object
represent a matching configuration.
*/
class MatchDecorator {
    /**
    Create a decorator.
    */
    constructor(config) {
        let { regexp, decoration, boundary } = config;
        if (!regexp.global)
            throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
        this.regexp = regexp;
        this.getDeco = typeof decoration == "function" ? decoration : () => decoration;
        this.boundary = boundary;
    }
    /**
    Compute the full set of decorations for matches in the given
    view's viewport. You'll want to call this when initializing your
    plugin.
    */
    createDeco(view) {
        let build = new rangeset.RangeSetBuilder();
        for (let { from, to } of view.visibleRanges)
            iterMatches(view.state.doc, this.regexp, from, to, (a, b, m) => build.add(a, b, this.getDeco(m, view, a)));
        return build.finish();
    }
    /**
    Update a set of decorations for a view update. `deco` _must_ be
    the set of decorations produced by _this_ `MatchDecorator` for
    the view state before the update.
    */
    updateDeco(update, deco) {
        let changeFrom = 1e9, changeTo = -1;
        if (update.docChanged)
            update.changes.iterChanges((_f, _t, from, to) => {
                if (to > update.view.viewport.from && from < update.view.viewport.to) {
                    changeFrom = Math.min(from, changeFrom);
                    changeTo = Math.max(to, changeTo);
                }
            });
        if (update.viewportChanged || changeTo - changeFrom > 1000)
            return this.createDeco(update.view);
        if (changeTo > -1)
            return this.updateRange(update.view, deco.map(update.changes), changeFrom, changeTo);
        return deco;
    }
    updateRange(view, deco, updateFrom, updateTo) {
        for (let r of view.visibleRanges) {
            let from = Math.max(r.from, updateFrom), to = Math.min(r.to, updateTo);
            if (to > from) {
                let fromLine = view.state.doc.lineAt(from), toLine = fromLine.to < to ? view.state.doc.lineAt(to) : fromLine;
                let start = Math.max(r.from, fromLine.from), end = Math.min(r.to, toLine.to);
                if (this.boundary) {
                    for (; from > fromLine.from; from--)
                        if (this.boundary.test(fromLine.text[from - 1 - fromLine.from])) {
                            start = from;
                            break;
                        }
                    for (; to < toLine.to; to++)
                        if (this.boundary.test(toLine.text[to - toLine.from])) {
                            end = to;
                            break;
                        }
                }
                let ranges = [], m;
                if (fromLine == toLine) {
                    this.regexp.lastIndex = start - fromLine.from;
                    while ((m = this.regexp.exec(fromLine.text)) && m.index < end - fromLine.from) {
                        let pos = m.index + fromLine.from;
                        ranges.push(this.getDeco(m, view, pos).range(pos, pos + m[0].length));
                    }
                }
                else {
                    iterMatches(view.state.doc, this.regexp, start, end, (from, to, m) => ranges.push(this.getDeco(m, view, from).range(from, to)));
                }
                deco = deco.update({ filterFrom: start, filterTo: end, filter: () => false, add: ranges });
            }
        }
        return deco;
    }
}

const UnicodeRegexpSupport = /x/.unicode != null ? "gu" : "g";
const Specials = new RegExp("[\u0000-\u0008\u000a-\u001f\u007f-\u009f\u00ad\u061c\u200b\u200e\u200f\u2028\u2029\ufeff\ufff9-\ufffc]", UnicodeRegexpSupport);
const Names = {
    0: "null",
    7: "bell",
    8: "backspace",
    10: "newline",
    11: "vertical tab",
    13: "carriage return",
    27: "escape",
    8203: "zero width space",
    8204: "zero width non-joiner",
    8205: "zero width joiner",
    8206: "left-to-right mark",
    8207: "right-to-left mark",
    8232: "line separator",
    8233: "paragraph separator",
    65279: "zero width no-break space",
    65532: "object replacement"
};
let _supportsTabSize = null;
function supportsTabSize() {
    var _a;
    if (_supportsTabSize == null && typeof document != "undefined" && document.body) {
        let styles = document.body.style;
        _supportsTabSize = ((_a = styles.tabSize) !== null && _a !== void 0 ? _a : styles.MozTabSize) != null;
    }
    return _supportsTabSize || false;
}
const specialCharConfig = state.Facet.define({
    combine(configs) {
        let config = state.combineConfig(configs, {
            render: null,
            specialChars: Specials,
            addSpecialChars: null
        });
        if (config.replaceTabs = !supportsTabSize())
            config.specialChars = new RegExp("\t|" + config.specialChars.source, UnicodeRegexpSupport);
        if (config.addSpecialChars)
            config.specialChars = new RegExp(config.specialChars.source + "|" + config.addSpecialChars.source, UnicodeRegexpSupport);
        return config;
    }
});
/**
Returns an extension that installs highlighting of special
characters.
*/
function highlightSpecialChars(
/**
Configuration options.
*/
config = {}) {
    return [specialCharConfig.of(config), specialCharPlugin()];
}
let _plugin = null;
function specialCharPlugin() {
    return _plugin || (_plugin = ViewPlugin.fromClass(class {
        constructor(view) {
            this.view = view;
            this.decorations = Decoration.none;
            this.decorationCache = Object.create(null);
            this.decorator = this.makeDecorator(view.state.facet(specialCharConfig));
            this.decorations = this.decorator.createDeco(view);
        }
        makeDecorator(conf) {
            return new MatchDecorator({
                regexp: conf.specialChars,
                decoration: (m, view, pos) => {
                    let { doc } = view.state;
                    let code = text.codePointAt(m[0], 0);
                    if (code == 9) {
                        let line = doc.lineAt(pos);
                        let size = view.state.tabSize, col = text.countColumn(doc.sliceString(line.from, pos), 0, size);
                        return Decoration.replace({ widget: new TabWidget((size - (col % size)) * this.view.defaultCharacterWidth) });
                    }
                    return this.decorationCache[code] ||
                        (this.decorationCache[code] = Decoration.replace({ widget: new SpecialCharWidget(conf, code) }));
                },
                boundary: conf.replaceTabs ? undefined : /[^]/
            });
        }
        update(update) {
            let conf = update.state.facet(specialCharConfig);
            if (update.startState.facet(specialCharConfig) != conf) {
                this.decorator = this.makeDecorator(conf);
                this.decorations = this.decorator.createDeco(update.view);
            }
            else {
                this.decorations = this.decorator.updateDeco(update, this.decorations);
            }
        }
    }, {
        decorations: v => v.decorations
    }));
}
const DefaultPlaceholder = "\u2022";
// Assigns placeholder characters from the Control Pictures block to
// ASCII control characters
function placeholder$1(code) {
    if (code >= 32)
        return DefaultPlaceholder;
    if (code == 10)
        return "\u2424";
    return String.fromCharCode(9216 + code);
}
class SpecialCharWidget extends WidgetType {
    constructor(options, code) {
        super();
        this.options = options;
        this.code = code;
    }
    eq(other) { return other.code == this.code; }
    toDOM(view) {
        let ph = placeholder$1(this.code);
        let desc = view.state.phrase("Control character") + " " + (Names[this.code] || "0x" + this.code.toString(16));
        let custom = this.options.render && this.options.render(this.code, desc, ph);
        if (custom)
            return custom;
        let span = document.createElement("span");
        span.textContent = ph;
        span.title = desc;
        span.setAttribute("aria-label", desc);
        span.className = "cm-specialChar";
        return span;
    }
    ignoreEvent() { return false; }
}
class TabWidget extends WidgetType {
    constructor(width) {
        super();
        this.width = width;
    }
    eq(other) { return other.width == this.width; }
    toDOM() {
        let span = document.createElement("span");
        span.textContent = "\t";
        span.className = "cm-tab";
        span.style.width = this.width + "px";
        return span;
    }
    ignoreEvent() { return false; }
}

/**
Mark lines that have a cursor on them with the `"cm-activeLine"`
DOM class.
*/
function highlightActiveLine() {
    return activeLineHighlighter;
}
const lineDeco = Decoration.line({ attributes: { class: "cm-activeLine" } });
const activeLineHighlighter = ViewPlugin.fromClass(class {
    constructor(view) {
        this.decorations = this.getDeco(view);
    }
    update(update) {
        if (update.docChanged || update.selectionSet)
            this.decorations = this.getDeco(update.view);
    }
    getDeco(view) {
        let lastLineStart = -1, deco = [];
        for (let r of view.state.selection.ranges) {
            if (!r.empty)
                return Decoration.none;
            let line = view.visualLineAt(r.head);
            if (line.from > lastLineStart) {
                deco.push(lineDeco.range(line.from));
                lastLineStart = line.from;
            }
        }
        return Decoration.set(deco);
    }
}, {
    decorations: v => v.decorations
});

class Placeholder extends WidgetType {
    constructor(content) {
        super();
        this.content = content;
    }
    toDOM() {
        let wrap = document.createElement("span");
        wrap.className = "cm-placeholder";
        wrap.style.pointerEvents = "none";
        wrap.appendChild(typeof this.content == "string" ? document.createTextNode(this.content) : this.content);
        if (typeof this.content == "string")
            wrap.setAttribute("aria-label", "placeholder " + this.content);
        else
            wrap.setAttribute("aria-hidden", "true");
        return wrap;
    }
    ignoreEvent() { return false; }
}
/**
Extension that enables a placeholder‚Äîa piece of example content
to show when the editor is empty.
*/
function placeholder(content) {
    return ViewPlugin.fromClass(class {
        constructor(view) {
            this.view = view;
            this.placeholder = Decoration.set([Decoration.widget({ widget: new Placeholder(content), side: 1 }).range(0)]);
        }
        get decorations() { return this.view.state.doc.length ? Decoration.none : this.placeholder; }
    }, { decorations: v => v.decorations });
}

/**
@internal
*/
const __test = { HeightMap, HeightOracle, MeasuredHeights, QueryType, ChangedRange, computeOrder, moveVisually };

Object.defineProperty(exports, 'Range', {
    enumerable: true,
    get: function () {
        return rangeset.Range;
    }
});
exports.BidiSpan = BidiSpan;
exports.BlockInfo = BlockInfo;
exports.Decoration = Decoration;
exports.EditorView = EditorView;
exports.MatchDecorator = MatchDecorator;
exports.PluginField = PluginField;
exports.PluginFieldProvider = PluginFieldProvider;
exports.ViewPlugin = ViewPlugin;
exports.ViewUpdate = ViewUpdate;
exports.WidgetType = WidgetType;
exports.__test = __test;
exports.drawSelection = drawSelection;
exports.highlightActiveLine = highlightActiveLine;
exports.highlightSpecialChars = highlightSpecialChars;
exports.keymap = keymap;
exports.logException = logException;
exports.placeholder = placeholder;
exports.runScopeHandlers = runScopeHandlers;

},{"@codemirror/rangeset":14,"@codemirror/state":17,"@codemirror/text":18,"style-mod":24,"w3c-keyname":25}],21:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = global || self, global.Alpine = factory());
}(this, (function () { 'use strict';

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  // Thanks @stimulus:
  // https://github.com/stimulusjs/stimulus/blob/master/packages/%40stimulus/core/src/application.ts
  function domReady() {
    return new Promise(resolve => {
      if (document.readyState == "loading") {
        document.addEventListener("DOMContentLoaded", resolve);
      } else {
        resolve();
      }
    });
  }
  function arrayUnique(array) {
    return Array.from(new Set(array));
  }
  function isTesting() {
    return navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom");
  }
  function checkedAttrLooseCompare(valueA, valueB) {
    return valueA == valueB;
  }
  function warnIfMalformedTemplate(el, directive) {
    if (el.tagName.toLowerCase() !== 'template') {
      console.warn(`Alpine: [${directive}] directive should only be added to <template> tags. See https://github.com/alpinejs/alpine#${directive}`);
    } else if (el.content.childElementCount !== 1) {
      console.warn(`Alpine: <template> tag with [${directive}] encountered with an unexpected number of root elements. Make sure <template> has a single root element. `);
    }
  }
  function kebabCase(subject) {
    return subject.replace(/([a-z])([A-Z])/g, '$1-$2').replace(/[_\s]/, '-').toLowerCase();
  }
  function camelCase(subject) {
    return subject.toLowerCase().replace(/-(\w)/g, (match, char) => char.toUpperCase());
  }
  function walk(el, callback) {
    if (callback(el) === false) return;
    let node = el.firstElementChild;

    while (node) {
      walk(node, callback);
      node = node.nextElementSibling;
    }
  }
  function debounce(func, wait) {
    var timeout;
    return function () {
      var context = this,
          args = arguments;

      var later = function later() {
        timeout = null;
        func.apply(context, args);
      };

      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }

  const handleError = (el, expression, error) => {
    console.warn(`Alpine Error: "${error}"\n\nExpression: "${expression}"\nElement:`, el);

    if (!isTesting()) {
      Object.assign(error, {
        el,
        expression
      });
      throw error;
    }
  };

  function tryCatch(cb, {
    el,
    expression
  }) {
    try {
      const value = cb();
      return value instanceof Promise ? value.catch(e => handleError(el, expression, e)) : value;
    } catch (e) {
      handleError(el, expression, e);
    }
  }

  function saferEval(el, expression, dataContext, additionalHelperVariables = {}) {
    return tryCatch(() => {
      if (typeof expression === 'function') {
        return expression.call(dataContext);
      }

      return new Function(['$data', ...Object.keys(additionalHelperVariables)], `var __alpine_result; with($data) { __alpine_result = ${expression} }; return __alpine_result`)(dataContext, ...Object.values(additionalHelperVariables));
    }, {
      el,
      expression
    });
  }
  function saferEvalNoReturn(el, expression, dataContext, additionalHelperVariables = {}) {
    return tryCatch(() => {
      if (typeof expression === 'function') {
        return Promise.resolve(expression.call(dataContext, additionalHelperVariables['$event']));
      }

      let AsyncFunction = Function;
      /* MODERN-ONLY:START */

      AsyncFunction = Object.getPrototypeOf(async function () {}).constructor;
      /* MODERN-ONLY:END */
      // For the cases when users pass only a function reference to the caller: `x-on:click="foo"`
      // Where "foo" is a function. Also, we'll pass the function the event instance when we call it.

      if (Object.keys(dataContext).includes(expression)) {
        let methodReference = new Function(['dataContext', ...Object.keys(additionalHelperVariables)], `with(dataContext) { return ${expression} }`)(dataContext, ...Object.values(additionalHelperVariables));

        if (typeof methodReference === 'function') {
          return Promise.resolve(methodReference.call(dataContext, additionalHelperVariables['$event']));
        } else {
          return Promise.resolve();
        }
      }

      return Promise.resolve(new AsyncFunction(['dataContext', ...Object.keys(additionalHelperVariables)], `with(dataContext) { ${expression} }`)(dataContext, ...Object.values(additionalHelperVariables)));
    }, {
      el,
      expression
    });
  }
  const xAttrRE = /^x-(on|bind|data|text|html|model|if|for|show|cloak|transition|ref|spread)\b/;
  function isXAttr(attr) {
    const name = replaceAtAndColonWithStandardSyntax(attr.name);
    return xAttrRE.test(name);
  }
  function getXAttrs(el, component, type) {
    let directives = Array.from(el.attributes).filter(isXAttr).map(parseHtmlAttribute); // Get an object of directives from x-spread.

    let spreadDirective = directives.filter(directive => directive.type === 'spread')[0];

    if (spreadDirective) {
      let spreadObject = saferEval(el, spreadDirective.expression, component.$data); // Add x-spread directives to the pile of existing directives.

      directives = directives.concat(Object.entries(spreadObject).map(([name, value]) => parseHtmlAttribute({
        name,
        value
      })));
    }

    if (type) return directives.filter(i => i.type === type);
    return sortDirectives(directives);
  }

  function sortDirectives(directives) {
    let directiveOrder = ['bind', 'model', 'show', 'catch-all'];
    return directives.sort((a, b) => {
      let typeA = directiveOrder.indexOf(a.type) === -1 ? 'catch-all' : a.type;
      let typeB = directiveOrder.indexOf(b.type) === -1 ? 'catch-all' : b.type;
      return directiveOrder.indexOf(typeA) - directiveOrder.indexOf(typeB);
    });
  }

  function parseHtmlAttribute({
    name,
    value
  }) {
    const normalizedName = replaceAtAndColonWithStandardSyntax(name);
    const typeMatch = normalizedName.match(xAttrRE);
    const valueMatch = normalizedName.match(/:([a-zA-Z0-9\-:]+)/);
    const modifiers = normalizedName.match(/\.[^.\]]+(?=[^\]]*$)/g) || [];
    return {
      type: typeMatch ? typeMatch[1] : null,
      value: valueMatch ? valueMatch[1] : null,
      modifiers: modifiers.map(i => i.replace('.', '')),
      expression: value
    };
  }
  function isBooleanAttr(attrName) {
    // As per HTML spec table https://html.spec.whatwg.org/multipage/indices.html#attributes-3:boolean-attribute
    // Array roughly ordered by estimated usage
    const booleanAttributes = ['disabled', 'checked', 'required', 'readonly', 'hidden', 'open', 'selected', 'autofocus', 'itemscope', 'multiple', 'novalidate', 'allowfullscreen', 'allowpaymentrequest', 'formnovalidate', 'autoplay', 'controls', 'loop', 'muted', 'playsinline', 'default', 'ismap', 'reversed', 'async', 'defer', 'nomodule'];
    return booleanAttributes.includes(attrName);
  }
  function replaceAtAndColonWithStandardSyntax(name) {
    if (name.startsWith('@')) {
      return name.replace('@', 'x-on:');
    } else if (name.startsWith(':')) {
      return name.replace(':', 'x-bind:');
    }

    return name;
  }
  function convertClassStringToArray(classList, filterFn = Boolean) {
    return classList.split(' ').filter(filterFn);
  }
  const TRANSITION_TYPE_IN = 'in';
  const TRANSITION_TYPE_OUT = 'out';
  const TRANSITION_CANCELLED = 'cancelled';
  function transitionIn(el, show, reject, component, forceSkip = false) {
    // We don't want to transition on the initial page load.
    if (forceSkip) return show();

    if (el.__x_transition && el.__x_transition.type === TRANSITION_TYPE_IN) {
      // there is already a similar transition going on, this was probably triggered by
      // a change in a different property, let's just leave the previous one doing its job
      return;
    }

    const attrs = getXAttrs(el, component, 'transition');
    const showAttr = getXAttrs(el, component, 'show')[0]; // If this is triggered by a x-show.transition.

    if (showAttr && showAttr.modifiers.includes('transition')) {
      let modifiers = showAttr.modifiers; // If x-show.transition.out, we'll skip the "in" transition.

      if (modifiers.includes('out') && !modifiers.includes('in')) return show();
      const settingBothSidesOfTransition = modifiers.includes('in') && modifiers.includes('out'); // If x-show.transition.in...out... only use "in" related modifiers for this transition.

      modifiers = settingBothSidesOfTransition ? modifiers.filter((i, index) => index < modifiers.indexOf('out')) : modifiers;
      transitionHelperIn(el, modifiers, show, reject); // Otherwise, we can assume x-transition:enter.
    } else if (attrs.some(attr => ['enter', 'enter-start', 'enter-end'].includes(attr.value))) {
      transitionClassesIn(el, component, attrs, show, reject);
    } else {
      // If neither, just show that damn thing.
      show();
    }
  }
  function transitionOut(el, hide, reject, component, forceSkip = false) {
    // We don't want to transition on the initial page load.
    if (forceSkip) return hide();

    if (el.__x_transition && el.__x_transition.type === TRANSITION_TYPE_OUT) {
      // there is already a similar transition going on, this was probably triggered by
      // a change in a different property, let's just leave the previous one doing its job
      return;
    }

    const attrs = getXAttrs(el, component, 'transition');
    const showAttr = getXAttrs(el, component, 'show')[0];

    if (showAttr && showAttr.modifiers.includes('transition')) {
      let modifiers = showAttr.modifiers;
      if (modifiers.includes('in') && !modifiers.includes('out')) return hide();
      const settingBothSidesOfTransition = modifiers.includes('in') && modifiers.includes('out');
      modifiers = settingBothSidesOfTransition ? modifiers.filter((i, index) => index > modifiers.indexOf('out')) : modifiers;
      transitionHelperOut(el, modifiers, settingBothSidesOfTransition, hide, reject);
    } else if (attrs.some(attr => ['leave', 'leave-start', 'leave-end'].includes(attr.value))) {
      transitionClassesOut(el, component, attrs, hide, reject);
    } else {
      hide();
    }
  }
  function transitionHelperIn(el, modifiers, showCallback, reject) {
    // Default values inspired by: https://material.io/design/motion/speed.html#duration
    const styleValues = {
      duration: modifierValue(modifiers, 'duration', 150),
      origin: modifierValue(modifiers, 'origin', 'center'),
      first: {
        opacity: 0,
        scale: modifierValue(modifiers, 'scale', 95)
      },
      second: {
        opacity: 1,
        scale: 100
      }
    };
    transitionHelper(el, modifiers, showCallback, () => {}, reject, styleValues, TRANSITION_TYPE_IN);
  }
  function transitionHelperOut(el, modifiers, settingBothSidesOfTransition, hideCallback, reject) {
    // Make the "out" transition .5x slower than the "in". (Visually better)
    // HOWEVER, if they explicitly set a duration for the "out" transition,
    // use that.
    const duration = settingBothSidesOfTransition ? modifierValue(modifiers, 'duration', 150) : modifierValue(modifiers, 'duration', 150) / 2;
    const styleValues = {
      duration: duration,
      origin: modifierValue(modifiers, 'origin', 'center'),
      first: {
        opacity: 1,
        scale: 100
      },
      second: {
        opacity: 0,
        scale: modifierValue(modifiers, 'scale', 95)
      }
    };
    transitionHelper(el, modifiers, () => {}, hideCallback, reject, styleValues, TRANSITION_TYPE_OUT);
  }

  function modifierValue(modifiers, key, fallback) {
    // If the modifier isn't present, use the default.
    if (modifiers.indexOf(key) === -1) return fallback; // If it IS present, grab the value after it: x-show.transition.duration.500ms

    const rawValue = modifiers[modifiers.indexOf(key) + 1];
    if (!rawValue) return fallback;

    if (key === 'scale') {
      // Check if the very next value is NOT a number and return the fallback.
      // If x-show.transition.scale, we'll use the default scale value.
      // That is how a user opts out of the opacity transition.
      if (!isNumeric(rawValue)) return fallback;
    }

    if (key === 'duration') {
      // Support x-show.transition.duration.500ms && duration.500
      let match = rawValue.match(/([0-9]+)ms/);
      if (match) return match[1];
    }

    if (key === 'origin') {
      // Support chaining origin directions: x-show.transition.top.right
      if (['top', 'right', 'left', 'center', 'bottom'].includes(modifiers[modifiers.indexOf(key) + 2])) {
        return [rawValue, modifiers[modifiers.indexOf(key) + 2]].join(' ');
      }
    }

    return rawValue;
  }

  function transitionHelper(el, modifiers, hook1, hook2, reject, styleValues, type) {
    // clear the previous transition if exists to avoid caching the wrong styles
    if (el.__x_transition) {
      el.__x_transition.cancel && el.__x_transition.cancel();
    } // If the user set these style values, we'll put them back when we're done with them.


    const opacityCache = el.style.opacity;
    const transformCache = el.style.transform;
    const transformOriginCache = el.style.transformOrigin; // If no modifiers are present: x-show.transition, we'll default to both opacity and scale.

    const noModifiers = !modifiers.includes('opacity') && !modifiers.includes('scale');
    const transitionOpacity = noModifiers || modifiers.includes('opacity');
    const transitionScale = noModifiers || modifiers.includes('scale'); // These are the explicit stages of a transition (same stages for in and for out).
    // This way you can get a birds eye view of the hooks, and the differences
    // between them.

    const stages = {
      start() {
        if (transitionOpacity) el.style.opacity = styleValues.first.opacity;
        if (transitionScale) el.style.transform = `scale(${styleValues.first.scale / 100})`;
      },

      during() {
        if (transitionScale) el.style.transformOrigin = styleValues.origin;
        el.style.transitionProperty = [transitionOpacity ? `opacity` : ``, transitionScale ? `transform` : ``].join(' ').trim();
        el.style.transitionDuration = `${styleValues.duration / 1000}s`;
        el.style.transitionTimingFunction = `cubic-bezier(0.4, 0.0, 0.2, 1)`;
      },

      show() {
        hook1();
      },

      end() {
        if (transitionOpacity) el.style.opacity = styleValues.second.opacity;
        if (transitionScale) el.style.transform = `scale(${styleValues.second.scale / 100})`;
      },

      hide() {
        hook2();
      },

      cleanup() {
        if (transitionOpacity) el.style.opacity = opacityCache;
        if (transitionScale) el.style.transform = transformCache;
        if (transitionScale) el.style.transformOrigin = transformOriginCache;
        el.style.transitionProperty = null;
        el.style.transitionDuration = null;
        el.style.transitionTimingFunction = null;
      }

    };
    transition(el, stages, type, reject);
  }

  const ensureStringExpression = (expression, el, component) => {
    return typeof expression === 'function' ? component.evaluateReturnExpression(el, expression) : expression;
  };

  function transitionClassesIn(el, component, directives, showCallback, reject) {
    const enter = convertClassStringToArray(ensureStringExpression((directives.find(i => i.value === 'enter') || {
      expression: ''
    }).expression, el, component));
    const enterStart = convertClassStringToArray(ensureStringExpression((directives.find(i => i.value === 'enter-start') || {
      expression: ''
    }).expression, el, component));
    const enterEnd = convertClassStringToArray(ensureStringExpression((directives.find(i => i.value === 'enter-end') || {
      expression: ''
    }).expression, el, component));
    transitionClasses(el, enter, enterStart, enterEnd, showCallback, () => {}, TRANSITION_TYPE_IN, reject);
  }
  function transitionClassesOut(el, component, directives, hideCallback, reject) {
    const leave = convertClassStringToArray(ensureStringExpression((directives.find(i => i.value === 'leave') || {
      expression: ''
    }).expression, el, component));
    const leaveStart = convertClassStringToArray(ensureStringExpression((directives.find(i => i.value === 'leave-start') || {
      expression: ''
    }).expression, el, component));
    const leaveEnd = convertClassStringToArray(ensureStringExpression((directives.find(i => i.value === 'leave-end') || {
      expression: ''
    }).expression, el, component));
    transitionClasses(el, leave, leaveStart, leaveEnd, () => {}, hideCallback, TRANSITION_TYPE_OUT, reject);
  }
  function transitionClasses(el, classesDuring, classesStart, classesEnd, hook1, hook2, type, reject) {
    // clear the previous transition if exists to avoid caching the wrong classes
    if (el.__x_transition) {
      el.__x_transition.cancel && el.__x_transition.cancel();
    }

    const originalClasses = el.__x_original_classes || [];
    const stages = {
      start() {
        el.classList.add(...classesStart);
      },

      during() {
        el.classList.add(...classesDuring);
      },

      show() {
        hook1();
      },

      end() {
        // Don't remove classes that were in the original class attribute.
        el.classList.remove(...classesStart.filter(i => !originalClasses.includes(i)));
        el.classList.add(...classesEnd);
      },

      hide() {
        hook2();
      },

      cleanup() {
        el.classList.remove(...classesDuring.filter(i => !originalClasses.includes(i)));
        el.classList.remove(...classesEnd.filter(i => !originalClasses.includes(i)));
      }

    };
    transition(el, stages, type, reject);
  }
  function transition(el, stages, type, reject) {
    const finish = once(() => {
      stages.hide(); // Adding an "isConnected" check, in case the callback
      // removed the element from the DOM.

      if (el.isConnected) {
        stages.cleanup();
      }

      delete el.__x_transition;
    });
    el.__x_transition = {
      // Set transition type so we can avoid clearing transition if the direction is the same
      type: type,
      // create a callback for the last stages of the transition so we can call it
      // from different point and early terminate it. Once will ensure that function
      // is only called one time.
      cancel: once(() => {
        reject(TRANSITION_CANCELLED);
        finish();
      }),
      finish,
      // This store the next animation frame so we can cancel it
      nextFrame: null
    };
    stages.start();
    stages.during();
    el.__x_transition.nextFrame = requestAnimationFrame(() => {
      // Note: Safari's transitionDuration property will list out comma separated transition durations
      // for every single transition property. Let's grab the first one and call it a day.
      let duration = Number(getComputedStyle(el).transitionDuration.replace(/,.*/, '').replace('s', '')) * 1000;

      if (duration === 0) {
        duration = Number(getComputedStyle(el).animationDuration.replace('s', '')) * 1000;
      }

      stages.show();
      el.__x_transition.nextFrame = requestAnimationFrame(() => {
        stages.end();
        setTimeout(el.__x_transition.finish, duration);
      });
    });
  }
  function isNumeric(subject) {
    return !Array.isArray(subject) && !isNaN(subject);
  } // Thanks @vuejs
  // https://github.com/vuejs/vue/blob/4de4649d9637262a9b007720b59f80ac72a5620c/src/shared/util.js

  function once(callback) {
    let called = false;
    return function () {
      if (!called) {
        called = true;
        callback.apply(this, arguments);
      }
    };
  }

  function handleForDirective(component, templateEl, expression, initialUpdate, extraVars) {
    warnIfMalformedTemplate(templateEl, 'x-for');
    let iteratorNames = typeof expression === 'function' ? parseForExpression(component.evaluateReturnExpression(templateEl, expression)) : parseForExpression(expression);
    let items = evaluateItemsAndReturnEmptyIfXIfIsPresentAndFalseOnElement(component, templateEl, iteratorNames, extraVars); // As we walk the array, we'll also walk the DOM (updating/creating as we go).

    let currentEl = templateEl;
    items.forEach((item, index) => {
      let iterationScopeVariables = getIterationScopeVariables(iteratorNames, item, index, items, extraVars());
      let currentKey = generateKeyForIteration(component, templateEl, index, iterationScopeVariables);
      let nextEl = lookAheadForMatchingKeyedElementAndMoveItIfFound(currentEl.nextElementSibling, currentKey); // If we haven't found a matching key, insert the element at the current position.

      if (!nextEl) {
        nextEl = addElementInLoopAfterCurrentEl(templateEl, currentEl); // And transition it in if it's not the first page load.

        transitionIn(nextEl, () => {}, () => {}, component, initialUpdate);
        nextEl.__x_for = iterationScopeVariables;
        component.initializeElements(nextEl, () => nextEl.__x_for); // Otherwise update the element we found.
      } else {
        // Temporarily remove the key indicator to allow the normal "updateElements" to work.
        delete nextEl.__x_for_key;
        nextEl.__x_for = iterationScopeVariables;
        component.updateElements(nextEl, () => nextEl.__x_for);
      }

      currentEl = nextEl;
      currentEl.__x_for_key = currentKey;
    });
    removeAnyLeftOverElementsFromPreviousUpdate(currentEl, component);
  } // This was taken from VueJS 2.* core. Thanks Vue!

  function parseForExpression(expression) {
    let forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
    let stripParensRE = /^\(|\)$/g;
    let forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
    let inMatch = String(expression).match(forAliasRE);
    if (!inMatch) return;
    let res = {};
    res.items = inMatch[2].trim();
    let item = inMatch[1].trim().replace(stripParensRE, '');
    let iteratorMatch = item.match(forIteratorRE);

    if (iteratorMatch) {
      res.item = item.replace(forIteratorRE, '').trim();
      res.index = iteratorMatch[1].trim();

      if (iteratorMatch[2]) {
        res.collection = iteratorMatch[2].trim();
      }
    } else {
      res.item = item;
    }

    return res;
  }

  function getIterationScopeVariables(iteratorNames, item, index, items, extraVars) {
    // We must create a new object, so each iteration has a new scope
    let scopeVariables = extraVars ? _objectSpread2({}, extraVars) : {};
    scopeVariables[iteratorNames.item] = item;
    if (iteratorNames.index) scopeVariables[iteratorNames.index] = index;
    if (iteratorNames.collection) scopeVariables[iteratorNames.collection] = items;
    return scopeVariables;
  }

  function generateKeyForIteration(component, el, index, iterationScopeVariables) {
    let bindKeyAttribute = getXAttrs(el, component, 'bind').filter(attr => attr.value === 'key')[0]; // If the dev hasn't specified a key, just return the index of the iteration.

    if (!bindKeyAttribute) return index;
    return component.evaluateReturnExpression(el, bindKeyAttribute.expression, () => iterationScopeVariables);
  }

  function evaluateItemsAndReturnEmptyIfXIfIsPresentAndFalseOnElement(component, el, iteratorNames, extraVars) {
    let ifAttribute = getXAttrs(el, component, 'if')[0];

    if (ifAttribute && !component.evaluateReturnExpression(el, ifAttribute.expression)) {
      return [];
    }

    let items = component.evaluateReturnExpression(el, iteratorNames.items, extraVars); // This adds support for the `i in n` syntax.

    if (isNumeric(items) && items >= 0) {
      items = Array.from(Array(items).keys(), i => i + 1);
    }

    return items;
  }

  function addElementInLoopAfterCurrentEl(templateEl, currentEl) {
    let clone = document.importNode(templateEl.content, true);
    currentEl.parentElement.insertBefore(clone, currentEl.nextElementSibling);
    return currentEl.nextElementSibling;
  }

  function lookAheadForMatchingKeyedElementAndMoveItIfFound(nextEl, currentKey) {
    if (!nextEl) return; // If we are already past the x-for generated elements, we don't need to look ahead.

    if (nextEl.__x_for_key === undefined) return; // If the the key's DO match, no need to look ahead.

    if (nextEl.__x_for_key === currentKey) return nextEl; // If they don't, we'll look ahead for a match.
    // If we find it, we'll move it to the current position in the loop.

    let tmpNextEl = nextEl;

    while (tmpNextEl) {
      if (tmpNextEl.__x_for_key === currentKey) {
        return tmpNextEl.parentElement.insertBefore(tmpNextEl, nextEl);
      }

      tmpNextEl = tmpNextEl.nextElementSibling && tmpNextEl.nextElementSibling.__x_for_key !== undefined ? tmpNextEl.nextElementSibling : false;
    }
  }

  function removeAnyLeftOverElementsFromPreviousUpdate(currentEl, component) {
    var nextElementFromOldLoop = currentEl.nextElementSibling && currentEl.nextElementSibling.__x_for_key !== undefined ? currentEl.nextElementSibling : false;

    while (nextElementFromOldLoop) {
      let nextElementFromOldLoopImmutable = nextElementFromOldLoop;
      let nextSibling = nextElementFromOldLoop.nextElementSibling;
      transitionOut(nextElementFromOldLoop, () => {
        nextElementFromOldLoopImmutable.remove();
      }, () => {}, component);
      nextElementFromOldLoop = nextSibling && nextSibling.__x_for_key !== undefined ? nextSibling : false;
    }
  }

  function handleAttributeBindingDirective(component, el, attrName, expression, extraVars, attrType, modifiers) {
    var value = component.evaluateReturnExpression(el, expression, extraVars);

    if (attrName === 'value') {
      if (Alpine.ignoreFocusedForValueBinding && document.activeElement.isSameNode(el)) return; // If nested model key is undefined, set the default value to empty string.

      if (value === undefined && String(expression).match(/\./)) {
        value = '';
      }

      if (el.type === 'radio') {
        // Set radio value from x-bind:value, if no "value" attribute exists.
        // If there are any initial state values, radio will have a correct
        // "checked" value since x-bind:value is processed before x-model.
        if (el.attributes.value === undefined && attrType === 'bind') {
          el.value = value;
        } else if (attrType !== 'bind') {
          el.checked = checkedAttrLooseCompare(el.value, value);
        }
      } else if (el.type === 'checkbox') {
        // If we are explicitly binding a string to the :value, set the string,
        // If the value is a boolean, leave it alone, it will be set to "on"
        // automatically.
        if (typeof value !== 'boolean' && ![null, undefined].includes(value) && attrType === 'bind') {
          el.value = String(value);
        } else if (attrType !== 'bind') {
          if (Array.isArray(value)) {
            // I'm purposely not using Array.includes here because it's
            // strict, and because of Numeric/String mis-casting, I
            // want the "includes" to be "fuzzy".
            el.checked = value.some(val => checkedAttrLooseCompare(val, el.value));
          } else {
            el.checked = !!value;
          }
        }
      } else if (el.tagName === 'SELECT') {
        updateSelect(el, value);
      } else {
        if (el.value === value) return;
        el.value = value;
      }
    } else if (attrName === 'class') {
      if (Array.isArray(value)) {
        const originalClasses = el.__x_original_classes || [];
        el.setAttribute('class', arrayUnique(originalClasses.concat(value)).join(' '));
      } else if (typeof value === 'object') {
        // Sorting the keys / class names by their boolean value will ensure that
        // anything that evaluates to `false` and needs to remove classes is run first.
        const keysSortedByBooleanValue = Object.keys(value).sort((a, b) => value[a] - value[b]);
        keysSortedByBooleanValue.forEach(classNames => {
          if (value[classNames]) {
            convertClassStringToArray(classNames).forEach(className => el.classList.add(className));
          } else {
            convertClassStringToArray(classNames).forEach(className => el.classList.remove(className));
          }
        });
      } else {
        const originalClasses = el.__x_original_classes || [];
        const newClasses = value ? convertClassStringToArray(value) : [];
        el.setAttribute('class', arrayUnique(originalClasses.concat(newClasses)).join(' '));
      }
    } else {
      attrName = modifiers.includes('camel') ? camelCase(attrName) : attrName; // If an attribute's bound value is null, undefined or false, remove the attribute

      if ([null, undefined, false].includes(value)) {
        el.removeAttribute(attrName);
      } else {
        isBooleanAttr(attrName) ? setIfChanged(el, attrName, attrName) : setIfChanged(el, attrName, value);
      }
    }
  }

  function setIfChanged(el, attrName, value) {
    if (el.getAttribute(attrName) != value) {
      el.setAttribute(attrName, value);
    }
  }

  function updateSelect(el, value) {
    const arrayWrappedValue = [].concat(value).map(value => {
      return value + '';
    });
    Array.from(el.options).forEach(option => {
      option.selected = arrayWrappedValue.includes(option.value || option.text);
    });
  }

  function handleTextDirective(el, output, expression) {
    // If nested model key is undefined, set the default value to empty string.
    if (output === undefined && String(expression).match(/\./)) {
      output = '';
    }

    el.textContent = output;
  }

  function handleHtmlDirective(component, el, expression, extraVars) {
    el.innerHTML = component.evaluateReturnExpression(el, expression, extraVars);
  }

  function handleShowDirective(component, el, value, modifiers, initialUpdate = false) {
    const hide = () => {
      el.style.display = 'none';
      el.__x_is_shown = false;
    };

    const show = () => {
      if (el.style.length === 1 && el.style.display === 'none') {
        el.removeAttribute('style');
      } else {
        el.style.removeProperty('display');
      }

      el.__x_is_shown = true;
    };

    if (initialUpdate === true) {
      if (value) {
        show();
      } else {
        hide();
      }

      return;
    }

    const handle = (resolve, reject) => {
      if (value) {
        if (el.style.display === 'none' || el.__x_transition) {
          transitionIn(el, () => {
            show();
          }, reject, component);
        }

        resolve(() => {});
      } else {
        if (el.style.display !== 'none') {
          transitionOut(el, () => {
            resolve(() => {
              hide();
            });
          }, reject, component);
        } else {
          resolve(() => {});
        }
      }
    }; // The working of x-show is a bit complex because we need to
    // wait for any child transitions to finish before hiding
    // some element. Also, this has to be done recursively.
    // If x-show.immediate, foregoe the waiting.


    if (modifiers.includes('immediate')) {
      handle(finish => finish(), () => {});
      return;
    } // x-show is encountered during a DOM tree walk. If an element
    // we encounter is NOT a child of another x-show element we
    // can execute the previous x-show stack (if one exists).


    if (component.showDirectiveLastElement && !component.showDirectiveLastElement.contains(el)) {
      component.executeAndClearRemainingShowDirectiveStack();
    }

    component.showDirectiveStack.push(handle);
    component.showDirectiveLastElement = el;
  }

  function handleIfDirective(component, el, expressionResult, initialUpdate, extraVars) {
    warnIfMalformedTemplate(el, 'x-if');
    const elementHasAlreadyBeenAdded = el.nextElementSibling && el.nextElementSibling.__x_inserted_me === true;

    if (expressionResult && (!elementHasAlreadyBeenAdded || el.__x_transition)) {
      const clone = document.importNode(el.content, true);
      el.parentElement.insertBefore(clone, el.nextElementSibling);
      transitionIn(el.nextElementSibling, () => {}, () => {}, component, initialUpdate);
      component.initializeElements(el.nextElementSibling, extraVars);
      el.nextElementSibling.__x_inserted_me = true;
    } else if (!expressionResult && elementHasAlreadyBeenAdded) {
      transitionOut(el.nextElementSibling, () => {
        el.nextElementSibling.remove();
      }, () => {}, component, initialUpdate);
    }
  }

  function registerListener(component, el, event, modifiers, expression, extraVars = {}) {
    const options = {
      passive: modifiers.includes('passive')
    };

    if (modifiers.includes('camel')) {
      event = camelCase(event);
    }

    let handler, listenerTarget;

    if (modifiers.includes('away')) {
      listenerTarget = document;

      handler = e => {
        // Don't do anything if the click came from the element or within it.
        if (el.contains(e.target)) return; // Don't do anything if this element isn't currently visible.

        if (el.offsetWidth < 1 && el.offsetHeight < 1) return; // Now that we are sure the element is visible, AND the click
        // is from outside it, let's run the expression.

        runListenerHandler(component, expression, e, extraVars);

        if (modifiers.includes('once')) {
          document.removeEventListener(event, handler, options);
        }
      };
    } else {
      listenerTarget = modifiers.includes('window') ? window : modifiers.includes('document') ? document : el;

      handler = e => {
        // Remove this global event handler if the element that declared it
        // has been removed. It's now stale.
        if (listenerTarget === window || listenerTarget === document) {
          if (!document.body.contains(el)) {
            listenerTarget.removeEventListener(event, handler, options);
            return;
          }
        }

        if (isKeyEvent(event)) {
          if (isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers)) {
            return;
          }
        }

        if (modifiers.includes('prevent')) e.preventDefault();
        if (modifiers.includes('stop')) e.stopPropagation(); // If the .self modifier isn't present, or if it is present and
        // the target element matches the element we are registering the
        // event on, run the handler

        if (!modifiers.includes('self') || e.target === el) {
          const returnValue = runListenerHandler(component, expression, e, extraVars);
          returnValue.then(value => {
            if (value === false) {
              e.preventDefault();
            } else {
              if (modifiers.includes('once')) {
                listenerTarget.removeEventListener(event, handler, options);
              }
            }
          });
        }
      };
    }

    if (modifiers.includes('debounce')) {
      let nextModifier = modifiers[modifiers.indexOf('debounce') + 1] || 'invalid-wait';
      let wait = isNumeric(nextModifier.split('ms')[0]) ? Number(nextModifier.split('ms')[0]) : 250;
      handler = debounce(handler, wait);
    }

    listenerTarget.addEventListener(event, handler, options);
  }

  function runListenerHandler(component, expression, e, extraVars) {
    return component.evaluateCommandExpression(e.target, expression, () => {
      return _objectSpread2(_objectSpread2({}, extraVars()), {}, {
        '$event': e
      });
    });
  }

  function isKeyEvent(event) {
    return ['keydown', 'keyup'].includes(event);
  }

  function isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers) {
    let keyModifiers = modifiers.filter(i => {
      return !['window', 'document', 'prevent', 'stop'].includes(i);
    });

    if (keyModifiers.includes('debounce')) {
      let debounceIndex = keyModifiers.indexOf('debounce');
      keyModifiers.splice(debounceIndex, isNumeric((keyModifiers[debounceIndex + 1] || 'invalid-wait').split('ms')[0]) ? 2 : 1);
    } // If no modifier is specified, we'll call it a press.


    if (keyModifiers.length === 0) return false; // If one is passed, AND it matches the key pressed, we'll call it a press.

    if (keyModifiers.length === 1 && keyModifiers[0] === keyToModifier(e.key)) return false; // The user is listening for key combinations.

    const systemKeyModifiers = ['ctrl', 'shift', 'alt', 'meta', 'cmd', 'super'];
    const selectedSystemKeyModifiers = systemKeyModifiers.filter(modifier => keyModifiers.includes(modifier));
    keyModifiers = keyModifiers.filter(i => !selectedSystemKeyModifiers.includes(i));

    if (selectedSystemKeyModifiers.length > 0) {
      const activelyPressedKeyModifiers = selectedSystemKeyModifiers.filter(modifier => {
        // Alias "cmd" and "super" to "meta"
        if (modifier === 'cmd' || modifier === 'super') modifier = 'meta';
        return e[`${modifier}Key`];
      }); // If all the modifiers selected are pressed, ...

      if (activelyPressedKeyModifiers.length === selectedSystemKeyModifiers.length) {
        // AND the remaining key is pressed as well. It's a press.
        if (keyModifiers[0] === keyToModifier(e.key)) return false;
      }
    } // We'll call it NOT a valid keypress.


    return true;
  }

  function keyToModifier(key) {
    switch (key) {
      case '/':
        return 'slash';

      case ' ':
      case 'Spacebar':
        return 'space';

      default:
        return key && kebabCase(key);
    }
  }

  function registerModelListener(component, el, modifiers, expression, extraVars) {
    // If the element we are binding to is a select, a radio, or checkbox
    // we'll listen for the change event instead of the "input" event.
    var event = el.tagName.toLowerCase() === 'select' || ['checkbox', 'radio'].includes(el.type) || modifiers.includes('lazy') ? 'change' : 'input';
    const listenerExpression = `${expression} = rightSideOfExpression($event, ${expression})`;
    registerListener(component, el, event, modifiers, listenerExpression, () => {
      return _objectSpread2(_objectSpread2({}, extraVars()), {}, {
        rightSideOfExpression: generateModelAssignmentFunction(el, modifiers, expression)
      });
    });
  }

  function generateModelAssignmentFunction(el, modifiers, expression) {
    if (el.type === 'radio') {
      // Radio buttons only work properly when they share a name attribute.
      // People might assume we take care of that for them, because
      // they already set a shared "x-model" attribute.
      if (!el.hasAttribute('name')) el.setAttribute('name', expression);
    }

    return (event, currentValue) => {
      // Check for event.detail due to an issue where IE11 handles other events as a CustomEvent.
      if (event instanceof CustomEvent && event.detail) {
        return event.detail;
      } else if (el.type === 'checkbox') {
        // If the data we are binding to is an array, toggle its value inside the array.
        if (Array.isArray(currentValue)) {
          const newValue = modifiers.includes('number') ? safeParseNumber(event.target.value) : event.target.value;
          return event.target.checked ? currentValue.concat([newValue]) : currentValue.filter(el => !checkedAttrLooseCompare(el, newValue));
        } else {
          return event.target.checked;
        }
      } else if (el.tagName.toLowerCase() === 'select' && el.multiple) {
        return modifiers.includes('number') ? Array.from(event.target.selectedOptions).map(option => {
          const rawValue = option.value || option.text;
          return safeParseNumber(rawValue);
        }) : Array.from(event.target.selectedOptions).map(option => {
          return option.value || option.text;
        });
      } else {
        const rawValue = event.target.value;
        return modifiers.includes('number') ? safeParseNumber(rawValue) : modifiers.includes('trim') ? rawValue.trim() : rawValue;
      }
    };
  }

  function safeParseNumber(rawValue) {
    const number = rawValue ? parseFloat(rawValue) : null;
    return isNumeric(number) ? number : rawValue;
  }

  /**
   * Copyright (C) 2017 salesforce.com, inc.
   */
  const { isArray } = Array;
  const { getPrototypeOf, create: ObjectCreate, defineProperty: ObjectDefineProperty, defineProperties: ObjectDefineProperties, isExtensible, getOwnPropertyDescriptor, getOwnPropertyNames, getOwnPropertySymbols, preventExtensions, hasOwnProperty, } = Object;
  const { push: ArrayPush, concat: ArrayConcat, map: ArrayMap, } = Array.prototype;
  function isUndefined(obj) {
      return obj === undefined;
  }
  function isFunction(obj) {
      return typeof obj === 'function';
  }
  function isObject(obj) {
      return typeof obj === 'object';
  }
  const proxyToValueMap = new WeakMap();
  function registerProxy(proxy, value) {
      proxyToValueMap.set(proxy, value);
  }
  const unwrap = (replicaOrAny) => proxyToValueMap.get(replicaOrAny) || replicaOrAny;

  function wrapValue(membrane, value) {
      return membrane.valueIsObservable(value) ? membrane.getProxy(value) : value;
  }
  /**
   * Unwrap property descriptors will set value on original descriptor
   * We only need to unwrap if value is specified
   * @param descriptor external descrpitor provided to define new property on original value
   */
  function unwrapDescriptor(descriptor) {
      if (hasOwnProperty.call(descriptor, 'value')) {
          descriptor.value = unwrap(descriptor.value);
      }
      return descriptor;
  }
  function lockShadowTarget(membrane, shadowTarget, originalTarget) {
      const targetKeys = ArrayConcat.call(getOwnPropertyNames(originalTarget), getOwnPropertySymbols(originalTarget));
      targetKeys.forEach((key) => {
          let descriptor = getOwnPropertyDescriptor(originalTarget, key);
          // We do not need to wrap the descriptor if configurable
          // Because we can deal with wrapping it when user goes through
          // Get own property descriptor. There is also a chance that this descriptor
          // could change sometime in the future, so we can defer wrapping
          // until we need to
          if (!descriptor.configurable) {
              descriptor = wrapDescriptor(membrane, descriptor, wrapValue);
          }
          ObjectDefineProperty(shadowTarget, key, descriptor);
      });
      preventExtensions(shadowTarget);
  }
  class ReactiveProxyHandler {
      constructor(membrane, value) {
          this.originalTarget = value;
          this.membrane = membrane;
      }
      get(shadowTarget, key) {
          const { originalTarget, membrane } = this;
          const value = originalTarget[key];
          const { valueObserved } = membrane;
          valueObserved(originalTarget, key);
          return membrane.getProxy(value);
      }
      set(shadowTarget, key, value) {
          const { originalTarget, membrane: { valueMutated } } = this;
          const oldValue = originalTarget[key];
          if (oldValue !== value) {
              originalTarget[key] = value;
              valueMutated(originalTarget, key);
          }
          else if (key === 'length' && isArray(originalTarget)) {
              // fix for issue #236: push will add the new index, and by the time length
              // is updated, the internal length is already equal to the new length value
              // therefore, the oldValue is equal to the value. This is the forking logic
              // to support this use case.
              valueMutated(originalTarget, key);
          }
          return true;
      }
      deleteProperty(shadowTarget, key) {
          const { originalTarget, membrane: { valueMutated } } = this;
          delete originalTarget[key];
          valueMutated(originalTarget, key);
          return true;
      }
      apply(shadowTarget, thisArg, argArray) {
          /* No op */
      }
      construct(target, argArray, newTarget) {
          /* No op */
      }
      has(shadowTarget, key) {
          const { originalTarget, membrane: { valueObserved } } = this;
          valueObserved(originalTarget, key);
          return key in originalTarget;
      }
      ownKeys(shadowTarget) {
          const { originalTarget } = this;
          return ArrayConcat.call(getOwnPropertyNames(originalTarget), getOwnPropertySymbols(originalTarget));
      }
      isExtensible(shadowTarget) {
          const shadowIsExtensible = isExtensible(shadowTarget);
          if (!shadowIsExtensible) {
              return shadowIsExtensible;
          }
          const { originalTarget, membrane } = this;
          const targetIsExtensible = isExtensible(originalTarget);
          if (!targetIsExtensible) {
              lockShadowTarget(membrane, shadowTarget, originalTarget);
          }
          return targetIsExtensible;
      }
      setPrototypeOf(shadowTarget, prototype) {
      }
      getPrototypeOf(shadowTarget) {
          const { originalTarget } = this;
          return getPrototypeOf(originalTarget);
      }
      getOwnPropertyDescriptor(shadowTarget, key) {
          const { originalTarget, membrane } = this;
          const { valueObserved } = this.membrane;
          // keys looked up via hasOwnProperty need to be reactive
          valueObserved(originalTarget, key);
          let desc = getOwnPropertyDescriptor(originalTarget, key);
          if (isUndefined(desc)) {
              return desc;
          }
          const shadowDescriptor = getOwnPropertyDescriptor(shadowTarget, key);
          if (!isUndefined(shadowDescriptor)) {
              return shadowDescriptor;
          }
          // Note: by accessing the descriptor, the key is marked as observed
          // but access to the value, setter or getter (if available) cannot observe
          // mutations, just like regular methods, in which case we just do nothing.
          desc = wrapDescriptor(membrane, desc, wrapValue);
          if (!desc.configurable) {
              // If descriptor from original target is not configurable,
              // We must copy the wrapped descriptor over to the shadow target.
              // Otherwise, proxy will throw an invariant error.
              // This is our last chance to lock the value.
              // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getOwnPropertyDescriptor#Invariants
              ObjectDefineProperty(shadowTarget, key, desc);
          }
          return desc;
      }
      preventExtensions(shadowTarget) {
          const { originalTarget, membrane } = this;
          lockShadowTarget(membrane, shadowTarget, originalTarget);
          preventExtensions(originalTarget);
          return true;
      }
      defineProperty(shadowTarget, key, descriptor) {
          const { originalTarget, membrane } = this;
          const { valueMutated } = membrane;
          const { configurable } = descriptor;
          // We have to check for value in descriptor
          // because Object.freeze(proxy) calls this method
          // with only { configurable: false, writeable: false }
          // Additionally, method will only be called with writeable:false
          // if the descriptor has a value, as opposed to getter/setter
          // So we can just check if writable is present and then see if
          // value is present. This eliminates getter and setter descriptors
          if (hasOwnProperty.call(descriptor, 'writable') && !hasOwnProperty.call(descriptor, 'value')) {
              const originalDescriptor = getOwnPropertyDescriptor(originalTarget, key);
              descriptor.value = originalDescriptor.value;
          }
          ObjectDefineProperty(originalTarget, key, unwrapDescriptor(descriptor));
          if (configurable === false) {
              ObjectDefineProperty(shadowTarget, key, wrapDescriptor(membrane, descriptor, wrapValue));
          }
          valueMutated(originalTarget, key);
          return true;
      }
  }

  function wrapReadOnlyValue(membrane, value) {
      return membrane.valueIsObservable(value) ? membrane.getReadOnlyProxy(value) : value;
  }
  class ReadOnlyHandler {
      constructor(membrane, value) {
          this.originalTarget = value;
          this.membrane = membrane;
      }
      get(shadowTarget, key) {
          const { membrane, originalTarget } = this;
          const value = originalTarget[key];
          const { valueObserved } = membrane;
          valueObserved(originalTarget, key);
          return membrane.getReadOnlyProxy(value);
      }
      set(shadowTarget, key, value) {
          return false;
      }
      deleteProperty(shadowTarget, key) {
          return false;
      }
      apply(shadowTarget, thisArg, argArray) {
          /* No op */
      }
      construct(target, argArray, newTarget) {
          /* No op */
      }
      has(shadowTarget, key) {
          const { originalTarget, membrane: { valueObserved } } = this;
          valueObserved(originalTarget, key);
          return key in originalTarget;
      }
      ownKeys(shadowTarget) {
          const { originalTarget } = this;
          return ArrayConcat.call(getOwnPropertyNames(originalTarget), getOwnPropertySymbols(originalTarget));
      }
      setPrototypeOf(shadowTarget, prototype) {
      }
      getOwnPropertyDescriptor(shadowTarget, key) {
          const { originalTarget, membrane } = this;
          const { valueObserved } = membrane;
          // keys looked up via hasOwnProperty need to be reactive
          valueObserved(originalTarget, key);
          let desc = getOwnPropertyDescriptor(originalTarget, key);
          if (isUndefined(desc)) {
              return desc;
          }
          const shadowDescriptor = getOwnPropertyDescriptor(shadowTarget, key);
          if (!isUndefined(shadowDescriptor)) {
              return shadowDescriptor;
          }
          // Note: by accessing the descriptor, the key is marked as observed
          // but access to the value or getter (if available) cannot be observed,
          // just like regular methods, in which case we just do nothing.
          desc = wrapDescriptor(membrane, desc, wrapReadOnlyValue);
          if (hasOwnProperty.call(desc, 'set')) {
              desc.set = undefined; // readOnly membrane does not allow setters
          }
          if (!desc.configurable) {
              // If descriptor from original target is not configurable,
              // We must copy the wrapped descriptor over to the shadow target.
              // Otherwise, proxy will throw an invariant error.
              // This is our last chance to lock the value.
              // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getOwnPropertyDescriptor#Invariants
              ObjectDefineProperty(shadowTarget, key, desc);
          }
          return desc;
      }
      preventExtensions(shadowTarget) {
          return false;
      }
      defineProperty(shadowTarget, key, descriptor) {
          return false;
      }
  }
  function createShadowTarget(value) {
      let shadowTarget = undefined;
      if (isArray(value)) {
          shadowTarget = [];
      }
      else if (isObject(value)) {
          shadowTarget = {};
      }
      return shadowTarget;
  }
  const ObjectDotPrototype = Object.prototype;
  function defaultValueIsObservable(value) {
      // intentionally checking for null
      if (value === null) {
          return false;
      }
      // treat all non-object types, including undefined, as non-observable values
      if (typeof value !== 'object') {
          return false;
      }
      if (isArray(value)) {
          return true;
      }
      const proto = getPrototypeOf(value);
      return (proto === ObjectDotPrototype || proto === null || getPrototypeOf(proto) === null);
  }
  const defaultValueObserved = (obj, key) => {
      /* do nothing */
  };
  const defaultValueMutated = (obj, key) => {
      /* do nothing */
  };
  const defaultValueDistortion = (value) => value;
  function wrapDescriptor(membrane, descriptor, getValue) {
      const { set, get } = descriptor;
      if (hasOwnProperty.call(descriptor, 'value')) {
          descriptor.value = getValue(membrane, descriptor.value);
      }
      else {
          if (!isUndefined(get)) {
              descriptor.get = function () {
                  // invoking the original getter with the original target
                  return getValue(membrane, get.call(unwrap(this)));
              };
          }
          if (!isUndefined(set)) {
              descriptor.set = function (value) {
                  // At this point we don't have a clear indication of whether
                  // or not a valid mutation will occur, we don't have the key,
                  // and we are not sure why and how they are invoking this setter.
                  // Nevertheless we preserve the original semantics by invoking the
                  // original setter with the original target and the unwrapped value
                  set.call(unwrap(this), membrane.unwrapProxy(value));
              };
          }
      }
      return descriptor;
  }
  class ReactiveMembrane {
      constructor(options) {
          this.valueDistortion = defaultValueDistortion;
          this.valueMutated = defaultValueMutated;
          this.valueObserved = defaultValueObserved;
          this.valueIsObservable = defaultValueIsObservable;
          this.objectGraph = new WeakMap();
          if (!isUndefined(options)) {
              const { valueDistortion, valueMutated, valueObserved, valueIsObservable } = options;
              this.valueDistortion = isFunction(valueDistortion) ? valueDistortion : defaultValueDistortion;
              this.valueMutated = isFunction(valueMutated) ? valueMutated : defaultValueMutated;
              this.valueObserved = isFunction(valueObserved) ? valueObserved : defaultValueObserved;
              this.valueIsObservable = isFunction(valueIsObservable) ? valueIsObservable : defaultValueIsObservable;
          }
      }
      getProxy(value) {
          const unwrappedValue = unwrap(value);
          const distorted = this.valueDistortion(unwrappedValue);
          if (this.valueIsObservable(distorted)) {
              const o = this.getReactiveState(unwrappedValue, distorted);
              // when trying to extract the writable version of a readonly
              // we return the readonly.
              return o.readOnly === value ? value : o.reactive;
          }
          return distorted;
      }
      getReadOnlyProxy(value) {
          value = unwrap(value);
          const distorted = this.valueDistortion(value);
          if (this.valueIsObservable(distorted)) {
              return this.getReactiveState(value, distorted).readOnly;
          }
          return distorted;
      }
      unwrapProxy(p) {
          return unwrap(p);
      }
      getReactiveState(value, distortedValue) {
          const { objectGraph, } = this;
          let reactiveState = objectGraph.get(distortedValue);
          if (reactiveState) {
              return reactiveState;
          }
          const membrane = this;
          reactiveState = {
              get reactive() {
                  const reactiveHandler = new ReactiveProxyHandler(membrane, distortedValue);
                  // caching the reactive proxy after the first time it is accessed
                  const proxy = new Proxy(createShadowTarget(distortedValue), reactiveHandler);
                  registerProxy(proxy, value);
                  ObjectDefineProperty(this, 'reactive', { value: proxy });
                  return proxy;
              },
              get readOnly() {
                  const readOnlyHandler = new ReadOnlyHandler(membrane, distortedValue);
                  // caching the readOnly proxy after the first time it is accessed
                  const proxy = new Proxy(createShadowTarget(distortedValue), readOnlyHandler);
                  registerProxy(proxy, value);
                  ObjectDefineProperty(this, 'readOnly', { value: proxy });
                  return proxy;
              }
          };
          objectGraph.set(distortedValue, reactiveState);
          return reactiveState;
      }
  }
  /** version: 0.26.0 */

  function wrap(data, mutationCallback) {

    let membrane = new ReactiveMembrane({
      valueMutated(target, key) {
        mutationCallback(target, key);
      }

    });
    return {
      data: membrane.getProxy(data),
      membrane: membrane
    };
  }
  function unwrap$1(membrane, observable) {
    let unwrappedData = membrane.unwrapProxy(observable);
    let copy = {};
    Object.keys(unwrappedData).forEach(key => {
      if (['$el', '$refs', '$nextTick', '$watch'].includes(key)) return;
      copy[key] = unwrappedData[key];
    });
    return copy;
  }

  class Component {
    constructor(el, componentForClone = null) {
      this.$el = el;
      const dataAttr = this.$el.getAttribute('x-data');
      const dataExpression = dataAttr === '' ? '{}' : dataAttr;
      const initExpression = this.$el.getAttribute('x-init');
      let dataExtras = {
        $el: this.$el
      };
      let canonicalComponentElementReference = componentForClone ? componentForClone.$el : this.$el;
      Object.entries(Alpine.magicProperties).forEach(([name, callback]) => {
        Object.defineProperty(dataExtras, `$${name}`, {
          get: function get() {
            return callback(canonicalComponentElementReference);
          }
        });
      });
      this.unobservedData = componentForClone ? componentForClone.getUnobservedData() : saferEval(el, dataExpression, dataExtras);
      // Construct a Proxy-based observable. This will be used to handle reactivity.

      let {
        membrane,
        data
      } = this.wrapDataInObservable(this.unobservedData);
      this.$data = data;
      this.membrane = membrane; // After making user-supplied data methods reactive, we can now add
      // our magic properties to the original data for access.

      this.unobservedData.$el = this.$el;
      this.unobservedData.$refs = this.getRefsProxy();
      this.nextTickStack = [];

      this.unobservedData.$nextTick = callback => {
        this.nextTickStack.push(callback);
      };

      this.watchers = {};

      this.unobservedData.$watch = (property, callback) => {
        if (!this.watchers[property]) this.watchers[property] = [];
        this.watchers[property].push(callback);
      };
      /* MODERN-ONLY:START */
      // We remove this piece of code from the legacy build.
      // In IE11, we have already defined our helpers at this point.
      // Register custom magic properties.


      Object.entries(Alpine.magicProperties).forEach(([name, callback]) => {
        Object.defineProperty(this.unobservedData, `$${name}`, {
          get: function get() {
            return callback(canonicalComponentElementReference, this.$el);
          }
        });
      });
      /* MODERN-ONLY:END */

      this.showDirectiveStack = [];
      this.showDirectiveLastElement;
      componentForClone || Alpine.onBeforeComponentInitializeds.forEach(callback => callback(this));
      var initReturnedCallback; // If x-init is present AND we aren't cloning (skip x-init on clone)

      if (initExpression && !componentForClone) {
        // We want to allow data manipulation, but not trigger DOM updates just yet.
        // We haven't even initialized the elements with their Alpine bindings. I mean c'mon.
        this.pauseReactivity = true;
        initReturnedCallback = this.evaluateReturnExpression(this.$el, initExpression);
        this.pauseReactivity = false;
      } // Register all our listeners and set all our attribute bindings.
      // If we're cloning a component, the third parameter ensures no duplicate
      // event listeners are registered (the mutation observer will take care of them)


      this.initializeElements(this.$el, () => {}, componentForClone); // Use mutation observer to detect new elements being added within this component at run-time.
      // Alpine's just so darn flexible amirite?

      this.listenForNewElementsToInitialize();

      if (typeof initReturnedCallback === 'function') {
        // Run the callback returned from the "x-init" hook to allow the user to do stuff after
        // Alpine's got it's grubby little paws all over everything.
        initReturnedCallback.call(this.$data);
      }

      componentForClone || setTimeout(() => {
        Alpine.onComponentInitializeds.forEach(callback => callback(this));
      }, 0);
    }

    getUnobservedData() {
      return unwrap$1(this.membrane, this.$data);
    }

    wrapDataInObservable(data) {
      var self = this;
      let updateDom = debounce(function () {
        self.updateElements(self.$el);
      }, 0);
      return wrap(data, (target, key) => {
        if (self.watchers[key]) {
          // If there's a watcher for this specific key, run it.
          self.watchers[key].forEach(callback => callback(target[key]));
        } else if (Array.isArray(target)) {
          // Arrays are special cases, if any of the items change, we consider the array as mutated.
          Object.keys(self.watchers).forEach(fullDotNotationKey => {
            let dotNotationParts = fullDotNotationKey.split('.'); // Ignore length mutations since they would result in duplicate calls.
            // For example, when calling push, we would get a mutation for the item's key
            // and a second mutation for the length property.

            if (key === 'length') return;
            dotNotationParts.reduce((comparisonData, part) => {
              if (Object.is(target, comparisonData[part])) {
                self.watchers[fullDotNotationKey].forEach(callback => callback(target));
              }

              return comparisonData[part];
            }, self.unobservedData);
          });
        } else {
          // Let's walk through the watchers with "dot-notation" (foo.bar) and see
          // if this mutation fits any of them.
          Object.keys(self.watchers).filter(i => i.includes('.')).forEach(fullDotNotationKey => {
            let dotNotationParts = fullDotNotationKey.split('.'); // If this dot-notation watcher's last "part" doesn't match the current
            // key, then skip it early for performance reasons.

            if (key !== dotNotationParts[dotNotationParts.length - 1]) return; // Now, walk through the dot-notation "parts" recursively to find
            // a match, and call the watcher if one's found.

            dotNotationParts.reduce((comparisonData, part) => {
              if (Object.is(target, comparisonData)) {
                // Run the watchers.
                self.watchers[fullDotNotationKey].forEach(callback => callback(target[key]));
              }

              return comparisonData[part];
            }, self.unobservedData);
          });
        } // Don't react to data changes for cases like the `x-created` hook.


        if (self.pauseReactivity) return;
        updateDom();
      });
    }

    walkAndSkipNestedComponents(el, callback, initializeComponentCallback = () => {}) {
      walk(el, el => {
        // We've hit a component.
        if (el.hasAttribute('x-data')) {
          // If it's not the current one.
          if (!el.isSameNode(this.$el)) {
            // Initialize it if it's not.
            if (!el.__x) initializeComponentCallback(el); // Now we'll let that sub-component deal with itself.

            return false;
          }
        }

        return callback(el);
      });
    }

    initializeElements(rootEl, extraVars = () => {}, componentForClone = false) {
      this.walkAndSkipNestedComponents(rootEl, el => {
        // Don't touch spawns from for loop
        if (el.__x_for_key !== undefined) return false; // Don't touch spawns from if directives

        if (el.__x_inserted_me !== undefined) return false;
        this.initializeElement(el, extraVars, componentForClone ? false : true);
      }, el => {
        if (!componentForClone) el.__x = new Component(el);
      });
      this.executeAndClearRemainingShowDirectiveStack();
      this.executeAndClearNextTickStack(rootEl);
    }

    initializeElement(el, extraVars, shouldRegisterListeners = true) {
      // To support class attribute merging, we have to know what the element's
      // original class attribute looked like for reference.
      if (el.hasAttribute('class') && getXAttrs(el, this).length > 0) {
        el.__x_original_classes = convertClassStringToArray(el.getAttribute('class'));
      }

      shouldRegisterListeners && this.registerListeners(el, extraVars);
      this.resolveBoundAttributes(el, true, extraVars);
    }

    updateElements(rootEl, extraVars = () => {}) {
      this.walkAndSkipNestedComponents(rootEl, el => {
        // Don't touch spawns from for loop (and check if the root is actually a for loop in a parent, don't skip it.)
        if (el.__x_for_key !== undefined && !el.isSameNode(this.$el)) return false;
        this.updateElement(el, extraVars);
      }, el => {
        el.__x = new Component(el);
      });
      this.executeAndClearRemainingShowDirectiveStack();
      this.executeAndClearNextTickStack(rootEl);
    }

    executeAndClearNextTickStack(el) {
      // Skip spawns from alpine directives
      if (el === this.$el && this.nextTickStack.length > 0) {
        // We run the tick stack after the next frame to allow any
        // running transitions to pass the initial show stage.
        requestAnimationFrame(() => {
          while (this.nextTickStack.length > 0) {
            this.nextTickStack.shift()();
          }
        });
      }
    }

    executeAndClearRemainingShowDirectiveStack() {
      // The goal here is to start all the x-show transitions
      // and build a nested promise chain so that elements
      // only hide when the children are finished hiding.
      this.showDirectiveStack.reverse().map(handler => {
        return new Promise((resolve, reject) => {
          handler(resolve, reject);
        });
      }).reduce((promiseChain, promise) => {
        return promiseChain.then(() => {
          return promise.then(finishElement => {
            finishElement();
          });
        });
      }, Promise.resolve(() => {})).catch(e => {
        if (e !== TRANSITION_CANCELLED) throw e;
      }); // We've processed the handler stack. let's clear it.

      this.showDirectiveStack = [];
      this.showDirectiveLastElement = undefined;
    }

    updateElement(el, extraVars) {
      this.resolveBoundAttributes(el, false, extraVars);
    }

    registerListeners(el, extraVars) {
      getXAttrs(el, this).forEach(({
        type,
        value,
        modifiers,
        expression
      }) => {
        switch (type) {
          case 'on':
            registerListener(this, el, value, modifiers, expression, extraVars);
            break;

          case 'model':
            registerModelListener(this, el, modifiers, expression, extraVars);
            break;
        }
      });
    }

    resolveBoundAttributes(el, initialUpdate = false, extraVars) {
      let attrs = getXAttrs(el, this);
      attrs.forEach(({
        type,
        value,
        modifiers,
        expression
      }) => {
        switch (type) {
          case 'model':
            handleAttributeBindingDirective(this, el, 'value', expression, extraVars, type, modifiers);
            break;

          case 'bind':
            // The :key binding on an x-for is special, ignore it.
            if (el.tagName.toLowerCase() === 'template' && value === 'key') return;
            handleAttributeBindingDirective(this, el, value, expression, extraVars, type, modifiers);
            break;

          case 'text':
            var output = this.evaluateReturnExpression(el, expression, extraVars);
            handleTextDirective(el, output, expression);
            break;

          case 'html':
            handleHtmlDirective(this, el, expression, extraVars);
            break;

          case 'show':
            var output = this.evaluateReturnExpression(el, expression, extraVars);
            handleShowDirective(this, el, output, modifiers, initialUpdate);
            break;

          case 'if':
            // If this element also has x-for on it, don't process x-if.
            // We will let the "x-for" directive handle the "if"ing.
            if (attrs.some(i => i.type === 'for')) return;
            var output = this.evaluateReturnExpression(el, expression, extraVars);
            handleIfDirective(this, el, output, initialUpdate, extraVars);
            break;

          case 'for':
            handleForDirective(this, el, expression, initialUpdate, extraVars);
            break;

          case 'cloak':
            el.removeAttribute('x-cloak');
            break;
        }
      });
    }

    evaluateReturnExpression(el, expression, extraVars = () => {}) {
      return saferEval(el, expression, this.$data, _objectSpread2(_objectSpread2({}, extraVars()), {}, {
        $dispatch: this.getDispatchFunction(el)
      }));
    }

    evaluateCommandExpression(el, expression, extraVars = () => {}) {
      return saferEvalNoReturn(el, expression, this.$data, _objectSpread2(_objectSpread2({}, extraVars()), {}, {
        $dispatch: this.getDispatchFunction(el)
      }));
    }

    getDispatchFunction(el) {
      return (event, detail = {}) => {
        el.dispatchEvent(new CustomEvent(event, {
          detail,
          bubbles: true
        }));
      };
    }

    listenForNewElementsToInitialize() {
      const targetNode = this.$el;
      const observerOptions = {
        childList: true,
        attributes: true,
        subtree: true
      };
      const observer = new MutationObserver(mutations => {
        for (let i = 0; i < mutations.length; i++) {
          // Filter out mutations triggered from child components.
          const closestParentComponent = mutations[i].target.closest('[x-data]');
          if (!(closestParentComponent && closestParentComponent.isSameNode(this.$el))) continue;

          if (mutations[i].type === 'attributes' && mutations[i].attributeName === 'x-data') {
            const xAttr = mutations[i].target.getAttribute('x-data') || '{}';
            const rawData = saferEval(this.$el, xAttr, {
              $el: this.$el
            });
            Object.keys(rawData).forEach(key => {
              if (this.$data[key] !== rawData[key]) {
                this.$data[key] = rawData[key];
              }
            });
          }

          if (mutations[i].addedNodes.length > 0) {
            mutations[i].addedNodes.forEach(node => {
              if (node.nodeType !== 1 || node.__x_inserted_me) return;

              if (node.matches('[x-data]') && !node.__x) {
                node.__x = new Component(node);
                return;
              }

              this.initializeElements(node);
            });
          }
        }
      });
      observer.observe(targetNode, observerOptions);
    }

    getRefsProxy() {
      var self = this;
      var refObj = {};
      // One of the goals of this is to not hold elements in memory, but rather re-evaluate
      // the DOM when the system needs something from it. This way, the framework is flexible and
      // friendly to outside DOM changes from libraries like Vue/Livewire.
      // For this reason, I'm using an "on-demand" proxy to fake a "$refs" object.

      return new Proxy(refObj, {
        get(object, property) {
          if (property === '$isAlpineProxy') return true;
          var ref; // We can't just query the DOM because it's hard to filter out refs in
          // nested components.

          self.walkAndSkipNestedComponents(self.$el, el => {
            if (el.hasAttribute('x-ref') && el.getAttribute('x-ref') === property) {
              ref = el;
            }
          });
          return ref;
        }

      });
    }

  }

  const Alpine = {
    version: "2.8.2",
    pauseMutationObserver: false,
    magicProperties: {},
    onComponentInitializeds: [],
    onBeforeComponentInitializeds: [],
    ignoreFocusedForValueBinding: false,
    start: async function start() {
      if (!isTesting()) {
        await domReady();
      }

      this.discoverComponents(el => {
        this.initializeComponent(el);
      }); // It's easier and more performant to just support Turbolinks than listen
      // to MutationObserver mutations at the document level.

      document.addEventListener("turbolinks:load", () => {
        this.discoverUninitializedComponents(el => {
          this.initializeComponent(el);
        });
      });
      this.listenForNewUninitializedComponentsAtRunTime();
    },
    discoverComponents: function discoverComponents(callback) {
      const rootEls = document.querySelectorAll('[x-data]');
      rootEls.forEach(rootEl => {
        callback(rootEl);
      });
    },
    discoverUninitializedComponents: function discoverUninitializedComponents(callback, el = null) {
      const rootEls = (el || document).querySelectorAll('[x-data]');
      Array.from(rootEls).filter(el => el.__x === undefined).forEach(rootEl => {
        callback(rootEl);
      });
    },
    listenForNewUninitializedComponentsAtRunTime: function listenForNewUninitializedComponentsAtRunTime() {
      const targetNode = document.querySelector('body');
      const observerOptions = {
        childList: true,
        attributes: true,
        subtree: true
      };
      const observer = new MutationObserver(mutations => {
        if (this.pauseMutationObserver) return;

        for (let i = 0; i < mutations.length; i++) {
          if (mutations[i].addedNodes.length > 0) {
            mutations[i].addedNodes.forEach(node => {
              // Discard non-element nodes (like line-breaks)
              if (node.nodeType !== 1) return; // Discard any changes happening within an existing component.
              // They will take care of themselves.

              if (node.parentElement && node.parentElement.closest('[x-data]')) return;
              this.discoverUninitializedComponents(el => {
                this.initializeComponent(el);
              }, node.parentElement);
            });
          }
        }
      });
      observer.observe(targetNode, observerOptions);
    },
    initializeComponent: function initializeComponent(el) {
      if (!el.__x) {
        // Wrap in a try/catch so that we don't prevent other components
        // from initializing when one component contains an error.
        try {
          el.__x = new Component(el);
        } catch (error) {
          setTimeout(() => {
            throw error;
          }, 0);
        }
      }
    },
    clone: function clone(component, newEl) {
      if (!newEl.__x) {
        newEl.__x = new Component(newEl, component);
      }
    },
    addMagicProperty: function addMagicProperty(name, callback) {
      this.magicProperties[name] = callback;
    },
    onComponentInitialized: function onComponentInitialized(callback) {
      this.onComponentInitializeds.push(callback);
    },
    onBeforeComponentInitialized: function onBeforeComponentInitialized(callback) {
      this.onBeforeComponentInitializeds.push(callback);
    }
  };

  if (!isTesting()) {
    window.Alpine = Alpine;

    if (window.deferLoadingAlpine) {
      window.deferLoadingAlpine(function () {
        window.Alpine.start();
      });
    } else {
      window.Alpine.start();
    }
  }

  return Alpine;

})));

},{}],22:[function(require,module,exports){
'use strict';

function crelt() {
  var elt = arguments[0];
  if (typeof elt == "string") elt = document.createElement(elt);
  var i = 1, next = arguments[1];
  if (next && typeof next == "object" && next.nodeType == null && !Array.isArray(next)) {
    for (var name in next) if (Object.prototype.hasOwnProperty.call(next, name)) {
      var value = next[name];
      if (typeof value == "string") elt.setAttribute(name, value);
      else if (value != null) elt[name] = value;
    }
    i++;
  }
  for (; i < arguments.length; i++) add(elt, arguments[i]);
  return elt
}

function add(elt, child) {
  if (typeof child == "string") {
    elt.appendChild(document.createTextNode(child));
  } else if (child == null) ; else if (child.nodeType != null) {
    elt.appendChild(child);
  } else if (Array.isArray(child)) {
    for (var i = 0; i < child.length; i++) add(elt, child[i]);
  } else {
    throw new RangeError("Unsupported child node: " + child)
  }
}

module.exports = crelt;

},{}],23:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/// The default maximum length of a `TreeBuffer` node.
const DefaultBufferLength = 1024;
let nextPropID = 0;
const CachedNode = new WeakMap();
/// Each [node type](#tree.NodeType) can have metadata associated with
/// it in props. Instances of this class represent prop names.
class NodeProp {
    /// Create a new node prop type. You can optionally pass a
    /// `deserialize` function.
    constructor({ deserialize } = {}) {
        this.id = nextPropID++;
        this.deserialize = deserialize || (() => {
            throw new Error("This node type doesn't define a deserialize function");
        });
    }
    /// Create a string-valued node prop whose deserialize function is
    /// the identity function.
    static string() { return new NodeProp({ deserialize: str => str }); }
    /// Create a number-valued node prop whose deserialize function is
    /// just `Number`.
    static number() { return new NodeProp({ deserialize: Number }); }
    /// Creates a boolean-valued node prop whose deserialize function
    /// returns true for any input.
    static flag() { return new NodeProp({ deserialize: () => true }); }
    /// Store a value for this prop in the given object. This can be
    /// useful when building up a prop object to pass to the
    /// [`NodeType`](#tree.NodeType) constructor. Returns its first
    /// argument.
    set(propObj, value) {
        propObj[this.id] = value;
        return propObj;
    }
    /// This is meant to be used with
    /// [`NodeSet.extend`](#tree.NodeSet.extend) or
    /// [`Parser.withProps`](#lezer.Parser.withProps) to compute prop
    /// values for each node type in the set. Takes a [match
    /// object](#tree.NodeType^match) or function that returns undefined
    /// if the node type doesn't get this prop, and the prop's value if
    /// it does.
    add(match) {
        if (typeof match != "function")
            match = NodeType.match(match);
        return (type) => {
            let result = match(type);
            return result === undefined ? null : [this, result];
        };
    }
}
/// Prop that is used to describe matching delimiters. For opening
/// delimiters, this holds an array of node names (written as a
/// space-separated string when declaring this prop in a grammar)
/// for the node types of closing delimiters that match it.
NodeProp.closedBy = new NodeProp({ deserialize: str => str.split(" ") });
/// The inverse of [`openedBy`](#tree.NodeProp^closedBy). This is
/// attached to closing delimiters, holding an array of node names
/// of types of matching opening delimiters.
NodeProp.openedBy = new NodeProp({ deserialize: str => str.split(" ") });
/// Used to assign node types to groups (for example, all node
/// types that represent an expression could be tagged with an
/// `"Expression"` group).
NodeProp.group = new NodeProp({ deserialize: str => str.split(" ") });
const noProps = Object.create(null);
/// Each node in a syntax tree has a node type associated with it.
class NodeType {
    /// @internal
    constructor(
    /// The name of the node type. Not necessarily unique, but if the
    /// grammar was written properly, different node types with the
    /// same name within a node set should play the same semantic
    /// role.
    name, 
    /// @internal
    props, 
    /// The id of this node in its set. Corresponds to the term ids
    /// used in the parser.
    id, 
    /// @internal
    flags = 0) {
        this.name = name;
        this.props = props;
        this.id = id;
        this.flags = flags;
    }
    static define(spec) {
        let props = spec.props && spec.props.length ? Object.create(null) : noProps;
        let flags = (spec.top ? 1 /* Top */ : 0) | (spec.skipped ? 2 /* Skipped */ : 0) |
            (spec.error ? 4 /* Error */ : 0) | (spec.name == null ? 8 /* Anonymous */ : 0);
        let type = new NodeType(spec.name || "", props, spec.id, flags);
        if (spec.props)
            for (let src of spec.props) {
                if (!Array.isArray(src))
                    src = src(type);
                if (src)
                    src[0].set(props, src[1]);
            }
        return type;
    }
    /// Retrieves a node prop for this type. Will return `undefined` if
    /// the prop isn't present on this node.
    prop(prop) { return this.props[prop.id]; }
    /// True when this is the top node of a grammar.
    get isTop() { return (this.flags & 1 /* Top */) > 0; }
    /// True when this node is produced by a skip rule.
    get isSkipped() { return (this.flags & 2 /* Skipped */) > 0; }
    /// Indicates whether this is an error node.
    get isError() { return (this.flags & 4 /* Error */) > 0; }
    /// When true, this node type doesn't correspond to a user-declared
    /// named node, for example because it is used to cache repetition.
    get isAnonymous() { return (this.flags & 8 /* Anonymous */) > 0; }
    /// Returns true when this node's name or one of its
    /// [groups](#tree.NodeProp^group) matches the given string.
    is(name) {
        if (typeof name == 'string') {
            if (this.name == name)
                return true;
            let group = this.prop(NodeProp.group);
            return group ? group.indexOf(name) > -1 : false;
        }
        return this.id == name;
    }
    /// Create a function from node types to arbitrary values by
    /// specifying an object whose property names are node or
    /// [group](#tree.NodeProp^group) names. Often useful with
    /// [`NodeProp.add`](#tree.NodeProp.add). You can put multiple
    /// names, separated by spaces, in a single property name to map
    /// multiple node names to a single value.
    static match(map) {
        let direct = Object.create(null);
        for (let prop in map)
            for (let name of prop.split(" "))
                direct[name] = map[prop];
        return (node) => {
            for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
                let found = direct[i < 0 ? node.name : groups[i]];
                if (found)
                    return found;
            }
        };
    }
}
/// An empty dummy node type to use when no actual type is available.
NodeType.none = new NodeType("", Object.create(null), 0, 8 /* Anonymous */);
/// A node set holds a collection of node types. It is used to
/// compactly represent trees by storing their type ids, rather than a
/// full pointer to the type object, in a number array. Each parser
/// [has](#lezer.Parser.nodeSet) a node set, and [tree
/// buffers](#tree.TreeBuffer) can only store collections of nodes
/// from the same set. A set can have a maximum of 2**16 (65536)
/// node types in it, so that the ids fit into 16-bit typed array
/// slots.
class NodeSet {
    /// Create a set with the given types. The `id` property of each
    /// type should correspond to its position within the array.
    constructor(
    /// The node types in this set, by id.
    types) {
        this.types = types;
        for (let i = 0; i < types.length; i++)
            if (types[i].id != i)
                throw new RangeError("Node type ids should correspond to array positions when creating a node set");
    }
    /// Create a copy of this set with some node properties added. The
    /// arguments to this method should be created with
    /// [`NodeProp.add`](#tree.NodeProp.add).
    extend(...props) {
        let newTypes = [];
        for (let type of this.types) {
            let newProps = null;
            for (let source of props) {
                let add = source(type);
                if (add) {
                    if (!newProps)
                        newProps = Object.assign({}, type.props);
                    add[0].set(newProps, add[1]);
                }
            }
            newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
        }
        return new NodeSet(newTypes);
    }
}
/// A piece of syntax tree. There are two ways to approach these
/// trees: the way they are actually stored in memory, and the
/// convenient way.
///
/// Syntax trees are stored as a tree of `Tree` and `TreeBuffer`
/// objects. By packing detail information into `TreeBuffer` leaf
/// nodes, the representation is made a lot more memory-efficient.
///
/// However, when you want to actually work with tree nodes, this
/// representation is very awkward, so most client code will want to
/// use the `TreeCursor` interface instead, which provides a view on
/// some part of this data structure, and can be used to move around
/// to adjacent nodes.
class Tree {
    /// Construct a new tree. You usually want to go through
    /// [`Tree.build`](#tree.Tree^build) instead.
    constructor(type, 
    /// The tree's child nodes. Children small enough to fit in a
    /// `TreeBuffer will be represented as such, other children can be
    /// further `Tree` instances with their own internal structure.
    children, 
    /// The positions (offsets relative to the start of this tree) of
    /// the children.
    positions, 
    /// The total length of this tree
    length) {
        this.type = type;
        this.children = children;
        this.positions = positions;
        this.length = length;
    }
    /// @internal
    toString() {
        let children = this.children.map(c => c.toString()).join();
        return !this.type.name ? children :
            (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +
                (children.length ? "(" + children + ")" : "");
    }
    /// Get a [tree cursor](#tree.TreeCursor) rooted at this tree. When
    /// `pos` is given, the cursor is [moved](#tree.TreeCursor.moveTo)
    /// to the given position and side.
    cursor(pos, side = 0) {
        let scope = (pos != null && CachedNode.get(this)) || this.topNode;
        let cursor = new TreeCursor(scope);
        if (pos != null) {
            cursor.moveTo(pos, side);
            CachedNode.set(this, cursor._tree);
        }
        return cursor;
    }
    /// Get a [tree cursor](#tree.TreeCursor) that, unlike regular
    /// cursors, doesn't skip [anonymous](#tree.NodeType.isAnonymous)
    /// nodes.
    fullCursor() {
        return new TreeCursor(this.topNode, true);
    }
    /// Get a [syntax node](#tree.SyntaxNode) object for the top of the
    /// tree.
    get topNode() {
        return new TreeNode(this, 0, 0, null);
    }
    /// Get the [syntax node](#tree.SyntaxNode) at the given position.
    /// If `side` is -1, this will move into nodes that end at the
    /// position. If 1, it'll move into nodes that start at the
    /// position. With 0, it'll only enter nodes that cover the position
    /// from both sides.
    resolve(pos, side = 0) {
        return this.cursor(pos, side).node;
    }
    /// Iterate over the tree and its children, calling `enter` for any
    /// node that touches the `from`/`to` region (if given) before
    /// running over such a node's children, and `leave` (if given) when
    /// leaving the node. When `enter` returns `false`, the given node
    /// will not have its children iterated over (or `leave` called).
    iterate(spec) {
        let { enter, leave, from = 0, to = this.length } = spec;
        for (let c = this.cursor();;) {
            let mustLeave = false;
            if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c.type, c.from, c.to) !== false)) {
                if (c.firstChild())
                    continue;
                if (!c.type.isAnonymous)
                    mustLeave = true;
            }
            for (;;) {
                if (mustLeave && leave)
                    leave(c.type, c.from, c.to);
                mustLeave = c.type.isAnonymous;
                if (c.nextSibling())
                    break;
                if (!c.parent())
                    return;
                mustLeave = true;
            }
        }
    }
    /// Balance the direct children of this tree.
    balance(maxBufferLength = DefaultBufferLength) {
        return this.children.length <= BalanceBranchFactor ? this
            : balanceRange(this.type, NodeType.none, this.children, this.positions, 0, this.children.length, 0, maxBufferLength, this.length, 0);
    }
    /// Build a tree from a postfix-ordered buffer of node information,
    /// or a cursor over such a buffer.
    static build(data) { return buildTree(data); }
}
/// The empty tree
Tree.empty = new Tree(NodeType.none, [], [], 0);
// For trees that need a context hash attached, we're using this
// kludge which assigns an extra property directly after
// initialization (creating a single new object shape).
function withHash(tree, hash) {
    if (hash)
        tree.contextHash = hash;
    return tree;
}
/// Tree buffers contain (type, start, end, endIndex) quads for each
/// node. In such a buffer, nodes are stored in prefix order (parents
/// before children, with the endIndex of the parent indicating which
/// children belong to it)
class TreeBuffer {
    /// Create a tree buffer @internal
    constructor(
    /// @internal
    buffer, 
    // The total length of the group of nodes in the buffer.
    length, 
    /// @internal
    set, type = NodeType.none) {
        this.buffer = buffer;
        this.length = length;
        this.set = set;
        this.type = type;
    }
    /// @internal
    toString() {
        let result = [];
        for (let index = 0; index < this.buffer.length;) {
            result.push(this.childString(index));
            index = this.buffer[index + 3];
        }
        return result.join(",");
    }
    /// @internal
    childString(index) {
        let id = this.buffer[index], endIndex = this.buffer[index + 3];
        let type = this.set.types[id], result = type.name;
        if (/\W/.test(result) && !type.isError)
            result = JSON.stringify(result);
        index += 4;
        if (endIndex == index)
            return result;
        let children = [];
        while (index < endIndex) {
            children.push(this.childString(index));
            index = this.buffer[index + 3];
        }
        return result + "(" + children.join(",") + ")";
    }
    /// @internal
    findChild(startIndex, endIndex, dir, after) {
        let { buffer } = this, pick = -1;
        for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {
            if (after != -100000000 /* None */) {
                let start = buffer[i + 1], end = buffer[i + 2];
                if (dir > 0) {
                    if (end > after)
                        pick = i;
                    if (end > after)
                        break;
                }
                else {
                    if (start < after)
                        pick = i;
                    if (end >= after)
                        break;
                }
            }
            else {
                pick = i;
                if (dir > 0)
                    break;
            }
        }
        return pick;
    }
}
class TreeNode {
    constructor(node, from, index, _parent) {
        this.node = node;
        this.from = from;
        this.index = index;
        this._parent = _parent;
    }
    get type() { return this.node.type; }
    get name() { return this.node.type.name; }
    get to() { return this.from + this.node.length; }
    nextChild(i, dir, after, full = false) {
        for (let parent = this;;) {
            for (let { children, positions } = parent.node, e = dir > 0 ? children.length : -1; i != e; i += dir) {
                let next = children[i], start = positions[i] + parent.from;
                if (after != -100000000 /* None */ && (dir < 0 ? start >= after : start + next.length <= after))
                    continue;
                if (next instanceof TreeBuffer) {
                    let index = next.findChild(0, next.buffer.length, dir, after == -100000000 /* None */ ? -100000000 /* None */ : after - start);
                    if (index > -1)
                        return new BufferNode(new BufferContext(parent, next, i, start), null, index);
                }
                else if (full || (!next.type.isAnonymous || hasChild(next))) {
                    let inner = new TreeNode(next, start, i, parent);
                    return full || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, after);
                }
            }
            if (full || !parent.type.isAnonymous)
                return null;
            i = parent.index + dir;
            parent = parent._parent;
            if (!parent)
                return null;
        }
    }
    get firstChild() { return this.nextChild(0, 1, -100000000 /* None */); }
    get lastChild() { return this.nextChild(this.node.children.length - 1, -1, -100000000 /* None */); }
    childAfter(pos) { return this.nextChild(0, 1, pos); }
    childBefore(pos) { return this.nextChild(this.node.children.length - 1, -1, pos); }
    nextSignificantParent() {
        let val = this;
        while (val.type.isAnonymous && val._parent)
            val = val._parent;
        return val;
    }
    get parent() {
        return this._parent ? this._parent.nextSignificantParent() : null;
    }
    get nextSibling() {
        return this._parent ? this._parent.nextChild(this.index + 1, 1, -1) : null;
    }
    get prevSibling() {
        return this._parent ? this._parent.nextChild(this.index - 1, -1, -1) : null;
    }
    get cursor() { return new TreeCursor(this); }
    resolve(pos, side = 0) {
        return this.cursor.moveTo(pos, side).node;
    }
    getChild(type, before = null, after = null) {
        let r = getChildren(this, type, before, after);
        return r.length ? r[0] : null;
    }
    getChildren(type, before = null, after = null) {
        return getChildren(this, type, before, after);
    }
    /// @internal
    toString() { return this.node.toString(); }
}
function getChildren(node, type, before, after) {
    let cur = node.cursor, result = [];
    if (!cur.firstChild())
        return result;
    if (before != null)
        while (!cur.type.is(before))
            if (!cur.nextSibling())
                return result;
    for (;;) {
        if (after != null && cur.type.is(after))
            return result;
        if (cur.type.is(type))
            result.push(cur.node);
        if (!cur.nextSibling())
            return after == null ? result : [];
    }
}
class BufferContext {
    constructor(parent, buffer, index, start) {
        this.parent = parent;
        this.buffer = buffer;
        this.index = index;
        this.start = start;
    }
}
class BufferNode {
    constructor(context, _parent, index) {
        this.context = context;
        this._parent = _parent;
        this.index = index;
        this.type = context.buffer.set.types[context.buffer.buffer[index]];
    }
    get name() { return this.type.name; }
    get from() { return this.context.start + this.context.buffer.buffer[this.index + 1]; }
    get to() { return this.context.start + this.context.buffer.buffer[this.index + 2]; }
    child(dir, after) {
        let { buffer } = this.context;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, after == -100000000 /* None */ ? -100000000 /* None */ : after - this.context.start);
        return index < 0 ? null : new BufferNode(this.context, this, index);
    }
    get firstChild() { return this.child(1, -100000000 /* None */); }
    get lastChild() { return this.child(-1, -100000000 /* None */); }
    childAfter(pos) { return this.child(1, pos); }
    childBefore(pos) { return this.child(-1, pos); }
    get parent() {
        return this._parent || this.context.parent.nextSignificantParent();
    }
    externalSibling(dir) {
        return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, -1);
    }
    get nextSibling() {
        let { buffer } = this.context;
        let after = buffer.buffer[this.index + 3];
        if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
            return new BufferNode(this.context, this._parent, after);
        return this.externalSibling(1);
    }
    get prevSibling() {
        let { buffer } = this.context;
        let parentStart = this._parent ? this._parent.index + 4 : 0;
        if (this.index == parentStart)
            return this.externalSibling(-1);
        return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, -100000000 /* None */));
    }
    get cursor() { return new TreeCursor(this); }
    resolve(pos, side = 0) {
        return this.cursor.moveTo(pos, side).node;
    }
    /// @internal
    toString() { return this.context.buffer.childString(this.index); }
    getChild(type, before = null, after = null) {
        let r = getChildren(this, type, before, after);
        return r.length ? r[0] : null;
    }
    getChildren(type, before = null, after = null) {
        return getChildren(this, type, before, after);
    }
}
/// A tree cursor object focuses on a given node in a syntax tree, and
/// allows you to move to adjacent nodes.
class TreeCursor {
    /// @internal
    constructor(node, full = false) {
        this.full = full;
        this.buffer = null;
        this.stack = [];
        this.index = 0;
        this.bufferNode = null;
        if (node instanceof TreeNode) {
            this.yieldNode(node);
        }
        else {
            this._tree = node.context.parent;
            this.buffer = node.context;
            for (let n = node._parent; n; n = n._parent)
                this.stack.unshift(n.index);
            this.bufferNode = node;
            this.yieldBuf(node.index);
        }
    }
    /// Shorthand for `.type.name`.
    get name() { return this.type.name; }
    yieldNode(node) {
        if (!node)
            return false;
        this._tree = node;
        this.type = node.type;
        this.from = node.from;
        this.to = node.to;
        return true;
    }
    yieldBuf(index, type) {
        this.index = index;
        let { start, buffer } = this.buffer;
        this.type = type || buffer.set.types[buffer.buffer[index]];
        this.from = start + buffer.buffer[index + 1];
        this.to = start + buffer.buffer[index + 2];
        return true;
    }
    yield(node) {
        if (!node)
            return false;
        if (node instanceof TreeNode) {
            this.buffer = null;
            return this.yieldNode(node);
        }
        this.buffer = node.context;
        return this.yieldBuf(node.index, node.type);
    }
    /// @internal
    toString() {
        return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
    }
    /// @internal
    enter(dir, after) {
        if (!this.buffer)
            return this.yield(this._tree.nextChild(dir < 0 ? this._tree.node.children.length - 1 : 0, dir, after, this.full));
        let { buffer } = this.buffer;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, after == -100000000 /* None */ ? -100000000 /* None */ : after - this.buffer.start);
        if (index < 0)
            return false;
        this.stack.push(this.index);
        return this.yieldBuf(index);
    }
    /// Move the cursor to this node's first child. When this returns
    /// false, the node has no child, and the cursor has not been moved.
    firstChild() { return this.enter(1, -100000000 /* None */); }
    /// Move the cursor to this node's last child.
    lastChild() { return this.enter(-1, -100000000 /* None */); }
    /// Move the cursor to the first child that starts at or after `pos`.
    childAfter(pos) { return this.enter(1, pos); }
    /// Move to the last child that ends at or before `pos`.
    childBefore(pos) { return this.enter(-1, pos); }
    /// Move the node's parent node, if this isn't the top node.
    parent() {
        if (!this.buffer)
            return this.yieldNode(this.full ? this._tree._parent : this._tree.parent);
        if (this.stack.length)
            return this.yieldBuf(this.stack.pop());
        let parent = this.full ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
        this.buffer = null;
        return this.yieldNode(parent);
    }
    /// @internal
    sibling(dir) {
        if (!this.buffer)
            return !this._tree._parent ? false
                : this.yield(this._tree._parent.nextChild(this._tree.index + dir, dir, -100000000 /* None */, this.full));
        let { buffer } = this.buffer, d = this.stack.length - 1;
        if (dir < 0) {
            let parentStart = d < 0 ? 0 : this.stack[d] + 4;
            if (this.index != parentStart)
                return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, -100000000 /* None */));
        }
        else {
            let after = buffer.buffer[this.index + 3];
            if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))
                return this.yieldBuf(after);
        }
        return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, -100000000 /* None */, this.full)) : false;
    }
    /// Move to this node's next sibling, if any.
    nextSibling() { return this.sibling(1); }
    /// Move to this node's previous sibling, if any.
    prevSibling() { return this.sibling(-1); }
    atLastNode(dir) {
        let index, parent, { buffer } = this;
        if (buffer) {
            if (dir > 0) {
                if (this.index < buffer.buffer.buffer.length)
                    return false;
            }
            else {
                for (let i = 0; i < this.index; i++)
                    if (buffer.buffer.buffer[i + 3] < this.index)
                        return false;
            }
            ({ index, parent } = buffer);
        }
        else {
            ({ index, _parent: parent } = this._tree);
        }
        for (; parent; { index, _parent: parent } = parent) {
            for (let i = index + dir, e = dir < 0 ? -1 : parent.node.children.length; i != e; i += dir) {
                let child = parent.node.children[i];
                if (this.full || !child.type.isAnonymous || child instanceof TreeBuffer || hasChild(child))
                    return false;
            }
        }
        return true;
    }
    move(dir) {
        if (this.enter(dir, -100000000 /* None */))
            return true;
        for (;;) {
            if (this.sibling(dir))
                return true;
            if (this.atLastNode(dir) || !this.parent())
                return false;
        }
    }
    /// Move to the next node in a
    /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR))
    /// traversal, going from a node to its first child or, if the
    /// current node is empty, its next sibling or the next sibling of
    /// the first parent node that has one.
    next() { return this.move(1); }
    /// Move to the next node in a last-to-first pre-order traveral. A
    /// node is followed by ist last child or, if it has none, its
    /// previous sibling or the previous sibling of the first parent
    /// node that has one.
    prev() { return this.move(-1); }
    /// Move the cursor to the innermost node that covers `pos`. If
    /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,
    /// it will enter nodes that start at `pos`.
    moveTo(pos, side = 0) {
        // Move up to a node that actually holds the position, if possible
        while (this.from == this.to ||
            (side < 1 ? this.from >= pos : this.from > pos) ||
            (side > -1 ? this.to <= pos : this.to < pos))
            if (!this.parent())
                break;
        // Then scan down into child nodes as far as possible
        for (;;) {
            if (side < 0 ? !this.childBefore(pos) : !this.childAfter(pos))
                break;
            if (this.from == this.to ||
                (side < 1 ? this.from >= pos : this.from > pos) ||
                (side > -1 ? this.to <= pos : this.to < pos)) {
                this.parent();
                break;
            }
        }
        return this;
    }
    /// Get a [syntax node](#tree.SyntaxNode) at the cursor's current
    /// position.
    get node() {
        if (!this.buffer)
            return this._tree;
        let cache = this.bufferNode, result = null, depth = 0;
        if (cache && cache.context == this.buffer) {
            scan: for (let index = this.index, d = this.stack.length; d >= 0;) {
                for (let c = cache; c; c = c._parent)
                    if (c.index == index) {
                        if (index == this.index)
                            return c;
                        result = c;
                        depth = d + 1;
                        break scan;
                    }
                index = this.stack[--d];
            }
        }
        for (let i = depth; i < this.stack.length; i++)
            result = new BufferNode(this.buffer, result, this.stack[i]);
        return this.bufferNode = new BufferNode(this.buffer, result, this.index);
    }
    /// Get the [tree](#tree.Tree) that represents the current node, if
    /// any. Will return null when the node is in a [tree
    /// buffer](#tree.TreeBuffer).
    get tree() {
        return this.buffer ? null : this._tree.node;
    }
}
function hasChild(tree) {
    return tree.children.some(ch => !ch.type.isAnonymous || ch instanceof TreeBuffer || hasChild(ch));
}
class FlatBufferCursor {
    constructor(buffer, index) {
        this.buffer = buffer;
        this.index = index;
    }
    get id() { return this.buffer[this.index - 4]; }
    get start() { return this.buffer[this.index - 3]; }
    get end() { return this.buffer[this.index - 2]; }
    get size() { return this.buffer[this.index - 1]; }
    get pos() { return this.index; }
    next() { this.index -= 4; }
    fork() { return new FlatBufferCursor(this.buffer, this.index); }
}
const BalanceBranchFactor = 8;
function buildTree(data) {
    var _a;
    let { buffer, nodeSet, topID = 0, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;
    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
    let types = nodeSet.types;
    let contextHash = 0;
    function takeNode(parentStart, minPos, children, positions, inRepeat) {
        let { id, start, end, size } = cursor;
        let startPos = start - parentStart;
        if (size < 0) {
            if (size == -1) { // Reused node
                children.push(reused[id]);
                positions.push(startPos);
            }
            else { // Context change
                contextHash = id;
            }
            cursor.next();
            return;
        }
        let type = types[id], node, buffer;
        if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {
            // Small enough for a buffer, and no reused nodes inside
            let data = new Uint16Array(buffer.size - buffer.skip);
            let endPos = cursor.pos - buffer.size, index = data.length;
            while (cursor.pos > endPos)
                index = copyToBuffer(buffer.start, data, index, inRepeat);
            node = new TreeBuffer(data, end - buffer.start, nodeSet, inRepeat < 0 ? NodeType.none : types[inRepeat]);
            startPos = buffer.start - parentStart;
        }
        else { // Make it a node
            let endPos = cursor.pos - size;
            cursor.next();
            let localChildren = [], localPositions = [];
            let localInRepeat = id >= minRepeatType ? id : -1;
            while (cursor.pos > endPos) {
                if (cursor.id == localInRepeat)
                    cursor.next();
                else
                    takeNode(start, endPos, localChildren, localPositions, localInRepeat);
            }
            localChildren.reverse();
            localPositions.reverse();
            if (localInRepeat > -1 && localChildren.length > BalanceBranchFactor)
                node = balanceRange(type, type, localChildren, localPositions, 0, localChildren.length, 0, maxBufferLength, end - start, contextHash);
            else
                node = withHash(new Tree(type, localChildren, localPositions, end - start), contextHash);
        }
        children.push(node);
        positions.push(startPos);
    }
    function findBufferSize(maxSize, inRepeat) {
        // Scan through the buffer to find previous siblings that fit
        // together in a TreeBuffer, and don't contain any reused nodes
        // (which can't be stored in a buffer).
        // If `inRepeat` is > -1, ignore node boundaries of that type for
        // nesting, but make sure the end falls either at the start
        // (`maxSize`) or before such a node.
        let fork = cursor.fork();
        let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;
        let result = { size: 0, start: 0, skip: 0 };
        scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {
            // Pretend nested repeat nodes of the same type don't exist
            if (fork.id == inRepeat) {
                // Except that we store the current state as a valid return
                // value.
                result.size = size;
                result.start = start;
                result.skip = skip;
                skip += 4;
                size += 4;
                fork.next();
                continue;
            }
            let nodeSize = fork.size, startPos = fork.pos - nodeSize;
            if (nodeSize < 0 || startPos < minPos || fork.start < minStart)
                break;
            let localSkipped = fork.id >= minRepeatType ? 4 : 0;
            let nodeStart = fork.start;
            fork.next();
            while (fork.pos > startPos) {
                if (fork.size < 0)
                    break scan;
                if (fork.id >= minRepeatType)
                    localSkipped += 4;
                fork.next();
            }
            start = nodeStart;
            size += nodeSize;
            skip += localSkipped;
        }
        if (inRepeat < 0 || size == maxSize) {
            result.size = size;
            result.start = start;
            result.skip = skip;
        }
        return result.size > 4 ? result : undefined;
    }
    function copyToBuffer(bufferStart, buffer, index, inRepeat) {
        let { id, start, end, size } = cursor;
        cursor.next();
        if (id == inRepeat)
            return index;
        let startIndex = index;
        if (size > 4) {
            let endPos = cursor.pos - (size - 4);
            while (cursor.pos > endPos)
                index = copyToBuffer(bufferStart, buffer, index, inRepeat);
        }
        if (id < minRepeatType) { // Don't copy repeat nodes into buffers
            buffer[--index] = startIndex;
            buffer[--index] = end - bufferStart;
            buffer[--index] = start - bufferStart;
            buffer[--index] = id;
        }
        return index;
    }
    let children = [], positions = [];
    while (cursor.pos > 0)
        takeNode(data.start || 0, 0, children, positions, -1);
    let length = (_a = data.length) !== null && _a !== void 0 ? _a : (children.length ? positions[0] + children[0].length : 0);
    return new Tree(types[topID], children.reverse(), positions.reverse(), length);
}
function balanceRange(outerType, innerType, children, positions, from, to, start, maxBufferLength, length, contextHash) {
    let localChildren = [], localPositions = [];
    if (length <= maxBufferLength) {
        for (let i = from; i < to; i++) {
            localChildren.push(children[i]);
            localPositions.push(positions[i] - start);
        }
    }
    else {
        let maxChild = Math.max(maxBufferLength, Math.ceil(length * 1.5 / BalanceBranchFactor));
        for (let i = from; i < to;) {
            let groupFrom = i, groupStart = positions[i];
            i++;
            for (; i < to; i++) {
                let nextEnd = positions[i] + children[i].length;
                if (nextEnd - groupStart > maxChild)
                    break;
            }
            if (i == groupFrom + 1) {
                let only = children[groupFrom];
                if (only instanceof Tree && only.type == innerType && only.length > maxChild << 1) { // Too big, collapse
                    for (let j = 0; j < only.children.length; j++) {
                        localChildren.push(only.children[j]);
                        localPositions.push(only.positions[j] + groupStart - start);
                    }
                    continue;
                }
                localChildren.push(only);
            }
            else if (i == groupFrom + 1) {
                localChildren.push(children[groupFrom]);
            }
            else {
                let inner = balanceRange(innerType, innerType, children, positions, groupFrom, i, groupStart, maxBufferLength, positions[i - 1] + children[i - 1].length - groupStart, contextHash);
                if (innerType != NodeType.none && !containsType(inner.children, innerType))
                    inner = withHash(new Tree(NodeType.none, inner.children, inner.positions, inner.length), contextHash);
                localChildren.push(inner);
            }
            localPositions.push(groupStart - start);
        }
    }
    return withHash(new Tree(outerType, localChildren, localPositions, length), contextHash);
}
function containsType(nodes, type) {
    for (let elt of nodes)
        if (elt.type == type)
            return true;
    return false;
}
/// Tree fragments are used during [incremental
/// parsing](#lezer.ParseOptions.fragments) to track parts of old
/// trees that can be reused in a new parse. An array of fragments is
/// used to track regions of an old tree whose nodes might be reused
/// in new parses. Use the static
/// [`applyChanges`](#tree.TreeFragment^applyChanges) method to update
/// fragments for document changes.
class TreeFragment {
    constructor(
    /// The start of the unchanged range pointed to by this fragment.
    /// This refers to an offset in the _updated_ document (as opposed
    /// to the original tree).
    from, 
    /// The end of the unchanged range.
    to, 
    /// The tree that this fragment is based on.
    tree, 
    /// The offset between the fragment's tree and the document that
    /// this fragment can be used against. Add this when going from
    /// document to tree positions, subtract it to go from tree to
    /// document positions.
    offset, open) {
        this.from = from;
        this.to = to;
        this.tree = tree;
        this.offset = offset;
        this.open = open;
    }
    get openStart() { return (this.open & 1 /* Start */) > 0; }
    get openEnd() { return (this.open & 2 /* End */) > 0; }
    /// Apply a set of edits to an array of fragments, removing or
    /// splitting fragments as necessary to remove edited ranges, and
    /// adjusting offsets for fragments that moved.
    static applyChanges(fragments, changes, minGap = 128) {
        if (!changes.length)
            return fragments;
        let result = [];
        let fI = 1, nextF = fragments.length ? fragments[0] : null;
        let cI = 0, pos = 0, off = 0;
        for (;;) {
            let nextC = cI < changes.length ? changes[cI++] : null;
            let nextPos = nextC ? nextC.fromA : 1e9;
            if (nextPos - pos >= minGap)
                while (nextF && nextF.from < nextPos) {
                    let cut = nextF;
                    if (pos >= cut.from || nextPos <= cut.to || off) {
                        let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;
                        cut = fFrom >= fTo ? null :
                            new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, (cI > 0 ? 1 /* Start */ : 0) | (nextC ? 2 /* End */ : 0));
                    }
                    if (cut)
                        result.push(cut);
                    if (nextF.to > nextPos)
                        break;
                    nextF = fI < fragments.length ? fragments[fI++] : null;
                }
            if (!nextC)
                break;
            pos = nextC.toA;
            off = nextC.toA - nextC.toB;
        }
        return result;
    }
    /// Create a set of fragments from a freshly parsed tree, or update
    /// an existing set of fragments by replacing the ones that overlap
    /// with a tree with content from the new tree. When `partial` is
    /// true, the parse is treated as incomplete, and the token at its
    /// end is not included in [`safeTo`](#tree.TreeFragment.safeTo).
    static addTree(tree, fragments = [], partial = false) {
        let result = [new TreeFragment(0, tree.length, tree, 0, partial ? 2 /* End */ : 0)];
        for (let f of fragments)
            if (f.to > tree.length)
                result.push(f);
        return result;
    }
}
// Creates an `Input` that is backed by a single, flat string.
function stringInput(input) { return new StringInput(input); }
class StringInput {
    constructor(string, length = string.length) {
        this.string = string;
        this.length = length;
    }
    get(pos) {
        return pos < 0 || pos >= this.length ? -1 : this.string.charCodeAt(pos);
    }
    lineAfter(pos) {
        if (pos < 0)
            return "";
        let end = this.string.indexOf("\n", pos);
        return this.string.slice(pos, end < 0 ? this.length : Math.min(end, this.length));
    }
    read(from, to) { return this.string.slice(from, Math.min(this.length, to)); }
    clip(at) { return new StringInput(this.string, at); }
}

exports.DefaultBufferLength = DefaultBufferLength;
exports.NodeProp = NodeProp;
exports.NodeSet = NodeSet;
exports.NodeType = NodeType;
exports.Tree = Tree;
exports.TreeBuffer = TreeBuffer;
exports.TreeCursor = TreeCursor;
exports.TreeFragment = TreeFragment;
exports.stringInput = stringInput;


},{}],24:[function(require,module,exports){
var C = "\u037c"
var COUNT = typeof Symbol == "undefined" ? "__" + C : Symbol.for(C)
var SET = typeof Symbol == "undefined" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet")
var top = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : {}

// :: - Style modules encapsulate a set of CSS rules defined from
// JavaScript. Their definitions are only available in a given DOM
// root after it has been _mounted_ there with `StyleModule.mount`.
//
// Style modules should be created once and stored somewhere, as
// opposed to re-creating them every time you need them. The amount of
// CSS rules generated for a given DOM root is bounded by the amount
// of style modules that were used. So to avoid leaking rules, don't
// create these dynamically, but treat them as one-time allocations.
var StyleModule = exports.StyleModule = function StyleModule(spec, options) {
  this.rules = []
  var ref = options || {};
  var finish = ref.finish;

  function splitSelector(selector) {
    return /^@/.test(selector) ? [selector] : selector.split(/,\s*/)
  }

  function render(selectors, spec, target, isKeyframes) {
    var local = [], isAt = /^@(\w+)\b/.exec(selectors[0]), keyframes = isAt && isAt[1] == "keyframes"
    if (isAt && spec == null) { return target.push(selectors[0] + ";") }
    for (var prop in spec) {
      var value = spec[prop]
      if (/&/.test(prop)) {
        render(prop.split(/,\s*/).map(function (part) { return selectors.map(function (sel) { return part.replace(/&/, sel); }); }).reduce(function (a, b) { return a.concat(b); }),
               value, target)
      } else if (value && typeof value == "object") {
        if (!isAt) { throw new RangeError("The value of a property (" + prop + ") should be a primitive value.") }
        render(splitSelector(prop), value, local, keyframes)
      } else if (value != null) {
        local.push(prop.replace(/_.*/, "").replace(/[A-Z]/g, function (l) { return "-" + l.toLowerCase(); }) + ": " + value + ";")
      }
    }
    if (local.length || keyframes) {
      target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(", ") +
                  " {" + local.join(" ") + "}")
    }
  }

  for (var prop in spec) { render(splitSelector(prop), spec[prop], this.rules) }
};

// :: () ‚Üí string
// Returns a string containing the module's CSS rules.
StyleModule.prototype.getRules = function getRules () { return this.rules.join("\n") };

// :: () ‚Üí string
// Generate a new unique CSS class name.
StyleModule.newName = function newName () {
  var id = top[COUNT] || 1
  top[COUNT] = id + 1
  return C + id.toString(36)
};

// :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>)
//
// Mount the given set of modules in the given DOM root, which ensures
// that the CSS rules defined by the module are available in that
// context.
//
// Rules are only added to the document once per root.
//
// Rule order will follow the order of the modules, so that rules from
// modules later in the array take precedence of those from earlier
// modules. If you call this function multiple times for the same root
// in a way that changes the order of already mounted modules, the old
// order will be changed.
StyleModule.mount = function mount (root, modules) {
  (root[SET] || new StyleSet(root)).mount(Array.isArray(modules) ? modules : [modules])
};

var adoptedSet = null

var StyleSet = function StyleSet(root) {
  if (!root.head && root.adoptedStyleSheets && typeof CSSStyleSheet != "undefined") {
    if (adoptedSet) {
      root.adoptedStyleSheets = [adoptedSet.sheet].concat(root.adoptedStyleSheets)
      return root[SET] = adoptedSet
    }
    this.sheet = new CSSStyleSheet
    root.adoptedStyleSheets = [this.sheet].concat(root.adoptedStyleSheets)
    adoptedSet = this
  } else {
    this.styleTag = (root.ownerDocument || root).createElement("style")
    var target = root.head || root
    target.insertBefore(this.styleTag, target.firstChild)
  }
  this.modules = []
  root[SET] = this
};

StyleSet.prototype.mount = function mount (modules) {
  var sheet = this.sheet
  var pos = 0 /* Current rule offset */, j = 0 /* Index into this.modules */
  for (var i = 0; i < modules.length; i++) {
    var mod = modules[i], index = this.modules.indexOf(mod)
    if (index < j && index > -1) { // Ordering conflict
      this.modules.splice(index, 1)
      j--
      index = -1
    }
    if (index == -1) {
      this.modules.splice(j++, 0, mod)
      if (sheet) { for (var k = 0; k < mod.rules.length; k++)
        { sheet.insertRule(mod.rules[k], pos++) } }
    } else {
      while (j < index) { pos += this.modules[j++].rules.length }
      pos += mod.rules.length
      j++
    }
  }

  if (!sheet) {
    var text = ""
    for (var i$1 = 0; i$1 < this.modules.length; i$1++)
      { text += this.modules[i$1].getRules() + "\n" }
    this.styleTag.textContent = text
  }
};

// Style::Object<union<Style,string>>
//
// A style is an object that, in the simple case, maps CSS property
// names to strings holding their values, as in `{color: "red",
// fontWeight: "bold"}`. The property names can be given in
// camel-case‚Äîthe library will insert a dash before capital letters
// when converting them to CSS.
//
// If you include an underscore in a property name, it and everything
// after it will be removed from the output, which can be useful when
// providing a property multiple times, for browser compatibility
// reasons.
//
// A property in a style object can also be a sub-selector, which
// extends the current context to add a pseudo-selector or a child
// selector. Such a property should contain a `&` character, which
// will be replaced by the current selector. For example `{"&:before":
// {content: '"hi"'}}`. Sub-selectors and regular properties can
// freely be mixed in a given object. Any property containing a `&` is
// assumed to be a sub-selector.
//
// Finally, a property can specify an @-block to be wrapped around the
// styles defined inside the object that's the property's value. For
// example to create a media query you can do `{"@media screen and
// (min-width: 400px)": {...}}`.


},{}],25:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'",
  229: "q"
};

var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: "\"",
  229: "Q"
};

var chrome = typeof navigator != "undefined" && /Chrome\/(\d+)/.exec(navigator.userAgent);
var safari = typeof navigator != "undefined" && /Apple Computer/.test(navigator.vendor);
var gecko = typeof navigator != "undefined" && /Gecko\/\d+/.test(navigator.userAgent);
var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
var brokenModifierNames = chrome && (mac || +chrome[1] < 57) || gecko && mac;

// Fill in the digit keys
for (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i);

// The function keys
for (var i = 1; i <= 24; i++) base[i + 111] = "F" + i;

// And the alphabetic keys
for (var i = 65; i <= 90; i++) {
  base[i] = String.fromCharCode(i + 32);
  shift[i] = String.fromCharCode(i);
}

// For each code that doesn't have a shift-equivalent, copy the base name
for (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code];

function keyName(event) {
  // Don't trust event.key in Chrome when there are modifiers until
  // they fix https://bugs.chromium.org/p/chromium/issues/detail?id=633838
  var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) ||
    (safari || ie) && event.shiftKey && event.key && event.key.length == 1;
  var name = (!ignoreKey && event.key) ||
    (event.shiftKey ? shift : base)[event.keyCode] ||
    event.key || "Unidentified";
  // Edge sometimes produces wrong names (Issue #3)
  if (name == "Esc") name = "Escape";
  if (name == "Del") name = "Delete";
  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/
  if (name == "Left") name = "ArrowLeft";
  if (name == "Up") name = "ArrowUp";
  if (name == "Right") name = "ArrowRight";
  if (name == "Down") name = "ArrowDown";
  return name
}

exports.base = base;
exports.keyName = keyName;
exports.shift = shift;

},{}],26:[function(require,module,exports){
"use strict";

require("alpinejs");

var _Notify = _interopRequireDefault(require("./components/Notify"));

var _Statement = _interopRequireDefault(require("./components/Statement"));

var _Modal = _interopRequireDefault(require("./components/Modal"));

var _basicSetup = require("@codemirror/basic-setup");

var _state = require("@codemirror/state");

var _tooltip = require("@codemirror/tooltip");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

window.notify = _Notify["default"];

window.App = function () {
  return new function () {
    this.start = function (fileSelector, filterSelector, codeInput, modalTemplateRemove, modalTemplateAdd) {
      var data = {
        codeEditor: undefined,
        statement: new _Statement["default"]({
          notification: _Notify["default"]
        }),
        statementObject: undefined,
        tableColumns: [],
        filterText: false,
        // bool, on selectColumn this is true, then the CM change plugin below sets the cm text to the values
        filteredView: false,
        // name of column to filter by
        resetFilter: false,
        editorDirty: false,
        // when user switches the column tables a lot and changes values - make content of editor dirty->need to set column values, editor is dirty when this value is !== false, it gets the changed column
        modalRemove: new _Modal["default"]({
          template: document.querySelector(modalTemplateRemove)
        }),
        modalAdd: new _Modal["default"]({
          template: document.querySelector(modalTemplateAdd),
          // this is the config object in the context of these callbacks 
          onShow: function onShow() {
            this.domModal.querySelector('.js-input').value = '';
            this.domModal.querySelector('.js-input').focus();
          },
          onConfirm: function onConfirm() {
            return this.domModal.querySelector('.js-input').value !== '';
          },
          onResolve: function onResolve(accepted) {
            return [accepted, this.domModal.querySelector('.js-input').value];
          }
        })
      };
      var cm = {
        setText: function setText(text) {
          data.codeEditor.dispatch({
            changes: {
              from: 0,
              to: data.codeEditor.state.doc.length,
              insert: text
            }
          });
        },
        getCurrentLine: function getCurrentLine() {
          return data.codeEditor.state.doc.lineAt(data.codeEditor.state.selection.main.head);
        },
        getCaretPosition: function getCaretPosition() {
          return data.codeEditor.state.selection.main.head;
        },
        setCaretPosition: function setCaretPosition(offset) {
          return data.codeEditor.dispatch({
            selection: {
              anchor: offset
            },
            scrollIntoView: true
          });
        },
        setFilterView: function setFilterView(column) {
          if (data.statementObject) {
            data.filteredView = column;
            data.filterText = true; // indicate we're going to filter in listenChangesExtension

            cm.setText(data.statementObject.getValuesByColumn(column).join('\n'));
          }
        },
        resetFilterView: function resetFilterView() {
          if (data.statementObject) {
            data.resetFilter = true; // get current filtered text

            var rows = data.codeEditor.state.doc.toJSON(); // change existing values

            if (data.statementObject.updateValues(data.filteredView, rows)) {
              data.filteredView = false;
              data.filterText = false; // assemble new full string

              var statement = data.statementObject.assemble();

              if (statement !== undefined) {
                // use new insert text for CM
                cm.setText(statement);
              } else {
                cm.setText('error');
              }
            } else {
              data.filteredView = false;
              data.filterText = false;
              cm.setText(data.statementObject.assemble());
              notify.warning('Update values failed', 'Reverting last changes');
            }

            data.editorDirty = false;
          }
        }
      };
      var toChangesUpdate = undefined;

      var listenChangesExtension = _state.StateField.define({
        // we won't use the actual StateField value, null or undefined is fine
        create: function create() {
          return null;
        },
        update: function update(value, transaction) {
          if (transaction.docChanged) {
            clearTimeout(toChangesUpdate);
            toChangesUpdate = setTimeout(function () {
              if (data.resetFilter) {
                data.resetFilter = false;
                return;
              } else if (data.filterText) {
                // filter view, do not re-analyze, user clicks different columns
                data.filterText = false;

                if (data.editorDirty !== false) {
                  if (!data.statementObject.updateValues(data.editorDirty[0], data.editorDirty[1])) {
                    notify.warning('Update values failed', 'Reverting last changes');
                  }

                  data.editorDirty = false;
                }
              } else if (!!data.filteredView) {
                // values are displayed for a given column and user edits values of a column
                // User changed a value, make editorDirty by remembering what column was changed
                // if user clicks on another column to filter by, the above data.filtertext is triggered
                // if user resets the filter by clicking active column, the cm.resetFilterView is invoked dealing with the update of values
                data.editorDirty = [data.filteredView, data.codeEditor.state.doc.toJSON()];
              } else {
                // normal view - text changed, analyze content
                var scrollToTop = !!!data.statementObject; // when previously a valid doc existed - do not scroll to top

                data.statementObject = data.statement.createObject(transaction.newDoc.toJSON().join(''));

                if (data.statementObject) {
                  data.tableColumns = data.statementObject.getColumns(); // outside of alpine this is a hacky way of accessing data

                  document.querySelector('body[x-data]').__x.$data.displayedTableColumns = data.tableColumns.slice(0);
                  document.querySelector('body[x-data]').__x.$data.contextName = data.statementObject.getTable();
                  scrollToTop && data.codeEditor.dispatch({
                    selection: {
                      anchor: 0
                    },
                    scrollIntoView: true
                  });
                } else {
                  document.querySelector('body[x-data]').__x.$data.displayedTableColumns = [];
                  document.querySelector('body[x-data]').__x.$data.contextName = 'QuEdit';
                }
              }
            }, 250);
          }

          return null;
        }
      });

      var toRemoveTooltip = undefined;

      var getCursorTooltips = function getCursorTooltips(state) {
        return state.selection.ranges.filter(function (range) {
          return range.empty;
        }).map(function (range) {
          var line = state.doc.lineAt(range.head);

          if (line.number > 1 && data.statementObject) {
            var posOnLine = range.head - line.from;
            var column = data.statementObject.getColumnAtPosition(posOnLine, line.text);

            if (column !== false) {
              clearTimeout(toRemoveTooltip);
              toRemoveTooltip = setTimeout(function () {
                try {
                  document.querySelector('.cm-cursor-tooltip').remove();
                } catch (e) {//
                }
              }, 500);
              return {
                pos: range.head,
                above: true,
                strictSide: true,
                "class": 'cm-cursor-tooltip',
                create: function create() {
                  var dom = document.createElement('div');
                  dom.textContent = column;
                  return {
                    dom: dom
                  };
                }
              };
            }
          }

          return false;
        });
      };

      var tooltipExtension = _state.StateField.define({
        // we won't use the actual StateField value, null or undefined is fine
        create: getCursorTooltips,
        update: function update(tooltips, tr) {
          if (!tr.docChanged && !tr.selection) {
            return tooltips;
          }

          return getCursorTooltips(tr.state);
        },
        provide: function provide(f) {
          return _tooltip.showTooltip.computeN([f], function (state) {
            return state.field(f);
          });
        }
      }); // Create CodeEditor instance


      data.codeEditor = new _basicSetup.EditorView({
        state: _basicSetup.EditorState.create({
          extensions: [_basicSetup.basicSetup, listenChangesExtension, tooltipExtension],
          lineWrapping: true
        }),
        parent: document.querySelector(codeInput)
      });
      return {
        // options
        clearButton: false,
        // x-text
        contextName: 'QuEdit',
        searchTableColumnsByText: '',
        // Text to filter tableColumns by
        selectedColumn: '',
        // a selected column to display the values for
        displayedTableColumns: [],
        // List of the displayed table columns, manipulated by searchTableColumnsByText
        // DOM elements
        searchFilter: document.querySelector(filterSelector),
        openFileInput: document.querySelector(fileSelector),
        // delay timers
        toFilterColumns: undefined,
        // cache
        cacheSearchFilter: {},
        openFilePicker: function openFilePicker() {
          this.openFileInput.click();
        },
        loadFile: function loadFile() {
          // Picking a file that returns error, then picking again and clicking cancel and the value is empty
          if (this.openFileInput.value.length === 0) {
            return;
          }

          this.loadedFilePath = this.openFileInput.files[0].path;
          var reader = new FileReader();

          reader.onload = function () {
            cm.setText(reader.result);
          };

          if (this.openFileInput.files[0].size > 262144000) {
            notify.danger('File too large', 'You can only open files up too 250 MiB size.');
            return;
          }

          reader.readAsText(this.openFileInput.files[0]);
        },
        clearFilter: function clearFilter() {
          this.searchTableColumnsByText = '';
          this.searchFilter.value = '';
          this.clearButton = false;
          this.displayedTableColumns = data.tableColumns.slice(0);
        },
        filterColumns: function filterColumns() {
          var _this = this;

          // kill previous timer
          clearTimeout(this.toFilterColumns);
          this.toFilterColumns = setTimeout(function () {
            _this.clearButton = true;
            _this.searchTableColumnsByText = _this.searchFilter.value;

            if (_this.searchTableColumnsByText.length === 0) {
              _this.displayedTableColumns = data.tableColumns.slice(0);
              return;
            } else if (typeof _this.cacheSearchFilter[_this.searchTableColumnsByText] !== 'undefined') {
              _this.displayedTableColumns = _this.cacheSearchFilter[_this.searchTableColumnsByText].slice(0);
              return;
            }

            var reFilter = new RegExp(_this.searchTableColumnsByText, 'i');
            _this.displayedTableColumns = data.tableColumns.reduce(function (prevVal, curVal) {
              if (curVal.match(reFilter)) {
                prevVal.push(curVal);
              }

              return prevVal;
            }, []);
            _this.cacheSearchFilter[_this.searchTableColumnsByText] = _this.displayedTableColumns.slice(0);
          }, 200);
        },
        selectColumn: function selectColumn(column) {
          if (column === this.selectedColumn) {
            this.selectedColumn = '';
            cm.resetFilterView();
            return;
          }

          this.selectedColumn = column;
          cm.setFilterView(this.selectedColumn);
        },

        /**
         * Trashicon on a column was selected.
         * Only available if data.statementObject is a valid instance.
         * 
         * @param	string	column		The column to remove.
         */
        removeValuesByColumn: function removeValuesByColumn(column) {
          var _this2 = this;

          if (data.tableColumns.length === 1) {
            notify.warning('Warning', "At least 1 column must be present, or your statement becomes invalid!");
            return;
          }

          data.modalRemove.confirm(column).then(function (accepted) {
            if (accepted) {
              var newColumns;

              if (newColumns = data.statementObject.removeColumn(column)) {
                data.tableColumns = newColumns;
                _this2.displayedTableColumns = data.tableColumns.slice(0);
                _this2.cacheSearchFilter = {}; // reset or deleted column might be displayed

                notify.success('Deleted', "'".concat(column, "' was removed."));
              } else {
                notify.danger('Error', "".concat(column, " could not be removed, reverting."));
              }

              data.resetFilter = true; // trick codeEditor in not doing double the work

              cm.setText(data.statementObject.assemble());
            }
          });
        },
        addColumn: function addColumn() {
          if (this.selectedColumn.length > 0) {
            return;
          }

          data.modalAdd.show().then(function (param) {
            if (param[0] === true) {
              var oldStatement = data.statementObject.assemble();

              if (data.statementObject.addColumn(param[1])) {
                var statement = data.statementObject.assemble();

                if (statement !== undefined) {
                  // use new insert text for CM
                  cm.setText(statement);
                  return;
                }
              }

              cm.setText(oldStatement);
            }
          });
        },
        clearApp: function clearApp() {
          this.clearButton = false;
          this.contextName = 'QuEdit';
          this.searchTableColumnsByText = '';
          this.selectedColumn = '';
          this.displayedTableColumns = [];
          this.toFilterColumns = undefined;
          this.cacheSearchFilter = {};
          data.statementObject = undefined;
          data.tableColumns = [];
          data.filterText = false;
          data.filteredView = false;
          data.resetFilter = false;
          data.editorDirty = false;
          cm.setText('');
        }
      };
    };
  }();
}();

},{"./components/Modal":28,"./components/Notify":29,"./components/Statement":30,"@codemirror/basic-setup":2,"@codemirror/state":17,"@codemirror/tooltip":19,"alpinejs":21}],27:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = Insert;

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function Insert(config) {
  this.insertText = '';
  this.config = _objectSpread(_objectSpread({}, {
    isValid: false,
    parent: undefined
  }), config);
  /**
   * Name of the table where values are inserted.
   */

  this.tableName = '';
  /**
   * The Array of columns of the statement.
   */

  this.columns = [];
  this.mapColumnToIndex = {};
  /**
   * The values to be inserted.
   * The length of this property is equivalent to the amount of rows, because each SQL tupel is one entry:
   * [ ['uid1', 'description1'], ['uid2', 'description2'] ]
   */

  this.values = [];
  /**
   * A link from column to value.
   * Index based, meaning, "columnAtIndexY" inside columns maps to values a, b, ..., z.
   */

  this.mapColumnsToValues = [];
}
/**
 * Resets the state of the instance to the initial one.
 */


Insert.prototype.reset = function () {
  this.insertText = '';
  this.tableName = '';
  this.columns = [];
  this.mapColumnToIndex = {};
  this.values = [];
  this.mapColumnsToValues = [];
  this.config = {
    isValid: false,
    parent: this.config.parent
  };
};
/**
 * Only changed, whenever analyze is invoked.
 * 
 * @returns bool	Indicating, if previous statement was valid.
 */


Insert.prototype.isValid = function () {
  return this.config.isValid;
};
/**
 * Returns the cached insert statement.
 * 
 * @returns	string		The cached insert statement.
 */


Insert.prototype.getInsertStatement = function () {
  return this.insertText;
};
/**
 * Creates the new INSERT INTO statement.
 * Saves the result back into the instance.
 * 
 * @returns	mixed		The new INSERT statement, undefined on error.
 */


Insert.prototype.assemble = function () {
  try {
    var newFullStatement = 'INSERT INTO `' + this.tableName + '` (';
    newFullStatement += '`' + this.columns.join('`, `') + '`) VALUES \n';
    var values = [];
    var rows = this.values.length; // see comment of this.values why this is used for rows

    for (var val = 0; val < rows; ++val) {
      var row = [];

      for (var col = 0; col < this.columns.length; ++col) {
        row.push(this.mapColumnsToValues[col][val]);
      }

      values.push('(' + row.join(', ') + ')');
    }

    newFullStatement += values.join(', \n') + ';';
    this.insertText = newFullStatement;
    return newFullStatement.slice(0);
  } catch (e) {
    this.config.parent.notify('danger', e);
    console.error(e);
    return undefined;
  }
};
/**
 * Dismembers all the parts of the statement.
 * Creates indexes and maps.
 * 
 * @param	insertText	The text to anayte and take apart.
 * @returns bool		If true, valid statement, otherwise resets previous data.
 */


Insert.prototype.analyze = function (insertText) {
  var _this = this;

  this.insertText = insertText;
  var text = insertText;
  var reInsert = /INSERT[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]INTO[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]`([\s\S]+?)`[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]+\(([\s\S]+?)\)[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]+VALUES[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]?([\s\S]*)/gim;
  var matched = reInsert.exec(text);

  if (!matched) {
    this.reset();
    return false;
  }

  var toInfo = undefined;

  try {
    var reCountInsert = /INSERT[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]INTO[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]`([\s\S]+?)`[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]+\(([\s\S]+?)\)[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]+VALUES[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]?/gim;
    var countInserts = text.match(reCountInsert);

    if (countInserts && countInserts.length > 1) {
      for (var i = 0; i < countInserts.length - 1; ++i) {
        if (countInserts[i].trim() != countInserts[i + 1].trim()) {
          throw 'Multiple incompatible INSERT statements found.';
        }
      }
    } else {
      countInserts = []; // this way we can use .length either way
    } // get parts


    var _ref = _toConsumableArray(matched),
        table = _ref[1],
        columns = _ref[2],
        values = _ref[3];

    this.tableName = table; // Columns

    columns = columns.split(',');
    this.mapColumnToIndex = {};

    for (var _i = 0; _i < columns.length; ++_i) {
      columns[_i] = columns[_i].trim().replace(/`/g, '').trim();
      this.mapColumnToIndex[columns[_i]] = _i;
    }

    this.columns = columns; // Values
    // Remove multiple inserts

    if (countInserts.length > 1) {
      values = values.split(countInserts[0]).join(''); // delay the info, in case mismatched value count triggers exception
      // if there's a LOT of text to parse, taking longer than ~XYms it's okay to first display the info

      toInfo = setTimeout(function () {
        _this.config.parent.notify('info', 'Duplicate INSERT\'s detected', 'They will be ignored/removed on change.');
      }, 500);
    } // Remove leading and closing brackets


    values = values.trim();
    var foundTuples = [],
        openTuple = false;
    var curVal = '',
        foundValues = [],
        openValue = false;

    for (var _i2 = 0; _i2 < values.length; ++_i2) {
      if (!openTuple && !openValue && values[_i2] == ';' || !openTuple && (values[_i2] === ',' || values[_i2].match(/[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]/)) || openTuple && openValue === false && (values[_i2] === ',' || values[_i2].match(/[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]/))) {
        continue; // skip comma and whitespace between tuples
      } // opening bracket of new tuple


      if (!openTuple && values[_i2] === '(') {
        openTuple = true;
        continue;
      } // closing bracket of current tuple, while no open value or open value was empty


      if (openTuple && (openValue === false || openValue === '') && values[_i2] === ')') {
        if (openValue === '') {
          // int or null as a value at the end
          foundValues.push(curVal);
          curVal = '';
          openValue = false;
        }

        openTuple = false;
        foundTuples.push(foundValues.slice(0));
        foundValues.length = 0;
        continue;
      } // currently open value and the next char is a closing char the same as it was opened - but not escaped
      // or there was no '"` as beginning then comma is the separator


      if (openTuple && openValue !== false && (values[_i2] === openValue && values[_i2 - 1] !== '\\' || values[_i2] === ',' && openValue === '')) {
        if (openValue !== '') {
          curVal += values[_i2];
        }

        foundValues.push(curVal.trim());
        curVal = '';
        openValue = false;
        continue;
      }

      if (openTuple && openValue === false && (values[_i2] === "'" || values[_i2] === '"' || values[_i2] === '`')) {
        openValue = values[_i2];
        curVal += values[_i2];
        continue;
      }

      if (openValue === false) {
        openValue = '';
      }

      curVal += values[_i2];
    }

    this.mapColumnsToValues = [];

    for (var _i3 = 0; _i3 < foundTuples.length; ++_i3) {
      if (foundTuples[_i3].length !== columns.length) {
        throw "Found ".concat(foundTuples[_i3].length, " values in row ").concat(_i3 + 1, ", ").concat(columns.length, " values expected, abort!");
      }

      for (var j = 0; j < foundTuples[_i3].length; ++j) {
        var colIndex = this.mapColumnToIndex[columns[j]];

        if (typeof this.mapColumnsToValues[colIndex] === 'undefined') {
          this.mapColumnsToValues[colIndex] = [];
        }

        this.mapColumnsToValues[colIndex].push(foundTuples[_i3][j]);
      }
    }

    this.values = foundTuples;
    this.config.isValid = true;
    return true;
  } catch (e) {
    clearTimeout(toInfo);
    this.config.parent.notify('danger', e);
    console.error(e);
    this.reset();
    return false;
  }
};
/**
 * Gets the target table name.
 * 
 * @returns	string	The name of the table the query has as a target.
 */


Insert.prototype.getTable = function () {
  return this.tableName;
};
/**
 * Returns the available columns, sorted ascending.
 * 
 * @returns	Array	A sorted Array of columns, empty if not yet set.
 */


Insert.prototype.getColumns = function () {
  return this.columns.slice(0).sort(function (a, b) {
    return a.toLocaleLowerCase().localeCompare(b.toLocaleLowerCase());
  });
};
/**
 * 
 * @param	string	column	Name of the column to get all the values of.
 * @returns Array			An array of values, can be empty, if invalid column requested.
 */


Insert.prototype.getValuesByColumn = function (column) {
  var colIndex = this.mapColumnToIndex[column];

  if (colIndex === undefined || this.mapColumnsToValues[colIndex] === undefined) {
    return [];
  }

  var values = [];

  for (var i = 0; i < this.mapColumnsToValues[colIndex].length; ++i) {
    values.push(this.mapColumnsToValues[colIndex][i]);
  }

  return values;
};
/**
 * Removes an entire column, including their values.
 * 
 * @param	string	column	Name of the column to remove.
 * @returns mixed			Boolean false on error, Array with the new columns on success.
 */


Insert.prototype.removeColumn = function (column) {
  try {
    var colIndex = this.mapColumnToIndex[column];

    if (colIndex === undefined || this.mapColumnsToValues[colIndex] === undefined) {
      return false;
    }

    var newColumns = this.columns.slice(0);
    newColumns.splice(colIndex, 1);
    var newMapColumnToIndex = Object.assign({}, this.mapColumnToIndex); // Update index for columnName -> index-in-values

    for (var i = 0; i < newColumns.length; ++i) {
      if (newMapColumnToIndex[newColumns[i]] < colIndex) {
        continue;
      }

      newMapColumnToIndex[newColumns[i]] = newMapColumnToIndex[newColumns[i]] - 1;
    }

    var newValues = this.values.slice(0); // remove the column from each row

    for (var row = 0; row < newValues.length; ++row) {
      newValues[row].splice(colIndex, 1);
    }

    delete this.mapColumnToIndex[column];
    this.mapColumnsToValues.splice(colIndex, 1);
    this.values = newValues;
    this.columns = newColumns;
    this.mapColumnToIndex = newMapColumnToIndex;
    return this.columns.slice(0).sort();
  } catch (e) {
    this.config.parent.notify('danger', e);
    console.error(e);
    return false;
  }
};
/**
 * 
 * @param	string	column	The name of the column to update a value of.
 * @param	int		row		The row of the value to update, 0 based!
 * @param	mixed	value	The new value to set.
 * @returns	bool			True on success, false otherwise.
 */


Insert.prototype.updateValue = function (column, row, value) {
  try {
    var colIndex = this.mapColumnToIndex[column];

    if (colIndex === undefined || this.mapColumnsToValues[colIndex] === undefined) {
      return false;
    }

    var newValue = value
    /*.replace(/^(`|'|")|(`|'|")$/g, '')*/
    .trim(); // Update the value

    this.values[row][colIndex] = newValue; // Update the map of columX => [ value1, value2 ]

    this.mapColumnsToValues[colIndex][row] = newValue;
    return true;
  } catch (e) {
    this.config.parent.notify('danger', e);
    console.error(e);
    return false;
  }
};
/**
 * Similar to `updateValue` only for all values of a specific column.
 * 
 * @param	string	column	Name of the column to update values of.
 * @param	Array	values	An array of new values for the column.
 * @returns	bool			True on success, false otherwise.
 */


Insert.prototype.updateValues = function (column, values) {
  try {
    var colIndex = this.mapColumnToIndex[column];

    if (colIndex === undefined || this.mapColumnsToValues[colIndex] === undefined) {
      return false;
    } // Check for correct count of values


    var rows = values.length;

    if (this.values.length !== rows) {
      return false;
    }

    for (var i = 0; i < rows; ++i) {
      var newValue = values[i].trim(); // Update the value

      this.values[i][colIndex] = newValue; // Update the map of columX => [ value1, value2 ]

      this.mapColumnsToValues[colIndex][i] = newValue;
    }

    return true;
  } catch (e) {
    this.config.parent.notify('danger', e);
    console.error(e);
    return false;
  }
};
/**
 * Determines the column name within a values position.
 * 
 * @param	int		position		The position within the string.
 * @param	string	valueString		The string to analyze. 
 * @returns	mixed					Boolean false on error, ie column is invalid, the column name as a string otherwise.
 */


Insert.prototype.getColumnAtPosition = function (position, valueString) {
  try {
    var openTuple = false,
        openValue = false,
        valueIndex = -1;
    var str = valueString.trim().replace(/(;|,)$/, ''); // end of beginning of string - no columns available

    if (position >= str.length || position === 0) {
      return false;
    }

    for (var pos = 0; pos < str.length; ++pos) {
      if (!openTuple && (str[pos] === ',' || str[pos].match(/[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]/)) || openTuple && openValue === false && (str[pos] === ',' || str[pos].match(/[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]/))) {
        continue;
      } // opening bracket of new tuple


      if (!openTuple && str[pos] === '(') {
        openTuple = true;
        continue;
      } // closing bracket of current tuple, while no open value or open value was empty


      if (openTuple && (openValue === false || openValue === '') && str[pos] === ')') {
        if (openValue === '') {
          // int or null as a value at the end
          openValue = false;
        }

        openTuple = false;
        continue;
      } // currently open value and the next char is a closing char the same as it was opened - but not escaped
      // or there was no '"` as beginning then comma is the separator


      if (openTuple && openValue !== false && (str[pos] === openValue && str[pos - 1] !== '\\' || str[pos] === ',' && openValue === '')) {
        openValue = false;

        if (pos >= position) {
          break;
        }

        continue;
      }

      if (openTuple && openValue === false && (str[pos] === "'" || str[pos] === '"' || str[pos] === '`')) {
        ++valueIndex;
        openValue = str[pos];
        continue;
      }

      if (openValue === false) {
        ++valueIndex;
        openValue = '';
      } // Specifically check at end, so "(3" with cursor before 3 will have 3 checked as openValue = '' -> ++valueIndex


      if (pos >= position) {
        if (!openTuple || openValue === false) {
          valueIndex = -1;
        }

        break;
      }
    }

    if (typeof this.columns[valueIndex] !== 'undefined') {
      return this.columns[valueIndex];
    }

    throw "Invalid column";
  } catch (e) {
    return false;
  }
};
/**
 * Adds a new column.
 * 
 * @param	string	columnName	The new column name to add.
 * @param	mixed	value		Optional new value, default is empty string.
 * @returns	bool				A boolean indicating success.
 */


Insert.prototype.addColumn = function (columnName) {
  var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "''";

  try {
    this.columns.push(columnName);
    this.mapColumnToIndex[columnName] = this.columns.length - 1;
    this.mapColumnsToValues.push([]);

    for (var i = 0; i < this.values.length; ++i) {
      this.values[this.mapColumnToIndex[columnName]].push(value);
      this.mapColumnsToValues[this.mapColumnToIndex[columnName]].push(value);
    }

    return true;
  } catch (e) {
    this.config.parent.notify('danger', e);
    console.error(e);
    return false;
  }
};

},{}],28:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = Modal;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function Modal(config) {
  var _this = this;

  if (!(this instanceof Modal)) {
    return new Modal(config);
  }

  this.config = _objectSpread(_objectSpread({}, {
    open: false,
    template: undefined,
    activePromise: undefined,
    domModal: undefined,
    domBackdrop: undefined,
    domContent: undefined,
    btnAbort: undefined,
    btnConfirm: undefined,
    onConfirm: function onConfirm() {
      return true;
    },
    onAbort: function onAbort() {
      return true;
    },
    onShow: function onShow() {
      _this.config.btnConfirm.focus();
    },
    onResolve: function onResolve(resp) {
      return resp;
    }
  }), config);

  try {
    var _div = document.createElement('div');

    var modalHTML = this.config.template.innerHTML.slice(0);
    _div.innerHTML = modalHTML;
    this.config.domModal = _div.firstElementChild;
    this.config.domBackdrop = this.config.domModal.querySelector('.modal-backdrop');
    this.config.domContent = this.config.domModal.querySelector('.modal-content');
    this.config.domBackdrop.classList.add('ease-out', 'duration-300', 'opacity-0', 'pointer-events-none');
    this.config.domContent.classList.add('opacity-0', 'translate-y-4', 'sm:translate-y-0', 'sm:scale-95');
    document.body.appendChild(this.config.domModal);
    document.body.addEventListener('keyup', function (e) {
      if (!_this.config.open) {
        return true;
      }

      if (e.key === 'Enter' || e.key === 'Escape') {
        _this.hide(e.key === 'Enter');
      }
    });
    this.config.btnConfirm = this.config.domModal.querySelector('.js-confirm');
    this.config.btnConfirm.addEventListener('click', function (e) {
      if (!_this.config.open) {
        return;
      }

      if (!_this.config.onConfirm()) {
        return;
      }

      _this.hide(true);
    });
    this.config.btnAbort = this.config.domModal.querySelector('.js-abort');
    this.config.btnAbort.addEventListener('click', function (e) {
      if (!_this.config.onAbort()) {
        return;
      }

      _this.hide(false);
    });
  } catch (e) {
    console.log(e);
  }
}

Modal.prototype.show = function () {
  var _this2 = this;

  return new Promise(function (resolve, reject) {
    if (_this2.config.open) {
      return;
    }

    _this2.config.domModal.classList.remove('hidden');

    setTimeout(function () {
      _this2.config.domBackdrop.classList.remove('ease-in', 'duration-200', 'opacity-0');

      _this2.config.domBackdrop.classList.add('ease-out', 'duration-300', 'opacity-100');

      _this2.config.domContent.classList.remove('ease-in', 'duration-200', 'opacity-0', 'translate-y-4', 'sm:translate-y-0', 'sm:scale-95');

      _this2.config.domContent.classList.add('ease-out', 'duration-300', 'opacity-100', 'translate-y-0', 'sm:scale-100');
    }, 25);
    _this2.config.open = true;
    _this2.config.activePromise = resolve;

    _this2.config.onShow();
  });
};

Modal.prototype.hide = function (accepted) {
  var _this3 = this;

  if (!this.config.open) {
    return;
  }

  this.config.domBackdrop.classList.remove('ease-out', 'duration-300', 'opacity-100');
  this.config.domBackdrop.classList.add('ease-in', 'duration-200', 'opacity-0');
  this.config.domContent.classList.remove('ease-out', 'duration-300', 'opacity-100', 'translate-y-0', 'sm:scale-100');
  this.config.domContent.classList.add('ease-in', 'duration-200', 'opacity-0', 'translate-y-4', 'sm:translate-y-0', 'sm:scale-95');
  setTimeout(function () {
    return _this3.config.domModal.classList.add('hidden');
  }, 200);
  this.config.open = false;
  this.config.activePromise(this.config.onResolve(accepted));
  this.config.activePromise = undefined;
};

Modal.prototype.confirm = function (column) {
  this.config.domContent.querySelectorAll('.js-column').forEach(function (el) {
    return el.innerText = column;
  });
  return this.show();
};

},{}],29:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Helper class to keep track on the last displayed notification.
 * Preventing duplicates being displayed for a certain amount of time.
 * Unless another notification was displayed in the meantime.
 * Implemented with a Singleton pattern since Notify is not instantiated.
 */
var NotificationStatus = function () {
  var instance;

  function createInstance() {
    var NotificationStatus = function NotificationStatus() {
      this.lastNotify = '';
      this.threshold = undefined;
    };

    NotificationStatus.prototype.last = function (msg) {
      this.timer(msg);
      var oldValue = this.lastNotify;
      return this.lastNotify = msg, oldValue === msg;
    }; // Resets timer if necessary, or starts it


    NotificationStatus.prototype.timer = function (msg) {
      var _this = this;

      if (!this.threshold) {
        this.threshold = setTimeout(function () {
          _this.lastNotify = '';
          _this.threshold = undefined;
        }, 3000);
      } else if (msg != this.lastNotify) {
        this.threshold = clearTimeout(this.threshold);
        this.timer();
      }
    };

    return new NotificationStatus();
  }

  return {
    getInstance: function getInstance() {
      if (!instance) {
        instance = createInstance();
      }

      return instance;
    }
  };
}();

function Notify() {
  var title = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'title';
  var text = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'text';
  var cfg = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var status = NotificationStatus.getInstance();

  if (status.last(text)) {
    return;
  }

  var config = _objectSpread(_objectSpread({}, {
    // Title of the notification
    title: title,
    // Message content
    text: text,
    // Type of notifcation, info, warning, danger, success
    type: 'info',
    // the container holding all notification items
    notificationsContainer: document.querySelector('.notifications'),
    // Auto removing notification after this, in ms
    autoRemoveDuration: 3000,
    // fadein/-out animation time
    animationDuration: 800,
    // the template for notifications to use
    templateHTML: document.querySelector('#notification-item').innerHTML,
    // class for opening animation
    openingAnimationClass: 'fadeInDown',
    // class for closing animation
    closingAnimationClass: 'fadeOutRight',
    // close btn hover:color for info and warning
    warningInfoCloseColor: 'text-gray-500',
    // close bnt hover:color for danger and success
    dangerSuccessCloseColor: 'text-gray-200'
  }), cfg);

  var timerClose = undefined;
  var timerFadeIn = undefined;

  var _div = document.createElement('div');

  var tmpl = config.templateHTML.slice(0);
  _div.innerHTML = tmpl;
  _div = _div.firstElementChild;

  _div.classList.add('is-' + config.type, config.openingAnimationClass);

  _div.addEventListener('click', function (e) {
    if (timerClose !== undefined) {
      timerClose = clearTimeout(timerClose);
    }

    if (timerFadeIn !== undefined) {
      timerFadeIn = clearTimeout(timerFadeIn);
    }

    _div.classList.add(config.closingAnimationClass);

    setTimeout(function () {
      _div.remove();
    }, config.animationDuration + 50);
  });

  _div.addEventListener('mouseover', function (e) {
    if (timerClose !== undefined) {
      timerClose = clearTimeout(timerClose);
    }
  });

  _div.addEventListener('mouseleave', function (e) {
    timerClose = setTimeout(function () {
      _div.click();
    }, config.autoRemoveDuration);
  });

  var closeBtn = _toConsumableArray(_div.querySelectorAll('[n-close]'));

  closeBtn.forEach(function (btn) {
    btn.innerHTML = 'x';
    btn.classList.add(config.type === 'warning' || config.type === 'info' ? "group-hover:".concat(config.warningInfoCloseColor) : "group-hover:".concat(config.dangerSuccessCloseColor));
    btn.addEventListener('click', function (e) {
      _div.click();
    });
  });
  ['title', 'text'].forEach(function (key) {
    var el = _div.querySelector("[n-".concat(key, "]"));

    el && (el.innerHTML = config[key]);
  });

  var icon = _div.querySelector("[n-type-".concat(config.type, "]"));

  icon && icon.classList.remove('hidden');
  !!config.notificationsContainer && config.notificationsContainer.prepend(_div);
  timerFadeIn = setTimeout(function () {
    _div.classList.remove(config.openingAnimationClass);
  }, config.animationDuration + 50); // start timer to close automatically after 5s

  _div.dispatchEvent(new Event('mouseleave'));
} // Creating shorthands in a hacky way


var wrappedNotify = function () {
  Notify.danger = function () {
    var title = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'title';
    var text = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'text';
    var cfg = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return Notify(title, text, _objectSpread({
      type: 'danger'
    }, cfg));
  };

  Notify.info = function () {
    var title = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'title';
    var text = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'text';
    var cfg = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return Notify(title, text, _objectSpread({
      type: 'info'
    }, cfg));
  };

  Notify.success = function () {
    var title = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'title';
    var text = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'text';
    var cfg = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return Notify(title, text, _objectSpread({
      type: 'success'
    }, cfg));
  };

  Notify.warning = function () {
    var title = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'title';
    var text = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'text';
    var cfg = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return Notify(title, text, _objectSpread({
      type: 'warning'
    }, cfg));
  };

  return Notify;
}();

var _default = wrappedNotify;
exports["default"] = _default;

},{}],30:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = Statement;

var _Insert = _interopRequireDefault(require("./Insert"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function Statement(config) {
  if (!(this instanceof Statement)) {
    return new Statement(config);
  }

  this.config = _objectSpread(_objectSpread({}, {
    notification: undefined
  }), config);
  this.object = undefined;
}
/**
 * Creates a notification.
 * 
 * @param	string	type				The type of notification, info, warning, success, danger.
 * @param	string	title 				The title of the notification.
 * @param	string	message				Optional body of the notifcation, cannot be an empty string, or it might not be displayed.
 * @param	int		autoRemoveDuration	Time for notification to be displayed.
 */


Statement.prototype.notify = function (type, title) {
  var message = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ' ';
  var autoRemoveDuration = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 5000;

  if (this.config.notification !== undefined) {
    if (_typeof(this.config.notification[type] !== 'undefined')) {
      this.config.notification[type](title, message, {
        autoRemoveDuration: autoRemoveDuration
      });
    } else {
      this.config.notification(title, message, {
        autoRemoveDuration: autoRemoveDuration
      });
    }
  }
};
/**
 * 
 * @param	string	statement	A statement to analyze and convert into an object.
 * @returns	mixed				An Object instance corresponding with the input, undefined if invalid input.
 */


Statement.prototype.createObject = function (statement) {
  switch (statement.substr(0, 11).toLowerCase()) {
    case 'insert into':
      this.object = new _Insert["default"]({
        parent: this
      });

      if (!this.object.analyze(statement)) {
        this.object = undefined;
      }

      break;

    default:
      this.object = undefined;
      break;
  }

  return this.object;
};

},{"./Insert":27}]},{},[26])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvYXV0b2NvbXBsZXRlL2Rpc3QvaW5kZXguY2pzIiwibm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2Jhc2ljLXNldHVwL2Rpc3QvaW5kZXguY2pzIiwibm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2Nsb3NlYnJhY2tldHMvZGlzdC9pbmRleC5janMiLCJub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvY29tbWFuZHMvZGlzdC9pbmRleC5janMiLCJub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvY29tbWVudC9kaXN0L2luZGV4LmNqcyIsIm5vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9mb2xkL2Rpc3QvaW5kZXguY2pzIiwibm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2d1dHRlci9kaXN0L2luZGV4LmNqcyIsIm5vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9oaWdobGlnaHQvZGlzdC9pbmRleC5janMiLCJub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvaGlzdG9yeS9kaXN0L2luZGV4LmNqcyIsIm5vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sYW5ndWFnZS9kaXN0L2luZGV4LmNqcyIsIm5vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9saW50L2Rpc3QvaW5kZXguY2pzIiwibm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL21hdGNoYnJhY2tldHMvZGlzdC9pbmRleC5janMiLCJub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvcGFuZWwvZGlzdC9pbmRleC5janMiLCJub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvcmFuZ2VzZXQvZGlzdC9pbmRleC5janMiLCJub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvcmVjdGFuZ3VsYXItc2VsZWN0aW9uL2Rpc3QvaW5kZXguY2pzIiwibm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL3NlYXJjaC9kaXN0L2luZGV4LmNqcyIsIm5vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9zdGF0ZS9kaXN0L2luZGV4LmNqcyIsIm5vZGVfbW9kdWxlcy9AY29kZW1pcnJvci90ZXh0L2Rpc3QvaW5kZXguY2pzIiwibm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL3Rvb2x0aXAvZGlzdC9pbmRleC5janMiLCJub2RlX21vZHVsZXMvQGNvZGVtaXJyb3Ivdmlldy9kaXN0L2luZGV4LmNqcyIsIm5vZGVfbW9kdWxlcy9hbHBpbmVqcy9kaXN0L2FscGluZS5qcyIsIm5vZGVfbW9kdWxlcy9jcmVsdC9kaXN0L2luZGV4LmNqcyIsIm5vZGVfbW9kdWxlcy9sZXplci10cmVlL2Rpc3QvdHJlZS5janMiLCJub2RlX21vZHVsZXMvc3R5bGUtbW9kL2Rpc3Qvc3R5bGUtbW9kLmNqcyIsIm5vZGVfbW9kdWxlcy93M2Mta2V5bmFtZS9pbmRleC5janMiLCJzcmMvanMvYXBwLmpzIiwic3JjL2pzL2NvbXBvbmVudHMvSW5zZXJ0LmpzIiwic3JjL2pzL2NvbXBvbmVudHMvTW9kYWwuanMiLCJzcmMvanMvY29tcG9uZW50cy9Ob3RpZnkuanMiLCJzcmMvanMvY29tcG9uZW50cy9TdGF0ZW1lbnQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcHlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzk2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzd2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxa0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMWhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcnNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy82QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDenFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbmpCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hnTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzc1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDcElBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOzs7O0FBRUEsTUFBTSxDQUFDLE1BQVAsR0FBZ0Isa0JBQWhCOztBQUNBLE1BQU0sQ0FBQyxHQUFQLEdBQWMsWUFBVztBQUN4QixTQUFPLElBQUksWUFBVztBQUNyQixTQUFLLEtBQUwsR0FBYSxVQUFDLFlBQUQsRUFBZSxjQUFmLEVBQStCLFNBQS9CLEVBQTBDLG1CQUExQyxFQUErRCxnQkFBL0QsRUFBb0Y7QUFDaEcsVUFBSSxJQUFJLEdBQUc7QUFDVixRQUFBLFVBQVUsRUFBRSxTQURGO0FBRVYsUUFBQSxTQUFTLEVBQUUsSUFBSSxxQkFBSixDQUFjO0FBQUUsVUFBQSxZQUFZLEVBQUU7QUFBaEIsU0FBZCxDQUZEO0FBR1YsUUFBQSxlQUFlLEVBQUUsU0FIUDtBQUlWLFFBQUEsWUFBWSxFQUFFLEVBSko7QUFLVixRQUFBLFVBQVUsRUFBRSxLQUxGO0FBS1U7QUFDcEIsUUFBQSxZQUFZLEVBQUUsS0FOSjtBQU1XO0FBQ3JCLFFBQUEsV0FBVyxFQUFFLEtBUEg7QUFRVixRQUFBLFdBQVcsRUFBRSxLQVJIO0FBUVc7QUFDckIsUUFBQSxXQUFXLEVBQUUsSUFBSSxpQkFBSixDQUFVO0FBQUUsVUFBQSxRQUFRLEVBQUUsUUFBUSxDQUFDLGFBQVQsQ0FBdUIsbUJBQXZCO0FBQVosU0FBVixDQVRIO0FBVVYsUUFBQSxRQUFRLEVBQUUsSUFBSSxpQkFBSixDQUFVO0FBQ2xCLFVBQUEsUUFBUSxFQUFFLFFBQVEsQ0FBQyxhQUFULENBQXVCLGdCQUF2QixDQURRO0FBRWxCO0FBQ0EsVUFBQSxNQUFNLEVBQUUsa0JBQVc7QUFDbEIsaUJBQUssUUFBTCxDQUFjLGFBQWQsQ0FBNEIsV0FBNUIsRUFBeUMsS0FBekMsR0FBaUQsRUFBakQ7QUFDQSxpQkFBSyxRQUFMLENBQWMsYUFBZCxDQUE0QixXQUE1QixFQUF5QyxLQUF6QztBQUNBLFdBTmlCO0FBT2xCLFVBQUEsU0FBUyxFQUFFLHFCQUFXO0FBQ3JCLG1CQUFPLEtBQUssUUFBTCxDQUFjLGFBQWQsQ0FBNEIsV0FBNUIsRUFBeUMsS0FBekMsS0FBbUQsRUFBMUQ7QUFDQSxXQVRpQjtBQVVsQixVQUFBLFNBQVMsRUFBRSxtQkFBUyxRQUFULEVBQW1CO0FBQzdCLG1CQUFPLENBQUUsUUFBRixFQUFZLEtBQUssUUFBTCxDQUFjLGFBQWQsQ0FBNEIsV0FBNUIsRUFBeUMsS0FBckQsQ0FBUDtBQUNBO0FBWmlCLFNBQVY7QUFWQSxPQUFYO0FBMEJBLFVBQUksRUFBRSxHQUFHO0FBQ1IsUUFBQSxPQUFPLEVBQUUsaUJBQUEsSUFBSSxFQUFJO0FBQ2hCLFVBQUEsSUFBSSxDQUFDLFVBQUwsQ0FBZ0IsUUFBaEIsQ0FBeUI7QUFDeEIsWUFBQSxPQUFPLEVBQUU7QUFBRSxjQUFBLElBQUksRUFBRSxDQUFSO0FBQVcsY0FBQSxFQUFFLEVBQUUsSUFBSSxDQUFDLFVBQUwsQ0FBZ0IsS0FBaEIsQ0FBc0IsR0FBdEIsQ0FBMEIsTUFBekM7QUFBaUQsY0FBQSxNQUFNLEVBQUU7QUFBekQ7QUFEZSxXQUF6QjtBQUdBLFNBTE87QUFNUixRQUFBLGNBQWMsRUFBRTtBQUFBLGlCQUFNLElBQUksQ0FBQyxVQUFMLENBQWdCLEtBQWhCLENBQXNCLEdBQXRCLENBQTBCLE1BQTFCLENBQWlDLElBQUksQ0FBQyxVQUFMLENBQWdCLEtBQWhCLENBQXNCLFNBQXRCLENBQWdDLElBQWhDLENBQXFDLElBQXRFLENBQU47QUFBQSxTQU5SO0FBT1IsUUFBQSxnQkFBZ0IsRUFBRTtBQUFBLGlCQUFNLElBQUksQ0FBQyxVQUFMLENBQWdCLEtBQWhCLENBQXNCLFNBQXRCLENBQWdDLElBQWhDLENBQXFDLElBQTNDO0FBQUEsU0FQVjtBQVFSLFFBQUEsZ0JBQWdCLEVBQUUsMEJBQUEsTUFBTTtBQUFBLGlCQUFJLElBQUksQ0FBQyxVQUFMLENBQWdCLFFBQWhCLENBQXlCO0FBQUUsWUFBQSxTQUFTLEVBQUU7QUFBRSxjQUFBLE1BQU0sRUFBRTtBQUFWLGFBQWI7QUFBaUMsWUFBQSxjQUFjLEVBQUU7QUFBakQsV0FBekIsQ0FBSjtBQUFBLFNBUmhCO0FBU1IsUUFBQSxhQUFhLEVBQUUsdUJBQUEsTUFBTSxFQUFJO0FBQ3hCLGNBQUksSUFBSSxDQUFDLGVBQVQsRUFBMEI7QUFDekIsWUFBQSxJQUFJLENBQUMsWUFBTCxHQUFvQixNQUFwQjtBQUVBLFlBQUEsSUFBSSxDQUFDLFVBQUwsR0FBa0IsSUFBbEIsQ0FIeUIsQ0FHQTs7QUFDekIsWUFBQSxFQUFFLENBQUMsT0FBSCxDQUFXLElBQUksQ0FBQyxlQUFMLENBQXFCLGlCQUFyQixDQUF1QyxNQUF2QyxFQUErQyxJQUEvQyxDQUFvRCxJQUFwRCxDQUFYO0FBQ0E7QUFDRCxTQWhCTztBQWlCUixRQUFBLGVBQWUsRUFBRSwyQkFBTTtBQUN0QixjQUFJLElBQUksQ0FBQyxlQUFULEVBQTBCO0FBQ3pCLFlBQUEsSUFBSSxDQUFDLFdBQUwsR0FBbUIsSUFBbkIsQ0FEeUIsQ0FHekI7O0FBQ0EsZ0JBQUksSUFBSSxHQUFHLElBQUksQ0FBQyxVQUFMLENBQWdCLEtBQWhCLENBQXNCLEdBQXRCLENBQTBCLE1BQTFCLEVBQVgsQ0FKeUIsQ0FNekI7O0FBQ0EsZ0JBQUksSUFBSSxDQUFDLGVBQUwsQ0FBcUIsWUFBckIsQ0FBa0MsSUFBSSxDQUFDLFlBQXZDLEVBQXFELElBQXJELENBQUosRUFBZ0U7QUFDL0QsY0FBQSxJQUFJLENBQUMsWUFBTCxHQUFvQixLQUFwQjtBQUNBLGNBQUEsSUFBSSxDQUFDLFVBQUwsR0FBa0IsS0FBbEIsQ0FGK0QsQ0FJL0Q7O0FBQ0Esa0JBQUksU0FBUyxHQUFHLElBQUksQ0FBQyxlQUFMLENBQXFCLFFBQXJCLEVBQWhCOztBQUNBLGtCQUFJLFNBQVMsS0FBSyxTQUFsQixFQUE2QjtBQUM1QjtBQUNBLGdCQUFBLEVBQUUsQ0FBQyxPQUFILENBQVcsU0FBWDtBQUNBLGVBSEQsTUFHTztBQUNOLGdCQUFBLEVBQUUsQ0FBQyxPQUFILENBQVcsT0FBWDtBQUNBO0FBQ0QsYUFaRCxNQVlPO0FBQ04sY0FBQSxJQUFJLENBQUMsWUFBTCxHQUFvQixLQUFwQjtBQUNBLGNBQUEsSUFBSSxDQUFDLFVBQUwsR0FBa0IsS0FBbEI7QUFDQSxjQUFBLEVBQUUsQ0FBQyxPQUFILENBQVcsSUFBSSxDQUFDLGVBQUwsQ0FBcUIsUUFBckIsRUFBWDtBQUVBLGNBQUEsTUFBTSxDQUFDLE9BQVAsQ0FBZSxzQkFBZixFQUF1Qyx3QkFBdkM7QUFDQTs7QUFFRCxZQUFBLElBQUksQ0FBQyxXQUFMLEdBQW1CLEtBQW5CO0FBQ0E7QUFDRDtBQS9DTyxPQUFUO0FBa0RBLFVBQUksZUFBZSxHQUFHLFNBQXRCOztBQUNBLFVBQU0sc0JBQXNCLEdBQUcsa0JBQVcsTUFBWCxDQUFrQjtBQUNoRDtBQUNBLFFBQUEsTUFBTSxFQUFFO0FBQUEsaUJBQU0sSUFBTjtBQUFBLFNBRndDO0FBR2hELFFBQUEsTUFBTSxFQUFFLGdCQUFDLEtBQUQsRUFBUSxXQUFSLEVBQXdCO0FBQy9CLGNBQUksV0FBVyxDQUFDLFVBQWhCLEVBQTRCO0FBQzNCLFlBQUEsWUFBWSxDQUFDLGVBQUQsQ0FBWjtBQUNBLFlBQUEsZUFBZSxHQUFHLFVBQVUsQ0FBQyxZQUFNO0FBQ2xDLGtCQUFJLElBQUksQ0FBQyxXQUFULEVBQXNCO0FBQ3JCLGdCQUFBLElBQUksQ0FBQyxXQUFMLEdBQW1CLEtBQW5CO0FBQ0E7QUFDQSxlQUhELE1BR08sSUFBSSxJQUFJLENBQUMsVUFBVCxFQUFxQjtBQUFHO0FBQzlCLGdCQUFBLElBQUksQ0FBQyxVQUFMLEdBQWtCLEtBQWxCOztBQUNBLG9CQUFJLElBQUksQ0FBQyxXQUFMLEtBQXFCLEtBQXpCLEVBQWdDO0FBQy9CLHNCQUFJLENBQUMsSUFBSSxDQUFDLGVBQUwsQ0FBcUIsWUFBckIsQ0FBa0MsSUFBSSxDQUFDLFdBQUwsQ0FBaUIsQ0FBakIsQ0FBbEMsRUFBdUQsSUFBSSxDQUFDLFdBQUwsQ0FBaUIsQ0FBakIsQ0FBdkQsQ0FBTCxFQUFrRjtBQUNqRixvQkFBQSxNQUFNLENBQUMsT0FBUCxDQUFlLHNCQUFmLEVBQXVDLHdCQUF2QztBQUNBOztBQUNELGtCQUFBLElBQUksQ0FBQyxXQUFMLEdBQW1CLEtBQW5CO0FBQ0E7QUFDRCxlQVJNLE1BUUEsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLFlBQVgsRUFBeUI7QUFBRztBQUNsQztBQUNBO0FBQ0E7QUFDQSxnQkFBQSxJQUFJLENBQUMsV0FBTCxHQUFtQixDQUFFLElBQUksQ0FBQyxZQUFQLEVBQXFCLElBQUksQ0FBQyxVQUFMLENBQWdCLEtBQWhCLENBQXNCLEdBQXRCLENBQTBCLE1BQTFCLEVBQXJCLENBQW5CO0FBQ0EsZUFMTSxNQUtBO0FBQUc7QUFDVCxvQkFBSSxXQUFXLEdBQUcsQ0FBRSxDQUFDLENBQUMsSUFBSSxDQUFDLGVBQTNCLENBRE0sQ0FDd0M7O0FBQzlDLGdCQUFBLElBQUksQ0FBQyxlQUFMLEdBQXVCLElBQUksQ0FBQyxTQUFMLENBQWUsWUFBZixDQUE0QixXQUFXLENBQUMsTUFBWixDQUFtQixNQUFuQixHQUE0QixJQUE1QixDQUFpQyxFQUFqQyxDQUE1QixDQUF2Qjs7QUFDQSxvQkFBSSxJQUFJLENBQUMsZUFBVCxFQUEwQjtBQUN6QixrQkFBQSxJQUFJLENBQUMsWUFBTCxHQUFvQixJQUFJLENBQUMsZUFBTCxDQUFxQixVQUFyQixFQUFwQixDQUR5QixDQUd6Qjs7QUFDQSxrQkFBQSxRQUFRLENBQUMsYUFBVCxDQUF1QixjQUF2QixFQUF1QyxHQUF2QyxDQUEyQyxLQUEzQyxDQUFpRCxxQkFBakQsR0FBeUUsSUFBSSxDQUFDLFlBQUwsQ0FBa0IsS0FBbEIsQ0FBd0IsQ0FBeEIsQ0FBekU7QUFDQSxrQkFBQSxRQUFRLENBQUMsYUFBVCxDQUF1QixjQUF2QixFQUF1QyxHQUF2QyxDQUEyQyxLQUEzQyxDQUFpRCxXQUFqRCxHQUErRCxJQUFJLENBQUMsZUFBTCxDQUFxQixRQUFyQixFQUEvRDtBQUVBLGtCQUFBLFdBQVcsSUFBSSxJQUFJLENBQUMsVUFBTCxDQUFnQixRQUFoQixDQUF5QjtBQUFFLG9CQUFBLFNBQVMsRUFBRTtBQUFFLHNCQUFBLE1BQU0sRUFBRTtBQUFWLHFCQUFiO0FBQTRCLG9CQUFBLGNBQWMsRUFBRTtBQUE1QyxtQkFBekIsQ0FBZjtBQUNBLGlCQVJELE1BUU87QUFDTixrQkFBQSxRQUFRLENBQUMsYUFBVCxDQUF1QixjQUF2QixFQUF1QyxHQUF2QyxDQUEyQyxLQUEzQyxDQUFpRCxxQkFBakQsR0FBeUUsRUFBekU7QUFDQSxrQkFBQSxRQUFRLENBQUMsYUFBVCxDQUF1QixjQUF2QixFQUF1QyxHQUF2QyxDQUEyQyxLQUEzQyxDQUFpRCxXQUFqRCxHQUErRCxRQUEvRDtBQUNBO0FBQ0Q7QUFDRCxhQWpDMkIsRUFpQ3pCLEdBakN5QixDQUE1QjtBQWtDQTs7QUFFRCxpQkFBTyxJQUFQO0FBQ0E7QUEzQytDLE9BQWxCLENBQS9COztBQThDQSxVQUFJLGVBQWUsR0FBRyxTQUF0Qjs7QUFDQSxVQUFJLGlCQUFpQixHQUFHLFNBQXBCLGlCQUFvQixDQUFBLEtBQUssRUFBSTtBQUNoQyxlQUFPLEtBQUssQ0FBQyxTQUFOLENBQWdCLE1BQWhCLENBQXVCLE1BQXZCLENBQThCLFVBQUEsS0FBSztBQUFBLGlCQUFJLEtBQUssQ0FBQyxLQUFWO0FBQUEsU0FBbkMsRUFBb0QsR0FBcEQsQ0FBd0QsVUFBQSxLQUFLLEVBQUk7QUFDdkUsY0FBSSxJQUFJLEdBQUcsS0FBSyxDQUFDLEdBQU4sQ0FBVSxNQUFWLENBQWlCLEtBQUssQ0FBQyxJQUF2QixDQUFYOztBQUNBLGNBQUksSUFBSSxDQUFDLE1BQUwsR0FBYyxDQUFkLElBQW1CLElBQUksQ0FBQyxlQUE1QixFQUE2QztBQUM1QyxnQkFBSSxTQUFTLEdBQUcsS0FBSyxDQUFDLElBQU4sR0FBYSxJQUFJLENBQUMsSUFBbEM7QUFDQSxnQkFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLGVBQUwsQ0FBcUIsbUJBQXJCLENBQXlDLFNBQXpDLEVBQW9ELElBQUksQ0FBQyxJQUF6RCxDQUFiOztBQUNBLGdCQUFJLE1BQU0sS0FBSyxLQUFmLEVBQXNCO0FBQ3JCLGNBQUEsWUFBWSxDQUFDLGVBQUQsQ0FBWjtBQUNBLGNBQUEsZUFBZSxHQUFHLFVBQVUsQ0FBQyxZQUFNO0FBQ2xDLG9CQUFJO0FBQ0gsa0JBQUEsUUFBUSxDQUFDLGFBQVQsQ0FBdUIsb0JBQXZCLEVBQTZDLE1BQTdDO0FBQ0EsaUJBRkQsQ0FFRSxPQUFPLENBQVAsRUFBVSxDQUNYO0FBQ0E7QUFDRCxlQU4yQixFQU16QixHQU55QixDQUE1QjtBQVFBLHFCQUFPO0FBQ04sZ0JBQUEsR0FBRyxFQUFFLEtBQUssQ0FBQyxJQURMO0FBRU4sZ0JBQUEsS0FBSyxFQUFFLElBRkQ7QUFHTixnQkFBQSxVQUFVLEVBQUUsSUFITjtBQUlOLHlCQUFPLG1CQUpEO0FBS04sZ0JBQUEsTUFBTSxFQUFFLGtCQUFNO0FBQ2Isc0JBQUksR0FBRyxHQUFHLFFBQVEsQ0FBQyxhQUFULENBQXVCLEtBQXZCLENBQVY7QUFDQSxrQkFBQSxHQUFHLENBQUMsV0FBSixHQUFrQixNQUFsQjtBQUNBLHlCQUFPO0FBQUUsb0JBQUEsR0FBRyxFQUFIO0FBQUYsbUJBQVA7QUFDQTtBQVRLLGVBQVA7QUFXQTtBQUNEOztBQUVELGlCQUFPLEtBQVA7QUFDQSxTQTlCTSxDQUFQO0FBK0JBLE9BaENEOztBQWlDQSxVQUFNLGdCQUFnQixHQUFHLGtCQUFXLE1BQVgsQ0FBa0I7QUFDMUM7QUFDQSxRQUFBLE1BQU0sRUFBRSxpQkFGa0M7QUFHMUMsUUFBQSxNQUgwQyxrQkFHbkMsUUFIbUMsRUFHekIsRUFIeUIsRUFHckI7QUFDcEIsY0FBSSxDQUFDLEVBQUUsQ0FBQyxVQUFKLElBQWtCLENBQUMsRUFBRSxDQUFDLFNBQTFCLEVBQXFDO0FBQ3BDLG1CQUFPLFFBQVA7QUFDQTs7QUFFRCxpQkFBTyxpQkFBaUIsQ0FBQyxFQUFFLENBQUMsS0FBSixDQUF4QjtBQUNBLFNBVHlDO0FBVTFDLFFBQUEsT0FBTyxFQUFFLGlCQUFBLENBQUM7QUFBQSxpQkFBSSxxQkFBWSxRQUFaLENBQXFCLENBQUMsQ0FBRCxDQUFyQixFQUEwQixVQUFBLEtBQUs7QUFBQSxtQkFBSSxLQUFLLENBQUMsS0FBTixDQUFZLENBQVosQ0FBSjtBQUFBLFdBQS9CLENBQUo7QUFBQTtBQVZnQyxPQUFsQixDQUF6QixDQTlKZ0csQ0EyS2hHOzs7QUFDQSxNQUFBLElBQUksQ0FBQyxVQUFMLEdBQWtCLElBQUksc0JBQUosQ0FBZTtBQUNoQyxRQUFBLEtBQUssRUFBRSx3QkFBWSxNQUFaLENBQW1CO0FBQ3pCLFVBQUEsVUFBVSxFQUFFLENBQUUsc0JBQUYsRUFBYyxzQkFBZCxFQUFzQyxnQkFBdEMsQ0FEYTtBQUV6QixVQUFBLFlBQVksRUFBRTtBQUZXLFNBQW5CLENBRHlCO0FBS2hDLFFBQUEsTUFBTSxFQUFFLFFBQVEsQ0FBQyxhQUFULENBQXVCLFNBQXZCO0FBTHdCLE9BQWYsQ0FBbEI7QUFRQSxhQUFPO0FBQ047QUFDQSxRQUFBLFdBQVcsRUFBRSxLQUZQO0FBSU47QUFDQSxRQUFBLFdBQVcsRUFBRSxRQUxQO0FBTU4sUUFBQSx3QkFBd0IsRUFBRSxFQU5wQjtBQU13QjtBQUM5QixRQUFBLGNBQWMsRUFBRSxFQVBWO0FBT2lCO0FBRXZCLFFBQUEscUJBQXFCLEVBQUUsRUFUakI7QUFTdUI7QUFFN0I7QUFDQSxRQUFBLFlBQVksRUFBRSxRQUFRLENBQUMsYUFBVCxDQUF1QixjQUF2QixDQVpSO0FBYU4sUUFBQSxhQUFhLEVBQUUsUUFBUSxDQUFDLGFBQVQsQ0FBdUIsWUFBdkIsQ0FiVDtBQWVOO0FBQ0EsUUFBQSxlQUFlLEVBQUUsU0FoQlg7QUFrQk47QUFDQSxRQUFBLGlCQUFpQixFQUFFLEVBbkJiO0FBcUJOLFFBQUEsY0FyQk0sNEJBcUJXO0FBQ2hCLGVBQUssYUFBTCxDQUFtQixLQUFuQjtBQUNBLFNBdkJLO0FBeUJOLFFBQUEsUUF6Qk0sc0JBeUJLO0FBQ1Y7QUFDQSxjQUFJLEtBQUssYUFBTCxDQUFtQixLQUFuQixDQUF5QixNQUF6QixLQUFvQyxDQUF4QyxFQUEyQztBQUMxQztBQUNBOztBQUVELGVBQUssY0FBTCxHQUFzQixLQUFLLGFBQUwsQ0FBbUIsS0FBbkIsQ0FBeUIsQ0FBekIsRUFBNEIsSUFBbEQ7QUFDQSxjQUFJLE1BQU0sR0FBRyxJQUFJLFVBQUosRUFBYjs7QUFDQSxVQUFBLE1BQU0sQ0FBQyxNQUFQLEdBQWdCLFlBQU07QUFDckIsWUFBQSxFQUFFLENBQUMsT0FBSCxDQUFXLE1BQU0sQ0FBQyxNQUFsQjtBQUNBLFdBRkQ7O0FBSUEsY0FBSSxLQUFLLGFBQUwsQ0FBbUIsS0FBbkIsQ0FBeUIsQ0FBekIsRUFBNEIsSUFBNUIsR0FBbUMsU0FBdkMsRUFBb0Q7QUFDbkQsWUFBQSxNQUFNLENBQUMsTUFBUCxDQUFjLGdCQUFkLEVBQWdDLDhDQUFoQztBQUNBO0FBQ0E7O0FBRUQsVUFBQSxNQUFNLENBQUMsVUFBUCxDQUFrQixLQUFLLGFBQUwsQ0FBbUIsS0FBbkIsQ0FBeUIsQ0FBekIsQ0FBbEI7QUFDQSxTQTNDSztBQTZDTixRQUFBLFdBN0NNLHlCQTZDUTtBQUNiLGVBQUssd0JBQUwsR0FBZ0MsRUFBaEM7QUFDQSxlQUFLLFlBQUwsQ0FBa0IsS0FBbEIsR0FBMEIsRUFBMUI7QUFDQSxlQUFLLFdBQUwsR0FBbUIsS0FBbkI7QUFDQSxlQUFLLHFCQUFMLEdBQTZCLElBQUksQ0FBQyxZQUFMLENBQWtCLEtBQWxCLENBQXdCLENBQXhCLENBQTdCO0FBQ0EsU0FsREs7QUFvRE4sUUFBQSxhQXBETSwyQkFvRFU7QUFBQTs7QUFDZjtBQUNBLFVBQUEsWUFBWSxDQUFDLEtBQUssZUFBTixDQUFaO0FBQ0EsZUFBSyxlQUFMLEdBQXVCLFVBQVUsQ0FBQyxZQUFNO0FBQ3ZDLFlBQUEsS0FBSSxDQUFDLFdBQUwsR0FBbUIsSUFBbkI7QUFDQSxZQUFBLEtBQUksQ0FBQyx3QkFBTCxHQUFnQyxLQUFJLENBQUMsWUFBTCxDQUFrQixLQUFsRDs7QUFFQSxnQkFBSSxLQUFJLENBQUMsd0JBQUwsQ0FBOEIsTUFBOUIsS0FBeUMsQ0FBN0MsRUFBZ0Q7QUFDL0MsY0FBQSxLQUFJLENBQUMscUJBQUwsR0FBNkIsSUFBSSxDQUFDLFlBQUwsQ0FBa0IsS0FBbEIsQ0FBd0IsQ0FBeEIsQ0FBN0I7QUFFQTtBQUNBLGFBSkQsTUFJTyxJQUFJLE9BQU8sS0FBSSxDQUFDLGlCQUFMLENBQXVCLEtBQUksQ0FBQyx3QkFBNUIsQ0FBUCxLQUFrRSxXQUF0RSxFQUFtRjtBQUN6RixjQUFBLEtBQUksQ0FBQyxxQkFBTCxHQUE2QixLQUFJLENBQUMsaUJBQUwsQ0FBdUIsS0FBSSxDQUFDLHdCQUE1QixFQUFzRCxLQUF0RCxDQUE0RCxDQUE1RCxDQUE3QjtBQUVBO0FBQ0E7O0FBRUQsZ0JBQUksUUFBUSxHQUFHLElBQUksTUFBSixDQUFXLEtBQUksQ0FBQyx3QkFBaEIsRUFBMEMsR0FBMUMsQ0FBZjtBQUNBLFlBQUEsS0FBSSxDQUFDLHFCQUFMLEdBQTZCLElBQUksQ0FBQyxZQUFMLENBQWtCLE1BQWxCLENBQXlCLFVBQUMsT0FBRCxFQUFVLE1BQVYsRUFBcUI7QUFDMUUsa0JBQUksTUFBTSxDQUFDLEtBQVAsQ0FBYSxRQUFiLENBQUosRUFBNEI7QUFDM0IsZ0JBQUEsT0FBTyxDQUFDLElBQVIsQ0FBYSxNQUFiO0FBQ0E7O0FBRUQscUJBQU8sT0FBUDtBQUNBLGFBTjRCLEVBTTFCLEVBTjBCLENBQTdCO0FBT0EsWUFBQSxLQUFJLENBQUMsaUJBQUwsQ0FBdUIsS0FBSSxDQUFDLHdCQUE1QixJQUF3RCxLQUFJLENBQUMscUJBQUwsQ0FBMkIsS0FBM0IsQ0FBaUMsQ0FBakMsQ0FBeEQ7QUFDQSxXQXZCZ0MsRUF1QjlCLEdBdkI4QixDQUFqQztBQXdCQSxTQS9FSztBQWlGTixRQUFBLFlBakZNLHdCQWlGTyxNQWpGUCxFQWlGZTtBQUNwQixjQUFJLE1BQU0sS0FBSyxLQUFLLGNBQXBCLEVBQW9DO0FBQ25DLGlCQUFLLGNBQUwsR0FBc0IsRUFBdEI7QUFDQSxZQUFBLEVBQUUsQ0FBQyxlQUFIO0FBQ0E7QUFDQTs7QUFFRCxlQUFLLGNBQUwsR0FBc0IsTUFBdEI7QUFDQSxVQUFBLEVBQUUsQ0FBQyxhQUFILENBQWlCLEtBQUssY0FBdEI7QUFDQSxTQTFGSzs7QUE0Rk47QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0ksUUFBQSxvQkFsR00sZ0NBa0dlLE1BbEdmLEVBa0d1QjtBQUFBOztBQUM1QixjQUFJLElBQUksQ0FBQyxZQUFMLENBQWtCLE1BQWxCLEtBQTZCLENBQWpDLEVBQW9DO0FBQ25DLFlBQUEsTUFBTSxDQUFDLE9BQVAsQ0FBZSxTQUFmO0FBQ0E7QUFDQTs7QUFDRCxVQUFBLElBQUksQ0FBQyxXQUFMLENBQWlCLE9BQWpCLENBQXlCLE1BQXpCLEVBQWlDLElBQWpDLENBQXNDLFVBQUMsUUFBRCxFQUFjO0FBQ25ELGdCQUFJLFFBQUosRUFBYztBQUNiLGtCQUFJLFVBQUo7O0FBRUEsa0JBQUksVUFBVSxHQUFHLElBQUksQ0FBQyxlQUFMLENBQXFCLFlBQXJCLENBQWtDLE1BQWxDLENBQWpCLEVBQTREO0FBQzNELGdCQUFBLElBQUksQ0FBQyxZQUFMLEdBQW9CLFVBQXBCO0FBQ0EsZ0JBQUEsTUFBSSxDQUFDLHFCQUFMLEdBQTZCLElBQUksQ0FBQyxZQUFMLENBQWtCLEtBQWxCLENBQXdCLENBQXhCLENBQTdCO0FBRUEsZ0JBQUEsTUFBSSxDQUFDLGlCQUFMLEdBQXlCLEVBQXpCLENBSjJELENBSTdCOztBQUM5QixnQkFBQSxNQUFNLENBQUMsT0FBUCxDQUFlLFNBQWYsYUFBK0IsTUFBL0I7QUFDQSxlQU5ELE1BTU87QUFDTixnQkFBQSxNQUFNLENBQUMsTUFBUCxDQUFjLE9BQWQsWUFBMkIsTUFBM0I7QUFDQTs7QUFFRCxjQUFBLElBQUksQ0FBQyxXQUFMLEdBQW1CLElBQW5CLENBYmEsQ0FhYTs7QUFDMUIsY0FBQSxFQUFFLENBQUMsT0FBSCxDQUFXLElBQUksQ0FBQyxlQUFMLENBQXFCLFFBQXJCLEVBQVg7QUFDQTtBQUNELFdBakJEO0FBa0JBLFNBekhLO0FBMkhOLFFBQUEsU0EzSE0sdUJBMkhNO0FBQ1gsY0FBSSxLQUFLLGNBQUwsQ0FBb0IsTUFBcEIsR0FBNkIsQ0FBakMsRUFBb0M7QUFBRTtBQUFTOztBQUUvQyxVQUFBLElBQUksQ0FBQyxRQUFMLENBQWMsSUFBZCxHQUFxQixJQUFyQixDQUEwQixVQUFBLEtBQUssRUFBSTtBQUNsQyxnQkFBSSxLQUFLLENBQUMsQ0FBRCxDQUFMLEtBQWEsSUFBakIsRUFBdUI7QUFDdEIsa0JBQUksWUFBWSxHQUFHLElBQUksQ0FBQyxlQUFMLENBQXFCLFFBQXJCLEVBQW5COztBQUNBLGtCQUFJLElBQUksQ0FBQyxlQUFMLENBQXFCLFNBQXJCLENBQStCLEtBQUssQ0FBQyxDQUFELENBQXBDLENBQUosRUFBOEM7QUFDN0Msb0JBQUksU0FBUyxHQUFHLElBQUksQ0FBQyxlQUFMLENBQXFCLFFBQXJCLEVBQWhCOztBQUNBLG9CQUFJLFNBQVMsS0FBSyxTQUFsQixFQUE2QjtBQUM1QjtBQUNBLGtCQUFBLEVBQUUsQ0FBQyxPQUFILENBQVcsU0FBWDtBQUNBO0FBQ0E7QUFDRDs7QUFFRCxjQUFBLEVBQUUsQ0FBQyxPQUFILENBQVcsWUFBWDtBQUNBO0FBQ0QsV0FkRDtBQWVBLFNBN0lLO0FBK0lOLFFBQUEsUUEvSU0sc0JBK0lLO0FBQ1YsZUFBSyxXQUFMLEdBQW1CLEtBQW5CO0FBQ0EsZUFBSyxXQUFMLEdBQW1CLFFBQW5CO0FBQ0EsZUFBSyx3QkFBTCxHQUFnQyxFQUFoQztBQUNBLGVBQUssY0FBTCxHQUFzQixFQUF0QjtBQUNBLGVBQUsscUJBQUwsR0FBNkIsRUFBN0I7QUFDQSxlQUFLLGVBQUwsR0FBdUIsU0FBdkI7QUFDQSxlQUFLLGlCQUFMLEdBQXlCLEVBQXpCO0FBRUEsVUFBQSxJQUFJLENBQUMsZUFBTCxHQUF1QixTQUF2QjtBQUNBLFVBQUEsSUFBSSxDQUFDLFlBQUwsR0FBb0IsRUFBcEI7QUFDQSxVQUFBLElBQUksQ0FBQyxVQUFMLEdBQWtCLEtBQWxCO0FBQ0EsVUFBQSxJQUFJLENBQUMsWUFBTCxHQUFvQixLQUFwQjtBQUNBLFVBQUEsSUFBSSxDQUFDLFdBQUwsR0FBbUIsS0FBbkI7QUFDQSxVQUFBLElBQUksQ0FBQyxXQUFMLEdBQW1CLEtBQW5CO0FBRUEsVUFBQSxFQUFFLENBQUMsT0FBSCxDQUFXLEVBQVg7QUFDQTtBQWhLSyxPQUFQO0FBa0tBLEtBdFZEO0FBdVZBLEdBeFZNLEVBQVA7QUF5VkEsQ0ExVlksRUFBYjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1ZlLFNBQVMsTUFBVCxDQUFnQixNQUFoQixFQUF3QjtBQUN0QyxPQUFLLFVBQUwsR0FBa0IsRUFBbEI7QUFFQSxPQUFLLE1BQUwsbUNBQ0k7QUFDRixJQUFBLE9BQU8sRUFBRSxLQURQO0FBRUYsSUFBQSxNQUFNLEVBQUU7QUFGTixHQURKLEdBS0ksTUFMSjtBQVFBO0FBQ0Q7QUFDQTs7QUFDQyxPQUFLLFNBQUwsR0FBaUIsRUFBakI7QUFDQTtBQUNEO0FBQ0E7O0FBQ0MsT0FBSyxPQUFMLEdBQWUsRUFBZjtBQUNBLE9BQUssZ0JBQUwsR0FBd0IsRUFBeEI7QUFFQTtBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUNDLE9BQUssTUFBTCxHQUFjLEVBQWQ7QUFFQTtBQUNEO0FBQ0E7QUFDQTs7QUFDQyxPQUFLLGtCQUFMLEdBQTBCLEVBQTFCO0FBQ0E7QUFFRDtBQUNBO0FBQ0E7OztBQUNBLE1BQU0sQ0FBQyxTQUFQLENBQWlCLEtBQWpCLEdBQXlCLFlBQVc7QUFDbkMsT0FBSyxVQUFMLEdBQWtCLEVBQWxCO0FBQ0EsT0FBSyxTQUFMLEdBQWlCLEVBQWpCO0FBQ0EsT0FBSyxPQUFMLEdBQWUsRUFBZjtBQUNBLE9BQUssZ0JBQUwsR0FBd0IsRUFBeEI7QUFDQSxPQUFLLE1BQUwsR0FBYyxFQUFkO0FBQ0EsT0FBSyxrQkFBTCxHQUEwQixFQUExQjtBQUNBLE9BQUssTUFBTCxHQUFjO0FBQ2IsSUFBQSxPQUFPLEVBQUUsS0FESTtBQUViLElBQUEsTUFBTSxFQUFFLEtBQUssTUFBTCxDQUFZO0FBRlAsR0FBZDtBQUlBLENBWEQ7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxNQUFNLENBQUMsU0FBUCxDQUFpQixPQUFqQixHQUEyQixZQUFXO0FBQ3JDLFNBQU8sS0FBSyxNQUFMLENBQVksT0FBbkI7QUFDQSxDQUZEO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsTUFBTSxDQUFDLFNBQVAsQ0FBaUIsa0JBQWpCLEdBQXNDLFlBQVc7QUFDaEQsU0FBTyxLQUFLLFVBQVo7QUFDQSxDQUZEO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxNQUFNLENBQUMsU0FBUCxDQUFpQixRQUFqQixHQUE0QixZQUFXO0FBQ3RDLE1BQUk7QUFDSCxRQUFJLGdCQUFnQixHQUFHLGtCQUFrQixLQUFLLFNBQXZCLEdBQW1DLEtBQTFEO0FBQ0MsSUFBQSxnQkFBZ0IsSUFBSSxNQUFNLEtBQUssT0FBTCxDQUFhLElBQWIsQ0FBa0IsTUFBbEIsQ0FBTixHQUFrQyxjQUF0RDtBQUVELFFBQUksTUFBTSxHQUFHLEVBQWI7QUFDQSxRQUFJLElBQUksR0FBRyxLQUFLLE1BQUwsQ0FBWSxNQUF2QixDQUxHLENBSzZCOztBQUNoQyxTQUFLLElBQUksR0FBRyxHQUFHLENBQWYsRUFBa0IsR0FBRyxHQUFHLElBQXhCLEVBQThCLEVBQUUsR0FBaEMsRUFBcUM7QUFDcEMsVUFBSSxHQUFHLEdBQUcsRUFBVjs7QUFDQSxXQUFLLElBQUksR0FBRyxHQUFHLENBQWYsRUFBa0IsR0FBRyxHQUFHLEtBQUssT0FBTCxDQUFhLE1BQXJDLEVBQTZDLEVBQUUsR0FBL0MsRUFBb0Q7QUFDbkQsUUFBQSxHQUFHLENBQUMsSUFBSixDQUFTLEtBQUssa0JBQUwsQ0FBeUIsR0FBekIsRUFBZ0MsR0FBaEMsQ0FBVDtBQUNBOztBQUVELE1BQUEsTUFBTSxDQUFDLElBQVAsQ0FBWSxNQUFNLEdBQUcsQ0FBQyxJQUFKLENBQVMsSUFBVCxDQUFOLEdBQXVCLEdBQW5DO0FBQ0E7O0FBQ0QsSUFBQSxnQkFBZ0IsSUFBSSxNQUFNLENBQUMsSUFBUCxDQUFZLE1BQVosSUFBc0IsR0FBMUM7QUFFQSxTQUFLLFVBQUwsR0FBa0IsZ0JBQWxCO0FBRUEsV0FBTyxnQkFBZ0IsQ0FBQyxLQUFqQixDQUF1QixDQUF2QixDQUFQO0FBQ0EsR0FuQkQsQ0FtQkUsT0FBTyxDQUFQLEVBQVU7QUFDWCxTQUFLLE1BQUwsQ0FBWSxNQUFaLENBQW1CLE1BQW5CLENBQTBCLFFBQTFCLEVBQW9DLENBQXBDO0FBQ0EsSUFBQSxPQUFPLENBQUMsS0FBUixDQUFjLENBQWQ7QUFFQSxXQUFPLFNBQVA7QUFDQTtBQUNELENBMUJEO0FBNEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxNQUFNLENBQUMsU0FBUCxDQUFpQixPQUFqQixHQUEyQixVQUFTLFVBQVQsRUFBcUI7QUFBQTs7QUFDL0MsT0FBSyxVQUFMLEdBQWtCLFVBQWxCO0FBQ0EsTUFBSSxJQUFJLEdBQUcsVUFBWDtBQUNBLE1BQUksUUFBUSxHQUFHLDBZQUFmO0FBRUEsTUFBSSxPQUFPLEdBQUcsUUFBUSxDQUFDLElBQVQsQ0FBYyxJQUFkLENBQWQ7O0FBQ0EsTUFBSSxDQUFDLE9BQUwsRUFBYztBQUNiLFNBQUssS0FBTDtBQUVBLFdBQU8sS0FBUDtBQUNBOztBQUVELE1BQUksTUFBTSxHQUFHLFNBQWI7O0FBQ0EsTUFBSTtBQUNILFFBQUksYUFBYSxHQUFHLGlZQUFwQjtBQUNBLFFBQUksWUFBWSxHQUFHLElBQUksQ0FBQyxLQUFMLENBQVcsYUFBWCxDQUFuQjs7QUFDQSxRQUFJLFlBQVksSUFBSSxZQUFZLENBQUMsTUFBYixHQUFzQixDQUExQyxFQUE2QztBQUM1QyxXQUFLLElBQUksQ0FBQyxHQUFHLENBQWIsRUFBZ0IsQ0FBQyxHQUFHLFlBQVksQ0FBQyxNQUFiLEdBQW9CLENBQXhDLEVBQTJDLEVBQUUsQ0FBN0MsRUFBZ0Q7QUFDL0MsWUFBSSxZQUFZLENBQUMsQ0FBRCxDQUFaLENBQWdCLElBQWhCLE1BQTBCLFlBQVksQ0FBQyxDQUFDLEdBQUMsQ0FBSCxDQUFaLENBQWtCLElBQWxCLEVBQTlCLEVBQXdEO0FBQ3ZELGdCQUFNLGdEQUFOO0FBQ0E7QUFDRDtBQUNELEtBTkQsTUFNTztBQUNOLE1BQUEsWUFBWSxHQUFHLEVBQWYsQ0FETSxDQUNjO0FBQ3BCLEtBWEUsQ0FhSDs7O0FBYkcsa0NBY3FDLE9BZHJDO0FBQUEsUUFjSyxLQWRMO0FBQUEsUUFjWSxPQWRaO0FBQUEsUUFjcUIsTUFkckI7O0FBZUgsU0FBSyxTQUFMLEdBQWlCLEtBQWpCLENBZkcsQ0FpQkg7O0FBQ0EsSUFBQSxPQUFPLEdBQUcsT0FBTyxDQUFDLEtBQVIsQ0FBYyxHQUFkLENBQVY7QUFDQSxTQUFLLGdCQUFMLEdBQXdCLEVBQXhCOztBQUNBLFNBQUssSUFBSSxFQUFDLEdBQUcsQ0FBYixFQUFnQixFQUFDLEdBQUcsT0FBTyxDQUFDLE1BQTVCLEVBQW9DLEVBQUUsRUFBdEMsRUFBeUM7QUFDeEMsTUFBQSxPQUFPLENBQUUsRUFBRixDQUFQLEdBQWUsT0FBTyxDQUFFLEVBQUYsQ0FBUCxDQUFhLElBQWIsR0FBb0IsT0FBcEIsQ0FBNEIsSUFBNUIsRUFBa0MsRUFBbEMsRUFBc0MsSUFBdEMsRUFBZjtBQUVBLFdBQUssZ0JBQUwsQ0FBdUIsT0FBTyxDQUFFLEVBQUYsQ0FBOUIsSUFBd0MsRUFBeEM7QUFDQTs7QUFDRCxTQUFLLE9BQUwsR0FBZSxPQUFmLENBekJHLENBMkJIO0FBQ0E7O0FBQ0EsUUFBSSxZQUFZLENBQUMsTUFBYixHQUFzQixDQUExQixFQUE2QjtBQUM1QixNQUFBLE1BQU0sR0FBRyxNQUFNLENBQUMsS0FBUCxDQUFhLFlBQVksQ0FBQyxDQUFELENBQXpCLEVBQThCLElBQTlCLENBQW1DLEVBQW5DLENBQVQsQ0FENEIsQ0FHNUI7QUFDQTs7QUFDQSxNQUFBLE1BQU0sR0FBRyxVQUFVLENBQUMsWUFBTTtBQUN6QixRQUFBLEtBQUksQ0FBQyxNQUFMLENBQVksTUFBWixDQUFtQixNQUFuQixDQUEwQixNQUExQixFQUFrQyw4QkFBbEMsRUFBa0UseUNBQWxFO0FBQ0EsT0FGa0IsRUFFaEIsR0FGZ0IsQ0FBbkI7QUFHQSxLQXJDRSxDQXNDSDs7O0FBQ0EsSUFBQSxNQUFNLEdBQUcsTUFBTSxDQUFDLElBQVAsRUFBVDtBQUVBLFFBQUksV0FBVyxHQUFHLEVBQWxCO0FBQUEsUUFDQyxTQUFTLEdBQUcsS0FEYjtBQUdBLFFBQUksTUFBTSxHQUFHLEVBQWI7QUFBQSxRQUNDLFdBQVcsR0FBRyxFQURmO0FBQUEsUUFFQyxTQUFTLEdBQUcsS0FGYjs7QUFHQSxTQUFLLElBQUksR0FBQyxHQUFHLENBQWIsRUFBZ0IsR0FBQyxHQUFHLE1BQU0sQ0FBQyxNQUEzQixFQUFtQyxFQUFFLEdBQXJDLEVBQXdDO0FBQ3ZDLFVBQU0sQ0FBQyxTQUFELElBQWMsQ0FBQyxTQUFmLElBQTRCLE1BQU0sQ0FBQyxHQUFELENBQU4sSUFBYSxHQUExQyxJQUFtRCxDQUFDLFNBQUQsS0FBZSxNQUFNLENBQUMsR0FBRCxDQUFOLEtBQWMsR0FBZCxJQUFxQixNQUFNLENBQUMsR0FBRCxDQUFOLENBQVUsS0FBVixDQUFnQixxRUFBaEIsQ0FBcEMsQ0FBbkQsSUFBb0gsU0FBUyxJQUFJLFNBQVMsS0FBSyxLQUEzQixLQUFxQyxNQUFNLENBQUMsR0FBRCxDQUFOLEtBQWMsR0FBZCxJQUFxQixNQUFNLENBQUMsR0FBRCxDQUFOLENBQVUsS0FBVixDQUFnQixxRUFBaEIsQ0FBMUQsQ0FBekgsRUFBOE07QUFDN00saUJBRDZNLENBQ2xNO0FBQ1gsT0FIc0MsQ0FLdkM7OztBQUNBLFVBQUksQ0FBQyxTQUFELElBQWMsTUFBTSxDQUFDLEdBQUQsQ0FBTixLQUFjLEdBQWhDLEVBQXFDO0FBQ3BDLFFBQUEsU0FBUyxHQUFHLElBQVo7QUFDQTtBQUNBLE9BVHNDLENBVXZDOzs7QUFDQSxVQUFJLFNBQVMsS0FBSyxTQUFTLEtBQUssS0FBZCxJQUF1QixTQUFTLEtBQUssRUFBMUMsQ0FBVCxJQUEwRCxNQUFNLENBQUMsR0FBRCxDQUFOLEtBQWMsR0FBNUUsRUFBaUY7QUFDaEYsWUFBSSxTQUFTLEtBQUssRUFBbEIsRUFBc0I7QUFBRztBQUN4QixVQUFBLFdBQVcsQ0FBQyxJQUFaLENBQWlCLE1BQWpCO0FBQ0EsVUFBQSxNQUFNLEdBQUcsRUFBVDtBQUNBLFVBQUEsU0FBUyxHQUFHLEtBQVo7QUFDQTs7QUFFRCxRQUFBLFNBQVMsR0FBRyxLQUFaO0FBQ0EsUUFBQSxXQUFXLENBQUMsSUFBWixDQUFpQixXQUFXLENBQUMsS0FBWixDQUFrQixDQUFsQixDQUFqQjtBQUNBLFFBQUEsV0FBVyxDQUFDLE1BQVosR0FBcUIsQ0FBckI7QUFDQTtBQUNBLE9BdEJzQyxDQXdCdkM7QUFDQTs7O0FBQ0EsVUFBSSxTQUFTLElBQUksU0FBUyxLQUFLLEtBQTNCLEtBQXNDLE1BQU0sQ0FBQyxHQUFELENBQU4sS0FBYyxTQUFkLElBQTJCLE1BQU0sQ0FBQyxHQUFDLEdBQUMsQ0FBSCxDQUFOLEtBQWdCLElBQTVDLElBQXNELE1BQU0sQ0FBQyxHQUFELENBQU4sS0FBYyxHQUFkLElBQXFCLFNBQVMsS0FBSyxFQUE5SCxDQUFKLEVBQXlJO0FBQ3hJLFlBQUksU0FBUyxLQUFLLEVBQWxCLEVBQXNCO0FBQ3JCLFVBQUEsTUFBTSxJQUFJLE1BQU0sQ0FBQyxHQUFELENBQWhCO0FBQ0E7O0FBQ0QsUUFBQSxXQUFXLENBQUMsSUFBWixDQUFpQixNQUFNLENBQUMsSUFBUCxFQUFqQjtBQUNBLFFBQUEsTUFBTSxHQUFHLEVBQVQ7QUFDQSxRQUFBLFNBQVMsR0FBRyxLQUFaO0FBQ0E7QUFDQTs7QUFDRCxVQUFJLFNBQVMsSUFBSSxTQUFTLEtBQUssS0FBM0IsS0FBcUMsTUFBTSxDQUFDLEdBQUQsQ0FBTixLQUFjLEdBQWQsSUFBcUIsTUFBTSxDQUFDLEdBQUQsQ0FBTixLQUFjLEdBQW5DLElBQTBDLE1BQU0sQ0FBQyxHQUFELENBQU4sS0FBYyxHQUE3RixDQUFKLEVBQXVHO0FBQ3RHLFFBQUEsU0FBUyxHQUFHLE1BQU0sQ0FBQyxHQUFELENBQWxCO0FBQ0EsUUFBQSxNQUFNLElBQUksTUFBTSxDQUFDLEdBQUQsQ0FBaEI7QUFDQTtBQUNBOztBQUNELFVBQUksU0FBUyxLQUFLLEtBQWxCLEVBQXlCO0FBQ3hCLFFBQUEsU0FBUyxHQUFHLEVBQVo7QUFDQTs7QUFFRCxNQUFBLE1BQU0sSUFBSSxNQUFNLENBQUMsR0FBRCxDQUFoQjtBQUNBOztBQUVELFNBQUssa0JBQUwsR0FBMEIsRUFBMUI7O0FBQ0EsU0FBSyxJQUFJLEdBQUMsR0FBRyxDQUFiLEVBQWdCLEdBQUMsR0FBRyxXQUFXLENBQUMsTUFBaEMsRUFBd0MsRUFBRSxHQUExQyxFQUE2QztBQUM1QyxVQUFJLFdBQVcsQ0FBQyxHQUFELENBQVgsQ0FBZSxNQUFmLEtBQTBCLE9BQU8sQ0FBQyxNQUF0QyxFQUE4QztBQUM3Qyw4QkFBZ0IsV0FBVyxDQUFDLEdBQUQsQ0FBWCxDQUFlLE1BQS9CLDRCQUF5RCxHQUFDLEdBQUMsQ0FBM0QsZUFBbUUsT0FBTyxDQUFDLE1BQTNFO0FBQ0E7O0FBRUQsV0FBSyxJQUFJLENBQUMsR0FBRyxDQUFiLEVBQWdCLENBQUMsR0FBRyxXQUFXLENBQUUsR0FBRixDQUFYLENBQWlCLE1BQXJDLEVBQTZDLEVBQUUsQ0FBL0MsRUFBa0Q7QUFDakQsWUFBSSxRQUFRLEdBQUcsS0FBSyxnQkFBTCxDQUF1QixPQUFPLENBQUUsQ0FBRixDQUE5QixDQUFmOztBQUVBLFlBQUksT0FBTyxLQUFLLGtCQUFMLENBQXlCLFFBQXpCLENBQVAsS0FBZ0QsV0FBcEQsRUFBaUU7QUFDaEUsZUFBSyxrQkFBTCxDQUF5QixRQUF6QixJQUFzQyxFQUF0QztBQUNBOztBQUVELGFBQUssa0JBQUwsQ0FBeUIsUUFBekIsRUFBb0MsSUFBcEMsQ0FBeUMsV0FBVyxDQUFFLEdBQUYsQ0FBWCxDQUFrQixDQUFsQixDQUF6QztBQUNBO0FBQ0Q7O0FBQ0QsU0FBSyxNQUFMLEdBQWMsV0FBZDtBQUVBLFNBQUssTUFBTCxDQUFZLE9BQVosR0FBc0IsSUFBdEI7QUFDQSxXQUFPLElBQVA7QUFDQSxHQWxIRCxDQWtIRSxPQUFPLENBQVAsRUFBVTtBQUNYLElBQUEsWUFBWSxDQUFDLE1BQUQsQ0FBWjtBQUNBLFNBQUssTUFBTCxDQUFZLE1BQVosQ0FBbUIsTUFBbkIsQ0FBMEIsUUFBMUIsRUFBb0MsQ0FBcEM7QUFDQSxJQUFBLE9BQU8sQ0FBQyxLQUFSLENBQWMsQ0FBZDtBQUNBLFNBQUssS0FBTDtBQUVBLFdBQU8sS0FBUDtBQUNBO0FBQ0QsQ0F2SUQ7QUF5SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsTUFBTSxDQUFDLFNBQVAsQ0FBaUIsUUFBakIsR0FBNEIsWUFBVztBQUN0QyxTQUFPLEtBQUssU0FBWjtBQUNBLENBRkQ7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxNQUFNLENBQUMsU0FBUCxDQUFpQixVQUFqQixHQUE4QixZQUFXO0FBQ3hDLFNBQU8sS0FBSyxPQUFMLENBQWEsS0FBYixDQUFtQixDQUFuQixFQUFzQixJQUF0QixDQUEyQixVQUFDLENBQUQsRUFBSSxDQUFKO0FBQUEsV0FBVSxDQUFDLENBQUMsaUJBQUYsR0FBc0IsYUFBdEIsQ0FBb0MsQ0FBQyxDQUFDLGlCQUFGLEVBQXBDLENBQVY7QUFBQSxHQUEzQixDQUFQO0FBQ0EsQ0FGRDtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLE1BQU0sQ0FBQyxTQUFQLENBQWlCLGlCQUFqQixHQUFxQyxVQUFTLE1BQVQsRUFBaUI7QUFDckQsTUFBSSxRQUFRLEdBQUcsS0FBSyxnQkFBTCxDQUF1QixNQUF2QixDQUFmOztBQUVBLE1BQUksUUFBUSxLQUFLLFNBQWIsSUFBMEIsS0FBSyxrQkFBTCxDQUF5QixRQUF6QixNQUF3QyxTQUF0RSxFQUFpRjtBQUNoRixXQUFPLEVBQVA7QUFDQTs7QUFFRCxNQUFJLE1BQU0sR0FBRyxFQUFiOztBQUNBLE9BQUssSUFBSSxDQUFDLEdBQUcsQ0FBYixFQUFnQixDQUFDLEdBQUcsS0FBSyxrQkFBTCxDQUF5QixRQUF6QixFQUFvQyxNQUF4RCxFQUFnRSxFQUFFLENBQWxFLEVBQXFFO0FBQ3BFLElBQUEsTUFBTSxDQUFDLElBQVAsQ0FBWSxLQUFLLGtCQUFMLENBQXlCLFFBQXpCLEVBQXFDLENBQXJDLENBQVo7QUFDQTs7QUFFRCxTQUFPLE1BQVA7QUFDQSxDQWJEO0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxNQUFNLENBQUMsU0FBUCxDQUFpQixZQUFqQixHQUFnQyxVQUFTLE1BQVQsRUFBaUI7QUFDaEQsTUFBSTtBQUNILFFBQUksUUFBUSxHQUFHLEtBQUssZ0JBQUwsQ0FBdUIsTUFBdkIsQ0FBZjs7QUFFQSxRQUFJLFFBQVEsS0FBSyxTQUFiLElBQTBCLEtBQUssa0JBQUwsQ0FBeUIsUUFBekIsTUFBd0MsU0FBdEUsRUFBaUY7QUFDaEYsYUFBTyxLQUFQO0FBQ0E7O0FBRUQsUUFBSSxVQUFVLEdBQUcsS0FBSyxPQUFMLENBQWEsS0FBYixDQUFtQixDQUFuQixDQUFqQjtBQUNDLElBQUEsVUFBVSxDQUFDLE1BQVgsQ0FBa0IsUUFBbEIsRUFBNEIsQ0FBNUI7QUFDRCxRQUFJLG1CQUFtQixHQUFHLE1BQU0sQ0FBQyxNQUFQLENBQWMsRUFBZCxFQUFrQixLQUFLLGdCQUF2QixDQUExQixDQVRHLENBV0g7O0FBQ0EsU0FBSyxJQUFJLENBQUMsR0FBRyxDQUFiLEVBQWdCLENBQUMsR0FBRyxVQUFVLENBQUMsTUFBL0IsRUFBdUMsRUFBRSxDQUF6QyxFQUE0QztBQUMzQyxVQUFJLG1CQUFtQixDQUFFLFVBQVUsQ0FBQyxDQUFELENBQVosQ0FBbkIsR0FBdUMsUUFBM0MsRUFBcUQ7QUFDcEQ7QUFDQTs7QUFFRCxNQUFBLG1CQUFtQixDQUFFLFVBQVUsQ0FBQyxDQUFELENBQVosQ0FBbkIsR0FBdUMsbUJBQW1CLENBQUUsVUFBVSxDQUFDLENBQUQsQ0FBWixDQUFuQixHQUF1QyxDQUE5RTtBQUNBOztBQUVELFFBQUksU0FBUyxHQUFHLEtBQUssTUFBTCxDQUFZLEtBQVosQ0FBa0IsQ0FBbEIsQ0FBaEIsQ0FwQkcsQ0FxQkg7O0FBQ0EsU0FBSyxJQUFJLEdBQUcsR0FBRyxDQUFmLEVBQWtCLEdBQUcsR0FBRyxTQUFTLENBQUMsTUFBbEMsRUFBMEMsRUFBRSxHQUE1QyxFQUFpRDtBQUNoRCxNQUFBLFNBQVMsQ0FBRSxHQUFGLENBQVQsQ0FBaUIsTUFBakIsQ0FBd0IsUUFBeEIsRUFBa0MsQ0FBbEM7QUFDQTs7QUFFRCxXQUFPLEtBQUssZ0JBQUwsQ0FBdUIsTUFBdkIsQ0FBUDtBQUNBLFNBQUssa0JBQUwsQ0FBd0IsTUFBeEIsQ0FBK0IsUUFBL0IsRUFBeUMsQ0FBekM7QUFFQSxTQUFLLE1BQUwsR0FBYyxTQUFkO0FBQ0EsU0FBSyxPQUFMLEdBQWUsVUFBZjtBQUNBLFNBQUssZ0JBQUwsR0FBd0IsbUJBQXhCO0FBRUEsV0FBTyxLQUFLLE9BQUwsQ0FBYSxLQUFiLENBQW1CLENBQW5CLEVBQXNCLElBQXRCLEVBQVA7QUFDQSxHQWxDRCxDQWtDRSxPQUFPLENBQVAsRUFBVTtBQUNYLFNBQUssTUFBTCxDQUFZLE1BQVosQ0FBbUIsTUFBbkIsQ0FBMEIsUUFBMUIsRUFBb0MsQ0FBcEM7QUFDQSxJQUFBLE9BQU8sQ0FBQyxLQUFSLENBQWMsQ0FBZDtBQUVBLFdBQU8sS0FBUDtBQUNBO0FBQ0QsQ0F6Q0Q7QUE0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLE1BQU0sQ0FBQyxTQUFQLENBQWlCLFdBQWpCLEdBQStCLFVBQVMsTUFBVCxFQUFpQixHQUFqQixFQUFzQixLQUF0QixFQUE2QjtBQUMzRCxNQUFJO0FBQ0gsUUFBSSxRQUFRLEdBQUcsS0FBSyxnQkFBTCxDQUFzQixNQUF0QixDQUFmOztBQUNBLFFBQUksUUFBUSxLQUFLLFNBQWIsSUFBMEIsS0FBSyxrQkFBTCxDQUF5QixRQUF6QixNQUF3QyxTQUF0RSxFQUFpRjtBQUNoRixhQUFPLEtBQVA7QUFDQTs7QUFFRCxRQUFJLFFBQVEsR0FBRztBQUFLO0FBQUEsS0FBdUMsSUFBNUMsRUFBZixDQU5HLENBT0g7O0FBQ0EsU0FBSyxNQUFMLENBQWEsR0FBYixFQUFvQixRQUFwQixJQUFpQyxRQUFqQyxDQVJHLENBU0g7O0FBQ0EsU0FBSyxrQkFBTCxDQUF5QixRQUF6QixFQUFxQyxHQUFyQyxJQUE2QyxRQUE3QztBQUVBLFdBQU8sSUFBUDtBQUNBLEdBYkQsQ0FhRSxPQUFPLENBQVAsRUFBVTtBQUNYLFNBQUssTUFBTCxDQUFZLE1BQVosQ0FBbUIsTUFBbkIsQ0FBMEIsUUFBMUIsRUFBb0MsQ0FBcEM7QUFDQSxJQUFBLE9BQU8sQ0FBQyxLQUFSLENBQWMsQ0FBZDtBQUVBLFdBQU8sS0FBUDtBQUNBO0FBQ0QsQ0FwQkQ7QUFzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLE1BQU0sQ0FBQyxTQUFQLENBQWlCLFlBQWpCLEdBQWdDLFVBQVMsTUFBVCxFQUFpQixNQUFqQixFQUF5QjtBQUN4RCxNQUFJO0FBQ0gsUUFBSSxRQUFRLEdBQUcsS0FBSyxnQkFBTCxDQUF1QixNQUF2QixDQUFmOztBQUNBLFFBQUksUUFBUSxLQUFLLFNBQWIsSUFBMEIsS0FBSyxrQkFBTCxDQUF5QixRQUF6QixNQUF3QyxTQUF0RSxFQUFpRjtBQUNoRixhQUFPLEtBQVA7QUFDQSxLQUpFLENBTUg7OztBQUNBLFFBQUksSUFBSSxHQUFHLE1BQU0sQ0FBQyxNQUFsQjs7QUFDQSxRQUFJLEtBQUssTUFBTCxDQUFZLE1BQVosS0FBdUIsSUFBM0IsRUFBaUM7QUFDaEMsYUFBTyxLQUFQO0FBQ0E7O0FBRUQsU0FBSyxJQUFJLENBQUMsR0FBRyxDQUFiLEVBQWdCLENBQUMsR0FBRyxJQUFwQixFQUEwQixFQUFFLENBQTVCLEVBQStCO0FBQzlCLFVBQUksUUFBUSxHQUFHLE1BQU0sQ0FBRSxDQUFGLENBQU4sQ0FBWSxJQUFaLEVBQWYsQ0FEOEIsQ0FHOUI7O0FBQ0EsV0FBSyxNQUFMLENBQWEsQ0FBYixFQUFrQixRQUFsQixJQUErQixRQUEvQixDQUo4QixDQUs5Qjs7QUFDQSxXQUFLLGtCQUFMLENBQXlCLFFBQXpCLEVBQXFDLENBQXJDLElBQTJDLFFBQTNDO0FBQ0E7O0FBRUQsV0FBTyxJQUFQO0FBQ0EsR0F0QkQsQ0FzQkUsT0FBTyxDQUFQLEVBQVU7QUFDWCxTQUFLLE1BQUwsQ0FBWSxNQUFaLENBQW1CLE1BQW5CLENBQTBCLFFBQTFCLEVBQW9DLENBQXBDO0FBQ0EsSUFBQSxPQUFPLENBQUMsS0FBUixDQUFjLENBQWQ7QUFFQSxXQUFPLEtBQVA7QUFDQTtBQUNELENBN0JEO0FBK0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxNQUFNLENBQUMsU0FBUCxDQUFpQixtQkFBakIsR0FBdUMsVUFBUyxRQUFULEVBQW1CLFdBQW5CLEVBQWdDO0FBQ3RFLE1BQUk7QUFFSCxRQUFJLFNBQVMsR0FBRyxLQUFoQjtBQUFBLFFBQ0MsU0FBUyxHQUFHLEtBRGI7QUFBQSxRQUVDLFVBQVUsR0FBRyxDQUFDLENBRmY7QUFJQSxRQUFJLEdBQUcsR0FBRyxXQUFXLENBQUMsSUFBWixHQUFtQixPQUFuQixDQUEyQixRQUEzQixFQUFxQyxFQUFyQyxDQUFWLENBTkcsQ0FPSDs7QUFDQSxRQUFJLFFBQVEsSUFBSSxHQUFHLENBQUMsTUFBaEIsSUFBMEIsUUFBUSxLQUFLLENBQTNDLEVBQThDO0FBQzdDLGFBQU8sS0FBUDtBQUNBOztBQUVELFNBQUssSUFBSSxHQUFHLEdBQUcsQ0FBZixFQUFrQixHQUFHLEdBQUcsR0FBRyxDQUFDLE1BQTVCLEVBQW9DLEVBQUUsR0FBdEMsRUFBMkM7QUFDMUMsVUFBTSxDQUFDLFNBQUQsS0FBZSxHQUFHLENBQUMsR0FBRCxDQUFILEtBQWEsR0FBYixJQUFvQixHQUFHLENBQUMsR0FBRCxDQUFILENBQVMsS0FBVCxDQUFlLHFFQUFmLENBQW5DLENBQUQsSUFBZ0UsU0FBUyxJQUFJLFNBQVMsS0FBSyxLQUEzQixLQUFxQyxHQUFHLENBQUMsR0FBRCxDQUFILEtBQWEsR0FBYixJQUFvQixHQUFHLENBQUMsR0FBRCxDQUFILENBQVMsS0FBVCxDQUFlLHFFQUFmLENBQXpELENBQXJFLEVBQXdKO0FBQ3ZKO0FBQ0EsT0FIeUMsQ0FLMUM7OztBQUNBLFVBQUksQ0FBQyxTQUFELElBQWMsR0FBRyxDQUFDLEdBQUQsQ0FBSCxLQUFhLEdBQS9CLEVBQW9DO0FBQ25DLFFBQUEsU0FBUyxHQUFHLElBQVo7QUFDQTtBQUNBLE9BVHlDLENBVTFDOzs7QUFDQSxVQUFJLFNBQVMsS0FBSyxTQUFTLEtBQUssS0FBZCxJQUF1QixTQUFTLEtBQUssRUFBMUMsQ0FBVCxJQUEwRCxHQUFHLENBQUMsR0FBRCxDQUFILEtBQWEsR0FBM0UsRUFBZ0Y7QUFDL0UsWUFBSSxTQUFTLEtBQUssRUFBbEIsRUFBc0I7QUFBRztBQUN4QixVQUFBLFNBQVMsR0FBRyxLQUFaO0FBQ0E7O0FBQ0QsUUFBQSxTQUFTLEdBQUcsS0FBWjtBQUNBO0FBQ0EsT0FqQnlDLENBbUIxQztBQUNBOzs7QUFDQSxVQUFJLFNBQVMsSUFBSSxTQUFTLEtBQUssS0FBM0IsS0FBc0MsR0FBRyxDQUFDLEdBQUQsQ0FBSCxLQUFhLFNBQWIsSUFBMEIsR0FBRyxDQUFDLEdBQUcsR0FBQyxDQUFMLENBQUgsS0FBZSxJQUExQyxJQUFvRCxHQUFHLENBQUMsR0FBRCxDQUFILEtBQWEsR0FBYixJQUFvQixTQUFTLEtBQUssRUFBM0gsQ0FBSixFQUFzSTtBQUNySSxRQUFBLFNBQVMsR0FBRyxLQUFaOztBQUNBLFlBQUksR0FBRyxJQUFJLFFBQVgsRUFBcUI7QUFDcEI7QUFDQTs7QUFDRDtBQUNBOztBQUVELFVBQUksU0FBUyxJQUFJLFNBQVMsS0FBSyxLQUEzQixLQUFxQyxHQUFHLENBQUMsR0FBRCxDQUFILEtBQWEsR0FBYixJQUFvQixHQUFHLENBQUMsR0FBRCxDQUFILEtBQWEsR0FBakMsSUFBd0MsR0FBRyxDQUFDLEdBQUQsQ0FBSCxLQUFhLEdBQTFGLENBQUosRUFBb0c7QUFDbkcsVUFBRSxVQUFGO0FBQ0EsUUFBQSxTQUFTLEdBQUcsR0FBRyxDQUFDLEdBQUQsQ0FBZjtBQUNBO0FBQ0E7O0FBQ0QsVUFBSSxTQUFTLEtBQUssS0FBbEIsRUFBeUI7QUFDeEIsVUFBRSxVQUFGO0FBQ0EsUUFBQSxTQUFTLEdBQUcsRUFBWjtBQUNBLE9BckN5QyxDQXVDMUM7OztBQUNBLFVBQUksR0FBRyxJQUFJLFFBQVgsRUFBcUI7QUFDcEIsWUFBSSxDQUFDLFNBQUQsSUFBYyxTQUFTLEtBQUssS0FBaEMsRUFBdUM7QUFDdEMsVUFBQSxVQUFVLEdBQUcsQ0FBQyxDQUFkO0FBQ0E7O0FBQ0Q7QUFDQTtBQUNEOztBQUVELFFBQUksT0FBTyxLQUFLLE9BQUwsQ0FBYSxVQUFiLENBQVAsS0FBcUMsV0FBekMsRUFBc0Q7QUFDckQsYUFBTyxLQUFLLE9BQUwsQ0FBYSxVQUFiLENBQVA7QUFDQTs7QUFFRCxVQUFNLGdCQUFOO0FBQ0EsR0FqRUQsQ0FpRUUsT0FBTyxDQUFQLEVBQVU7QUFDWCxXQUFPLEtBQVA7QUFDQTtBQUNELENBckVEO0FBdUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxNQUFNLENBQUMsU0FBUCxDQUFpQixTQUFqQixHQUE2QixVQUFTLFVBQVQsRUFBbUM7QUFBQSxNQUFkLEtBQWMsdUVBQU4sSUFBTTs7QUFDL0QsTUFBSTtBQUNILFNBQUssT0FBTCxDQUFhLElBQWIsQ0FBa0IsVUFBbEI7QUFDQSxTQUFLLGdCQUFMLENBQXNCLFVBQXRCLElBQW9DLEtBQUssT0FBTCxDQUFhLE1BQWIsR0FBb0IsQ0FBeEQ7QUFFQSxTQUFLLGtCQUFMLENBQXdCLElBQXhCLENBQTZCLEVBQTdCOztBQUNBLFNBQUssSUFBSSxDQUFDLEdBQUcsQ0FBYixFQUFnQixDQUFDLEdBQUcsS0FBSyxNQUFMLENBQVksTUFBaEMsRUFBd0MsRUFBRSxDQUExQyxFQUE2QztBQUM1QyxXQUFLLE1BQUwsQ0FBYSxLQUFLLGdCQUFMLENBQXNCLFVBQXRCLENBQWIsRUFBaUQsSUFBakQsQ0FBc0QsS0FBdEQ7QUFDQSxXQUFLLGtCQUFMLENBQXlCLEtBQUssZ0JBQUwsQ0FBc0IsVUFBdEIsQ0FBekIsRUFBNkQsSUFBN0QsQ0FBa0UsS0FBbEU7QUFDQTs7QUFFRCxXQUFPLElBQVA7QUFDQSxHQVhELENBV0UsT0FBTyxDQUFQLEVBQVU7QUFDWCxTQUFLLE1BQUwsQ0FBWSxNQUFaLENBQW1CLE1BQW5CLENBQTBCLFFBQTFCLEVBQW9DLENBQXBDO0FBQ0EsSUFBQSxPQUFPLENBQUMsS0FBUixDQUFjLENBQWQ7QUFFQSxXQUFPLEtBQVA7QUFDQTtBQUNELENBbEJEOzs7Ozs7Ozs7Ozs7Ozs7O0FDdmVlLFNBQVMsS0FBVCxDQUFlLE1BQWYsRUFBdUI7QUFBQTs7QUFDckMsTUFBSSxFQUFFLGdCQUFnQixLQUFsQixDQUFKLEVBQThCO0FBQzdCLFdBQU8sSUFBSSxLQUFKLENBQVUsTUFBVixDQUFQO0FBQ0E7O0FBRUQsT0FBSyxNQUFMLG1DQUNJO0FBQ0YsSUFBQSxJQUFJLEVBQUUsS0FESjtBQUVGLElBQUEsUUFBUSxFQUFFLFNBRlI7QUFHRixJQUFBLGFBQWEsRUFBRSxTQUhiO0FBS0YsSUFBQSxRQUFRLEVBQUUsU0FMUjtBQU1GLElBQUEsV0FBVyxFQUFFLFNBTlg7QUFPRixJQUFBLFVBQVUsRUFBRSxTQVBWO0FBUUYsSUFBQSxRQUFRLEVBQUUsU0FSUjtBQVNGLElBQUEsVUFBVSxFQUFFLFNBVFY7QUFXRixJQUFBLFNBQVMsRUFBRTtBQUFBLGFBQU0sSUFBTjtBQUFBLEtBWFQ7QUFZRixJQUFBLE9BQU8sRUFBRTtBQUFBLGFBQU0sSUFBTjtBQUFBLEtBWlA7QUFhRixJQUFBLE1BQU0sRUFBRSxrQkFBTTtBQUFFLE1BQUEsS0FBSSxDQUFDLE1BQUwsQ0FBWSxVQUFaLENBQXVCLEtBQXZCO0FBQWlDLEtBYi9DO0FBY0YsSUFBQSxTQUFTLEVBQUUsbUJBQUEsSUFBSTtBQUFBLGFBQUksSUFBSjtBQUFBO0FBZGIsR0FESixHQWlCSSxNQWpCSjs7QUFvQkEsTUFBSTtBQUNILFFBQUksSUFBSSxHQUFHLFFBQVEsQ0FBQyxhQUFULENBQXVCLEtBQXZCLENBQVg7O0FBQ0EsUUFBSSxTQUFTLEdBQUcsS0FBSyxNQUFMLENBQVksUUFBWixDQUFxQixTQUFyQixDQUErQixLQUEvQixDQUFxQyxDQUFyQyxDQUFoQjtBQUNDLElBQUEsSUFBSSxDQUFDLFNBQUwsR0FBaUIsU0FBakI7QUFDRCxTQUFLLE1BQUwsQ0FBWSxRQUFaLEdBQXVCLElBQUksQ0FBQyxpQkFBNUI7QUFFQSxTQUFLLE1BQUwsQ0FBWSxXQUFaLEdBQTBCLEtBQUssTUFBTCxDQUFZLFFBQVosQ0FBcUIsYUFBckIsQ0FBbUMsaUJBQW5DLENBQTFCO0FBQ0EsU0FBSyxNQUFMLENBQVksVUFBWixHQUF5QixLQUFLLE1BQUwsQ0FBWSxRQUFaLENBQXFCLGFBQXJCLENBQW1DLGdCQUFuQyxDQUF6QjtBQUVBLFNBQUssTUFBTCxDQUFZLFdBQVosQ0FBd0IsU0FBeEIsQ0FBa0MsR0FBbEMsQ0FBc0MsVUFBdEMsRUFBa0QsY0FBbEQsRUFBa0UsV0FBbEUsRUFBK0UscUJBQS9FO0FBQ0EsU0FBSyxNQUFMLENBQVksVUFBWixDQUF1QixTQUF2QixDQUFpQyxHQUFqQyxDQUFxQyxXQUFyQyxFQUFrRCxlQUFsRCxFQUFtRSxrQkFBbkUsRUFBdUYsYUFBdkY7QUFFQSxJQUFBLFFBQVEsQ0FBQyxJQUFULENBQWMsV0FBZCxDQUEwQixLQUFLLE1BQUwsQ0FBWSxRQUF0QztBQUNBLElBQUEsUUFBUSxDQUFDLElBQVQsQ0FBYyxnQkFBZCxDQUErQixPQUEvQixFQUF3QyxVQUFBLENBQUMsRUFBSTtBQUM1QyxVQUFJLENBQUMsS0FBSSxDQUFDLE1BQUwsQ0FBWSxJQUFqQixFQUF1QjtBQUN0QixlQUFPLElBQVA7QUFDQTs7QUFDRCxVQUFJLENBQUMsQ0FBQyxHQUFGLEtBQVUsT0FBVixJQUFxQixDQUFDLENBQUMsR0FBRixLQUFVLFFBQW5DLEVBQTZDO0FBQzVDLFFBQUEsS0FBSSxDQUFDLElBQUwsQ0FBVSxDQUFDLENBQUMsR0FBRixLQUFVLE9BQXBCO0FBQ0E7QUFDRCxLQVBEO0FBU0EsU0FBSyxNQUFMLENBQVksVUFBWixHQUF5QixLQUFLLE1BQUwsQ0FBWSxRQUFaLENBQXFCLGFBQXJCLENBQW1DLGFBQW5DLENBQXpCO0FBQ0EsU0FBSyxNQUFMLENBQVksVUFBWixDQUF1QixnQkFBdkIsQ0FBd0MsT0FBeEMsRUFBaUQsVUFBQSxDQUFDLEVBQUk7QUFDckQsVUFBSSxDQUFDLEtBQUksQ0FBQyxNQUFMLENBQVksSUFBakIsRUFBdUI7QUFDdEI7QUFDQTs7QUFFRCxVQUFJLENBQUMsS0FBSSxDQUFDLE1BQUwsQ0FBWSxTQUFaLEVBQUwsRUFBOEI7QUFDN0I7QUFDQTs7QUFDRCxNQUFBLEtBQUksQ0FBQyxJQUFMLENBQVUsSUFBVjtBQUNBLEtBVEQ7QUFVQSxTQUFLLE1BQUwsQ0FBWSxRQUFaLEdBQXVCLEtBQUssTUFBTCxDQUFZLFFBQVosQ0FBcUIsYUFBckIsQ0FBbUMsV0FBbkMsQ0FBdkI7QUFDQSxTQUFLLE1BQUwsQ0FBWSxRQUFaLENBQXFCLGdCQUFyQixDQUFzQyxPQUF0QyxFQUErQyxVQUFBLENBQUMsRUFBSTtBQUNuRCxVQUFJLENBQUMsS0FBSSxDQUFDLE1BQUwsQ0FBWSxPQUFaLEVBQUwsRUFBNEI7QUFDM0I7QUFDQTs7QUFFRCxNQUFBLEtBQUksQ0FBQyxJQUFMLENBQVUsS0FBVjtBQUNBLEtBTkQ7QUFPQSxHQXpDRCxDQXlDRSxPQUFPLENBQVAsRUFBVTtBQUNYLElBQUEsT0FBTyxDQUFDLEdBQVIsQ0FBWSxDQUFaO0FBQ0E7QUFDRDs7QUFFRCxLQUFLLENBQUMsU0FBTixDQUFnQixJQUFoQixHQUF1QixZQUFXO0FBQUE7O0FBQ2pDLFNBQU8sSUFBSSxPQUFKLENBQVksVUFBQyxPQUFELEVBQVUsTUFBVixFQUFxQjtBQUN2QyxRQUFJLE1BQUksQ0FBQyxNQUFMLENBQVksSUFBaEIsRUFBc0I7QUFDckI7QUFDQTs7QUFFRCxJQUFBLE1BQUksQ0FBQyxNQUFMLENBQVksUUFBWixDQUFxQixTQUFyQixDQUErQixNQUEvQixDQUFzQyxRQUF0Qzs7QUFDQSxJQUFBLFVBQVUsQ0FBQyxZQUFNO0FBQ2hCLE1BQUEsTUFBSSxDQUFDLE1BQUwsQ0FBWSxXQUFaLENBQXdCLFNBQXhCLENBQWtDLE1BQWxDLENBQXlDLFNBQXpDLEVBQW9ELGNBQXBELEVBQW9FLFdBQXBFOztBQUNBLE1BQUEsTUFBSSxDQUFDLE1BQUwsQ0FBWSxXQUFaLENBQXdCLFNBQXhCLENBQWtDLEdBQWxDLENBQXNDLFVBQXRDLEVBQWtELGNBQWxELEVBQWtFLGFBQWxFOztBQUVBLE1BQUEsTUFBSSxDQUFDLE1BQUwsQ0FBWSxVQUFaLENBQXVCLFNBQXZCLENBQWlDLE1BQWpDLENBQXdDLFNBQXhDLEVBQW1ELGNBQW5ELEVBQW1FLFdBQW5FLEVBQWdGLGVBQWhGLEVBQWlHLGtCQUFqRyxFQUFxSCxhQUFySDs7QUFDQSxNQUFBLE1BQUksQ0FBQyxNQUFMLENBQVksVUFBWixDQUF1QixTQUF2QixDQUFpQyxHQUFqQyxDQUFxQyxVQUFyQyxFQUFpRCxjQUFqRCxFQUFpRSxhQUFqRSxFQUFnRixlQUFoRixFQUFpRyxjQUFqRztBQUNBLEtBTlMsRUFNUCxFQU5PLENBQVY7QUFRQSxJQUFBLE1BQUksQ0FBQyxNQUFMLENBQVksSUFBWixHQUFtQixJQUFuQjtBQUNBLElBQUEsTUFBSSxDQUFDLE1BQUwsQ0FBWSxhQUFaLEdBQTRCLE9BQTVCOztBQUNBLElBQUEsTUFBSSxDQUFDLE1BQUwsQ0FBWSxNQUFaO0FBQ0EsR0FqQk0sQ0FBUDtBQWtCQSxDQW5CRDs7QUFxQkEsS0FBSyxDQUFDLFNBQU4sQ0FBZ0IsSUFBaEIsR0FBdUIsVUFBUyxRQUFULEVBQW1CO0FBQUE7O0FBQ3pDLE1BQUksQ0FBQyxLQUFLLE1BQUwsQ0FBWSxJQUFqQixFQUF1QjtBQUN0QjtBQUNBOztBQUVELE9BQUssTUFBTCxDQUFZLFdBQVosQ0FBd0IsU0FBeEIsQ0FBa0MsTUFBbEMsQ0FBeUMsVUFBekMsRUFBcUQsY0FBckQsRUFBcUUsYUFBckU7QUFDQSxPQUFLLE1BQUwsQ0FBWSxXQUFaLENBQXdCLFNBQXhCLENBQWtDLEdBQWxDLENBQXNDLFNBQXRDLEVBQWlELGNBQWpELEVBQWlFLFdBQWpFO0FBRUEsT0FBSyxNQUFMLENBQVksVUFBWixDQUF1QixTQUF2QixDQUFpQyxNQUFqQyxDQUF3QyxVQUF4QyxFQUFvRCxjQUFwRCxFQUFvRSxhQUFwRSxFQUFtRixlQUFuRixFQUFvRyxjQUFwRztBQUNBLE9BQUssTUFBTCxDQUFZLFVBQVosQ0FBdUIsU0FBdkIsQ0FBaUMsR0FBakMsQ0FBcUMsU0FBckMsRUFBZ0QsY0FBaEQsRUFBZ0UsV0FBaEUsRUFBNkUsZUFBN0UsRUFBOEYsa0JBQTlGLEVBQWtILGFBQWxIO0FBQ0EsRUFBQSxVQUFVLENBQUM7QUFBQSxXQUFNLE1BQUksQ0FBQyxNQUFMLENBQVksUUFBWixDQUFxQixTQUFyQixDQUErQixHQUEvQixDQUFtQyxRQUFuQyxDQUFOO0FBQUEsR0FBRCxFQUFxRCxHQUFyRCxDQUFWO0FBRUEsT0FBSyxNQUFMLENBQVksSUFBWixHQUFtQixLQUFuQjtBQUNBLE9BQUssTUFBTCxDQUFZLGFBQVosQ0FBMEIsS0FBSyxNQUFMLENBQVksU0FBWixDQUFzQixRQUF0QixDQUExQjtBQUNBLE9BQUssTUFBTCxDQUFZLGFBQVosR0FBNEIsU0FBNUI7QUFDQSxDQWZEOztBQWlCQSxLQUFLLENBQUMsU0FBTixDQUFnQixPQUFoQixHQUEwQixVQUFTLE1BQVQsRUFBaUI7QUFDMUMsT0FBSyxNQUFMLENBQVksVUFBWixDQUF1QixnQkFBdkIsQ0FBd0MsWUFBeEMsRUFBc0QsT0FBdEQsQ0FBOEQsVUFBQSxFQUFFO0FBQUEsV0FBSSxFQUFFLENBQUMsU0FBSCxHQUFlLE1BQW5CO0FBQUEsR0FBaEU7QUFFQSxTQUFPLEtBQUssSUFBTCxFQUFQO0FBQ0EsQ0FKRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGtCQUFrQixHQUFJLFlBQVk7QUFDckMsTUFBSSxRQUFKOztBQUVBLFdBQVMsY0FBVCxHQUEwQjtBQUN6QixRQUFJLGtCQUFrQixHQUFHLFNBQXJCLGtCQUFxQixHQUFXO0FBQ25DLFdBQUssVUFBTCxHQUFrQixFQUFsQjtBQUNBLFdBQUssU0FBTCxHQUFpQixTQUFqQjtBQUNBLEtBSEQ7O0FBSUEsSUFBQSxrQkFBa0IsQ0FBQyxTQUFuQixDQUE2QixJQUE3QixHQUFvQyxVQUFTLEdBQVQsRUFBYztBQUNqRCxXQUFLLEtBQUwsQ0FBVyxHQUFYO0FBRUEsVUFBSSxRQUFRLEdBQUcsS0FBSyxVQUFwQjtBQUNBLGFBQU8sS0FBSyxVQUFMLEdBQWtCLEdBQWxCLEVBQXVCLFFBQVEsS0FBSyxHQUEzQztBQUNBLEtBTEQsQ0FMeUIsQ0FXekI7OztBQUNBLElBQUEsa0JBQWtCLENBQUMsU0FBbkIsQ0FBNkIsS0FBN0IsR0FBcUMsVUFBUyxHQUFULEVBQWM7QUFBQTs7QUFDbEQsVUFBSSxDQUFDLEtBQUssU0FBVixFQUFxQjtBQUNwQixhQUFLLFNBQUwsR0FBaUIsVUFBVSxDQUFDLFlBQU07QUFDakMsVUFBQSxLQUFJLENBQUMsVUFBTCxHQUFrQixFQUFsQjtBQUNBLFVBQUEsS0FBSSxDQUFDLFNBQUwsR0FBaUIsU0FBakI7QUFDQSxTQUgwQixFQUd4QixJQUh3QixDQUEzQjtBQUlBLE9BTEQsTUFLTyxJQUFJLEdBQUcsSUFBSSxLQUFLLFVBQWhCLEVBQTRCO0FBQ2xDLGFBQUssU0FBTCxHQUFpQixZQUFZLENBQUMsS0FBSyxTQUFOLENBQTdCO0FBQ0EsYUFBSyxLQUFMO0FBQ0E7QUFDRCxLQVZEOztBQVlBLFdBQU8sSUFBSSxrQkFBSixFQUFQO0FBQ0E7O0FBRUQsU0FBTztBQUNOLElBQUEsV0FBVyxFQUFFLHVCQUFXO0FBQ3ZCLFVBQUksQ0FBQyxRQUFMLEVBQWU7QUFDZCxRQUFBLFFBQVEsR0FBRyxjQUFjLEVBQXpCO0FBQ0E7O0FBQ0QsYUFBTyxRQUFQO0FBQ0E7QUFOSyxHQUFQO0FBUUEsQ0F0Q3dCLEVBQXpCOztBQXdDQSxTQUFTLE1BQVQsR0FBMEQ7QUFBQSxNQUExQyxLQUEwQyx1RUFBbEMsT0FBa0M7QUFBQSxNQUF6QixJQUF5Qix1RUFBbEIsTUFBa0I7QUFBQSxNQUFWLEdBQVUsdUVBQUosRUFBSTtBQUN6RCxNQUFJLE1BQU0sR0FBRyxrQkFBa0IsQ0FBQyxXQUFuQixFQUFiOztBQUNBLE1BQUksTUFBTSxDQUFDLElBQVAsQ0FBWSxJQUFaLENBQUosRUFBdUI7QUFBRTtBQUFTOztBQUVsQyxNQUFJLE1BQU0sbUNBQ047QUFDRjtBQUNBLElBQUEsS0FBSyxFQUFFLEtBRkw7QUFHRjtBQUNBLElBQUEsSUFBSSxFQUFFLElBSko7QUFLRjtBQUNBLElBQUEsSUFBSSxFQUFFLE1BTko7QUFPRjtBQUNBLElBQUEsc0JBQXNCLEVBQUUsUUFBUSxDQUFDLGFBQVQsQ0FBdUIsZ0JBQXZCLENBUnRCO0FBU0Y7QUFDQSxJQUFBLGtCQUFrQixFQUFFLElBVmxCO0FBV0Y7QUFDQSxJQUFBLGlCQUFpQixFQUFFLEdBWmpCO0FBYUY7QUFDQSxJQUFBLFlBQVksRUFBRSxRQUFRLENBQUMsYUFBVCxDQUF1QixvQkFBdkIsRUFBNkMsU0FkekQ7QUFlRjtBQUNBLElBQUEscUJBQXFCLEVBQUUsWUFoQnJCO0FBaUJGO0FBQ0EsSUFBQSxxQkFBcUIsRUFBRSxjQWxCckI7QUFtQkY7QUFDQSxJQUFBLHFCQUFxQixFQUFFLGVBcEJyQjtBQXFCRjtBQUNBLElBQUEsdUJBQXVCLEVBQUU7QUF0QnZCLEdBRE0sR0F5Qk4sR0F6Qk0sQ0FBVjs7QUE0QkEsTUFBSSxVQUFVLEdBQUcsU0FBakI7QUFDQSxNQUFJLFdBQVcsR0FBRyxTQUFsQjs7QUFFQSxNQUFJLElBQUksR0FBRyxRQUFRLENBQUMsYUFBVCxDQUF1QixLQUF2QixDQUFYOztBQUNBLE1BQUksSUFBSSxHQUFHLE1BQU0sQ0FBQyxZQUFQLENBQW9CLEtBQXBCLENBQTBCLENBQTFCLENBQVg7QUFFQSxFQUFBLElBQUksQ0FBQyxTQUFMLEdBQWlCLElBQWpCO0FBQ0EsRUFBQSxJQUFJLEdBQUcsSUFBSSxDQUFDLGlCQUFaOztBQUNBLEVBQUEsSUFBSSxDQUFDLFNBQUwsQ0FBZSxHQUFmLENBQW1CLFFBQVEsTUFBTSxDQUFDLElBQWxDLEVBQXdDLE1BQU0sQ0FBQyxxQkFBL0M7O0FBRUEsRUFBQSxJQUFJLENBQUMsZ0JBQUwsQ0FBc0IsT0FBdEIsRUFBK0IsVUFBQSxDQUFDLEVBQUk7QUFDbkMsUUFBSSxVQUFVLEtBQUssU0FBbkIsRUFBOEI7QUFDN0IsTUFBQSxVQUFVLEdBQUcsWUFBWSxDQUFDLFVBQUQsQ0FBekI7QUFDQTs7QUFDRCxRQUFJLFdBQVcsS0FBSyxTQUFwQixFQUErQjtBQUM5QixNQUFBLFdBQVcsR0FBRyxZQUFZLENBQUMsV0FBRCxDQUExQjtBQUNBOztBQUVELElBQUEsSUFBSSxDQUFDLFNBQUwsQ0FBZSxHQUFmLENBQW1CLE1BQU0sQ0FBQyxxQkFBMUI7O0FBQ0EsSUFBQSxVQUFVLENBQUMsWUFBVztBQUNyQixNQUFBLElBQUksQ0FBQyxNQUFMO0FBQ0EsS0FGUyxFQUVQLE1BQU0sQ0FBQyxpQkFBUCxHQUF5QixFQUZsQixDQUFWO0FBR0EsR0FaRDs7QUFjQSxFQUFBLElBQUksQ0FBQyxnQkFBTCxDQUFzQixXQUF0QixFQUFtQyxVQUFTLENBQVQsRUFBWTtBQUM5QyxRQUFJLFVBQVUsS0FBSyxTQUFuQixFQUE4QjtBQUM3QixNQUFBLFVBQVUsR0FBRyxZQUFZLENBQUMsVUFBRCxDQUF6QjtBQUNBO0FBQ0QsR0FKRDs7QUFLQSxFQUFBLElBQUksQ0FBQyxnQkFBTCxDQUFzQixZQUF0QixFQUFvQyxVQUFTLENBQVQsRUFBWTtBQUMvQyxJQUFBLFVBQVUsR0FBRyxVQUFVLENBQUMsWUFBVztBQUNsQyxNQUFBLElBQUksQ0FBQyxLQUFMO0FBQ0EsS0FGc0IsRUFFcEIsTUFBTSxDQUFDLGtCQUZhLENBQXZCO0FBR0EsR0FKRDs7QUFNQSxNQUFJLFFBQVEsc0JBQVEsSUFBSSxDQUFDLGdCQUFMLENBQXNCLFdBQXRCLENBQVIsQ0FBWjs7QUFDQyxFQUFBLFFBQVEsQ0FBQyxPQUFULENBQWlCLFVBQUEsR0FBRyxFQUFJO0FBQ3ZCLElBQUEsR0FBRyxDQUFDLFNBQUosR0FBZ0IsR0FBaEI7QUFFQSxJQUFBLEdBQUcsQ0FBQyxTQUFKLENBQWMsR0FBZCxDQUFtQixNQUFNLENBQUMsSUFBUCxLQUFnQixTQUFoQixJQUE2QixNQUFNLENBQUMsSUFBUCxLQUFnQixNQUE3Qyx5QkFBc0UsTUFBTSxDQUFDLHFCQUE3RSwwQkFBd0gsTUFBTSxDQUFDLHVCQUEvSCxDQUFuQjtBQUVBLElBQUEsR0FBRyxDQUFDLGdCQUFKLENBQXFCLE9BQXJCLEVBQThCLFVBQUEsQ0FBQyxFQUFJO0FBQ2xDLE1BQUEsSUFBSSxDQUFDLEtBQUw7QUFDQSxLQUZEO0FBR0EsR0FSRDtBQVVELEdBQUUsT0FBRixFQUFXLE1BQVgsRUFBb0IsT0FBcEIsQ0FBNEIsVUFBQSxHQUFHLEVBQUk7QUFDbEMsUUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLGFBQUwsY0FBMEIsR0FBMUIsT0FBVDs7QUFDQSxJQUFBLEVBQUUsS0FBSyxFQUFFLENBQUMsU0FBSCxHQUFlLE1BQU0sQ0FBQyxHQUFELENBQTFCLENBQUY7QUFDQSxHQUhEOztBQUtBLE1BQUksSUFBSSxHQUFHLElBQUksQ0FBQyxhQUFMLG1CQUErQixNQUFNLENBQUMsSUFBdEMsT0FBWDs7QUFDQSxFQUFBLElBQUksSUFBSSxJQUFJLENBQUMsU0FBTCxDQUFlLE1BQWYsQ0FBc0IsUUFBdEIsQ0FBUjtBQUVBLEdBQUMsQ0FBQyxNQUFNLENBQUMsc0JBQVQsSUFBbUMsTUFBTSxDQUFDLHNCQUFQLENBQThCLE9BQTlCLENBQXNDLElBQXRDLENBQW5DO0FBRUEsRUFBQSxXQUFXLEdBQUcsVUFBVSxDQUFDLFlBQVc7QUFDbkMsSUFBQSxJQUFJLENBQUMsU0FBTCxDQUFlLE1BQWYsQ0FBc0IsTUFBTSxDQUFDLHFCQUE3QjtBQUNBLEdBRnVCLEVBRXJCLE1BQU0sQ0FBQyxpQkFBUCxHQUF5QixFQUZKLENBQXhCLENBeEZ5RCxDQTRGekQ7O0FBQ0EsRUFBQSxJQUFJLENBQUMsYUFBTCxDQUFtQixJQUFJLEtBQUosQ0FBVSxZQUFWLENBQW5CO0FBQ0EsQyxDQUdEOzs7QUFDQSxJQUFJLGFBQWEsR0FBSSxZQUFNO0FBQzFCLEVBQUEsTUFBTSxDQUFDLE1BQVAsR0FBZ0IsWUFBbUQ7QUFBQSxRQUExQyxLQUEwQyx1RUFBbEMsT0FBa0M7QUFBQSxRQUF6QixJQUF5Qix1RUFBbEIsTUFBa0I7QUFBQSxRQUFWLEdBQVUsdUVBQUosRUFBSTtBQUNsRSxXQUFPLE1BQU0sQ0FBQyxLQUFELEVBQVEsSUFBUjtBQUFnQixNQUFBLElBQUksRUFBRTtBQUF0QixPQUFtQyxHQUFuQyxFQUFiO0FBQ0EsR0FGRDs7QUFHQSxFQUFBLE1BQU0sQ0FBQyxJQUFQLEdBQWMsWUFBbUQ7QUFBQSxRQUExQyxLQUEwQyx1RUFBbEMsT0FBa0M7QUFBQSxRQUF6QixJQUF5Qix1RUFBbEIsTUFBa0I7QUFBQSxRQUFWLEdBQVUsdUVBQUosRUFBSTtBQUNoRSxXQUFPLE1BQU0sQ0FBQyxLQUFELEVBQVEsSUFBUjtBQUFnQixNQUFBLElBQUksRUFBRTtBQUF0QixPQUFpQyxHQUFqQyxFQUFiO0FBQ0EsR0FGRDs7QUFHQSxFQUFBLE1BQU0sQ0FBQyxPQUFQLEdBQWlCLFlBQW1EO0FBQUEsUUFBMUMsS0FBMEMsdUVBQWxDLE9BQWtDO0FBQUEsUUFBekIsSUFBeUIsdUVBQWxCLE1BQWtCO0FBQUEsUUFBVixHQUFVLHVFQUFKLEVBQUk7QUFDbkUsV0FBTyxNQUFNLENBQUMsS0FBRCxFQUFRLElBQVI7QUFBZ0IsTUFBQSxJQUFJLEVBQUU7QUFBdEIsT0FBb0MsR0FBcEMsRUFBYjtBQUNBLEdBRkQ7O0FBR0EsRUFBQSxNQUFNLENBQUMsT0FBUCxHQUFpQixZQUFtRDtBQUFBLFFBQTFDLEtBQTBDLHVFQUFsQyxPQUFrQztBQUFBLFFBQXpCLElBQXlCLHVFQUFsQixNQUFrQjtBQUFBLFFBQVYsR0FBVSx1RUFBSixFQUFJO0FBQ25FLFdBQU8sTUFBTSxDQUFDLEtBQUQsRUFBUSxJQUFSO0FBQWdCLE1BQUEsSUFBSSxFQUFFO0FBQXRCLE9BQW9DLEdBQXBDLEVBQWI7QUFDQSxHQUZEOztBQUlBLFNBQU8sTUFBUDtBQUNBLENBZm1CLEVBQXBCOztlQWlCZSxhOzs7Ozs7Ozs7OztBQ2pLZjs7Ozs7Ozs7Ozs7O0FBRWUsU0FBUyxTQUFULENBQW1CLE1BQW5CLEVBQTJCO0FBQ3pDLE1BQUksRUFBRSxnQkFBZ0IsU0FBbEIsQ0FBSixFQUFrQztBQUNqQyxXQUFPLElBQUksU0FBSixDQUFjLE1BQWQsQ0FBUDtBQUNBOztBQUVELE9BQUssTUFBTCxtQ0FDSTtBQUNGLElBQUEsWUFBWSxFQUFFO0FBRFosR0FESixHQUlJLE1BSko7QUFNQSxPQUFLLE1BQUwsR0FBYyxTQUFkO0FBQ0E7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTLENBQUMsU0FBVixDQUFvQixNQUFwQixHQUE2QixVQUFTLElBQVQsRUFBZSxLQUFmLEVBQWdFO0FBQUEsTUFBMUMsT0FBMEMsdUVBQWhDLEdBQWdDO0FBQUEsTUFBM0Isa0JBQTJCLHVFQUFOLElBQU07O0FBQzVGLE1BQUksS0FBSyxNQUFMLENBQVksWUFBWixLQUE2QixTQUFqQyxFQUE0QztBQUMzQyxnQkFBVyxLQUFLLE1BQUwsQ0FBWSxZQUFaLENBQXlCLElBQXpCLE1BQW1DLFdBQTlDLEdBQTREO0FBQzNELFdBQUssTUFBTCxDQUFZLFlBQVosQ0FBeUIsSUFBekIsRUFBK0IsS0FBL0IsRUFBc0MsT0FBdEMsRUFBK0M7QUFBRSxRQUFBLGtCQUFrQixFQUFsQjtBQUFGLE9BQS9DO0FBQ0EsS0FGRCxNQUVPO0FBQ04sV0FBSyxNQUFMLENBQVksWUFBWixDQUF5QixLQUF6QixFQUFnQyxPQUFoQyxFQUF5QztBQUFFLFFBQUEsa0JBQWtCLEVBQWxCO0FBQUYsT0FBekM7QUFDQTtBQUNEO0FBQ0QsQ0FSRDtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVMsQ0FBQyxTQUFWLENBQW9CLFlBQXBCLEdBQW1DLFVBQVMsU0FBVCxFQUFvQjtBQUN0RCxVQUFRLFNBQVMsQ0FBQyxNQUFWLENBQWlCLENBQWpCLEVBQW9CLEVBQXBCLEVBQXdCLFdBQXhCLEVBQVI7QUFDQyxTQUFLLGFBQUw7QUFDQyxXQUFLLE1BQUwsR0FBYyxJQUFJLGtCQUFKLENBQVc7QUFBRSxRQUFBLE1BQU0sRUFBRTtBQUFWLE9BQVgsQ0FBZDs7QUFDQSxVQUFJLENBQUMsS0FBSyxNQUFMLENBQVksT0FBWixDQUFvQixTQUFwQixDQUFMLEVBQXFDO0FBQ3BDLGFBQUssTUFBTCxHQUFjLFNBQWQ7QUFDQTs7QUFDRjs7QUFFQTtBQUNDLFdBQUssTUFBTCxHQUFjLFNBQWQ7QUFDRDtBQVZEOztBQWFBLFNBQU8sS0FBSyxNQUFaO0FBQ0EsQ0FmRCIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIHN0YXRlID0gcmVxdWlyZSgnQGNvZGVtaXJyb3Ivc3RhdGUnKTtcbnZhciB2aWV3ID0gcmVxdWlyZSgnQGNvZGVtaXJyb3IvdmlldycpO1xudmFyIHRvb2x0aXAgPSByZXF1aXJlKCdAY29kZW1pcnJvci90b29sdGlwJyk7XG52YXIgbGFuZ3VhZ2UgPSByZXF1aXJlKCdAY29kZW1pcnJvci9sYW5ndWFnZScpO1xudmFyIHRleHQgPSByZXF1aXJlKCdAY29kZW1pcnJvci90ZXh0Jyk7XG5cbi8qKlxuQW4gaW5zdGFuY2Ugb2YgdGhpcyBpcyBwYXNzZWQgdG8gY29tcGxldGlvbiBzb3VyY2UgZnVuY3Rpb25zLlxuKi9cbmNsYXNzIENvbXBsZXRpb25Db250ZXh0IHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgY29tcGxldGlvbiBjb250ZXh0LiAoTW9zdGx5IHVzZWZ1bCBmb3IgdGVzdGluZ1xuICAgIGNvbXBsZXRpb24gc291cmNlc+KAlGluIHRoZSBlZGl0b3IsIHRoZSBleHRlbnNpb24gd2lsbCBjcmVhdGVcbiAgICB0aGVzZSBmb3IgeW91LilcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBlZGl0b3Igc3RhdGUgdGhhdCB0aGUgY29tcGxldGlvbiBoYXBwZW5zIGluLlxuICAgICovXG4gICAgc3RhdGUsIFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBhdCB3aGljaCB0aGUgY29tcGxldGlvbiBpcyBoYXBwZW5pbmcuXG4gICAgKi9cbiAgICBwb3MsIFxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIGNvbXBsZXRpb24gd2FzIGFjdGl2YXRlZCBleHBsaWNpdGx5LCBvclxuICAgIGltcGxpY2l0bHkgYnkgdHlwaW5nLiBUaGUgdXN1YWwgd2F5IHRvIHJlc3BvbmQgdG8gdGhpcyBpcyB0b1xuICAgIG9ubHkgcmV0dXJuIGNvbXBsZXRpb25zIHdoZW4gZWl0aGVyIHRoZXJlIGlzIHBhcnQgb2YgYVxuICAgIGNvbXBsZXRhYmxlIGVudGl0eSBiZWZvcmUgdGhlIGN1cnNvciwgb3IgYGV4cGxpY2l0YCBpcyB0cnVlLlxuICAgICovXG4gICAgZXhwbGljaXQpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5leHBsaWNpdCA9IGV4cGxpY2l0O1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuYWJvcnRMaXN0ZW5lcnMgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBleHRlbnQsIGNvbnRlbnQsIGFuZCAoaWYgdGhlcmUgaXMgYSB0b2tlbikgdHlwZSBvZiB0aGVcbiAgICB0b2tlbiBiZWZvcmUgYHRoaXMucG9zYC5cbiAgICAqL1xuICAgIHRva2VuQmVmb3JlKHR5cGVzKSB7XG4gICAgICAgIGxldCB0b2tlbiA9IGxhbmd1YWdlLnN5bnRheFRyZWUodGhpcy5zdGF0ZSkucmVzb2x2ZSh0aGlzLnBvcywgLTEpO1xuICAgICAgICB3aGlsZSAodG9rZW4gJiYgdHlwZXMuaW5kZXhPZih0b2tlbi5uYW1lKSA8IDApXG4gICAgICAgICAgICB0b2tlbiA9IHRva2VuLnBhcmVudDtcbiAgICAgICAgcmV0dXJuIHRva2VuID8geyBmcm9tOiB0b2tlbi5mcm9tLCB0bzogdGhpcy5wb3MsXG4gICAgICAgICAgICB0ZXh0OiB0aGlzLnN0YXRlLnNsaWNlRG9jKHRva2VuLmZyb20sIHRoaXMucG9zKSxcbiAgICAgICAgICAgIHR5cGU6IHRva2VuLnR5cGUgfSA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgbWF0Y2ggb2YgdGhlIGdpdmVuIGV4cHJlc3Npb24gZGlyZWN0bHkgYmVmb3JlIHRoZVxuICAgIGN1cnNvci5cbiAgICAqL1xuICAgIG1hdGNoQmVmb3JlKGV4cHIpIHtcbiAgICAgICAgbGV0IGxpbmUgPSB0aGlzLnN0YXRlLmRvYy5saW5lQXQodGhpcy5wb3MpO1xuICAgICAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChsaW5lLmZyb20sIHRoaXMucG9zIC0gMjUwKTtcbiAgICAgICAgbGV0IHN0ciA9IGxpbmUudGV4dC5zbGljZShzdGFydCAtIGxpbmUuZnJvbSwgdGhpcy5wb3MgLSBsaW5lLmZyb20pO1xuICAgICAgICBsZXQgZm91bmQgPSBzdHIuc2VhcmNoKGVuc3VyZUFuY2hvcihleHByLCBmYWxzZSkpO1xuICAgICAgICByZXR1cm4gZm91bmQgPCAwID8gbnVsbCA6IHsgZnJvbTogc3RhcnQgKyBmb3VuZCwgdG86IHRoaXMucG9zLCB0ZXh0OiBzdHIuc2xpY2UoZm91bmQpIH07XG4gICAgfVxuICAgIC8qKlxuICAgIFlpZWxkcyB0cnVlIHdoZW4gdGhlIHF1ZXJ5IGhhcyBiZWVuIGFib3J0ZWQuIENhbiBiZSB1c2VmdWwgaW5cbiAgICBhc3luY2hyb25vdXMgcXVlcmllcyB0byBhdm9pZCBkb2luZyB3b3JrIHRoYXQgd2lsbCBiZSBpZ25vcmVkLlxuICAgICovXG4gICAgZ2V0IGFib3J0ZWQoKSB7IHJldHVybiB0aGlzLmFib3J0TGlzdGVuZXJzID09IG51bGw7IH1cbiAgICAvKipcbiAgICBBbGxvd3MgeW91IHRvIHJlZ2lzdGVyIGFib3J0IGhhbmRsZXJzLCB3aGljaCB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gICAgdGhlIHF1ZXJ5IGlzXG4gICAgW2Fib3J0ZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLkNvbXBsZXRpb25Db250ZXh0LmFib3J0ZWQpLlxuICAgICovXG4gICAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICBpZiAodHlwZSA9PSBcImFib3J0XCIgJiYgdGhpcy5hYm9ydExpc3RlbmVycylcbiAgICAgICAgICAgIHRoaXMuYWJvcnRMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgfVxufVxuZnVuY3Rpb24gdG9TZXQoY2hhcnMpIHtcbiAgICBsZXQgZmxhdCA9IE9iamVjdC5rZXlzKGNoYXJzKS5qb2luKFwiXCIpO1xuICAgIGxldCB3b3JkcyA9IC9cXHcvLnRlc3QoZmxhdCk7XG4gICAgaWYgKHdvcmRzKVxuICAgICAgICBmbGF0ID0gZmxhdC5yZXBsYWNlKC9cXHcvZywgXCJcIik7XG4gICAgcmV0dXJuIGBbJHt3b3JkcyA/IFwiXFxcXHdcIiA6IFwiXCJ9JHtmbGF0LnJlcGxhY2UoL1teXFx3XFxzXS9nLCBcIlxcXFwkJlwiKX1dYDtcbn1cbmZ1bmN0aW9uIHByZWZpeE1hdGNoKG9wdGlvbnMpIHtcbiAgICBsZXQgZmlyc3QgPSBPYmplY3QuY3JlYXRlKG51bGwpLCByZXN0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGxldCB7IGxhYmVsIH0gb2Ygb3B0aW9ucykge1xuICAgICAgICBmaXJzdFtsYWJlbFswXV0gPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxhYmVsLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcmVzdFtsYWJlbFtpXV0gPSB0cnVlO1xuICAgIH1cbiAgICBsZXQgc291cmNlID0gdG9TZXQoZmlyc3QpICsgdG9TZXQocmVzdCkgKyBcIiokXCI7XG4gICAgcmV0dXJuIFtuZXcgUmVnRXhwKFwiXlwiICsgc291cmNlKSwgbmV3IFJlZ0V4cChzb3VyY2UpXTtcbn1cbi8qKlxuR2l2ZW4gYSBhIGZpeGVkIGFycmF5IG9mIG9wdGlvbnMsIHJldHVybiBhbiBhdXRvY29tcGxldGVyIHRoYXRcbmNvbXBsZXRlcyB0aGVtLlxuKi9cbmZ1bmN0aW9uIGNvbXBsZXRlRnJvbUxpc3QobGlzdCkge1xuICAgIGxldCBvcHRpb25zID0gbGlzdC5tYXAobyA9PiB0eXBlb2YgbyA9PSBcInN0cmluZ1wiID8geyBsYWJlbDogbyB9IDogbyk7XG4gICAgbGV0IFtzcGFuLCBtYXRjaF0gPSBvcHRpb25zLmV2ZXJ5KG8gPT4gL15cXHcrJC8udGVzdChvLmxhYmVsKSkgPyBbL1xcdyokLywgL1xcdyskL10gOiBwcmVmaXhNYXRjaChvcHRpb25zKTtcbiAgICByZXR1cm4gKGNvbnRleHQpID0+IHtcbiAgICAgICAgbGV0IHRva2VuID0gY29udGV4dC5tYXRjaEJlZm9yZShtYXRjaCk7XG4gICAgICAgIHJldHVybiB0b2tlbiB8fCBjb250ZXh0LmV4cGxpY2l0ID8geyBmcm9tOiB0b2tlbiA/IHRva2VuLmZyb20gOiBjb250ZXh0LnBvcywgb3B0aW9ucywgc3BhbiB9IDogbnVsbDtcbiAgICB9O1xufVxuLyoqXG5XcmFwIHRoZSBnaXZlbiBjb21wbGV0aW9uIHNvdXJjZSBzbyB0aGF0IGl0IHdpbGwgbm90IGZpcmUgd2hlbiB0aGVcbmN1cnNvciBpcyBpbiBhIHN5bnRheCBub2RlIHdpdGggb25lIG9mIHRoZSBnaXZlbiBuYW1lcy5cbiovXG5mdW5jdGlvbiBpZk5vdEluKG5vZGVzLCBzb3VyY2UpIHtcbiAgICByZXR1cm4gKGNvbnRleHQpID0+IHtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gbGFuZ3VhZ2Uuc3ludGF4VHJlZShjb250ZXh0LnN0YXRlKS5yZXNvbHZlKGNvbnRleHQucG9zLCAtMSk7IHBvczsgcG9zID0gcG9zLnBhcmVudClcbiAgICAgICAgICAgIGlmIChub2Rlcy5pbmRleE9mKHBvcy5uYW1lKSA+IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gc291cmNlKGNvbnRleHQpO1xuICAgIH07XG59XG5jbGFzcyBPcHRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGNvbXBsZXRpb24sIHNvdXJjZSwgbWF0Y2gpIHtcbiAgICAgICAgdGhpcy5jb21wbGV0aW9uID0gY29tcGxldGlvbjtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMubWF0Y2ggPSBtYXRjaDtcbiAgICB9XG59XG5mdW5jdGlvbiBjdXIoc3RhdGUpIHsgcmV0dXJuIHN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQ7IH1cbi8vIE1ha2Ugc3VyZSB0aGUgZ2l2ZW4gcmVnZXhwIGhhcyBhICQgYXQgaXRzIGVuZCBhbmQsIGlmIGBzdGFydGAgaXNcbi8vIHRydWUsIGEgXiBhdCBpdHMgc3RhcnQuXG5mdW5jdGlvbiBlbnN1cmVBbmNob3IoZXhwciwgc3RhcnQpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHsgc291cmNlIH0gPSBleHByO1xuICAgIGxldCBhZGRTdGFydCA9IHN0YXJ0ICYmIHNvdXJjZVswXSAhPSBcIl5cIiwgYWRkRW5kID0gc291cmNlW3NvdXJjZS5sZW5ndGggLSAxXSAhPSBcIiRcIjtcbiAgICBpZiAoIWFkZFN0YXJ0ICYmICFhZGRFbmQpXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKGAke2FkZFN0YXJ0ID8gXCJeXCIgOiBcIlwifSg/OiR7c291cmNlfSkke2FkZEVuZCA/IFwiJFwiIDogXCJcIn1gLCAoX2EgPSBleHByLmZsYWdzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoZXhwci5pZ25vcmVDYXNlID8gXCJpXCIgOiBcIlwiKSk7XG59XG5mdW5jdGlvbiBhcHBseUNvbXBsZXRpb24odmlldywgb3B0aW9uKSB7XG4gICAgbGV0IGFwcGx5ID0gb3B0aW9uLmNvbXBsZXRpb24uYXBwbHkgfHwgb3B0aW9uLmNvbXBsZXRpb24ubGFiZWw7XG4gICAgbGV0IHJlc3VsdCA9IG9wdGlvbi5zb3VyY2U7XG4gICAgaWYgKHR5cGVvZiBhcHBseSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICAgICAgY2hhbmdlczogeyBmcm9tOiByZXN1bHQuZnJvbSwgdG86IHJlc3VsdC50bywgaW5zZXJ0OiBhcHBseSB9LFxuICAgICAgICAgICAgc2VsZWN0aW9uOiB7IGFuY2hvcjogcmVzdWx0LmZyb20gKyBhcHBseS5sZW5ndGggfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFwcGx5KHZpZXcsIG9wdGlvbi5jb21wbGV0aW9uLCByZXN1bHQuZnJvbSwgcmVzdWx0LnRvKTtcbiAgICB9XG59XG5jb25zdCBTb3VyY2VDYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBhc1NvdXJjZShzb3VyY2UpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc291cmNlKSlcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICBsZXQga25vd24gPSBTb3VyY2VDYWNoZS5nZXQoc291cmNlKTtcbiAgICBpZiAoIWtub3duKVxuICAgICAgICBTb3VyY2VDYWNoZS5zZXQoc291cmNlLCBrbm93biA9IGNvbXBsZXRlRnJvbUxpc3Qoc291cmNlKSk7XG4gICAgcmV0dXJuIGtub3duO1xufVxuXG4vLyBBIHBhdHRlcm4gbWF0Y2hlciBmb3IgZnV6enkgY29tcGxldGlvbiBtYXRjaGluZy4gQ3JlYXRlIGFuIGluc3RhbmNlXG4vLyBvbmNlIGZvciBhIHBhdHRlcm4sIGFuZCB0aGVuIHVzZSB0aGF0IHRvIG1hdGNoIGFueSBudW1iZXIgb2Zcbi8vIGNvbXBsZXRpb25zLlxuY2xhc3MgRnV6enlNYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgICAgIHRoaXMucGF0dGVybiA9IHBhdHRlcm47XG4gICAgICAgIHRoaXMuY2hhcnMgPSBbXTtcbiAgICAgICAgdGhpcy5mb2xkZWQgPSBbXTtcbiAgICAgICAgLy8gQnVmZmVycyByZXVzZWQgYnkgY2FsbHMgdG8gYG1hdGNoYCB0byB0cmFjayBtYXRjaGVkIGNoYXJhY3RlclxuICAgICAgICAvLyBwb3NpdGlvbnMuXG4gICAgICAgIHRoaXMuYW55ID0gW107XG4gICAgICAgIHRoaXMucHJlY2lzZSA9IFtdO1xuICAgICAgICB0aGlzLmJ5V29yZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IHBhdHRlcm4ubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGNoYXIgPSB0ZXh0LmNvZGVQb2ludEF0KHBhdHRlcm4sIHApLCBzaXplID0gdGV4dC5jb2RlUG9pbnRTaXplKGNoYXIpO1xuICAgICAgICAgICAgdGhpcy5jaGFycy5wdXNoKGNoYXIpO1xuICAgICAgICAgICAgbGV0IHBhcnQgPSBwYXR0ZXJuLnNsaWNlKHAsIHAgKyBzaXplKSwgdXBwZXIgPSBwYXJ0LnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB0aGlzLmZvbGRlZC5wdXNoKHRleHQuY29kZVBvaW50QXQodXBwZXIgPT0gcGFydCA/IHBhcnQudG9Mb3dlckNhc2UoKSA6IHVwcGVyLCAwKSk7XG4gICAgICAgICAgICBwICs9IHNpemU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hc3RyYWwgPSBwYXR0ZXJuLmxlbmd0aCAhPSB0aGlzLmNoYXJzLmxlbmd0aDtcbiAgICB9XG4gICAgLy8gTWF0Y2hlcyBhIGdpdmVuIHdvcmQgKGNvbXBsZXRpb24pIGFnYWluc3QgdGhlIHBhdHRlcm4gKGlucHV0KS5cbiAgICAvLyBXaWxsIHJldHVybiBudWxsIGZvciBubyBtYXRjaCwgYW5kIG90aGVyd2lzZSBhbiBhcnJheSB0aGF0IHN0YXJ0c1xuICAgIC8vIHdpdGggdGhlIG1hdGNoIHNjb3JlLCBmb2xsb3dlZCBieSBhbnkgbnVtYmVyIG9mIGBmcm9tLCB0b2AgcGFpcnNcbiAgICAvLyBpbmRpY2F0aW5nIHRoZSBtYXRjaGVkIHBhcnRzIG9mIGB3b3JkYC5cbiAgICAvL1xuICAgIC8vIFRoZSBzY29yZSBpcyBhIG51bWJlciB0aGF0IGlzIG1vcmUgbmVnYXRpdmUgdGhlIHdvcnNlIHRoZSBtYXRjaFxuICAgIC8vIGlzLiBTZWUgYFBlbmFsdHlgIGFib3ZlLlxuICAgIG1hdGNoKHdvcmQpIHtcbiAgICAgICAgaWYgKHRoaXMucGF0dGVybi5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiBbMF07XG4gICAgICAgIGlmICh3b3JkLmxlbmd0aCA8IHRoaXMucGF0dGVybi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHsgY2hhcnMsIGZvbGRlZCwgYW55LCBwcmVjaXNlLCBieVdvcmQgfSA9IHRoaXM7XG4gICAgICAgIC8vIEZvciBzaW5nbGUtY2hhcmFjdGVyIHF1ZXJpZXMsIG9ubHkgbWF0Y2ggd2hlbiB0aGV5IG9jY3VyIHJpZ2h0XG4gICAgICAgIC8vIGF0IHRoZSBzdGFydFxuICAgICAgICBpZiAoY2hhcnMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IHRleHQuY29kZVBvaW50QXQod29yZCwgMCk7XG4gICAgICAgICAgICByZXR1cm4gZmlyc3QgPT0gY2hhcnNbMF0gPyBbMCwgMCwgdGV4dC5jb2RlUG9pbnRTaXplKGZpcnN0KV1cbiAgICAgICAgICAgICAgICA6IGZpcnN0ID09IGZvbGRlZFswXSA/IFstMjAwIC8qIENhc2VGb2xkICovLCAwLCB0ZXh0LmNvZGVQb2ludFNpemUoZmlyc3QpXSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRpcmVjdCA9IHdvcmQuaW5kZXhPZih0aGlzLnBhdHRlcm4pO1xuICAgICAgICBpZiAoZGlyZWN0ID09IDApXG4gICAgICAgICAgICByZXR1cm4gWzAsIDAsIHRoaXMucGF0dGVybi5sZW5ndGhdO1xuICAgICAgICBsZXQgbGVuID0gY2hhcnMubGVuZ3RoLCBhbnlUbyA9IDA7XG4gICAgICAgIGlmIChkaXJlY3QgPCAwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgZSA9IE1hdGgubWluKHdvcmQubGVuZ3RoLCAyMDApOyBpIDwgZSAmJiBhbnlUbyA8IGxlbjspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHRleHQuY29kZVBvaW50QXQod29yZCwgaSk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgPT0gY2hhcnNbYW55VG9dIHx8IG5leHQgPT0gZm9sZGVkW2FueVRvXSlcbiAgICAgICAgICAgICAgICAgICAgYW55W2FueVRvKytdID0gaTtcbiAgICAgICAgICAgICAgICBpICs9IHRleHQuY29kZVBvaW50U2l6ZShuZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vIG1hdGNoLCBleGl0IGltbWVkaWF0ZWx5XG4gICAgICAgICAgICBpZiAoYW55VG8gPCBsZW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhpcyB0cmFja3MgdGhlIGV4dGVudCBvZiB0aGUgcHJlY2lzZSAobm9uLWZvbGRlZCwgbm90XG4gICAgICAgIC8vIG5lY2Vzc2FyaWx5IGFkamFjZW50KSBtYXRjaFxuICAgICAgICBsZXQgcHJlY2lzZVRvID0gMDtcbiAgICAgICAgLy8gVHJhY2tzIHdoZXRoZXIgdGhlcmUgaXMgYSBtYXRjaCB0aGF0IGhpdHMgb25seSBjaGFyYWN0ZXJzIHRoYXRcbiAgICAgICAgLy8gYXBwZWFyIHRvIGJlIHN0YXJ0aW5nIHdvcmRzLiBgYnlXb3JkRm9sZGVkYCBpcyBzZXQgdG8gdHJ1ZSB3aGVuXG4gICAgICAgIC8vIGEgY2FzZSBmb2xkZWQgY2hhcmFjdGVyIGlzIGVuY291bnRlcmVkIGluIHN1Y2ggYSBtYXRjaFxuICAgICAgICBsZXQgYnlXb3JkVG8gPSAwLCBieVdvcmRGb2xkZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gSWYgd2UndmUgZm91bmQgYSBwYXJ0aWFsIGFkamFjZW50IG1hdGNoLCB0aGVzZSB0cmFjayBpdHMgc3RhdGVcbiAgICAgICAgbGV0IGFkamFjZW50VG8gPSAwLCBhZGphY2VudFN0YXJ0ID0gLTEsIGFkamFjZW50RW5kID0gLTE7XG4gICAgICAgIGxldCBoYXNMb3dlciA9IC9bYS16XS8udGVzdCh3b3JkKTtcbiAgICAgICAgLy8gR28gb3ZlciB0aGUgb3B0aW9uJ3MgdGV4dCwgc2Nhbm5pbmcgZm9yIHRoZSB2YXJpb3VzIGtpbmRzIG9mIG1hdGNoZXNcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGUgPSBNYXRoLm1pbih3b3JkLmxlbmd0aCwgMjAwKSwgcHJldlR5cGUgPSAwIC8qIE5vbldvcmQgKi87IGkgPCBlICYmIGJ5V29yZFRvIDwgbGVuOykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSB0ZXh0LmNvZGVQb2ludEF0KHdvcmQsIGkpO1xuICAgICAgICAgICAgaWYgKGRpcmVjdCA8IDApIHtcbiAgICAgICAgICAgICAgICBpZiAocHJlY2lzZVRvIDwgbGVuICYmIG5leHQgPT0gY2hhcnNbcHJlY2lzZVRvXSlcbiAgICAgICAgICAgICAgICAgICAgcHJlY2lzZVtwcmVjaXNlVG8rK10gPSBpO1xuICAgICAgICAgICAgICAgIGlmIChhZGphY2VudFRvIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID09IGNoYXJzW2FkamFjZW50VG9dIHx8IG5leHQgPT0gZm9sZGVkW2FkamFjZW50VG9dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRqYWNlbnRUbyA9PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkamFjZW50U3RhcnQgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRqYWNlbnRFbmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRqYWNlbnRUbysrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRqYWNlbnRUbyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY2gsIHR5cGUgPSBuZXh0IDwgMHhmZlxuICAgICAgICAgICAgICAgID8gKG5leHQgPj0gNDggJiYgbmV4dCA8PSA1NyB8fCBuZXh0ID49IDk3ICYmIG5leHQgPD0gMTIyID8gMiAvKiBMb3dlciAqLyA6IG5leHQgPj0gNjUgJiYgbmV4dCA8PSA5MCA/IDEgLyogVXBwZXIgKi8gOiAwIC8qIE5vbldvcmQgKi8pXG4gICAgICAgICAgICAgICAgOiAoKGNoID0gdGV4dC5mcm9tQ29kZVBvaW50KG5leHQpKSAhPSBjaC50b0xvd2VyQ2FzZSgpID8gMSAvKiBVcHBlciAqLyA6IGNoICE9IGNoLnRvVXBwZXJDYXNlKCkgPyAyIC8qIExvd2VyICovIDogMCAvKiBOb25Xb3JkICovKTtcbiAgICAgICAgICAgIGlmICgodHlwZSA9PSAxIC8qIFVwcGVyICovICYmIGhhc0xvd2VyIHx8IHByZXZUeXBlID09IDAgLyogTm9uV29yZCAqLyAmJiB0eXBlICE9IDAgLyogTm9uV29yZCAqLykgJiZcbiAgICAgICAgICAgICAgICAoY2hhcnNbYnlXb3JkVG9dID09IG5leHQgfHwgKGZvbGRlZFtieVdvcmRUb10gPT0gbmV4dCAmJiAoYnlXb3JkRm9sZGVkID0gdHJ1ZSkpKSlcbiAgICAgICAgICAgICAgICBieVdvcmRbYnlXb3JkVG8rK10gPSBpO1xuICAgICAgICAgICAgcHJldlR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgaSArPSB0ZXh0LmNvZGVQb2ludFNpemUobmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ5V29yZFRvID09IGxlbiAmJiBieVdvcmRbMF0gPT0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdCgtMTAwIC8qIEJ5V29yZCAqLyArIChieVdvcmRGb2xkZWQgPyAtMjAwIC8qIENhc2VGb2xkICovIDogMCksIGJ5V29yZCwgd29yZCk7XG4gICAgICAgIGlmIChhZGphY2VudFRvID09IGxlbiAmJiBhZGphY2VudFN0YXJ0ID09IDApXG4gICAgICAgICAgICByZXR1cm4gWy0yMDAgLyogQ2FzZUZvbGQgKi8sIDAsIGFkamFjZW50RW5kXTtcbiAgICAgICAgaWYgKGRpcmVjdCA+IC0xKVxuICAgICAgICAgICAgcmV0dXJuIFstNzAwIC8qIE5vdFN0YXJ0ICovLCBkaXJlY3QsIGRpcmVjdCArIHRoaXMucGF0dGVybi5sZW5ndGhdO1xuICAgICAgICBpZiAoYWRqYWNlbnRUbyA9PSBsZW4pXG4gICAgICAgICAgICByZXR1cm4gWy0yMDAgLyogQ2FzZUZvbGQgKi8gKyAtNzAwIC8qIE5vdFN0YXJ0ICovLCBhZGphY2VudFN0YXJ0LCBhZGphY2VudEVuZF07XG4gICAgICAgIGlmIChieVdvcmRUbyA9PSBsZW4pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQoLTEwMCAvKiBCeVdvcmQgKi8gKyAoYnlXb3JkRm9sZGVkID8gLTIwMCAvKiBDYXNlRm9sZCAqLyA6IDApICsgLTcwMCAvKiBOb3RTdGFydCAqLywgYnlXb3JkLCB3b3JkKTtcbiAgICAgICAgcmV0dXJuIGNoYXJzLmxlbmd0aCA9PSAyID8gbnVsbCA6IHRoaXMucmVzdWx0KChhbnlbMF0gPyAtNzAwIC8qIE5vdFN0YXJ0ICovIDogMCkgKyAtMjAwIC8qIENhc2VGb2xkICovICsgLTExMDAgLyogR2FwICovLCBhbnksIHdvcmQpO1xuICAgIH1cbiAgICByZXN1bHQoc2NvcmUsIHBvc2l0aW9ucywgd29yZCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW3Njb3JlXSwgaSA9IDE7XG4gICAgICAgIGZvciAobGV0IHBvcyBvZiBwb3NpdGlvbnMpIHtcbiAgICAgICAgICAgIGxldCB0byA9IHBvcyArICh0aGlzLmFzdHJhbCA/IHRleHQuY29kZVBvaW50U2l6ZSh0ZXh0LmNvZGVQb2ludEF0KHdvcmQsIHBvcykpIDogMSk7XG4gICAgICAgICAgICBpZiAoaSA+IDEgJiYgcmVzdWx0W2kgLSAxXSA9PSBwb3MpXG4gICAgICAgICAgICAgICAgcmVzdWx0W2kgLSAxXSA9IHRvO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2krK10gPSBwb3M7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2krK10gPSB0bztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cblxuY29uc3QgY29tcGxldGlvbkNvbmZpZyA9IHN0YXRlLkZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShjb25maWdzKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZS5jb21iaW5lQ29uZmlnKGNvbmZpZ3MsIHtcbiAgICAgICAgICAgIGFjdGl2YXRlT25UeXBpbmc6IHRydWUsXG4gICAgICAgICAgICBvdmVycmlkZTogbnVsbCxcbiAgICAgICAgICAgIG1heFJlbmRlcmVkT3B0aW9uczogMTAwLFxuICAgICAgICAgICAgZGVmYXVsdEtleW1hcDogdHJ1ZVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBkZWZhdWx0S2V5bWFwOiAoYSwgYikgPT4gYSAmJiBiXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG5jb25zdCBNYXhJbmZvV2lkdGggPSAzMDA7XG5jb25zdCBiYXNlVGhlbWUgPSB2aWV3LkVkaXRvclZpZXcuYmFzZVRoZW1lKHtcbiAgICBcIi5jbS10b29sdGlwLmNtLXRvb2x0aXAtYXV0b2NvbXBsZXRlXCI6IHtcbiAgICAgICAgXCImID4gdWxcIjoge1xuICAgICAgICAgICAgZm9udEZhbWlseTogXCJtb25vc3BhY2VcIixcbiAgICAgICAgICAgIHdoaXRlU3BhY2U6IFwibm93cmFwXCIsXG4gICAgICAgICAgICBvdmVyZmxvdzogXCJhdXRvXCIsXG4gICAgICAgICAgICBtYXhXaWR0aF9mYWxsYmFjazogXCI3MDBweFwiLFxuICAgICAgICAgICAgbWF4V2lkdGg6IFwibWluKDcwMHB4LCA5NXZ3KVwiLFxuICAgICAgICAgICAgbWF4SGVpZ2h0OiBcIjEwZW1cIixcbiAgICAgICAgICAgIGxpc3RTdHlsZTogXCJub25lXCIsXG4gICAgICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICAgICAgXCImID4gbGlcIjoge1xuICAgICAgICAgICAgICAgIGN1cnNvcjogXCJwb2ludGVyXCIsXG4gICAgICAgICAgICAgICAgcGFkZGluZzogXCIxcHggMWVtIDFweCAzcHhcIixcbiAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0OiAxLjJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIiYgPiBsaVthcmlhLXNlbGVjdGVkXVwiOiB7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZF9mYWxsYmFjazogXCIjYmRmXCIsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIkhpZ2hsaWdodFwiLFxuICAgICAgICAgICAgICAgIGNvbG9yX2ZhbGxiYWNrOiBcIndoaXRlXCIsXG4gICAgICAgICAgICAgICAgY29sb3I6IFwiSGlnaGxpZ2h0VGV4dFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25MaXN0SW5jb21wbGV0ZVRvcDpiZWZvcmUsIC5jbS1jb21wbGV0aW9uTGlzdEluY29tcGxldGVCb3R0b206YWZ0ZXJcIjoge1xuICAgICAgICBjb250ZW50OiAnXCLCt8K3wrdcIicsXG4gICAgICAgIG9wYWNpdHk6IDAuNSxcbiAgICAgICAgZGlzcGxheTogXCJibG9ja1wiLFxuICAgICAgICB0ZXh0QWxpZ246IFwiY2VudGVyXCJcbiAgICB9LFxuICAgIFwiLmNtLXRvb2x0aXAuY20tY29tcGxldGlvbkluZm9cIjoge1xuICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICBwYWRkaW5nOiBcIjNweCA5cHhcIixcbiAgICAgICAgd2lkdGg6IFwibWF4LWNvbnRlbnRcIixcbiAgICAgICAgbWF4V2lkdGg6IE1heEluZm9XaWR0aCArIFwicHhcIixcbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JbmZvLmNtLWNvbXBsZXRpb25JbmZvLWxlZnRcIjogeyByaWdodDogXCIxMDAlXCIgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSW5mby5jbS1jb21wbGV0aW9uSW5mby1yaWdodFwiOiB7IGxlZnQ6IFwiMTAwJVwiIH0sXG4gICAgXCImbGlnaHQgLmNtLXNuaXBwZXRGaWVsZFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjMDAwMDAwMjJcIiB9LFxuICAgIFwiJmRhcmsgLmNtLXNuaXBwZXRGaWVsZFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjZmZmZmZmMjJcIiB9LFxuICAgIFwiLmNtLXNuaXBwZXRGaWVsZFBvc2l0aW9uXCI6IHtcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJ0ZXh0LXRvcFwiLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiBcIjEuMTVlbVwiLFxuICAgICAgICBtYXJnaW46IFwiMCAtMC43cHggLS43ZW1cIixcbiAgICAgICAgYm9yZGVyTGVmdDogXCIxLjRweCBkb3R0ZWQgIzg4OFwiXG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uTWF0Y2hlZFRleHRcIjoge1xuICAgICAgICB0ZXh0RGVjb3JhdGlvbjogXCJ1bmRlcmxpbmVcIlxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkRldGFpbFwiOiB7XG4gICAgICAgIG1hcmdpbkxlZnQ6IFwiMC41ZW1cIixcbiAgICAgICAgZm9udFN0eWxlOiBcIml0YWxpY1wiXG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvblwiOiB7XG4gICAgICAgIGZvbnRTaXplOiBcIjkwJVwiLFxuICAgICAgICB3aWR0aDogXCIuOGVtXCIsXG4gICAgICAgIGRpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCIsXG4gICAgICAgIHRleHRBbGlnbjogXCJjZW50ZXJcIixcbiAgICAgICAgcGFkZGluZ1JpZ2h0OiBcIi42ZW1cIixcbiAgICAgICAgb3BhY2l0eTogXCIwLjZcIlxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24tZnVuY3Rpb24sIC5jbS1jb21wbGV0aW9uSWNvbi1tZXRob2RcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIifGkidcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi1jbGFzc1wiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ+KXiydcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi1pbnRlcmZhY2VcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIifil4wnXCIgfVxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24tdmFyaWFibGVcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIifwnZGlJ1wiIH1cbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLWNvbnN0YW50XCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCIn8J2QtidcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi10eXBlXCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCIn8J2RoSdcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi1lbnVtXCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCIn4oiqJ1wiIH1cbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLXByb3BlcnR5XCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCIn4pahJ1wiIH1cbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLWtleXdvcmRcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIifwn5SRXFx1RkUwRSdcIiB9IC8vIERpc2FibGUgZW1vamkgcmVuZGVyaW5nXG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi1uYW1lc3BhY2VcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIifilqInXCIgfVxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24tdGV4dFwiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ2FiYydcIiwgZm9udFNpemU6IFwiNTAlXCIsIHZlcnRpY2FsQWxpZ246IFwibWlkZGxlXCIgfVxuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiBjcmVhdGVMaXN0Qm94KG9wdGlvbnMsIGlkLCByYW5nZSkge1xuICAgIGNvbnN0IHVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInVsXCIpO1xuICAgIHVsLmlkID0gaWQ7XG4gICAgdWwuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImxpc3Rib3hcIik7XG4gICAgdWwuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCBcInRydWVcIik7XG4gICAgZm9yIChsZXQgaSA9IHJhbmdlLmZyb207IGkgPCByYW5nZS50bzsgaSsrKSB7XG4gICAgICAgIGxldCB7IGNvbXBsZXRpb24sIG1hdGNoIH0gPSBvcHRpb25zW2ldO1xuICAgICAgICBjb25zdCBsaSA9IHVsLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaVwiKSk7XG4gICAgICAgIGxpLmlkID0gaWQgKyBcIi1cIiArIGk7XG4gICAgICAgIGxldCBpY29uID0gbGkuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgICAgIGljb24uY2xhc3NMaXN0LmFkZChcImNtLWNvbXBsZXRpb25JY29uXCIpO1xuICAgICAgICBpZiAoY29tcGxldGlvbi50eXBlKVxuICAgICAgICAgICAgaWNvbi5jbGFzc0xpc3QuYWRkKFwiY20tY29tcGxldGlvbkljb24tXCIgKyBjb21wbGV0aW9uLnR5cGUpO1xuICAgICAgICBpY29uLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgbGV0IGxhYmVsRWx0ID0gbGkuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIikpO1xuICAgICAgICBsYWJlbEVsdC5jbGFzc05hbWUgPSBcImNtLWNvbXBsZXRpb25MYWJlbFwiO1xuICAgICAgICBsZXQgeyBsYWJlbCwgZGV0YWlsIH0gPSBjb21wbGV0aW9uLCBvZmYgPSAwO1xuICAgICAgICBmb3IgKGxldCBqID0gMTsgaiA8IG1hdGNoLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gbWF0Y2hbaisrXSwgdG8gPSBtYXRjaFtqKytdO1xuICAgICAgICAgICAgaWYgKGZyb20gPiBvZmYpXG4gICAgICAgICAgICAgICAgbGFiZWxFbHQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGFiZWwuc2xpY2Uob2ZmLCBmcm9tKSkpO1xuICAgICAgICAgICAgbGV0IHNwYW4gPSBsYWJlbEVsdC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKSk7XG4gICAgICAgICAgICBzcGFuLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxhYmVsLnNsaWNlKGZyb20sIHRvKSkpO1xuICAgICAgICAgICAgc3Bhbi5jbGFzc05hbWUgPSBcImNtLWNvbXBsZXRpb25NYXRjaGVkVGV4dFwiO1xuICAgICAgICAgICAgb2ZmID0gdG87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9mZiA8IGxhYmVsLmxlbmd0aClcbiAgICAgICAgICAgIGxhYmVsRWx0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxhYmVsLnNsaWNlKG9mZikpKTtcbiAgICAgICAgaWYgKGRldGFpbCkge1xuICAgICAgICAgICAgbGV0IGRldGFpbEVsdCA9IGxpLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpKTtcbiAgICAgICAgICAgIGRldGFpbEVsdC5jbGFzc05hbWUgPSBcImNtLWNvbXBsZXRpb25EZXRhaWxcIjtcbiAgICAgICAgICAgIGRldGFpbEVsdC50ZXh0Q29udGVudCA9IGRldGFpbDtcbiAgICAgICAgfVxuICAgICAgICBsaS5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwib3B0aW9uXCIpO1xuICAgIH1cbiAgICBpZiAocmFuZ2UuZnJvbSlcbiAgICAgICAgdWwuY2xhc3NMaXN0LmFkZChcImNtLWNvbXBsZXRpb25MaXN0SW5jb21wbGV0ZVRvcFwiKTtcbiAgICBpZiAocmFuZ2UudG8gPCBvcHRpb25zLmxlbmd0aClcbiAgICAgICAgdWwuY2xhc3NMaXN0LmFkZChcImNtLWNvbXBsZXRpb25MaXN0SW5jb21wbGV0ZUJvdHRvbVwiKTtcbiAgICByZXR1cm4gdWw7XG59XG5mdW5jdGlvbiBjcmVhdGVJbmZvRGlhbG9nKG9wdGlvbiwgdmlldyQxKSB7XG4gICAgbGV0IGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZG9tLmNsYXNzTmFtZSA9IFwiY20tdG9vbHRpcCBjbS1jb21wbGV0aW9uSW5mb1wiO1xuICAgIGxldCB7IGluZm8gfSA9IG9wdGlvbi5jb21wbGV0aW9uO1xuICAgIGlmICh0eXBlb2YgaW5mbyA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGRvbS50ZXh0Q29udGVudCA9IGluZm87XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgY29udGVudCA9IGluZm8ob3B0aW9uLmNvbXBsZXRpb24pO1xuICAgICAgICBpZiAoY29udGVudC50aGVuKVxuICAgICAgICAgICAgY29udGVudC50aGVuKG5vZGUgPT4gZG9tLmFwcGVuZENoaWxkKG5vZGUpLCBlID0+IHZpZXcubG9nRXhjZXB0aW9uKHZpZXckMS5zdGF0ZSwgZSwgXCJjb21wbGV0aW9uIGluZm9cIikpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBkb20uYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgfVxuICAgIHJldHVybiBkb207XG59XG5mdW5jdGlvbiByYW5nZUFyb3VuZFNlbGVjdGVkKHRvdGFsLCBzZWxlY3RlZCwgbWF4KSB7XG4gICAgaWYgKHRvdGFsIDw9IG1heClcbiAgICAgICAgcmV0dXJuIHsgZnJvbTogMCwgdG86IHRvdGFsIH07XG4gICAgaWYgKHNlbGVjdGVkIDw9ICh0b3RhbCA+PiAxKSkge1xuICAgICAgICBsZXQgb2ZmID0gTWF0aC5mbG9vcihzZWxlY3RlZCAvIG1heCk7XG4gICAgICAgIHJldHVybiB7IGZyb206IG9mZiAqIG1heCwgdG86IChvZmYgKyAxKSAqIG1heCB9O1xuICAgIH1cbiAgICBsZXQgb2ZmID0gTWF0aC5mbG9vcigodG90YWwgLSBzZWxlY3RlZCkgLyBtYXgpO1xuICAgIHJldHVybiB7IGZyb206IHRvdGFsIC0gKG9mZiArIDEpICogbWF4LCB0bzogdG90YWwgLSBvZmYgKiBtYXggfTtcbn1cbmNsYXNzIENvbXBsZXRpb25Ub29sdGlwIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBzdGF0ZUZpZWxkKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuc3RhdGVGaWVsZCA9IHN0YXRlRmllbGQ7XG4gICAgICAgIHRoaXMuaW5mbyA9IG51bGw7XG4gICAgICAgIHRoaXMucGxhY2VJbmZvID0ge1xuICAgICAgICAgICAgcmVhZDogKCkgPT4gdGhpcy5tZWFzdXJlSW5mbygpLFxuICAgICAgICAgICAgd3JpdGU6IChwb3MpID0+IHRoaXMucG9zaXRpb25JbmZvKHBvcyksXG4gICAgICAgICAgICBrZXk6IHRoaXNcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGNTdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQoc3RhdGVGaWVsZCk7XG4gICAgICAgIGxldCB7IG9wdGlvbnMsIHNlbGVjdGVkIH0gPSBjU3RhdGUub3BlbjtcbiAgICAgICAgbGV0IGNvbmZpZyA9IHZpZXcuc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZyk7XG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZUFyb3VuZFNlbGVjdGVkKG9wdGlvbnMubGVuZ3RoLCBzZWxlY3RlZCwgY29uZmlnLm1heFJlbmRlcmVkT3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5kb20uY2xhc3NOYW1lID0gXCJjbS10b29sdGlwLWF1dG9jb21wbGV0ZVwiO1xuICAgICAgICB0aGlzLmRvbS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIChlKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBkb20gPSBlLnRhcmdldCwgbWF0Y2g7IGRvbSAmJiBkb20gIT0gdGhpcy5kb207IGRvbSA9IGRvbS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRvbS5ub2RlTmFtZSA9PSBcIkxJXCIgJiYgKG1hdGNoID0gLy0oXFxkKykkLy5leGVjKGRvbS5pZCkpICYmICttYXRjaFsxXSA8IG9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcGx5Q29tcGxldGlvbih2aWV3LCBvcHRpb25zWyttYXRjaFsxXV0pO1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmxpc3QgPSB0aGlzLmRvbS5hcHBlbmRDaGlsZChjcmVhdGVMaXN0Qm94KG9wdGlvbnMsIGNTdGF0ZS5pZCwgdGhpcy5yYW5nZSkpO1xuICAgICAgICB0aGlzLmxpc3QuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbmZvKVxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSh0aGlzLnBsYWNlSW5mbyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtb3VudCgpIHsgdGhpcy51cGRhdGVTZWwoKTsgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgaWYgKHVwZGF0ZS5zdGF0ZS5maWVsZCh0aGlzLnN0YXRlRmllbGQpICE9IHVwZGF0ZS5zdGFydFN0YXRlLmZpZWxkKHRoaXMuc3RhdGVGaWVsZCkpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNlbCgpO1xuICAgIH1cbiAgICBwb3NpdGlvbmVkKCkge1xuICAgICAgICBpZiAodGhpcy5pbmZvKVxuICAgICAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMucGxhY2VJbmZvKTtcbiAgICB9XG4gICAgdXBkYXRlU2VsKCkge1xuICAgICAgICBsZXQgY1N0YXRlID0gdGhpcy52aWV3LnN0YXRlLmZpZWxkKHRoaXMuc3RhdGVGaWVsZCksIG9wZW4gPSBjU3RhdGUub3BlbjtcbiAgICAgICAgaWYgKG9wZW4uc2VsZWN0ZWQgPCB0aGlzLnJhbmdlLmZyb20gfHwgb3Blbi5zZWxlY3RlZCA+PSB0aGlzLnJhbmdlLnRvKSB7XG4gICAgICAgICAgICB0aGlzLnJhbmdlID0gcmFuZ2VBcm91bmRTZWxlY3RlZChvcGVuLm9wdGlvbnMubGVuZ3RoLCBvcGVuLnNlbGVjdGVkLCB0aGlzLnZpZXcuc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZykubWF4UmVuZGVyZWRPcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMubGlzdC5yZW1vdmUoKTtcbiAgICAgICAgICAgIHRoaXMubGlzdCA9IHRoaXMuZG9tLmFwcGVuZENoaWxkKGNyZWF0ZUxpc3RCb3gob3Blbi5vcHRpb25zLCBjU3RhdGUuaWQsIHRoaXMucmFuZ2UpKTtcbiAgICAgICAgICAgIHRoaXMubGlzdC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmZvKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUodGhpcy5wbGFjZUluZm8pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudXBkYXRlU2VsZWN0ZWRPcHRpb24ob3Blbi5zZWxlY3RlZCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmluZm8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZm8ucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmZvID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBvcHRpb24gPSBvcGVuLm9wdGlvbnNbb3Blbi5zZWxlY3RlZF07XG4gICAgICAgICAgICBpZiAob3B0aW9uLmNvbXBsZXRpb24uaW5mbykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5mbyA9IHRoaXMuZG9tLmFwcGVuZENoaWxkKGNyZWF0ZUluZm9EaWFsb2cob3B0aW9uLCB0aGlzLnZpZXcpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUodGhpcy5wbGFjZUluZm8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZVNlbGVjdGVkT3B0aW9uKHNlbGVjdGVkKSB7XG4gICAgICAgIGxldCBzZXQgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBvcHQgPSB0aGlzLmxpc3QuZmlyc3RDaGlsZCwgaSA9IHRoaXMucmFuZ2UuZnJvbTsgb3B0OyBvcHQgPSBvcHQubmV4dFNpYmxpbmcsIGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9wdC5oYXNBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdC5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0ID0gb3B0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChvcHQuaGFzQXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiKSlcbiAgICAgICAgICAgICAgICAgICAgb3B0LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldClcbiAgICAgICAgICAgIHNjcm9sbEludG9WaWV3KHRoaXMubGlzdCwgc2V0KTtcbiAgICAgICAgcmV0dXJuIHNldDtcbiAgICB9XG4gICAgbWVhc3VyZUluZm8oKSB7XG4gICAgICAgIGxldCBzZWwgPSB0aGlzLmRvbS5xdWVyeVNlbGVjdG9yKFwiW2FyaWEtc2VsZWN0ZWRdXCIpO1xuICAgICAgICBpZiAoIXNlbClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgcmVjdCA9IHRoaXMuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBsZXQgdG9wID0gc2VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCAtIHJlY3QudG9wO1xuICAgICAgICBpZiAodG9wIDwgMCB8fCB0b3AgPiB0aGlzLmxpc3QuY2xpZW50SGVpZ2h0IC0gMTApXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGxlZnQgPSB0aGlzLnZpZXcudGV4dERpcmVjdGlvbiA9PSB2aWV3LkRpcmVjdGlvbi5SVEw7XG4gICAgICAgIGxldCBzcGFjZUxlZnQgPSByZWN0LmxlZnQsIHNwYWNlUmlnaHQgPSBpbm5lcldpZHRoIC0gcmVjdC5yaWdodDtcbiAgICAgICAgaWYgKGxlZnQgJiYgc3BhY2VMZWZ0IDwgTWF0aC5taW4oTWF4SW5mb1dpZHRoLCBzcGFjZVJpZ2h0KSlcbiAgICAgICAgICAgIGxlZnQgPSBmYWxzZTtcbiAgICAgICAgZWxzZSBpZiAoIWxlZnQgJiYgc3BhY2VSaWdodCA8IE1hdGgubWluKE1heEluZm9XaWR0aCwgc3BhY2VMZWZ0KSlcbiAgICAgICAgICAgIGxlZnQgPSB0cnVlO1xuICAgICAgICByZXR1cm4geyB0b3AsIGxlZnQgfTtcbiAgICB9XG4gICAgcG9zaXRpb25JbmZvKHBvcykge1xuICAgICAgICBpZiAodGhpcy5pbmZvICYmIHBvcykge1xuICAgICAgICAgICAgdGhpcy5pbmZvLnN0eWxlLnRvcCA9IHBvcy50b3AgKyBcInB4XCI7XG4gICAgICAgICAgICB0aGlzLmluZm8uY2xhc3NMaXN0LnRvZ2dsZShcImNtLWNvbXBsZXRpb25JbmZvLWxlZnRcIiwgcG9zLmxlZnQpO1xuICAgICAgICAgICAgdGhpcy5pbmZvLmNsYXNzTGlzdC50b2dnbGUoXCJjbS1jb21wbGV0aW9uSW5mby1yaWdodFwiLCAhcG9zLmxlZnQpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gV2UgYWxsb2NhdGUgYSBuZXcgZnVuY3Rpb24gaW5zdGFuY2UgZXZlcnkgdGltZSB0aGUgY29tcGxldGlvblxuLy8gY2hhbmdlcyB0byBmb3JjZSByZWRyYXdpbmcvcmVwb3NpdGlvbmluZyBvZiB0aGUgdG9vbHRpcFxuZnVuY3Rpb24gY29tcGxldGlvblRvb2x0aXAoc3RhdGVGaWVsZCkge1xuICAgIHJldHVybiAodmlldykgPT4gbmV3IENvbXBsZXRpb25Ub29sdGlwKHZpZXcsIHN0YXRlRmllbGQpO1xufVxuZnVuY3Rpb24gc2Nyb2xsSW50b1ZpZXcoY29udGFpbmVyLCBlbGVtZW50KSB7XG4gICAgbGV0IHBhcmVudCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgc2VsZiA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaWYgKHNlbGYudG9wIDwgcGFyZW50LnRvcClcbiAgICAgICAgY29udGFpbmVyLnNjcm9sbFRvcCAtPSBwYXJlbnQudG9wIC0gc2VsZi50b3A7XG4gICAgZWxzZSBpZiAoc2VsZi5ib3R0b20gPiBwYXJlbnQuYm90dG9tKVxuICAgICAgICBjb250YWluZXIuc2Nyb2xsVG9wICs9IHNlbGYuYm90dG9tIC0gcGFyZW50LmJvdHRvbTtcbn1cblxuY29uc3QgTWF4T3B0aW9ucyA9IDMwMDtcbi8vIFVzZWQgdG8gcGljayBhIHByZWZlcnJlZCBvcHRpb24gd2hlbiB0d28gb3B0aW9ucyB3aXRoIHRoZSBzYW1lXG4vLyBsYWJlbCBvY2N1ciBpbiB0aGUgcmVzdWx0LlxuZnVuY3Rpb24gc2NvcmUob3B0aW9uKSB7XG4gICAgcmV0dXJuIChvcHRpb24uYm9vc3QgfHwgMCkgKiAxMDAgKyAob3B0aW9uLmFwcGx5ID8gMTAgOiAwKSArIChvcHRpb24uaW5mbyA/IDUgOiAwKSArXG4gICAgICAgIChvcHRpb24udHlwZSA/IDEgOiAwKTtcbn1cbmZ1bmN0aW9uIHNvcnRPcHRpb25zKGFjdGl2ZSwgc3RhdGUpIHtcbiAgICBsZXQgb3B0aW9ucyA9IFtdO1xuICAgIGZvciAobGV0IGEgb2YgYWN0aXZlKVxuICAgICAgICBpZiAoYS5oYXNSZXN1bHQoKSkge1xuICAgICAgICAgICAgbGV0IG1hdGNoZXIgPSBuZXcgRnV6enlNYXRjaGVyKHN0YXRlLnNsaWNlRG9jKGEuZnJvbSwgYS50bykpLCBtYXRjaDtcbiAgICAgICAgICAgIGZvciAobGV0IG9wdGlvbiBvZiBhLnJlc3VsdC5vcHRpb25zKVxuICAgICAgICAgICAgICAgIGlmIChtYXRjaCA9IG1hdGNoZXIubWF0Y2gob3B0aW9uLmxhYmVsKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9uLmJvb3N0ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFswXSArPSBvcHRpb24uYm9vc3Q7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucHVzaChuZXcgT3B0aW9uKG9wdGlvbiwgYSwgbWF0Y2gpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBvcHRpb25zLnNvcnQoY21wT3B0aW9uKTtcbiAgICBsZXQgcmVzdWx0ID0gW10sIHByZXYgPSBudWxsO1xuICAgIGZvciAobGV0IG9wdCBvZiBvcHRpb25zLnNvcnQoY21wT3B0aW9uKSkge1xuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PSBNYXhPcHRpb25zKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmICghcHJldiB8fCBwcmV2LmxhYmVsICE9IG9wdC5jb21wbGV0aW9uLmxhYmVsIHx8IHByZXYuZGV0YWlsICE9IG9wdC5jb21wbGV0aW9uLmRldGFpbClcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG9wdCk7XG4gICAgICAgIGVsc2UgaWYgKHNjb3JlKG9wdC5jb21wbGV0aW9uKSA+IHNjb3JlKHByZXYpKVxuICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSA9IG9wdDtcbiAgICAgICAgcHJldiA9IG9wdC5jb21wbGV0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY2xhc3MgQ29tcGxldGlvbkRpYWxvZyB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgYXR0cnMsIHRvb2x0aXAsIHRpbWVzdGFtcCwgc2VsZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB0aGlzLnRvb2x0aXAgPSB0b29sdGlwO1xuICAgICAgICB0aGlzLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgIH1cbiAgICBzZXRTZWxlY3RlZChzZWxlY3RlZCwgaWQpIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkID09IHRoaXMuc2VsZWN0ZWQgfHwgc2VsZWN0ZWQgPj0gdGhpcy5vcHRpb25zLmxlbmd0aCA/IHRoaXNcbiAgICAgICAgICAgIDogbmV3IENvbXBsZXRpb25EaWFsb2codGhpcy5vcHRpb25zLCBtYWtlQXR0cnMoaWQsIHNlbGVjdGVkKSwgdGhpcy50b29sdGlwLCB0aGlzLnRpbWVzdGFtcCwgc2VsZWN0ZWQpO1xuICAgIH1cbiAgICBzdGF0aWMgYnVpbGQoYWN0aXZlLCBzdGF0ZSwgaWQsIHByZXYpIHtcbiAgICAgICAgbGV0IG9wdGlvbnMgPSBzb3J0T3B0aW9ucyhhY3RpdmUsIHN0YXRlKTtcbiAgICAgICAgaWYgKCFvcHRpb25zLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgc2VsZWN0ZWQgPSAwO1xuICAgICAgICBpZiAocHJldiAmJiBwcmV2LnNlbGVjdGVkKSB7XG4gICAgICAgICAgICBsZXQgc2VsZWN0ZWRWYWx1ZSA9IHByZXYub3B0aW9uc1twcmV2LnNlbGVjdGVkXS5jb21wbGV0aW9uO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcHRpb25zLmxlbmd0aCAmJiAhc2VsZWN0ZWQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zW2ldLmNvbXBsZXRpb24gPT0gc2VsZWN0ZWRWYWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ29tcGxldGlvbkRpYWxvZyhvcHRpb25zLCBtYWtlQXR0cnMoaWQsIHNlbGVjdGVkKSwge1xuICAgICAgICAgICAgcG9zOiBhY3RpdmUucmVkdWNlKChhLCBiKSA9PiBiLmhhc1Jlc3VsdCgpID8gTWF0aC5taW4oYSwgYi5mcm9tKSA6IGEsIDFlOCksXG4gICAgICAgICAgICBjcmVhdGU6IGNvbXBsZXRpb25Ub29sdGlwKGNvbXBsZXRpb25TdGF0ZSlcbiAgICAgICAgfSwgcHJldiA/IHByZXYudGltZXN0YW1wIDogRGF0ZS5ub3coKSwgc2VsZWN0ZWQpO1xuICAgIH1cbiAgICBtYXAoY2hhbmdlcykge1xuICAgICAgICByZXR1cm4gbmV3IENvbXBsZXRpb25EaWFsb2codGhpcy5vcHRpb25zLCB0aGlzLmF0dHJzLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMudG9vbHRpcCksIHsgcG9zOiBjaGFuZ2VzLm1hcFBvcyh0aGlzLnRvb2x0aXAucG9zKSB9KSwgdGhpcy50aW1lc3RhbXAsIHRoaXMuc2VsZWN0ZWQpO1xuICAgIH1cbn1cbmNsYXNzIENvbXBsZXRpb25TdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoYWN0aXZlLCBpZCwgb3Blbikge1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLm9wZW4gPSBvcGVuO1xuICAgIH1cbiAgICBzdGF0aWMgc3RhcnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcGxldGlvblN0YXRlKG5vbmUsIFwiY20tYWMtXCIgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyZTYpLnRvU3RyaW5nKDM2KSwgbnVsbCk7XG4gICAgfVxuICAgIHVwZGF0ZSh0cikge1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdHIsIGNvbmYgPSBzdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKTtcbiAgICAgICAgbGV0IHNvdXJjZXMgPSBjb25mLm92ZXJyaWRlIHx8XG4gICAgICAgICAgICBzdGF0ZS5sYW5ndWFnZURhdGFBdChcImF1dG9jb21wbGV0ZVwiLCBjdXIoc3RhdGUpKS5tYXAoYXNTb3VyY2UpO1xuICAgICAgICBsZXQgYWN0aXZlID0gc291cmNlcy5tYXAoc291cmNlID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuYWN0aXZlLmZpbmQocyA9PiBzLnNvdXJjZSA9PSBzb3VyY2UpIHx8IG5ldyBBY3RpdmVTb3VyY2Uoc291cmNlLCAwIC8qIEluYWN0aXZlICovLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudXBkYXRlKHRyLCBjb25mKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChhY3RpdmUubGVuZ3RoID09IHRoaXMuYWN0aXZlLmxlbmd0aCAmJiBhY3RpdmUuZXZlcnkoKGEsIGkpID0+IGEgPT0gdGhpcy5hY3RpdmVbaV0pKVxuICAgICAgICAgICAgYWN0aXZlID0gdGhpcy5hY3RpdmU7XG4gICAgICAgIGxldCBvcGVuID0gdHIuc2VsZWN0aW9uIHx8IGFjdGl2ZS5zb21lKGEgPT4gYS5oYXNSZXN1bHQoKSAmJiB0ci5jaGFuZ2VzLnRvdWNoZXNSYW5nZShhLmZyb20sIGEudG8pKSB8fFxuICAgICAgICAgICAgIXNhbWVSZXN1bHRzKGFjdGl2ZSwgdGhpcy5hY3RpdmUpID8gQ29tcGxldGlvbkRpYWxvZy5idWlsZChhY3RpdmUsIHN0YXRlLCB0aGlzLmlkLCB0aGlzLm9wZW4pXG4gICAgICAgICAgICA6IHRoaXMub3BlbiAmJiB0ci5kb2NDaGFuZ2VkID8gdGhpcy5vcGVuLm1hcCh0ci5jaGFuZ2VzKSA6IHRoaXMub3BlbjtcbiAgICAgICAgaWYgKCFvcGVuICYmIGFjdGl2ZS5ldmVyeShhID0+IGEuc3RhdGUgIT0gMSAvKiBQZW5kaW5nICovKSAmJiBhY3RpdmUuc29tZShhID0+IGEuaGFzUmVzdWx0KCkpKVxuICAgICAgICAgICAgYWN0aXZlID0gYWN0aXZlLm1hcChhID0+IGEuaGFzUmVzdWx0KCkgPyBuZXcgQWN0aXZlU291cmNlKGEuc291cmNlLCAwIC8qIEluYWN0aXZlICovLCBmYWxzZSkgOiBhKTtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpXG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHNldFNlbGVjdGVkRWZmZWN0KSlcbiAgICAgICAgICAgICAgICBvcGVuID0gb3BlbiAmJiBvcGVuLnNldFNlbGVjdGVkKGVmZmVjdC52YWx1ZSwgdGhpcy5pZCk7XG4gICAgICAgIHJldHVybiBhY3RpdmUgPT0gdGhpcy5hY3RpdmUgJiYgb3BlbiA9PSB0aGlzLm9wZW4gPyB0aGlzIDogbmV3IENvbXBsZXRpb25TdGF0ZShhY3RpdmUsIHRoaXMuaWQsIG9wZW4pO1xuICAgIH1cbiAgICBnZXQgdG9vbHRpcCgpIHsgcmV0dXJuIHRoaXMub3BlbiA/IHRoaXMub3Blbi50b29sdGlwIDogbnVsbDsgfVxuICAgIGdldCBhdHRycygpIHsgcmV0dXJuIHRoaXMub3BlbiA/IHRoaXMub3Blbi5hdHRycyA6IGJhc2VBdHRyczsgfVxufVxuZnVuY3Rpb24gc2FtZVJlc3VsdHMoYSwgYikge1xuICAgIGlmIChhID09IGIpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGZvciAobGV0IGlBID0gMCwgaUIgPSAwOzspIHtcbiAgICAgICAgd2hpbGUgKGlBIDwgYS5sZW5ndGggJiYgIWFbaUFdLmhhc1Jlc3VsdClcbiAgICAgICAgICAgIGlBKys7XG4gICAgICAgIHdoaWxlIChpQiA8IGIubGVuZ3RoICYmICFiW2lCXS5oYXNSZXN1bHQpXG4gICAgICAgICAgICBpQisrO1xuICAgICAgICBsZXQgZW5kQSA9IGlBID09IGEubGVuZ3RoLCBlbmRCID0gaUIgPT0gYi5sZW5ndGg7XG4gICAgICAgIGlmIChlbmRBIHx8IGVuZEIpXG4gICAgICAgICAgICByZXR1cm4gZW5kQSA9PSBlbmRCO1xuICAgICAgICBpZiAoYVtpQSsrXS5yZXN1bHQgIT0gYltpQisrXS5yZXN1bHQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gbWFrZUF0dHJzKGlkLCBzZWxlY3RlZCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIFwiYXJpYS1hdXRvY29tcGxldGVcIjogXCJsaXN0XCIsXG4gICAgICAgIFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCI6IGlkICsgXCItXCIgKyBzZWxlY3RlZCxcbiAgICAgICAgXCJhcmlhLW93bnNcIjogaWRcbiAgICB9O1xufVxuY29uc3QgYmFzZUF0dHJzID0geyBcImFyaWEtYXV0b2NvbXBsZXRlXCI6IFwibGlzdFwiIH0sIG5vbmUgPSBbXTtcbmZ1bmN0aW9uIGNtcE9wdGlvbihhLCBiKSB7XG4gICAgbGV0IGRTY29yZSA9IGIubWF0Y2hbMF0gLSBhLm1hdGNoWzBdO1xuICAgIGlmIChkU2NvcmUpXG4gICAgICAgIHJldHVybiBkU2NvcmU7XG4gICAgbGV0IGxBID0gYS5jb21wbGV0aW9uLmxhYmVsLCBsQiA9IGIuY29tcGxldGlvbi5sYWJlbDtcbiAgICByZXR1cm4gbEEgPCBsQiA/IC0xIDogbEEgPT0gbEIgPyAwIDogMTtcbn1cbmNsYXNzIEFjdGl2ZVNvdXJjZSB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlLCBzdGF0ZSwgZXhwbGljaXQpIHtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5leHBsaWNpdCA9IGV4cGxpY2l0O1xuICAgIH1cbiAgICBoYXNSZXN1bHQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIHVwZGF0ZSh0ciwgY29uZikge1xuICAgICAgICBsZXQgZXZlbnQgPSB0ci5hbm5vdGF0aW9uKHN0YXRlLlRyYW5zYWN0aW9uLnVzZXJFdmVudCksIHZhbHVlID0gdGhpcztcbiAgICAgICAgaWYgKGV2ZW50ID09IFwiaW5wdXRcIiB8fCBldmVudCA9PSBcImRlbGV0ZVwiKVxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5oYW5kbGVVc2VyRXZlbnQodHIsIGV2ZW50LCBjb25mKTtcbiAgICAgICAgZWxzZSBpZiAodHIuZG9jQ2hhbmdlZClcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuaGFuZGxlQ2hhbmdlKHRyKTtcbiAgICAgICAgZWxzZSBpZiAodHIuc2VsZWN0aW9uICYmIHZhbHVlLnN0YXRlICE9IDAgLyogSW5hY3RpdmUgKi8pXG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBBY3RpdmVTb3VyY2UodmFsdWUuc291cmNlLCAwIC8qIEluYWN0aXZlICovLCBmYWxzZSk7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHN0YXJ0Q29tcGxldGlvbkVmZmVjdCkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgQWN0aXZlU291cmNlKHZhbHVlLnNvdXJjZSwgMSAvKiBQZW5kaW5nICovLCBlZmZlY3QudmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZWZmZWN0LmlzKGNsb3NlQ29tcGxldGlvbkVmZmVjdCkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgQWN0aXZlU291cmNlKHZhbHVlLnNvdXJjZSwgMCAvKiBJbmFjdGl2ZSAqLywgZmFsc2UpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZWZmZWN0LmlzKHNldEFjdGl2ZUVmZmVjdCkpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYWN0aXZlIG9mIGVmZmVjdC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZS5zb3VyY2UgPT0gdmFsdWUuc291cmNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhY3RpdmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBoYW5kbGVVc2VyRXZlbnQoX3RyLCB0eXBlLCBjb25mKSB7XG4gICAgICAgIHJldHVybiB0eXBlID09IFwiZGVsZXRlXCIgfHwgIWNvbmYuYWN0aXZhdGVPblR5cGluZyA/IHRoaXMgOiBuZXcgQWN0aXZlU291cmNlKHRoaXMuc291cmNlLCAxIC8qIFBlbmRpbmcgKi8sIGZhbHNlKTtcbiAgICB9XG4gICAgaGFuZGxlQ2hhbmdlKHRyKSB7XG4gICAgICAgIHJldHVybiB0ci5jaGFuZ2VzLnRvdWNoZXNSYW5nZShjdXIodHIuc3RhcnRTdGF0ZSkpID8gbmV3IEFjdGl2ZVNvdXJjZSh0aGlzLnNvdXJjZSwgMCAvKiBJbmFjdGl2ZSAqLywgZmFsc2UpIDogdGhpcztcbiAgICB9XG59XG5jbGFzcyBBY3RpdmVSZXN1bHQgZXh0ZW5kcyBBY3RpdmVTb3VyY2Uge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSwgZXhwbGljaXQsIHJlc3VsdCwgZnJvbSwgdG8sIHNwYW4pIHtcbiAgICAgICAgc3VwZXIoc291cmNlLCAyIC8qIFJlc3VsdCAqLywgZXhwbGljaXQpO1xuICAgICAgICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLnNwYW4gPSBzcGFuO1xuICAgIH1cbiAgICBoYXNSZXN1bHQoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgaGFuZGxlVXNlckV2ZW50KHRyLCB0eXBlLCBjb25mKSB7XG4gICAgICAgIGxldCBmcm9tID0gdHIuY2hhbmdlcy5tYXBQb3ModGhpcy5mcm9tKSwgdG8gPSB0ci5jaGFuZ2VzLm1hcFBvcyh0aGlzLnRvLCAxKTtcbiAgICAgICAgbGV0IHBvcyA9IGN1cih0ci5zdGF0ZSk7XG4gICAgICAgIGlmICgodGhpcy5leHBsaWNpdCA/IHBvcyA8IGZyb20gOiBwb3MgPD0gZnJvbSkgfHwgcG9zID4gdG8pXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVNvdXJjZSh0aGlzLnNvdXJjZSwgdHlwZSA9PSBcImlucHV0XCIgJiYgY29uZi5hY3RpdmF0ZU9uVHlwaW5nID8gMSAvKiBQZW5kaW5nICovIDogMCAvKiBJbmFjdGl2ZSAqLywgZmFsc2UpO1xuICAgICAgICBpZiAodGhpcy5zcGFuICYmIChmcm9tID09IHRvIHx8IHRoaXMuc3Bhbi50ZXN0KHRyLnN0YXRlLnNsaWNlRG9jKGZyb20sIHRvKSkpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVSZXN1bHQodGhpcy5zb3VyY2UsIHRoaXMuZXhwbGljaXQsIHRoaXMucmVzdWx0LCBmcm9tLCB0bywgdGhpcy5zcGFuKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVTb3VyY2UodGhpcy5zb3VyY2UsIDEgLyogUGVuZGluZyAqLywgdGhpcy5leHBsaWNpdCk7XG4gICAgfVxuICAgIGhhbmRsZUNoYW5nZSh0cikge1xuICAgICAgICByZXR1cm4gdHIuY2hhbmdlcy50b3VjaGVzUmFuZ2UodGhpcy5mcm9tLCB0aGlzLnRvKVxuICAgICAgICAgICAgPyBuZXcgQWN0aXZlU291cmNlKHRoaXMuc291cmNlLCAwIC8qIEluYWN0aXZlICovLCBmYWxzZSlcbiAgICAgICAgICAgIDogbmV3IEFjdGl2ZVJlc3VsdCh0aGlzLnNvdXJjZSwgdGhpcy5leHBsaWNpdCwgdGhpcy5yZXN1bHQsIHRyLmNoYW5nZXMubWFwUG9zKHRoaXMuZnJvbSksIHRyLmNoYW5nZXMubWFwUG9zKHRoaXMudG8sIDEpLCB0aGlzLnNwYW4pO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVJlc3VsdCh0aGlzLnNvdXJjZSwgdGhpcy5leHBsaWNpdCwgdGhpcy5yZXN1bHQsIG1hcHBpbmcubWFwUG9zKHRoaXMuZnJvbSksIG1hcHBpbmcubWFwUG9zKHRoaXMudG8sIDEpLCB0aGlzLnNwYW4pO1xuICAgIH1cbn1cbmNvbnN0IHN0YXJ0Q29tcGxldGlvbkVmZmVjdCA9IHN0YXRlLlN0YXRlRWZmZWN0LmRlZmluZSgpO1xuY29uc3QgY2xvc2VDb21wbGV0aW9uRWZmZWN0ID0gc3RhdGUuU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCBzZXRBY3RpdmVFZmZlY3QgPSBzdGF0ZS5TdGF0ZUVmZmVjdC5kZWZpbmUoe1xuICAgIG1hcChzb3VyY2VzLCBtYXBwaW5nKSB7IHJldHVybiBzb3VyY2VzLm1hcChzID0+IHMuaGFzUmVzdWx0KCkgJiYgIW1hcHBpbmcuZW1wdHkgPyBzLm1hcChtYXBwaW5nKSA6IHMpOyB9XG59KTtcbmNvbnN0IHNldFNlbGVjdGVkRWZmZWN0ID0gc3RhdGUuU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCBjb21wbGV0aW9uU3RhdGUgPSBzdGF0ZS5TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkgeyByZXR1cm4gQ29tcGxldGlvblN0YXRlLnN0YXJ0KCk7IH0sXG4gICAgdXBkYXRlKHZhbHVlLCB0cikgeyByZXR1cm4gdmFsdWUudXBkYXRlKHRyKTsgfSxcbiAgICBwcm92aWRlOiBmID0+IFtcbiAgICAgICAgdG9vbHRpcC5zaG93VG9vbHRpcC5mcm9tKGYsIHZhbCA9PiB2YWwudG9vbHRpcCksXG4gICAgICAgIHZpZXcuRWRpdG9yVmlldy5jb250ZW50QXR0cmlidXRlcy5mcm9tKGYsIHN0YXRlID0+IHN0YXRlLmF0dHJzKVxuICAgIF1cbn0pO1xuXG5jb25zdCBDb21wbGV0aW9uSW50ZXJhY3RNYXJnaW4gPSA3NTtcbi8qKlxuUmV0dXJucyBhIGNvbW1hbmQgdGhhdCBtb3ZlcyB0aGUgY29tcGxldGlvbiBzZWxlY3Rpb24gZm9yd2FyZCBvclxuYmFja3dhcmQgYnkgdGhlIGdpdmVuIGFtb3VudC5cbiovXG5mdW5jdGlvbiBtb3ZlQ29tcGxldGlvblNlbGVjdGlvbihmb3J3YXJkLCBieSA9IFwib3B0aW9uXCIpIHtcbiAgICByZXR1cm4gKHZpZXcpID0+IHtcbiAgICAgICAgbGV0IGNTdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSk7XG4gICAgICAgIGlmICghY1N0YXRlIHx8ICFjU3RhdGUub3BlbiB8fCBEYXRlLm5vdygpIC0gY1N0YXRlLm9wZW4udGltZXN0YW1wIDwgQ29tcGxldGlvbkludGVyYWN0TWFyZ2luKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgc3RlcCA9IDEsIHRvb2x0aXA7XG4gICAgICAgIGlmIChieSA9PSBcInBhZ2VcIiAmJiAodG9vbHRpcCA9IHZpZXcuZG9tLnF1ZXJ5U2VsZWN0b3IoXCIuY20tdG9vbHRpcC1hdXRvY29tcGxldGVcIikpKVxuICAgICAgICAgICAgc3RlcCA9IE1hdGgubWF4KDIsIE1hdGguZmxvb3IodG9vbHRpcC5vZmZzZXRIZWlnaHQgLyB0b29sdGlwLmZpcnN0Q2hpbGQub2Zmc2V0SGVpZ2h0KSk7XG4gICAgICAgIGxldCBzZWxlY3RlZCA9IGNTdGF0ZS5vcGVuLnNlbGVjdGVkICsgc3RlcCAqIChmb3J3YXJkID8gMSA6IC0xKSwgeyBsZW5ndGggfSA9IGNTdGF0ZS5vcGVuLm9wdGlvbnM7XG4gICAgICAgIGlmIChzZWxlY3RlZCA8IDApXG4gICAgICAgICAgICBzZWxlY3RlZCA9IGJ5ID09IFwicGFnZVwiID8gMCA6IGxlbmd0aCAtIDE7XG4gICAgICAgIGVsc2UgaWYgKHNlbGVjdGVkID49IGxlbmd0aClcbiAgICAgICAgICAgIHNlbGVjdGVkID0gYnkgPT0gXCJwYWdlXCIgPyBsZW5ndGggLSAxIDogMDtcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHNldFNlbGVjdGVkRWZmZWN0Lm9mKHNlbGVjdGVkKSB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbi8qKlxuQWNjZXB0IHRoZSBjdXJyZW50IGNvbXBsZXRpb24uXG4qL1xuY29uc3QgYWNjZXB0Q29tcGxldGlvbiA9ICh2aWV3KSA9PiB7XG4gICAgbGV0IGNTdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKCFjU3RhdGUgfHwgIWNTdGF0ZS5vcGVuIHx8IERhdGUubm93KCkgLSBjU3RhdGUub3Blbi50aW1lc3RhbXAgPCBDb21wbGV0aW9uSW50ZXJhY3RNYXJnaW4pXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBhcHBseUNvbXBsZXRpb24odmlldywgY1N0YXRlLm9wZW4ub3B0aW9uc1tjU3RhdGUub3Blbi5zZWxlY3RlZF0pO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuRXhwbGljaXRseSBzdGFydCBhdXRvY29tcGxldGlvbi5cbiovXG5jb25zdCBzdGFydENvbXBsZXRpb24gPSAodmlldykgPT4ge1xuICAgIGxldCBjU3RhdGUgPSB2aWV3LnN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSwgZmFsc2UpO1xuICAgIGlmICghY1N0YXRlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHN0YXJ0Q29tcGxldGlvbkVmZmVjdC5vZih0cnVlKSB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkNsb3NlIHRoZSBjdXJyZW50bHkgYWN0aXZlIGNvbXBsZXRpb24uXG4qL1xuY29uc3QgY2xvc2VDb21wbGV0aW9uID0gKHZpZXcpID0+IHtcbiAgICBsZXQgY1N0YXRlID0gdmlldy5zdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUsIGZhbHNlKTtcbiAgICBpZiAoIWNTdGF0ZSB8fCAhY1N0YXRlLmFjdGl2ZS5zb21lKGEgPT4gYS5zdGF0ZSAhPSAwIC8qIEluYWN0aXZlICovKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBjbG9zZUNvbXBsZXRpb25FZmZlY3Qub2YobnVsbCkgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuY2xhc3MgUnVubmluZ1F1ZXJ5IHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMudGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMudXBkYXRlcyA9IFtdO1xuICAgICAgICAvLyBOb3RlIHRoYXQgJ3VuZGVmaW5lZCcgbWVhbnMgJ25vdCBkb25lIHlldCcsIHdoZXJlYXMgJ251bGwnIG1lYW5zXG4gICAgICAgIC8vICdxdWVyeSByZXR1cm5lZCBudWxsJy5cbiAgICAgICAgdGhpcy5kb25lID0gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmNvbnN0IERlYm91bmNlVGltZSA9IDUwLCBNYXhVcGRhdGVDb3VudCA9IDUwLCBNaW5BYm9ydFRpbWUgPSAxMDAwO1xuY29uc3QgY29tcGxldGlvblBsdWdpbiA9IHZpZXcuVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5kZWJvdW5jZVVwZGF0ZSA9IC0xO1xuICAgICAgICB0aGlzLnJ1bm5pbmcgPSBbXTtcbiAgICAgICAgdGhpcy5kZWJvdW5jZUFjY2VwdCA9IC0xO1xuICAgICAgICB0aGlzLmNvbXBvc2luZyA9IDAgLyogTm9uZSAqLztcbiAgICAgICAgZm9yIChsZXQgYWN0aXZlIG9mIHZpZXcuc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlKS5hY3RpdmUpXG4gICAgICAgICAgICBpZiAoYWN0aXZlLnN0YXRlID09IDEgLyogUGVuZGluZyAqLylcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0UXVlcnkoYWN0aXZlKTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgY1N0YXRlID0gdXBkYXRlLnN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSk7XG4gICAgICAgIGlmICghdXBkYXRlLnNlbGVjdGlvblNldCAmJiAhdXBkYXRlLmRvY0NoYW5nZWQgJiYgdXBkYXRlLnN0YXJ0U3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlKSA9PSBjU3RhdGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBkb2VzUmVzZXQgPSB1cGRhdGUudHJhbnNhY3Rpb25zLnNvbWUodHIgPT4ge1xuICAgICAgICAgICAgbGV0IGV2ZW50ID0gdHIuYW5ub3RhdGlvbihzdGF0ZS5UcmFuc2FjdGlvbi51c2VyRXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuICh0ci5zZWxlY3Rpb24gfHwgdHIuZG9jQ2hhbmdlZCkgJiYgZXZlbnQgIT0gXCJpbnB1dFwiICYmIGV2ZW50ICE9IFwiZGVsZXRlXCI7XG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucnVubmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5ydW5uaW5nW2ldO1xuICAgICAgICAgICAgaWYgKGRvZXNSZXNldCB8fFxuICAgICAgICAgICAgICAgIHF1ZXJ5LnVwZGF0ZXMubGVuZ3RoICsgdXBkYXRlLnRyYW5zYWN0aW9ucy5sZW5ndGggPiBNYXhVcGRhdGVDb3VudCAmJiBxdWVyeS50aW1lIC0gRGF0ZS5ub3coKSA+IE1pbkFib3J0VGltZSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGhhbmRsZXIgb2YgcXVlcnkuY29udGV4dC5hYm9ydExpc3RlbmVycykge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3LmxvZ0V4Y2VwdGlvbih0aGlzLnZpZXcuc3RhdGUsIGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHF1ZXJ5LmNvbnRleHQuYWJvcnRMaXN0ZW5lcnMgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMucnVubmluZy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHF1ZXJ5LnVwZGF0ZXMucHVzaCguLi51cGRhdGUudHJhbnNhY3Rpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kZWJvdW5jZVVwZGF0ZSA+IC0xKVxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZGVib3VuY2VVcGRhdGUpO1xuICAgICAgICB0aGlzLmRlYm91bmNlVXBkYXRlID0gY1N0YXRlLmFjdGl2ZS5zb21lKGEgPT4gYS5zdGF0ZSA9PSAxIC8qIFBlbmRpbmcgKi8gJiYgIXRoaXMucnVubmluZy5zb21lKHEgPT4gcS5zb3VyY2UgPT0gYS5zb3VyY2UpKVxuICAgICAgICAgICAgPyBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc3RhcnRVcGRhdGUoKSwgRGVib3VuY2VUaW1lKSA6IC0xO1xuICAgICAgICBpZiAodGhpcy5jb21wb3NpbmcgIT0gMCAvKiBOb25lICovKVxuICAgICAgICAgICAgZm9yIChsZXQgdHIgb2YgdXBkYXRlLnRyYW5zYWN0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmICh0ci5hbm5vdGF0aW9uKHN0YXRlLlRyYW5zYWN0aW9uLnVzZXJFdmVudCkgPT0gXCJpbnB1dFwiKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvc2luZyA9IDIgLyogQ2hhbmdlZCAqLztcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmNvbXBvc2luZyA9PSAyIC8qIENoYW5nZWQgKi8gJiYgdHIuc2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvc2luZyA9IDMgLyogQ2hhbmdlZEFuZE1vdmVkICovO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydFVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5kZWJvdW5jZVVwZGF0ZSA9IC0xO1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdGhpcy52aWV3LCBjU3RhdGUgPSBzdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUpO1xuICAgICAgICBmb3IgKGxldCBhY3RpdmUgb2YgY1N0YXRlLmFjdGl2ZSkge1xuICAgICAgICAgICAgaWYgKGFjdGl2ZS5zdGF0ZSA9PSAxIC8qIFBlbmRpbmcgKi8gJiYgIXRoaXMucnVubmluZy5zb21lKHIgPT4gci5zb3VyY2UgPT0gYWN0aXZlLnNvdXJjZSkpXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFF1ZXJ5KGFjdGl2ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnRRdWVyeShhY3RpdmUpIHtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHRoaXMudmlldywgcG9zID0gY3VyKHN0YXRlKTtcbiAgICAgICAgbGV0IGNvbnRleHQgPSBuZXcgQ29tcGxldGlvbkNvbnRleHQoc3RhdGUsIHBvcywgYWN0aXZlLmV4cGxpY2l0KTtcbiAgICAgICAgbGV0IHBlbmRpbmcgPSBuZXcgUnVubmluZ1F1ZXJ5KGFjdGl2ZS5zb3VyY2UsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnJ1bm5pbmcucHVzaChwZW5kaW5nKTtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKGFjdGl2ZS5zb3VyY2UoY29udGV4dCkpLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgICAgIGlmICghcGVuZGluZy5jb250ZXh0LmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICBwZW5kaW5nLmRvbmUgPSByZXN1bHQgfHwgbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnNjaGVkdWxlQWNjZXB0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGVyciA9PiB7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBjbG9zZUNvbXBsZXRpb25FZmZlY3Qub2YobnVsbCkgfSk7XG4gICAgICAgICAgICB2aWV3LmxvZ0V4Y2VwdGlvbih0aGlzLnZpZXcuc3RhdGUsIGVycik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzY2hlZHVsZUFjY2VwdCgpIHtcbiAgICAgICAgaWYgKHRoaXMucnVubmluZy5ldmVyeShxID0+IHEuZG9uZSAhPT0gdW5kZWZpbmVkKSlcbiAgICAgICAgICAgIHRoaXMuYWNjZXB0KCk7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZGVib3VuY2VBY2NlcHQgPCAwKVxuICAgICAgICAgICAgdGhpcy5kZWJvdW5jZUFjY2VwdCA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5hY2NlcHQoKSwgRGVib3VuY2VUaW1lKTtcbiAgICB9XG4gICAgLy8gRm9yIGVhY2ggZmluaXNoZWQgcXVlcnkgaW4gdGhpcy5ydW5uaW5nLCB0cnkgdG8gY3JlYXRlIGEgcmVzdWx0XG4gICAgLy8gb3IsIGlmIGFwcHJvcHJpYXRlLCByZXN0YXJ0IHRoZSBxdWVyeS5cbiAgICBhY2NlcHQoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRoaXMuZGVib3VuY2VBY2NlcHQgPiAtMSlcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRlYm91bmNlQWNjZXB0KTtcbiAgICAgICAgdGhpcy5kZWJvdW5jZUFjY2VwdCA9IC0xO1xuICAgICAgICBsZXQgdXBkYXRlZCA9IFtdO1xuICAgICAgICBsZXQgY29uZiA9IHRoaXMudmlldy5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJ1bm5pbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBxdWVyeSA9IHRoaXMucnVubmluZ1tpXTtcbiAgICAgICAgICAgIGlmIChxdWVyeS5kb25lID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB0aGlzLnJ1bm5pbmcuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgICAgICBpZiAocXVlcnkuZG9uZSkge1xuICAgICAgICAgICAgICAgIGxldCBhY3RpdmUgPSBuZXcgQWN0aXZlUmVzdWx0KHF1ZXJ5LnNvdXJjZSwgcXVlcnkuY29udGV4dC5leHBsaWNpdCwgcXVlcnkuZG9uZSwgcXVlcnkuZG9uZS5mcm9tLCAoX2EgPSBxdWVyeS5kb25lLnRvKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjdXIocXVlcnkudXBkYXRlcy5sZW5ndGggPyBxdWVyeS51cGRhdGVzWzBdLnN0YXJ0U3RhdGUgOiB0aGlzLnZpZXcuc3RhdGUpLCBxdWVyeS5kb25lLnNwYW4gPyBlbnN1cmVBbmNob3IocXVlcnkuZG9uZS5zcGFuLCB0cnVlKSA6IG51bGwpO1xuICAgICAgICAgICAgICAgIC8vIFJlcGxheSB0aGUgdHJhbnNhY3Rpb25zIHRoYXQgaGFwcGVuZWQgc2luY2UgdGhlIHN0YXJ0IG9mXG4gICAgICAgICAgICAgICAgLy8gdGhlIHJlcXVlc3QgYW5kIHNlZSBpZiB0aGF0IHByZXNlcnZlcyB0aGUgcmVzdWx0XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgdHIgb2YgcXVlcnkudXBkYXRlcylcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlID0gYWN0aXZlLnVwZGF0ZSh0ciwgY29uZik7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2ZS5oYXNSZXN1bHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkLnB1c2goYWN0aXZlKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLnZpZXcuc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlKS5hY3RpdmUuZmluZChhID0+IGEuc291cmNlID09IHF1ZXJ5LnNvdXJjZSk7XG4gICAgICAgICAgICBpZiAoY3VycmVudCAmJiBjdXJyZW50LnN0YXRlID09IDEgLyogUGVuZGluZyAqLykge1xuICAgICAgICAgICAgICAgIGlmIChxdWVyeS5kb25lID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRXhwbGljaXRseSBmYWlsZWQuIFNob3VsZCBjbGVhciB0aGUgcGVuZGluZyBzdGF0dXMgaWYgaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFzbid0IGJlZW4gcmUtc2V0IGluIHRoZSBtZWFudGltZS5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGFjdGl2ZSA9IG5ldyBBY3RpdmVTb3VyY2UocXVlcnkuc291cmNlLCAwIC8qIEluYWN0aXZlICovLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHRyIG9mIHF1ZXJ5LnVwZGF0ZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmUgPSBhY3RpdmUudXBkYXRlKHRyLCBjb25mKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZS5zdGF0ZSAhPSAxIC8qIFBlbmRpbmcgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkLnB1c2goYWN0aXZlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENsZWFyZWQgYnkgc3Vic2VxdWVudCB0cmFuc2FjdGlvbnMuIFJlc3RhcnQuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRRdWVyeShjdXJyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZWQubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc2V0QWN0aXZlRWZmZWN0Lm9mKHVwZGF0ZWQpIH0pO1xuICAgIH1cbn0sIHtcbiAgICBldmVudEhhbmRsZXJzOiB7XG4gICAgICAgIGNvbXBvc2l0aW9uc3RhcnQoKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvc2luZyA9IDEgLyogU3RhcnRlZCAqLztcbiAgICAgICAgfSxcbiAgICAgICAgY29tcG9zaXRpb25lbmQoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb21wb3NpbmcgPT0gMyAvKiBDaGFuZ2VkQW5kTW92ZWQgKi8pXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc3RhcnRDb21wbGV0aW9uRWZmZWN0Lm9mKGZhbHNlKSB9KTtcbiAgICAgICAgICAgIHRoaXMuY29tcG9zaW5nID0gMCAvKiBOb25lICovO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbmNsYXNzIEZpZWxkUG9zIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgbGluZSwgZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy5maWVsZCA9IGZpZWxkO1xuICAgICAgICB0aGlzLmxpbmUgPSBsaW5lO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgfVxufVxuY2xhc3MgRmllbGRSYW5nZSB7XG4gICAgY29uc3RydWN0b3IoZmllbGQsIGZyb20sIHRvKSB7XG4gICAgICAgIHRoaXMuZmllbGQgPSBmaWVsZDtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbiAgICBtYXAoY2hhbmdlcykge1xuICAgICAgICByZXR1cm4gbmV3IEZpZWxkUmFuZ2UodGhpcy5maWVsZCwgY2hhbmdlcy5tYXBQb3ModGhpcy5mcm9tLCAtMSksIGNoYW5nZXMubWFwUG9zKHRoaXMudG8sIDEpKTtcbiAgICB9XG59XG5jbGFzcyBTbmlwcGV0IHtcbiAgICBjb25zdHJ1Y3RvcihsaW5lcywgZmllbGRQb3NpdGlvbnMpIHtcbiAgICAgICAgdGhpcy5saW5lcyA9IGxpbmVzO1xuICAgICAgICB0aGlzLmZpZWxkUG9zaXRpb25zID0gZmllbGRQb3NpdGlvbnM7XG4gICAgfVxuICAgIGluc3RhbnRpYXRlKHN0YXRlLCBwb3MpIHtcbiAgICAgICAgbGV0IHRleHQgPSBbXSwgbGluZVN0YXJ0ID0gW3Bvc107XG4gICAgICAgIGxldCBsaW5lT2JqID0gc3RhdGUuZG9jLmxpbmVBdChwb3MpLCBiYXNlSW5kZW50ID0gL15cXHMqLy5leGVjKGxpbmVPYmoudGV4dClbMF07XG4gICAgICAgIGZvciAobGV0IGxpbmUgb2YgdGhpcy5saW5lcykge1xuICAgICAgICAgICAgaWYgKHRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGluZGVudCA9IGJhc2VJbmRlbnQsIHRhYnMgPSAvXlxcdCovLmV4ZWMobGluZSlbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFiczsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBpbmRlbnQgKz0gc3RhdGUuZmFjZXQobGFuZ3VhZ2UuaW5kZW50VW5pdCk7XG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0LnB1c2gocG9zICsgaW5kZW50Lmxlbmd0aCAtIHRhYnMpO1xuICAgICAgICAgICAgICAgIGxpbmUgPSBpbmRlbnQgKyBsaW5lLnNsaWNlKHRhYnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGV4dC5wdXNoKGxpbmUpO1xuICAgICAgICAgICAgcG9zICs9IGxpbmUubGVuZ3RoICsgMTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmFuZ2VzID0gdGhpcy5maWVsZFBvc2l0aW9ucy5tYXAocG9zID0+IG5ldyBGaWVsZFJhbmdlKHBvcy5maWVsZCwgbGluZVN0YXJ0W3Bvcy5saW5lXSArIHBvcy5mcm9tLCBsaW5lU3RhcnRbcG9zLmxpbmVdICsgcG9zLnRvKSk7XG4gICAgICAgIHJldHVybiB7IHRleHQsIHJhbmdlcyB9O1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2UodGVtcGxhdGUpIHtcbiAgICAgICAgbGV0IGZpZWxkcyA9IFtdO1xuICAgICAgICBsZXQgbGluZXMgPSBbXSwgcG9zaXRpb25zID0gW10sIG07XG4gICAgICAgIGZvciAobGV0IGxpbmUgb2YgdGVtcGxhdGUuc3BsaXQoL1xcclxcbj98XFxuLykpIHtcbiAgICAgICAgICAgIHdoaWxlIChtID0gL1sjJF1cXHsoPzooXFxkKykoPzo6KFtefV0qKSk/fChbXn1dKikpXFx9Ly5leGVjKGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNlcSA9IG1bMV0gPyArbVsxXSA6IG51bGwsIG5hbWUgPSBtWzJdIHx8IG1bM10sIGZvdW5kID0gLTE7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgPyBmaWVsZHNbaV0ubmFtZSA9PSBuYW1lIDogc2VxICE9IG51bGwgJiYgZmllbGRzW2ldLnNlcSA9PSBzZXEpXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmb3VuZCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaSA8IGZpZWxkcy5sZW5ndGggJiYgKHNlcSA9PSBudWxsIHx8IChmaWVsZHNbaV0uc2VxICE9IG51bGwgJiYgZmllbGRzW2ldLnNlcSA8IHNlcSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICBmaWVsZHMuc3BsaWNlKGksIDAsIHsgc2VxLCBuYW1lOiBuYW1lIHx8IG51bGwgfSk7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9zaXRpb25zLnB1c2gobmV3IEZpZWxkUG9zKGZvdW5kLCBsaW5lcy5sZW5ndGgsIG0uaW5kZXgsIG0uaW5kZXggKyBuYW1lLmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnNsaWNlKDAsIG0uaW5kZXgpICsgbmFtZSArIGxpbmUuc2xpY2UobS5pbmRleCArIG1bMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbmVzLnB1c2gobGluZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTbmlwcGV0KGxpbmVzLCBwb3NpdGlvbnMpO1xuICAgIH1cbn1cbmxldCBmaWVsZE1hcmtlciA9IHZpZXcuRGVjb3JhdGlvbi53aWRnZXQoeyB3aWRnZXQ6IG5ldyBjbGFzcyBleHRlbmRzIHZpZXcuV2lkZ2V0VHlwZSB7XG4gICAgICAgIHRvRE9NKCkge1xuICAgICAgICAgICAgbGV0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgICAgIHNwYW4uY2xhc3NOYW1lID0gXCJjbS1zbmlwcGV0RmllbGRQb3NpdGlvblwiO1xuICAgICAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgICAgIH1cbiAgICAgICAgaWdub3JlRXZlbnQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIH0gfSk7XG5sZXQgZmllbGRSYW5nZSA9IHZpZXcuRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tc25pcHBldEZpZWxkXCIgfSk7XG5jbGFzcyBBY3RpdmVTbmlwcGV0IHtcbiAgICBjb25zdHJ1Y3RvcihyYW5nZXMsIGFjdGl2ZSkge1xuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBhY3RpdmU7XG4gICAgICAgIHRoaXMuZGVjbyA9IHZpZXcuRGVjb3JhdGlvbi5zZXQocmFuZ2VzLm1hcChyID0+IChyLmZyb20gPT0gci50byA/IGZpZWxkTWFya2VyIDogZmllbGRSYW5nZSkucmFuZ2Uoci5mcm9tLCByLnRvKSkpO1xuICAgIH1cbiAgICBtYXAoY2hhbmdlcykge1xuICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVNuaXBwZXQodGhpcy5yYW5nZXMubWFwKHIgPT4gci5tYXAoY2hhbmdlcykpLCB0aGlzLmFjdGl2ZSk7XG4gICAgfVxuICAgIHNlbGVjdGlvbkluc2lkZUZpZWxkKHNlbCkge1xuICAgICAgICByZXR1cm4gc2VsLnJhbmdlcy5ldmVyeShyYW5nZSA9PiB0aGlzLnJhbmdlcy5zb21lKHIgPT4gci5maWVsZCA9PSB0aGlzLmFjdGl2ZSAmJiByLmZyb20gPD0gcmFuZ2UuZnJvbSAmJiByLnRvID49IHJhbmdlLnRvKSk7XG4gICAgfVxufVxuY29uc3Qgc2V0QWN0aXZlID0gc3RhdGUuU3RhdGVFZmZlY3QuZGVmaW5lKHtcbiAgICBtYXAodmFsdWUsIGNoYW5nZXMpIHsgcmV0dXJuIHZhbHVlICYmIHZhbHVlLm1hcChjaGFuZ2VzKTsgfVxufSk7XG5jb25zdCBtb3ZlVG9GaWVsZCA9IHN0YXRlLlN0YXRlRWZmZWN0LmRlZmluZSgpO1xuY29uc3Qgc25pcHBldFN0YXRlID0gc3RhdGUuU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgdXBkYXRlKHZhbHVlLCB0cikge1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhzZXRBY3RpdmUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBlZmZlY3QudmFsdWU7XG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKG1vdmVUb0ZpZWxkKSAmJiB2YWx1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVNuaXBwZXQodmFsdWUucmFuZ2VzLCBlZmZlY3QudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0ci5kb2NDaGFuZ2VkKVxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5tYXAodHIuY2hhbmdlcyk7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0ci5zZWxlY3Rpb24gJiYgIXZhbHVlLnNlbGVjdGlvbkluc2lkZUZpZWxkKHRyLnNlbGVjdGlvbikpXG4gICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHByb3ZpZGU6IGYgPT4gdmlldy5FZGl0b3JWaWV3LmRlY29yYXRpb25zLmZyb20oZiwgdmFsID0+IHZhbCA/IHZhbC5kZWNvIDogdmlldy5EZWNvcmF0aW9uLm5vbmUpXG59KTtcbmZ1bmN0aW9uIGZpZWxkU2VsZWN0aW9uKHJhbmdlcywgZmllbGQpIHtcbiAgICByZXR1cm4gc3RhdGUuRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMuZmlsdGVyKHIgPT4gci5maWVsZCA9PSBmaWVsZCkubWFwKHIgPT4gc3RhdGUuRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHIuZnJvbSwgci50bykpKTtcbn1cbi8qKlxuQ29udmVydCBhIHNuaXBwZXQgdGVtcGxhdGUgdG8gYSBmdW5jdGlvbiB0aGF0IGNhbiBhcHBseSBpdC5cblNuaXBwZXRzIGFyZSB3cml0dGVuIHVzaW5nIHN5bnRheCBsaWtlIHRoaXM6XG5cbiAgICBcImZvciAobGV0ICR7aW5kZXh9ID0gMDsgJHtpbmRleH0gPCAke2VuZH07ICR7aW5kZXh9KyspIHtcXG5cXHQke31cXG59XCJcblxuRWFjaCBgJHt9YCBwbGFjZWhvbGRlciAoeW91IG1heSBhbHNvIHVzZSBgI3t9YCkgaW5kaWNhdGVzIGEgZmllbGRcbnRoYXQgdGhlIHVzZXIgY2FuIGZpbGwgaW4uIEl0cyBuYW1lLCBpZiBhbnksIHdpbGwgYmUgdGhlIGRlZmF1bHRcbmNvbnRlbnQgZm9yIHRoZSBmaWVsZC5cblxuV2hlbiB0aGUgc25pcHBldCBpcyBhY3RpdmF0ZWQgYnkgY2FsbGluZyB0aGUgcmV0dXJuZWQgZnVuY3Rpb24sXG50aGUgY29kZSBpcyBpbnNlcnRlZCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uIE5ld2xpbmVzIGluIHRoZVxudGVtcGxhdGUgYXJlIGluZGVudGVkIGJ5IHRoZSBpbmRlbnRhdGlvbiBvZiB0aGUgc3RhcnQgbGluZSwgcGx1c1xub25lIFtpbmRlbnQgdW5pdF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRVbml0KSBwZXIgdGFiIGNoYXJhY3RlciBhZnRlclxudGhlIG5ld2xpbmUuXG5cbk9uIGFjdGl2YXRpb24sIChhbGwgaW5zdGFuY2VzIG9mKSB0aGUgZmlyc3QgZmllbGQgYXJlIHNlbGVjdGVkLlxuVGhlIHVzZXIgY2FuIG1vdmUgYmV0d2VlbiBmaWVsZHMgd2l0aCBUYWIgYW5kIFNoaWZ0LVRhYiBhcyBsb25nIGFzXG50aGUgZmllbGRzIGFyZSBhY3RpdmUuIE1vdmluZyB0byB0aGUgbGFzdCBmaWVsZCBvciBtb3ZpbmcgdGhlXG5jdXJzb3Igb3V0IG9mIHRoZSBjdXJyZW50IGZpZWxkIGRlYWN0aXZhdGVzIHRoZSBmaWVsZHMuXG5cblRoZSBvcmRlciBvZiBmaWVsZHMgZGVmYXVsdHMgdG8gdGV4dHVhbCBvcmRlciwgYnV0IHlvdSBjYW4gYWRkXG5udW1iZXJzIHRvIHBsYWNlaG9sZGVycyAoYCR7MX1gIG9yIGAkezE6ZGVmYXVsdFRleHR9YCkgdG8gcHJvdmlkZVxuYSBjdXN0b20gb3JkZXIuXG4qL1xuZnVuY3Rpb24gc25pcHBldCh0ZW1wbGF0ZSkge1xuICAgIGxldCBzbmlwcGV0ID0gU25pcHBldC5wYXJzZSh0ZW1wbGF0ZSk7XG4gICAgcmV0dXJuIChlZGl0b3IsIF9jb21wbGV0aW9uLCBmcm9tLCB0bykgPT4ge1xuICAgICAgICBsZXQgeyB0ZXh0LCByYW5nZXMgfSA9IHNuaXBwZXQuaW5zdGFudGlhdGUoZWRpdG9yLnN0YXRlLCBmcm9tKTtcbiAgICAgICAgbGV0IHNwZWMgPSB7IGNoYW5nZXM6IHsgZnJvbSwgdG8sIGluc2VydDogc3RhdGUuVGV4dC5vZih0ZXh0KSB9IH07XG4gICAgICAgIGlmIChyYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgc3BlYy5zZWxlY3Rpb24gPSBmaWVsZFNlbGVjdGlvbihyYW5nZXMsIDApO1xuICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGxldCBlZmZlY3RzID0gc3BlYy5lZmZlY3RzID0gW3NldEFjdGl2ZS5vZihuZXcgQWN0aXZlU25pcHBldChyYW5nZXMsIDApKV07XG4gICAgICAgICAgICBpZiAoZWRpdG9yLnN0YXRlLmZpZWxkKHNuaXBwZXRTdGF0ZSwgZmFsc2UpID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgZWZmZWN0cy5wdXNoKHN0YXRlLlN0YXRlRWZmZWN0LmFwcGVuZENvbmZpZy5vZihbc25pcHBldFN0YXRlLCBhZGRTbmlwcGV0S2V5bWFwLCBzbmlwcGV0UG9pbnRlckhhbmRsZXIsIGJhc2VUaGVtZV0pKTtcbiAgICAgICAgfVxuICAgICAgICBlZGl0b3IuZGlzcGF0Y2goZWRpdG9yLnN0YXRlLnVwZGF0ZShzcGVjKSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1vdmVGaWVsZChkaXIpIHtcbiAgICByZXR1cm4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICAgICAgbGV0IGFjdGl2ZSA9IHN0YXRlLmZpZWxkKHNuaXBwZXRTdGF0ZSwgZmFsc2UpO1xuICAgICAgICBpZiAoIWFjdGl2ZSB8fCBkaXIgPCAwICYmIGFjdGl2ZS5hY3RpdmUgPT0gMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IG5leHQgPSBhY3RpdmUuYWN0aXZlICsgZGlyLCBsYXN0ID0gZGlyID4gMCAmJiAhYWN0aXZlLnJhbmdlcy5zb21lKHIgPT4gci5maWVsZCA9PSBuZXh0ICsgZGlyKTtcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHtcbiAgICAgICAgICAgIHNlbGVjdGlvbjogZmllbGRTZWxlY3Rpb24oYWN0aXZlLnJhbmdlcywgbmV4dCksXG4gICAgICAgICAgICBlZmZlY3RzOiBzZXRBY3RpdmUub2YobGFzdCA/IG51bGwgOiBuZXcgQWN0aXZlU25pcHBldChhY3RpdmUucmFuZ2VzLCBuZXh0KSlcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG5BIGNvbW1hbmQgdGhhdCBjbGVhcnMgdGhlIGFjdGl2ZSBzbmlwcGV0LCBpZiBhbnkuXG4qL1xuY29uc3QgY2xlYXJTbmlwcGV0ID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBsZXQgYWN0aXZlID0gc3RhdGUuZmllbGQoc25pcHBldFN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKCFhY3RpdmUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoeyBlZmZlY3RzOiBzZXRBY3RpdmUub2YobnVsbCkgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuTW92ZSB0byB0aGUgbmV4dCBzbmlwcGV0IGZpZWxkLCBpZiBhdmFpbGFibGUuXG4qL1xuY29uc3QgbmV4dFNuaXBwZXRGaWVsZCA9IG1vdmVGaWVsZCgxKTtcbi8qKlxuTW92ZSB0byB0aGUgcHJldmlvdXMgc25pcHBldCBmaWVsZCwgaWYgYXZhaWxhYmxlLlxuKi9cbmNvbnN0IHByZXZTbmlwcGV0RmllbGQgPSBtb3ZlRmllbGQoLTEpO1xuY29uc3QgZGVmYXVsdFNuaXBwZXRLZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiVGFiXCIsIHJ1bjogbmV4dFNuaXBwZXRGaWVsZCwgc2hpZnQ6IHByZXZTbmlwcGV0RmllbGQgfSxcbiAgICB7IGtleTogXCJFc2NhcGVcIiwgcnVuOiBjbGVhclNuaXBwZXQgfVxuXTtcbi8qKlxuQSBmYWNldCB0aGF0IGNhbiBiZSB1c2VkIHRvIGNvbmZpZ3VyZSB0aGUga2V5IGJpbmRpbmdzIHVzZWQgYnlcbnNuaXBwZXRzLiBUaGUgZGVmYXVsdCBiaW5kcyBUYWIgdG9cbltgbmV4dFNuaXBwZXRGaWVsZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLm5leHRTbmlwcGV0RmllbGQpLCBTaGlmdC1UYWIgdG9cbltgcHJldlNuaXBwZXRGaWVsZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLnByZXZTbmlwcGV0RmllbGQpLCBhbmQgRXNjYXBlXG50byBbYGNsZWFyU25pcHBldGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLmNsZWFyU25pcHBldCkuXG4qL1xuY29uc3Qgc25pcHBldEtleW1hcCA9IHN0YXRlLkZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShtYXBzKSB7IHJldHVybiBtYXBzLmxlbmd0aCA/IG1hcHNbMF0gOiBkZWZhdWx0U25pcHBldEtleW1hcDsgfVxufSk7XG5jb25zdCBhZGRTbmlwcGV0S2V5bWFwID0gc3RhdGUuUHJlYy5vdmVycmlkZSh2aWV3LmtleW1hcC5jb21wdXRlKFtzbmlwcGV0S2V5bWFwXSwgc3RhdGUgPT4gc3RhdGUuZmFjZXQoc25pcHBldEtleW1hcCkpKTtcbi8qKlxuQ3JlYXRlIGEgY29tcGxldGlvbiBmcm9tIGEgc25pcHBldC4gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGVcbnByb3BlcnRpZXMgZnJvbSBgY29tcGxldGlvbmAsIHBsdXMgYW4gYGFwcGx5YCBmdW5jdGlvbiB0aGF0XG5hcHBsaWVzIHRoZSBzbmlwcGV0LlxuKi9cbmZ1bmN0aW9uIHNuaXBwZXRDb21wbGV0aW9uKHRlbXBsYXRlLCBjb21wbGV0aW9uKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29tcGxldGlvbiksIHsgYXBwbHk6IHNuaXBwZXQodGVtcGxhdGUpIH0pO1xufVxuY29uc3Qgc25pcHBldFBvaW50ZXJIYW5kbGVyID0gdmlldy5FZGl0b3JWaWV3LmRvbUV2ZW50SGFuZGxlcnMoe1xuICAgIG1vdXNlZG93bihldmVudCwgdmlldykge1xuICAgICAgICBsZXQgYWN0aXZlID0gdmlldy5zdGF0ZS5maWVsZChzbmlwcGV0U3RhdGUsIGZhbHNlKSwgcG9zO1xuICAgICAgICBpZiAoIWFjdGl2ZSB8fCAocG9zID0gdmlldy5wb3NBdENvb3Jkcyh7IHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFkgfSkpID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBtYXRjaCA9IGFjdGl2ZS5yYW5nZXMuZmluZChyID0+IHIuZnJvbSA8PSBwb3MgJiYgci50byA+PSBwb3MpO1xuICAgICAgICBpZiAoIW1hdGNoIHx8IG1hdGNoLmZpZWxkID09IGFjdGl2ZS5hY3RpdmUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICAgICAgc2VsZWN0aW9uOiBmaWVsZFNlbGVjdGlvbihhY3RpdmUucmFuZ2VzLCBtYXRjaC5maWVsZCksXG4gICAgICAgICAgICBlZmZlY3RzOiBzZXRBY3RpdmUub2YoYWN0aXZlLnJhbmdlcy5zb21lKHIgPT4gci5maWVsZCA+IG1hdGNoLmZpZWxkKSA/IG5ldyBBY3RpdmVTbmlwcGV0KGFjdGl2ZS5yYW5nZXMsIG1hdGNoLmZpZWxkKSA6IG51bGwpXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59KTtcblxuLyoqXG5BIGNvbXBsZXRpb24gc291cmNlIHRoYXQgd2lsbCBzY2FuIHRoZSBkb2N1bWVudCBmb3Igd29yZHMgKHVzaW5nIGFcbltjaGFyYWN0ZXIgY2F0ZWdvcml6ZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuY2hhckNhdGVnb3JpemVyKSksIGFuZFxucmV0dXJuIHRob3NlIGFzIGNvbXBsZXRpb25zLlxuKi9cbmNvbnN0IGNvbXBsZXRlQW55V29yZCA9IGNvbnRleHQgPT4ge1xuICAgIGxldCBvcHRpb25zID0gW10sIHNlZW4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGxldCBjYXQgPSBjb250ZXh0LnN0YXRlLmNoYXJDYXRlZ29yaXplcihjb250ZXh0LnBvcyk7XG4gICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgoMCwgY29udGV4dC5wb3MgLSA1MDAwMCAvKiBSYW5nZSAqLyksIGVuZCA9IE1hdGgubWluKGNvbnRleHQuc3RhdGUuZG9jLmxlbmd0aCwgc3RhcnQgKyA1MDAwMCAvKiBSYW5nZSAqLyAqIDIpO1xuICAgIGxldCBmcm9tID0gY29udGV4dC5wb3M7XG4gICAgZm9yIChsZXQgY3VyID0gY29udGV4dC5zdGF0ZS5kb2MuaXRlclJhbmdlKHN0YXJ0LCBlbmQpLCBwb3MgPSBzdGFydDsgIShjdXIubmV4dCgpKS5kb25lOykge1xuICAgICAgICBsZXQgeyB2YWx1ZSB9ID0gY3VyLCBzdGFydCA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gMDs7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPCB2YWx1ZS5sZW5ndGggJiYgY2F0KHZhbHVlW2ldKSA9PSBzdGF0ZS5DaGFyQ2F0ZWdvcnkuV29yZCkge1xuICAgICAgICAgICAgICAgIGlmIChzdGFydCA8IDApXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YXJ0ID4gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAocG9zICsgc3RhcnQgPD0gY29udGV4dC5wb3MgJiYgcG9zICsgaSA+PSBjb250ZXh0LnBvcykge1xuICAgICAgICAgICAgICAgICAgICBmcm9tID0gcG9zICsgc3RhcnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgd29yZCA9IHZhbHVlLnNsaWNlKHN0YXJ0LCBpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWVuW3dvcmRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnB1c2goeyB0eXBlOiBcInRleHRcIiwgbGFiZWw6IHdvcmQgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWVuW3dvcmRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGFydCA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPT0gdmFsdWUubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHBvcyArPSB2YWx1ZS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiB7IGZyb20sIG9wdGlvbnMsIHNwYW46IC9eXFx3Ki8gfTtcbn07XG5cbi8qKlxuUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBlbmFibGVzIGF1dG9jb21wbGV0aW9uLlxuKi9cbmZ1bmN0aW9uIGF1dG9jb21wbGV0aW9uKGNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgY29tcGxldGlvblN0YXRlLFxuICAgICAgICBjb21wbGV0aW9uQ29uZmlnLm9mKGNvbmZpZyksXG4gICAgICAgIGNvbXBsZXRpb25QbHVnaW4sXG4gICAgICAgIGNvbXBsZXRpb25LZXltYXBFeHQsXG4gICAgICAgIGJhc2VUaGVtZVxuICAgIF07XG59XG4vKipcbkJhc2ljIGtleWJpbmRpbmdzIGZvciBhdXRvY29tcGxldGlvbi5cblxuIC0gQ3RybC1TcGFjZTogW2BzdGFydENvbXBsZXRpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5zdGFydENvbXBsZXRpb24pXG4gLSBFc2NhcGU6IFtgY2xvc2VDb21wbGV0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuY2xvc2VDb21wbGV0aW9uKVxuIC0gQXJyb3dEb3duOiBbYG1vdmVDb21wbGV0aW9uU2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUubW92ZUNvbXBsZXRpb25TZWxlY3Rpb24pYCh0cnVlKWBcbiAtIEFycm93VXA6IFtgbW92ZUNvbXBsZXRpb25TZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5tb3ZlQ29tcGxldGlvblNlbGVjdGlvbilgKGZhbHNlKWBcbiAtIFBhZ2VEb3duOiBbYG1vdmVDb21wbGV0aW9uU2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUubW92ZUNvbXBsZXRpb25TZWxlY3Rpb24pYCh0cnVlLCBcInBhZ2VcIilgXG4gLSBQYWdlRG93bjogW2Btb3ZlQ29tcGxldGlvblNlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLm1vdmVDb21wbGV0aW9uU2VsZWN0aW9uKWAodHJ1ZSwgXCJwYWdlXCIpYFxuIC0gRW50ZXI6IFtgYWNjZXB0Q29tcGxldGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLmFjY2VwdENvbXBsZXRpb24pXG4qL1xuY29uc3QgY29tcGxldGlvbktleW1hcCA9IFtcbiAgICB7IGtleTogXCJDdHJsLVNwYWNlXCIsIHJ1bjogc3RhcnRDb21wbGV0aW9uIH0sXG4gICAgeyBrZXk6IFwiRXNjYXBlXCIsIHJ1bjogY2xvc2VDb21wbGV0aW9uIH0sXG4gICAgeyBrZXk6IFwiQXJyb3dEb3duXCIsIHJ1bjogbW92ZUNvbXBsZXRpb25TZWxlY3Rpb24odHJ1ZSkgfSxcbiAgICB7IGtleTogXCJBcnJvd1VwXCIsIHJ1bjogbW92ZUNvbXBsZXRpb25TZWxlY3Rpb24oZmFsc2UpIH0sXG4gICAgeyBrZXk6IFwiUGFnZURvd25cIiwgcnVuOiBtb3ZlQ29tcGxldGlvblNlbGVjdGlvbih0cnVlLCBcInBhZ2VcIikgfSxcbiAgICB7IGtleTogXCJQYWdlVXBcIiwgcnVuOiBtb3ZlQ29tcGxldGlvblNlbGVjdGlvbihmYWxzZSwgXCJwYWdlXCIpIH0sXG4gICAgeyBrZXk6IFwiRW50ZXJcIiwgcnVuOiBhY2NlcHRDb21wbGV0aW9uIH1cbl07XG5jb25zdCBjb21wbGV0aW9uS2V5bWFwRXh0ID0gc3RhdGUuUHJlYy5vdmVycmlkZSh2aWV3LmtleW1hcC5jb21wdXRlTihbY29tcGxldGlvbkNvbmZpZ10sIHN0YXRlID0+IHN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpLmRlZmF1bHRLZXltYXAgPyBbY29tcGxldGlvbktleW1hcF0gOiBbXSkpO1xuLyoqXG5HZXQgdGhlIGN1cnJlbnQgY29tcGxldGlvbiBzdGF0dXMuIFdoZW4gY29tcGxldGlvbnMgYXJlIGF2YWlsYWJsZSxcbnRoaXMgd2lsbCByZXR1cm4gYFwiYWN0aXZlXCJgLiBXaGVuIGNvbXBsZXRpb25zIGFyZSBwZW5kaW5nIChpbiB0aGVcbnByb2Nlc3Mgb2YgYmVpbmcgcXVlcmllZCksIHRoaXMgcmV0dXJucyBgXCJwZW5kaW5nXCJgLiBPdGhlcndpc2UsIGl0XG5yZXR1cm5zIGBudWxsYC5cbiovXG5mdW5jdGlvbiBjb21wbGV0aW9uU3RhdHVzKHN0YXRlKSB7XG4gICAgbGV0IGNTdGF0ZSA9IHN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSwgZmFsc2UpO1xuICAgIHJldHVybiBjU3RhdGUgJiYgY1N0YXRlLmFjdGl2ZS5zb21lKGEgPT4gYS5zdGF0ZSA9PSAxIC8qIFBlbmRpbmcgKi8pID8gXCJwZW5kaW5nXCJcbiAgICAgICAgOiBjU3RhdGUgJiYgY1N0YXRlLmFjdGl2ZS5zb21lKGEgPT4gYS5zdGF0ZSAhPSAwIC8qIEluYWN0aXZlICovKSA/IFwiYWN0aXZlXCIgOiBudWxsO1xufVxuLyoqXG5SZXR1cm5zIHRoZSBhdmFpbGFibGUgY29tcGxldGlvbnMgYXMgYW4gYXJyYXkuXG4qL1xuZnVuY3Rpb24gY3VycmVudENvbXBsZXRpb25zKHN0YXRlKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBvcGVuID0gKF9hID0gc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcGVuO1xuICAgIHJldHVybiBvcGVuID8gb3Blbi5vcHRpb25zLm1hcChvID0+IG8uY29tcGxldGlvbikgOiBbXTtcbn1cblxuZXhwb3J0cy5Db21wbGV0aW9uQ29udGV4dCA9IENvbXBsZXRpb25Db250ZXh0O1xuZXhwb3J0cy5hY2NlcHRDb21wbGV0aW9uID0gYWNjZXB0Q29tcGxldGlvbjtcbmV4cG9ydHMuYXV0b2NvbXBsZXRpb24gPSBhdXRvY29tcGxldGlvbjtcbmV4cG9ydHMuY2xlYXJTbmlwcGV0ID0gY2xlYXJTbmlwcGV0O1xuZXhwb3J0cy5jbG9zZUNvbXBsZXRpb24gPSBjbG9zZUNvbXBsZXRpb247XG5leHBvcnRzLmNvbXBsZXRlQW55V29yZCA9IGNvbXBsZXRlQW55V29yZDtcbmV4cG9ydHMuY29tcGxldGVGcm9tTGlzdCA9IGNvbXBsZXRlRnJvbUxpc3Q7XG5leHBvcnRzLmNvbXBsZXRpb25LZXltYXAgPSBjb21wbGV0aW9uS2V5bWFwO1xuZXhwb3J0cy5jb21wbGV0aW9uU3RhdHVzID0gY29tcGxldGlvblN0YXR1cztcbmV4cG9ydHMuY3VycmVudENvbXBsZXRpb25zID0gY3VycmVudENvbXBsZXRpb25zO1xuZXhwb3J0cy5pZk5vdEluID0gaWZOb3RJbjtcbmV4cG9ydHMubW92ZUNvbXBsZXRpb25TZWxlY3Rpb24gPSBtb3ZlQ29tcGxldGlvblNlbGVjdGlvbjtcbmV4cG9ydHMubmV4dFNuaXBwZXRGaWVsZCA9IG5leHRTbmlwcGV0RmllbGQ7XG5leHBvcnRzLnByZXZTbmlwcGV0RmllbGQgPSBwcmV2U25pcHBldEZpZWxkO1xuZXhwb3J0cy5zbmlwcGV0ID0gc25pcHBldDtcbmV4cG9ydHMuc25pcHBldENvbXBsZXRpb24gPSBzbmlwcGV0Q29tcGxldGlvbjtcbmV4cG9ydHMuc25pcHBldEtleW1hcCA9IHNuaXBwZXRLZXltYXA7XG5leHBvcnRzLnN0YXJ0Q29tcGxldGlvbiA9IHN0YXJ0Q29tcGxldGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIHZpZXcgPSByZXF1aXJlKCdAY29kZW1pcnJvci92aWV3Jyk7XG52YXIgc3RhdGUgPSByZXF1aXJlKCdAY29kZW1pcnJvci9zdGF0ZScpO1xudmFyIGhpc3RvcnkgPSByZXF1aXJlKCdAY29kZW1pcnJvci9oaXN0b3J5Jyk7XG52YXIgZm9sZCA9IHJlcXVpcmUoJ0Bjb2RlbWlycm9yL2ZvbGQnKTtcbnZhciBsYW5ndWFnZSA9IHJlcXVpcmUoJ0Bjb2RlbWlycm9yL2xhbmd1YWdlJyk7XG52YXIgZ3V0dGVyID0gcmVxdWlyZSgnQGNvZGVtaXJyb3IvZ3V0dGVyJyk7XG52YXIgY29tbWFuZHMgPSByZXF1aXJlKCdAY29kZW1pcnJvci9jb21tYW5kcycpO1xudmFyIG1hdGNoYnJhY2tldHMgPSByZXF1aXJlKCdAY29kZW1pcnJvci9tYXRjaGJyYWNrZXRzJyk7XG52YXIgY2xvc2VicmFja2V0cyA9IHJlcXVpcmUoJ0Bjb2RlbWlycm9yL2Nsb3NlYnJhY2tldHMnKTtcbnZhciBzZWFyY2ggPSByZXF1aXJlKCdAY29kZW1pcnJvci9zZWFyY2gnKTtcbnZhciBhdXRvY29tcGxldGUgPSByZXF1aXJlKCdAY29kZW1pcnJvci9hdXRvY29tcGxldGUnKTtcbnZhciBjb21tZW50ID0gcmVxdWlyZSgnQGNvZGVtaXJyb3IvY29tbWVudCcpO1xudmFyIHJlY3Rhbmd1bGFyU2VsZWN0aW9uID0gcmVxdWlyZSgnQGNvZGVtaXJyb3IvcmVjdGFuZ3VsYXItc2VsZWN0aW9uJyk7XG52YXIgaGlnaGxpZ2h0ID0gcmVxdWlyZSgnQGNvZGVtaXJyb3IvaGlnaGxpZ2h0Jyk7XG52YXIgbGludCA9IHJlcXVpcmUoJ0Bjb2RlbWlycm9yL2xpbnQnKTtcblxuLy8vIFRoaXMgaXMgYW4gZXh0ZW5zaW9uIHZhbHVlIHRoYXQganVzdCBwdWxscyB0b2dldGhlciBhIHdob2xlIGxvdCBvZlxuLy8vIGV4dGVuc2lvbnMgdGhhdCB5b3UgbWlnaHQgd2FudCBpbiBhIGJhc2ljIGVkaXRvci4gSXQgaXMgbWVhbnQgYXMgYVxuLy8vIGNvbnZlbmllbnQgaGVscGVyIHRvIHF1aWNrbHkgc2V0IHVwIENvZGVNaXJyb3Igd2l0aG91dCBpbnN0YWxsaW5nXG4vLy8gYW5kIGltcG9ydGluZyBhIGxvdCBvZiBwYWNrYWdlcy5cbi8vL1xuLy8vIFNwZWNpZmljYWxseSwgaXQgaW5jbHVkZXMuLi5cbi8vL1xuLy8vICAtIFt0aGUgZGVmYXVsdCBjb21tYW5kIGJpbmRpbmdzXSgjY29tbWFuZHMuZGVmYXVsdEtleW1hcClcbi8vLyAgLSBbbGluZSBudW1iZXJzXSgjZ3V0dGVyLmxpbmVOdW1iZXJzKVxuLy8vICAtIFtzcGVjaWFsIGNoYXJhY3RlciBoaWdobGlnaHRpbmddKCN2aWV3LmhpZ2hsaWdodFNwZWNpYWxDaGFycylcbi8vLyAgLSBbdGhlIHVuZG8gaGlzdG9yeV0oI2hpc3RvcnkuaGlzdG9yeSlcbi8vLyAgLSBbYSBmb2xkIGd1dHRlcl0oI2ZvbGQuZm9sZEd1dHRlcilcbi8vLyAgLSBbY3VzdG9tIHNlbGVjdGlvbiBkcmF3aW5nXSgjdmlldy5kcmF3U2VsZWN0aW9uKVxuLy8vICAtIFttdWx0aXBsZSBzZWxlY3Rpb25zXSgjc3RhdGUuRWRpdG9yU3RhdGVeYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnMpXG4vLy8gIC0gW3JlaW5kZW50YXRpb24gb24gaW5wdXRdKCNsYW5ndWFnZS5pbmRlbnRPbklucHV0KVxuLy8vICAtIFt0aGUgZGVmYXVsdCBoaWdobGlnaHQgc3R5bGVdKCNoaWdobGlnaHQuZGVmYXVsdEhpZ2hsaWdodFN0eWxlKSAoYXMgZmFsbGJhY2spXG4vLy8gIC0gW2JyYWNrZXQgbWF0Y2hpbmddKCNtYXRjaGJyYWNrZXRzLmJyYWNrZXRNYXRjaGluZylcbi8vLyAgLSBbYnJhY2tldCBjbG9zaW5nXSgjY2xvc2VicmFja2V0cy5jbG9zZUJyYWNrZXRzKVxuLy8vICAtIFthdXRvY29tcGxldGlvbl0oI2F1dG9jb21wbGV0ZS5hdXRvY29tcGxldGlvbilcbi8vLyAgLSBbcmVjdGFuZ3VsYXIgc2VsZWN0aW9uXSgjcmVjdGFuZ3VsYXItc2VsZWN0aW9uLnJlY3Rhbmd1bGFyU2VsZWN0aW9uKVxuLy8vICAtIFthY3RpdmUgbGluZSBoaWdobGlnaHRpbmddKCN2aWV3LmhpZ2hsaWdodEFjdGl2ZUxpbmUpXG4vLy8gIC0gW3NlbGVjdGlvbiBtYXRjaCBoaWdobGlnaHRpbmddKCNzZWFyY2guaGlnaGxpZ2h0U2VsZWN0aW9uTWF0Y2hlcylcbi8vLyAgLSBbc2VhcmNoXSgjc2VhcmNoLnNlYXJjaEtleW1hcClcbi8vLyAgLSBbY29tbWVudGluZ10oI2NvbW1lbnQuY29tbWVudEtleW1hcClcbi8vLyAgLSBbbGludGluZ10oI2xpbnQubGludEtleW1hcClcbi8vL1xuLy8vIChZb3UnbGwgcHJvYmFibHkgd2FudCB0byBhZGQgc29tZSBsYW5ndWFnZSBwYWNrYWdlIHRvIHlvdXIgc2V0dXBcbi8vLyB0b28uKVxuLy8vXG4vLy8gVGhpcyBwYWNrYWdlIGRvZXMgbm90IGFsbG93IGN1c3RvbWl6YXRpb24uIFRoZSBpZGVhIGlzIHRoYXQsIG9uY2Vcbi8vLyB5b3UgZGVjaWRlIHlvdSB3YW50IHRvIGNvbmZpZ3VyZSB5b3VyIGVkaXRvciBtb3JlIHByZWNpc2VseSwgeW91XG4vLy8gdGFrZSB0aGlzIHBhY2thZ2UncyBzb3VyY2UgKHdoaWNoIGlzIGp1c3QgYSBidW5jaCBvZiBpbXBvcnRzIGFuZFxuLy8vIGFuIGFycmF5IGxpdGVyYWwpLCBjb3B5IGl0IGludG8geW91ciBvd24gY29kZSwgYW5kIGFkanVzdCBpdCBhc1xuLy8vIGRlc2lyZWQuXG5jb25zdCBiYXNpY1NldHVwID0gW1xuICAgIGd1dHRlci5saW5lTnVtYmVycygpLFxuICAgIHZpZXcuaGlnaGxpZ2h0U3BlY2lhbENoYXJzKCksXG4gICAgaGlzdG9yeS5oaXN0b3J5KCksXG4gICAgZm9sZC5mb2xkR3V0dGVyKCksXG4gICAgdmlldy5kcmF3U2VsZWN0aW9uKCksXG4gICAgc3RhdGUuRWRpdG9yU3RhdGUuYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnMub2YodHJ1ZSksXG4gICAgbGFuZ3VhZ2UuaW5kZW50T25JbnB1dCgpLFxuICAgIGhpZ2hsaWdodC5kZWZhdWx0SGlnaGxpZ2h0U3R5bGUuZmFsbGJhY2ssXG4gICAgbWF0Y2hicmFja2V0cy5icmFja2V0TWF0Y2hpbmcoKSxcbiAgICBjbG9zZWJyYWNrZXRzLmNsb3NlQnJhY2tldHMoKSxcbiAgICBhdXRvY29tcGxldGUuYXV0b2NvbXBsZXRpb24oKSxcbiAgICByZWN0YW5ndWxhclNlbGVjdGlvbi5yZWN0YW5ndWxhclNlbGVjdGlvbigpLFxuICAgIHZpZXcuaGlnaGxpZ2h0QWN0aXZlTGluZSgpLFxuICAgIHNlYXJjaC5oaWdobGlnaHRTZWxlY3Rpb25NYXRjaGVzKCksXG4gICAgdmlldy5rZXltYXAub2YoW1xuICAgICAgICAuLi5jbG9zZWJyYWNrZXRzLmNsb3NlQnJhY2tldHNLZXltYXAsXG4gICAgICAgIC4uLmNvbW1hbmRzLmRlZmF1bHRLZXltYXAsXG4gICAgICAgIC4uLnNlYXJjaC5zZWFyY2hLZXltYXAsXG4gICAgICAgIC4uLmhpc3RvcnkuaGlzdG9yeUtleW1hcCxcbiAgICAgICAgLi4uZm9sZC5mb2xkS2V5bWFwLFxuICAgICAgICAuLi5jb21tZW50LmNvbW1lbnRLZXltYXAsXG4gICAgICAgIC4uLmF1dG9jb21wbGV0ZS5jb21wbGV0aW9uS2V5bWFwLFxuICAgICAgICAuLi5saW50LmxpbnRLZXltYXBcbiAgICBdKVxuXTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdFZGl0b3JWaWV3Jywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB2aWV3LkVkaXRvclZpZXc7XG4gICAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0VkaXRvclN0YXRlJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZS5FZGl0b3JTdGF0ZTtcbiAgICB9XG59KTtcbmV4cG9ydHMuYmFzaWNTZXR1cCA9IGJhc2ljU2V0dXA7XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciB2aWV3ID0gcmVxdWlyZSgnQGNvZGVtaXJyb3IvdmlldycpO1xudmFyIHN0YXRlID0gcmVxdWlyZSgnQGNvZGVtaXJyb3Ivc3RhdGUnKTtcbnZhciByYW5nZXNldCA9IHJlcXVpcmUoJ0Bjb2RlbWlycm9yL3Jhbmdlc2V0Jyk7XG52YXIgdGV4dCA9IHJlcXVpcmUoJ0Bjb2RlbWlycm9yL3RleHQnKTtcbnZhciBsYW5ndWFnZSA9IHJlcXVpcmUoJ0Bjb2RlbWlycm9yL2xhbmd1YWdlJyk7XG5cbmNvbnN0IGRlZmF1bHRzID0ge1xuICAgIGJyYWNrZXRzOiBbXCIoXCIsIFwiW1wiLCBcIntcIiwgXCInXCIsICdcIiddLFxuICAgIGJlZm9yZTogXCIpXX0nXFxcIjo7PlwiXG59O1xuY29uc3QgY2xvc2VCcmFja2V0RWZmZWN0ID0gc3RhdGUuU3RhdGVFZmZlY3QuZGVmaW5lKHtcbiAgICBtYXAodmFsdWUsIG1hcHBpbmcpIHtcbiAgICAgICAgbGV0IG1hcHBlZCA9IG1hcHBpbmcubWFwUG9zKHZhbHVlLCAtMSwgc3RhdGUuTWFwTW9kZS5UcmFja0FmdGVyKTtcbiAgICAgICAgcmV0dXJuIG1hcHBlZCA9PSBudWxsID8gdW5kZWZpbmVkIDogbWFwcGVkO1xuICAgIH1cbn0pO1xuY29uc3Qgc2tpcEJyYWNrZXRFZmZlY3QgPSBzdGF0ZS5TdGF0ZUVmZmVjdC5kZWZpbmUoe1xuICAgIG1hcCh2YWx1ZSwgbWFwcGluZykgeyByZXR1cm4gbWFwcGluZy5tYXBQb3ModmFsdWUpOyB9XG59KTtcbmNvbnN0IGNsb3NlZEJyYWNrZXQgPSBuZXcgY2xhc3MgZXh0ZW5kcyByYW5nZXNldC5SYW5nZVZhbHVlIHtcbn07XG5jbG9zZWRCcmFja2V0LnN0YXJ0U2lkZSA9IDE7XG5jbG9zZWRCcmFja2V0LmVuZFNpZGUgPSAtMTtcbmNvbnN0IGJyYWNrZXRTdGF0ZSA9IHN0YXRlLlN0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7IHJldHVybiByYW5nZXNldC5SYW5nZVNldC5lbXB0eTsgfSxcbiAgICB1cGRhdGUodmFsdWUsIHRyKSB7XG4gICAgICAgIGlmICh0ci5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGxldCBsaW5lU3RhcnQgPSB0ci5zdGF0ZS5kb2MubGluZUF0KHRyLnNlbGVjdGlvbi5tYWluLmhlYWQpLmZyb207XG4gICAgICAgICAgICBsZXQgcHJldkxpbmVTdGFydCA9IHRyLnN0YXJ0U3RhdGUuZG9jLmxpbmVBdCh0ci5zdGFydFN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpLmZyb207XG4gICAgICAgICAgICBpZiAobGluZVN0YXJ0ICE9IHRyLmNoYW5nZXMubWFwUG9zKHByZXZMaW5lU3RhcnQsIC0xKSlcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHJhbmdlc2V0LlJhbmdlU2V0LmVtcHR5O1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gdmFsdWUubWFwKHRyLmNoYW5nZXMpO1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhjbG9zZUJyYWNrZXRFZmZlY3QpKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudXBkYXRlKHsgYWRkOiBbY2xvc2VkQnJhY2tldC5yYW5nZShlZmZlY3QudmFsdWUsIGVmZmVjdC52YWx1ZSArIDEpXSB9KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGVmZmVjdC5pcyhza2lwQnJhY2tldEVmZmVjdCkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS51cGRhdGUoeyBmaWx0ZXI6IGZyb20gPT4gZnJvbSAhPSBlZmZlY3QudmFsdWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn0pO1xuLy8vIEV4dGVuc2lvbiB0byBlbmFibGUgYnJhY2tldC1jbG9zaW5nIGJlaGF2aW9yLiBXaGVuIGEgY2xvc2VhYmxlXG4vLy8gYnJhY2tldCBpcyB0eXBlZCwgaXRzIGNsb3NpbmcgYnJhY2tldCBpcyBpbW1lZGlhdGVseSBpbnNlcnRlZFxuLy8vIGFmdGVyIHRoZSBjdXJzb3IuIFdoZW4gY2xvc2luZyBhIGJyYWNrZXQgZGlyZWN0bHkgaW4gZnJvbnQgb2YgYVxuLy8vIGNsb3NpbmcgYnJhY2tldCBpbnNlcnRlZCBieSB0aGUgZXh0ZW5zaW9uLCB0aGUgY3Vyc29yIG1vdmVzIG92ZXJcbi8vLyB0aGF0IGJyYWNrZXQuXG5mdW5jdGlvbiBjbG9zZUJyYWNrZXRzKCkge1xuICAgIHJldHVybiBbdmlldy5FZGl0b3JWaWV3LmlucHV0SGFuZGxlci5vZihoYW5kbGVJbnB1dCksIGJyYWNrZXRTdGF0ZV07XG59XG5jb25zdCBkZWZpbmVkQ2xvc2luZyA9IFwiKClbXXt9PD5cIjtcbmZ1bmN0aW9uIGNsb3NpbmcoY2gpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlZmluZWRDbG9zaW5nLmxlbmd0aDsgaSArPSAyKVxuICAgICAgICBpZiAoZGVmaW5lZENsb3NpbmcuY2hhckNvZGVBdChpKSA9PSBjaClcbiAgICAgICAgICAgIHJldHVybiBkZWZpbmVkQ2xvc2luZy5jaGFyQXQoaSArIDEpO1xuICAgIHJldHVybiB0ZXh0LmZyb21Db2RlUG9pbnQoY2ggPCAxMjggPyBjaCA6IGNoICsgMSk7XG59XG5mdW5jdGlvbiBjb25maWcoc3RhdGUsIHBvcykge1xuICAgIHJldHVybiBzdGF0ZS5sYW5ndWFnZURhdGFBdChcImNsb3NlQnJhY2tldHNcIiwgcG9zKVswXSB8fCBkZWZhdWx0cztcbn1cbmZ1bmN0aW9uIGhhbmRsZUlucHV0KHZpZXcsIGZyb20sIHRvLCBpbnNlcnQpIHtcbiAgICBpZiAodmlldy5jb21wb3NpbmcpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICBpZiAoaW5zZXJ0Lmxlbmd0aCA+IDIgfHwgaW5zZXJ0Lmxlbmd0aCA9PSAyICYmIHRleHQuY29kZVBvaW50U2l6ZSh0ZXh0LmNvZGVQb2ludEF0KGluc2VydCwgMCkpID09IDEgfHxcbiAgICAgICAgZnJvbSAhPSBzZWwuZnJvbSB8fCB0byAhPSBzZWwudG8pXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgdHIgPSBpbnNlcnRCcmFja2V0KHZpZXcuc3RhdGUsIGluc2VydCk7XG4gICAgaWYgKCF0cilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgIHJldHVybiB0cnVlO1xufVxuLy8vIENvbW1hbmQgdGhhdCBpbXBsZW1lbnRzIGRlbGV0aW5nIGEgcGFpciBvZiBtYXRjaGluZyBicmFja2V0cyB3aGVuXG4vLy8gdGhlIGN1cnNvciBpcyBiZXR3ZWVuIHRoZW0uXG5jb25zdCBkZWxldGVCcmFja2V0UGFpciA9ICh7IHN0YXRlOiBzdGF0ZSQxLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgbGV0IGNvbmYgPSBjb25maWcoc3RhdGUkMSwgc3RhdGUkMS5zZWxlY3Rpb24ubWFpbi5oZWFkKTtcbiAgICBsZXQgdG9rZW5zID0gY29uZi5icmFja2V0cyB8fCBkZWZhdWx0cy5icmFja2V0cztcbiAgICBsZXQgZG9udCA9IG51bGwsIGNoYW5nZXMgPSBzdGF0ZSQxLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICBpZiAocmFuZ2UuZW1wdHkpIHtcbiAgICAgICAgICAgIGxldCBiZWZvcmUgPSBwcmV2Q2hhcihzdGF0ZSQxLmRvYywgcmFuZ2UuaGVhZCk7XG4gICAgICAgICAgICBmb3IgKGxldCB0b2tlbiBvZiB0b2tlbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT0gYmVmb3JlICYmIG5leHRDaGFyKHN0YXRlJDEuZG9jLCByYW5nZS5oZWFkKSA9PSBjbG9zaW5nKHRleHQuY29kZVBvaW50QXQodG9rZW4sIDApKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBmcm9tOiByYW5nZS5oZWFkIC0gdG9rZW4ubGVuZ3RoLCB0bzogcmFuZ2UuaGVhZCArIHRva2VuLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHN0YXRlLkVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuaGVhZCAtIHRva2VuLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAgICAgICBhbm5vdGF0aW9uczogc3RhdGUuVHJhbnNhY3Rpb24udXNlckV2ZW50Lm9mKFwiZGVsZXRlXCIpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IGRvbnQgPSByYW5nZSB9O1xuICAgIH0pO1xuICAgIGlmICghZG9udClcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUkMS51cGRhdGUoY2hhbmdlcywgeyBzY3JvbGxJbnRvVmlldzogdHJ1ZSB9KSk7XG4gICAgcmV0dXJuICFkb250O1xufTtcbi8vLyBDbG9zZS1icmFja2V0cyByZWxhdGVkIGtleSBiaW5kaW5ncy4gQmluZHMgQmFja3NwYWNlIHRvXG4vLy8gW2BkZWxldGVCcmFja2V0UGFpcmBdKCNjbG9zZWJyYWNrZXRzLmRlbGV0ZUJyYWNrZXRQYWlyKS5cbmNvbnN0IGNsb3NlQnJhY2tldHNLZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiQmFja3NwYWNlXCIsIHJ1bjogZGVsZXRlQnJhY2tldFBhaXIgfVxuXTtcbi8vLyBJbXBsZW1lbnRzIHRoZSBleHRlbnNpb24ncyBiZWhhdmlvciBvbiB0ZXh0IGluc2VydGlvbi4gSWYgdGhlXG4vLy8gZ2l2ZW4gc3RyaW5nIGNvdW50cyBhcyBhIGJyYWNrZXQgaW4gdGhlIGxhbmd1YWdlIGFyb3VuZCB0aGVcbi8vLyBzZWxlY3Rpb24sIGFuZCByZXBsYWNpbmcgdGhlIHNlbGVjdGlvbiB3aXRoIGl0IHJlcXVpcmVzIGN1c3RvbVxuLy8vIGJlaGF2aW9yIChpbnNlcnRpbmcgYSBjbG9zaW5nIHZlcnNpb24gb3Igc2tpcHBpbmcgcGFzdCBhXG4vLy8gcHJldmlvdXNseS1jbG9zZWQgYnJhY2tldCksIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIHRyYW5zYWN0aW9uXG4vLy8gcmVwcmVzZW50aW5nIHRoYXQgY3VzdG9tIGJlaGF2aW9yLiAoWW91IG9ubHkgbmVlZCB0aGlzIGlmIHlvdSB3YW50XG4vLy8gdG8gcHJvZ3JhbW1hdGljYWxseSBpbnNlcnQgYnJhY2tldHPigJR0aGVcbi8vLyBbYGNsb3NlQnJhY2tldHNgXSgjY2xvc2VicmFja2V0cy5jbG9zZUJyYWNrZXRzKSBleHRlbnNpb24gd2lsbFxuLy8vIHRha2UgY2FyZSBvZiBydW5uaW5nIHRoaXMgZm9yIHVzZXIgaW5wdXQuKVxuZnVuY3Rpb24gaW5zZXJ0QnJhY2tldChzdGF0ZSwgYnJhY2tldCkge1xuICAgIGxldCBjb25mID0gY29uZmlnKHN0YXRlLCBzdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKTtcbiAgICBsZXQgdG9rZW5zID0gY29uZi5icmFja2V0cyB8fCBkZWZhdWx0cy5icmFja2V0cztcbiAgICBmb3IgKGxldCB0b2sgb2YgdG9rZW5zKSB7XG4gICAgICAgIGxldCBjbG9zZWQgPSBjbG9zaW5nKHRleHQuY29kZVBvaW50QXQodG9rLCAwKSk7XG4gICAgICAgIGlmIChicmFja2V0ID09IHRvaylcbiAgICAgICAgICAgIHJldHVybiBjbG9zZWQgPT0gdG9rID8gaGFuZGxlU2FtZShzdGF0ZSwgdG9rLCB0b2tlbnMuaW5kZXhPZih0b2sgKyB0b2sgKyB0b2spID4gLTEpXG4gICAgICAgICAgICAgICAgOiBoYW5kbGVPcGVuKHN0YXRlLCB0b2ssIGNsb3NlZCwgY29uZi5iZWZvcmUgfHwgZGVmYXVsdHMuYmVmb3JlKTtcbiAgICAgICAgaWYgKGJyYWNrZXQgPT0gY2xvc2VkICYmIGNsb3NlZEJyYWNrZXRBdChzdGF0ZSwgc3RhdGUuc2VsZWN0aW9uLm1haW4uZnJvbSkpXG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlQ2xvc2Uoc3RhdGUsIHRvaywgY2xvc2VkKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjbG9zZWRCcmFja2V0QXQoc3RhdGUsIHBvcykge1xuICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgIHN0YXRlLmZpZWxkKGJyYWNrZXRTdGF0ZSkuYmV0d2VlbigwLCBzdGF0ZS5kb2MubGVuZ3RoLCBmcm9tID0+IHtcbiAgICAgICAgaWYgKGZyb20gPT0gcG9zKVxuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiBmb3VuZDtcbn1cbmZ1bmN0aW9uIG5leHRDaGFyKGRvYywgcG9zKSB7XG4gICAgbGV0IG5leHQgPSBkb2Muc2xpY2VTdHJpbmcocG9zLCBwb3MgKyAyKTtcbiAgICByZXR1cm4gbmV4dC5zbGljZSgwLCB0ZXh0LmNvZGVQb2ludFNpemUodGV4dC5jb2RlUG9pbnRBdChuZXh0LCAwKSkpO1xufVxuZnVuY3Rpb24gcHJldkNoYXIoZG9jLCBwb3MpIHtcbiAgICBsZXQgcHJldiA9IGRvYy5zbGljZVN0cmluZyhwb3MgLSAyLCBwb3MpO1xuICAgIHJldHVybiB0ZXh0LmNvZGVQb2ludFNpemUodGV4dC5jb2RlUG9pbnRBdChwcmV2LCAwKSkgPT0gcHJldi5sZW5ndGggPyBwcmV2IDogcHJldi5zbGljZSgxKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZU9wZW4oc3RhdGUkMSwgb3BlbiwgY2xvc2UsIGNsb3NlQmVmb3JlKSB7XG4gICAgbGV0IGRvbnQgPSBudWxsLCBjaGFuZ2VzID0gc3RhdGUkMS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSlcbiAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IFt7IGluc2VydDogb3BlbiwgZnJvbTogcmFuZ2UuZnJvbSB9LCB7IGluc2VydDogY2xvc2UsIGZyb206IHJhbmdlLnRvIH1dLFxuICAgICAgICAgICAgICAgIGVmZmVjdHM6IGNsb3NlQnJhY2tldEVmZmVjdC5vZihyYW5nZS50byArIG9wZW4ubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICByYW5nZTogc3RhdGUuRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHJhbmdlLmFuY2hvciArIG9wZW4ubGVuZ3RoLCByYW5nZS5oZWFkICsgb3Blbi5sZW5ndGgpIH07XG4gICAgICAgIGxldCBuZXh0ID0gbmV4dENoYXIoc3RhdGUkMS5kb2MsIHJhbmdlLmhlYWQpO1xuICAgICAgICBpZiAoIW5leHQgfHwgL1xccy8udGVzdChuZXh0KSB8fCBjbG9zZUJlZm9yZS5pbmRleE9mKG5leHQpID4gLTEpXG4gICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGluc2VydDogb3BlbiArIGNsb3NlLCBmcm9tOiByYW5nZS5oZWFkIH0sXG4gICAgICAgICAgICAgICAgZWZmZWN0czogY2xvc2VCcmFja2V0RWZmZWN0Lm9mKHJhbmdlLmhlYWQgKyBvcGVuLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgcmFuZ2U6IHN0YXRlLkVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuaGVhZCArIG9wZW4ubGVuZ3RoKSB9O1xuICAgICAgICByZXR1cm4geyByYW5nZTogZG9udCA9IHJhbmdlIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIGRvbnQgPyBudWxsIDogc3RhdGUkMS51cGRhdGUoY2hhbmdlcywge1xuICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZSxcbiAgICAgICAgYW5ub3RhdGlvbnM6IHN0YXRlLlRyYW5zYWN0aW9uLnVzZXJFdmVudC5vZihcImlucHV0XCIpXG4gICAgfSk7XG59XG5mdW5jdGlvbiBoYW5kbGVDbG9zZShzdGF0ZSQxLCBfb3BlbiwgY2xvc2UpIHtcbiAgICBsZXQgZG9udCA9IG51bGwsIG1vdmVkID0gc3RhdGUkMS5zZWxlY3Rpb24ucmFuZ2VzLm1hcChyYW5nZSA9PiB7XG4gICAgICAgIGlmIChyYW5nZS5lbXB0eSAmJiBuZXh0Q2hhcihzdGF0ZSQxLmRvYywgcmFuZ2UuaGVhZCkgPT0gY2xvc2UpXG4gICAgICAgICAgICByZXR1cm4gc3RhdGUuRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5oZWFkICsgY2xvc2UubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGRvbnQgPSByYW5nZTtcbiAgICB9KTtcbiAgICByZXR1cm4gZG9udCA/IG51bGwgOiBzdGF0ZSQxLnVwZGF0ZSh7XG4gICAgICAgIHNlbGVjdGlvbjogc3RhdGUuRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShtb3ZlZCwgc3RhdGUkMS5zZWxlY3Rpb24ubWFpbkluZGV4KSxcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWUsXG4gICAgICAgIGVmZmVjdHM6IHN0YXRlJDEuc2VsZWN0aW9uLnJhbmdlcy5tYXAoKHsgZnJvbSB9KSA9PiBza2lwQnJhY2tldEVmZmVjdC5vZihmcm9tKSlcbiAgICB9KTtcbn1cbi8vIEhhbmRsZXMgY2FzZXMgd2hlcmUgdGhlIG9wZW4gYW5kIGNsb3NlIHRva2VuIGFyZSB0aGUgc2FtZSwgYW5kXG4vLyBwb3NzaWJseSB0cmlwbGUgcXVvdGVzIChhcyBpbiBgXCJcIlwiYWJjXCJcIlwiYC1zdHlsZSBxdW90aW5nKS5cbmZ1bmN0aW9uIGhhbmRsZVNhbWUoc3RhdGUkMSwgdG9rZW4sIGFsbG93VHJpcGxlKSB7XG4gICAgbGV0IGRvbnQgPSBudWxsLCBjaGFuZ2VzID0gc3RhdGUkMS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSlcbiAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IFt7IGluc2VydDogdG9rZW4sIGZyb206IHJhbmdlLmZyb20gfSwgeyBpbnNlcnQ6IHRva2VuLCBmcm9tOiByYW5nZS50byB9XSxcbiAgICAgICAgICAgICAgICBlZmZlY3RzOiBjbG9zZUJyYWNrZXRFZmZlY3Qub2YocmFuZ2UudG8gKyB0b2tlbi5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIHJhbmdlOiBzdGF0ZS5FZGl0b3JTZWxlY3Rpb24ucmFuZ2UocmFuZ2UuYW5jaG9yICsgdG9rZW4ubGVuZ3RoLCByYW5nZS5oZWFkICsgdG9rZW4ubGVuZ3RoKSB9O1xuICAgICAgICBsZXQgcG9zID0gcmFuZ2UuaGVhZCwgbmV4dCA9IG5leHRDaGFyKHN0YXRlJDEuZG9jLCBwb3MpO1xuICAgICAgICBpZiAobmV4dCA9PSB0b2tlbikge1xuICAgICAgICAgICAgaWYgKG5vZGVTdGFydChzdGF0ZSQxLCBwb3MpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBpbnNlcnQ6IHRva2VuICsgdG9rZW4sIGZyb206IHBvcyB9LFxuICAgICAgICAgICAgICAgICAgICBlZmZlY3RzOiBjbG9zZUJyYWNrZXRFZmZlY3Qub2YocG9zICsgdG9rZW4ubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHN0YXRlLkVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zICsgdG9rZW4ubGVuZ3RoKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2xvc2VkQnJhY2tldEF0KHN0YXRlJDEsIHBvcykpIHtcbiAgICAgICAgICAgICAgICBsZXQgaXNUcmlwbGUgPSBhbGxvd1RyaXBsZSAmJiBzdGF0ZSQxLnNsaWNlRG9jKHBvcywgcG9zICsgdG9rZW4ubGVuZ3RoICogMykgPT0gdG9rZW4gKyB0b2tlbiArIHRva2VuO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHJhbmdlOiBzdGF0ZS5FZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcyArIHRva2VuLmxlbmd0aCAqIChpc1RyaXBsZSA/IDMgOiAxKSksXG4gICAgICAgICAgICAgICAgICAgIGVmZmVjdHM6IHNraXBCcmFja2V0RWZmZWN0Lm9mKHBvcykgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhbGxvd1RyaXBsZSAmJiBzdGF0ZSQxLnNsaWNlRG9jKHBvcyAtIDIgKiB0b2tlbi5sZW5ndGgsIHBvcykgPT0gdG9rZW4gKyB0b2tlbiAmJlxuICAgICAgICAgICAgbm9kZVN0YXJ0KHN0YXRlJDEsIHBvcyAtIDIgKiB0b2tlbi5sZW5ndGgpKSB7XG4gICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGluc2VydDogdG9rZW4gKyB0b2tlbiArIHRva2VuICsgdG9rZW4sIGZyb206IHBvcyB9LFxuICAgICAgICAgICAgICAgIGVmZmVjdHM6IGNsb3NlQnJhY2tldEVmZmVjdC5vZihwb3MgKyB0b2tlbi5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIHJhbmdlOiBzdGF0ZS5FZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcyArIHRva2VuLmxlbmd0aCkgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZSQxLmNoYXJDYXRlZ29yaXplcihwb3MpKG5leHQpICE9IHN0YXRlLkNoYXJDYXRlZ29yeS5Xb3JkKSB7XG4gICAgICAgICAgICBsZXQgcHJldiA9IHN0YXRlJDEuc2xpY2VEb2MocG9zIC0gMSwgcG9zKTtcbiAgICAgICAgICAgIGlmIChwcmV2ICE9IHRva2VuICYmIHN0YXRlJDEuY2hhckNhdGVnb3JpemVyKHBvcykocHJldikgIT0gc3RhdGUuQ2hhckNhdGVnb3J5LldvcmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBpbnNlcnQ6IHRva2VuICsgdG9rZW4sIGZyb206IHBvcyB9LFxuICAgICAgICAgICAgICAgICAgICBlZmZlY3RzOiBjbG9zZUJyYWNrZXRFZmZlY3Qub2YocG9zICsgdG9rZW4ubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHN0YXRlLkVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zICsgdG9rZW4ubGVuZ3RoKSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiBkb250ID0gcmFuZ2UgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gZG9udCA/IG51bGwgOiBzdGF0ZSQxLnVwZGF0ZShjaGFuZ2VzLCB7XG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICBhbm5vdGF0aW9uczogc3RhdGUuVHJhbnNhY3Rpb24udXNlckV2ZW50Lm9mKFwiaW5wdXRcIilcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIG5vZGVTdGFydChzdGF0ZSwgcG9zKSB7XG4gICAgbGV0IHRyZWUgPSBsYW5ndWFnZS5zeW50YXhUcmVlKHN0YXRlKS5yZXNvbHZlKHBvcyArIDEpO1xuICAgIHJldHVybiB0cmVlLnBhcmVudCAmJiB0cmVlLmZyb20gPT0gcG9zO1xufVxuXG5leHBvcnRzLmNsb3NlQnJhY2tldHMgPSBjbG9zZUJyYWNrZXRzO1xuZXhwb3J0cy5jbG9zZUJyYWNrZXRzS2V5bWFwID0gY2xvc2VCcmFja2V0c0tleW1hcDtcbmV4cG9ydHMuZGVsZXRlQnJhY2tldFBhaXIgPSBkZWxldGVCcmFja2V0UGFpcjtcbmV4cG9ydHMuaW5zZXJ0QnJhY2tldCA9IGluc2VydEJyYWNrZXQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBzdGF0ZSA9IHJlcXVpcmUoJ0Bjb2RlbWlycm9yL3N0YXRlJyk7XG52YXIgdGV4dCA9IHJlcXVpcmUoJ0Bjb2RlbWlycm9yL3RleHQnKTtcbnZhciB2aWV3ID0gcmVxdWlyZSgnQGNvZGVtaXJyb3IvdmlldycpO1xudmFyIG1hdGNoYnJhY2tldHMgPSByZXF1aXJlKCdAY29kZW1pcnJvci9tYXRjaGJyYWNrZXRzJyk7XG52YXIgbGFuZ3VhZ2UgPSByZXF1aXJlKCdAY29kZW1pcnJvci9sYW5ndWFnZScpO1xudmFyIGxlemVyVHJlZSA9IHJlcXVpcmUoJ2xlemVyLXRyZWUnKTtcblxuZnVuY3Rpb24gdXBkYXRlU2VsKHNlbCwgYnkpIHtcbiAgICByZXR1cm4gc3RhdGUuRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShzZWwucmFuZ2VzLm1hcChieSksIHNlbC5tYWluSW5kZXgpO1xufVxuZnVuY3Rpb24gc2V0U2VsKHN0YXRlJDEsIHNlbGVjdGlvbikge1xuICAgIHJldHVybiBzdGF0ZSQxLnVwZGF0ZSh7IHNlbGVjdGlvbiwgc2Nyb2xsSW50b1ZpZXc6IHRydWUsIGFubm90YXRpb25zOiBzdGF0ZS5UcmFuc2FjdGlvbi51c2VyRXZlbnQub2YoXCJrZXlib2FyZHNlbGVjdGlvblwiKSB9KTtcbn1cbmZ1bmN0aW9uIG1vdmVTZWwoeyBzdGF0ZSwgZGlzcGF0Y2ggfSwgaG93KSB7XG4gICAgbGV0IHNlbGVjdGlvbiA9IHVwZGF0ZVNlbChzdGF0ZS5zZWxlY3Rpb24sIGhvdyk7XG4gICAgaWYgKHNlbGVjdGlvbi5lcShzdGF0ZS5zZWxlY3Rpb24pKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc2V0U2VsKHN0YXRlLCBzZWxlY3Rpb24pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHJhbmdlRW5kKHJhbmdlLCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIHN0YXRlLkVkaXRvclNlbGVjdGlvbi5jdXJzb3IoZm9yd2FyZCA/IHJhbmdlLnRvIDogcmFuZ2UuZnJvbSk7XG59XG5mdW5jdGlvbiBjdXJzb3JCeUNoYXIodmlldywgZm9yd2FyZCkge1xuICAgIHJldHVybiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IHJhbmdlLmVtcHR5ID8gdmlldy5tb3ZlQnlDaGFyKHJhbmdlLCBmb3J3YXJkKSA6IHJhbmdlRW5kKHJhbmdlLCBmb3J3YXJkKSk7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgY2hhcmFjdGVyIHRvIHRoZSBsZWZ0ICh3aGljaCBpcyBiYWNrd2FyZCBpblxubGVmdC10by1yaWdodCB0ZXh0LCBmb3J3YXJkIGluIHJpZ2h0LXRvLWxlZnQgdGV4dCkuXG4qL1xuY29uc3QgY3Vyc29yQ2hhckxlZnQgPSB2aWV3JDEgPT4gY3Vyc29yQnlDaGFyKHZpZXckMSwgdmlldyQxLnRleHREaXJlY3Rpb24gIT0gdmlldy5EaXJlY3Rpb24uTFRSKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBjaGFyYWN0ZXIgdG8gdGhlIHJpZ2h0LlxuKi9cbmNvbnN0IGN1cnNvckNoYXJSaWdodCA9IHZpZXckMSA9PiBjdXJzb3JCeUNoYXIodmlldyQxLCB2aWV3JDEudGV4dERpcmVjdGlvbiA9PSB2aWV3LkRpcmVjdGlvbi5MVFIpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGNoYXJhY3RlciBmb3J3YXJkLlxuKi9cbmNvbnN0IGN1cnNvckNoYXJGb3J3YXJkID0gdmlldyA9PiBjdXJzb3JCeUNoYXIodmlldywgdHJ1ZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgY2hhcmFjdGVyIGJhY2t3YXJkLlxuKi9cbmNvbnN0IGN1cnNvckNoYXJCYWNrd2FyZCA9IHZpZXcgPT4gY3Vyc29yQnlDaGFyKHZpZXcsIGZhbHNlKTtcbmZ1bmN0aW9uIGN1cnNvckJ5R3JvdXAodmlldywgZm9yd2FyZCkge1xuICAgIHJldHVybiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IHJhbmdlLmVtcHR5ID8gdmlldy5tb3ZlQnlHcm91cChyYW5nZSwgZm9yd2FyZCkgOiByYW5nZUVuZChyYW5nZSwgZm9yd2FyZCkpO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gYWNyb3NzIG9uZSBncm91cCBvZiB3b3JkIG9yIG5vbi13b3JkIChidXQgYWxzb1xubm9uLXNwYWNlKSBjaGFyYWN0ZXJzLlxuKi9cbmNvbnN0IGN1cnNvckdyb3VwTGVmdCA9IHZpZXckMSA9PiBjdXJzb3JCeUdyb3VwKHZpZXckMSwgdmlldyQxLnRleHREaXJlY3Rpb24gIT0gdmlldy5EaXJlY3Rpb24uTFRSKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBncm91cCB0byB0aGUgcmlnaHQuXG4qL1xuY29uc3QgY3Vyc29yR3JvdXBSaWdodCA9IHZpZXckMSA9PiBjdXJzb3JCeUdyb3VwKHZpZXckMSwgdmlldyQxLnRleHREaXJlY3Rpb24gPT0gdmlldy5EaXJlY3Rpb24uTFRSKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBncm91cCBmb3J3YXJkLlxuKi9cbmNvbnN0IGN1cnNvckdyb3VwRm9yd2FyZCA9IHZpZXcgPT4gY3Vyc29yQnlHcm91cCh2aWV3LCB0cnVlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBncm91cCBiYWNrd2FyZC5cbiovXG5jb25zdCBjdXJzb3JHcm91cEJhY2t3YXJkID0gdmlldyA9PiBjdXJzb3JCeUdyb3VwKHZpZXcsIGZhbHNlKTtcbmZ1bmN0aW9uIGludGVyZXN0aW5nTm9kZShzdGF0ZSwgbm9kZSwgYnJhY2tldFByb3ApIHtcbiAgICBpZiAobm9kZS50eXBlLnByb3AoYnJhY2tldFByb3ApKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBsZXQgbGVuID0gbm9kZS50byAtIG5vZGUuZnJvbTtcbiAgICByZXR1cm4gbGVuICYmIChsZW4gPiAyIHx8IC9bXlxccywuOzpdLy50ZXN0KHN0YXRlLnNsaWNlRG9jKG5vZGUuZnJvbSwgbm9kZS50bykpKSB8fCBub2RlLmZpcnN0Q2hpbGQ7XG59XG5mdW5jdGlvbiBtb3ZlQnlTeW50YXgoc3RhdGUkMSwgc3RhcnQsIGZvcndhcmQpIHtcbiAgICBsZXQgcG9zID0gbGFuZ3VhZ2Uuc3ludGF4VHJlZShzdGF0ZSQxKS5yZXNvbHZlKHN0YXJ0LmhlYWQpO1xuICAgIGxldCBicmFja2V0UHJvcCA9IGZvcndhcmQgPyBsZXplclRyZWUuTm9kZVByb3AuY2xvc2VkQnkgOiBsZXplclRyZWUuTm9kZVByb3Aub3BlbmVkQnk7XG4gICAgLy8gU2NhbiBmb3J3YXJkIHRocm91Z2ggY2hpbGQgbm9kZXMgdG8gc2VlIGlmIHRoZXJlJ3MgYW4gaW50ZXJlc3RpbmdcbiAgICAvLyBub2RlIGFoZWFkLlxuICAgIGZvciAobGV0IGF0ID0gc3RhcnQuaGVhZDs7KSB7XG4gICAgICAgIGxldCBuZXh0ID0gZm9yd2FyZCA/IHBvcy5jaGlsZEFmdGVyKGF0KSA6IHBvcy5jaGlsZEJlZm9yZShhdCk7XG4gICAgICAgIGlmICghbmV4dClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAoaW50ZXJlc3RpbmdOb2RlKHN0YXRlJDEsIG5leHQsIGJyYWNrZXRQcm9wKSlcbiAgICAgICAgICAgIHBvcyA9IG5leHQ7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGF0ID0gZm9yd2FyZCA/IG5leHQudG8gOiBuZXh0LmZyb207XG4gICAgfVxuICAgIGxldCBicmFja2V0ID0gcG9zLnR5cGUucHJvcChicmFja2V0UHJvcCksIG1hdGNoLCBuZXdQb3M7XG4gICAgaWYgKGJyYWNrZXQgJiYgKG1hdGNoID0gZm9yd2FyZCA/IG1hdGNoYnJhY2tldHMubWF0Y2hCcmFja2V0cyhzdGF0ZSQxLCBwb3MuZnJvbSwgMSkgOiBtYXRjaGJyYWNrZXRzLm1hdGNoQnJhY2tldHMoc3RhdGUkMSwgcG9zLnRvLCAtMSkpICYmIG1hdGNoLm1hdGNoZWQpXG4gICAgICAgIG5ld1BvcyA9IGZvcndhcmQgPyBtYXRjaC5lbmQudG8gOiBtYXRjaC5lbmQuZnJvbTtcbiAgICBlbHNlXG4gICAgICAgIG5ld1BvcyA9IGZvcndhcmQgPyBwb3MudG8gOiBwb3MuZnJvbTtcbiAgICByZXR1cm4gc3RhdGUuRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihuZXdQb3MsIGZvcndhcmQgPyAtMSA6IDEpO1xufVxuLyoqXG5Nb3ZlIHRoZSBjdXJzb3Igb3ZlciB0aGUgbmV4dCBzeW50YWN0aWMgZWxlbWVudCB0byB0aGUgbGVmdC5cbiovXG5jb25zdCBjdXJzb3JTeW50YXhMZWZ0ID0gdmlldyQxID0+IG1vdmVTZWwodmlldyQxLCByYW5nZSA9PiBtb3ZlQnlTeW50YXgodmlldyQxLnN0YXRlLCByYW5nZSwgdmlldyQxLnRleHREaXJlY3Rpb24gIT0gdmlldy5EaXJlY3Rpb24uTFRSKSk7XG4vKipcbk1vdmUgdGhlIGN1cnNvciBvdmVyIHRoZSBuZXh0IHN5bnRhY3RpYyBlbGVtZW50IHRvIHRoZSByaWdodC5cbiovXG5jb25zdCBjdXJzb3JTeW50YXhSaWdodCA9IHZpZXckMSA9PiBtb3ZlU2VsKHZpZXckMSwgcmFuZ2UgPT4gbW92ZUJ5U3ludGF4KHZpZXckMS5zdGF0ZSwgcmFuZ2UsIHZpZXckMS50ZXh0RGlyZWN0aW9uID09IHZpZXcuRGlyZWN0aW9uLkxUUikpO1xuZnVuY3Rpb24gY3Vyc29yQnlMaW5lKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiByYW5nZS5lbXB0eSA/IHZpZXcubW92ZVZlcnRpY2FsbHkocmFuZ2UsIGZvcndhcmQpIDogcmFuZ2VFbmQocmFuZ2UsIGZvcndhcmQpKTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBsaW5lIHVwLlxuKi9cbmNvbnN0IGN1cnNvckxpbmVVcCA9IHZpZXcgPT4gY3Vyc29yQnlMaW5lKHZpZXcsIGZhbHNlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBsaW5lIGRvd24uXG4qL1xuY29uc3QgY3Vyc29yTGluZURvd24gPSB2aWV3ID0+IGN1cnNvckJ5TGluZSh2aWV3LCB0cnVlKTtcbmZ1bmN0aW9uIGN1cnNvckJ5UGFnZSh2aWV3LCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIG1vdmVTZWwodmlldywgcmFuZ2UgPT4gcmFuZ2UuZW1wdHkgPyB2aWV3Lm1vdmVWZXJ0aWNhbGx5KHJhbmdlLCBmb3J3YXJkLCB2aWV3LmRvbS5jbGllbnRIZWlnaHQpIDogcmFuZ2VFbmQocmFuZ2UsIGZvcndhcmQpKTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBwYWdlIHVwLlxuKi9cbmNvbnN0IGN1cnNvclBhZ2VVcCA9IHZpZXcgPT4gY3Vyc29yQnlQYWdlKHZpZXcsIGZhbHNlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBwYWdlIGRvd24uXG4qL1xuY29uc3QgY3Vyc29yUGFnZURvd24gPSB2aWV3ID0+IGN1cnNvckJ5UGFnZSh2aWV3LCB0cnVlKTtcbmZ1bmN0aW9uIG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCBzdGFydCwgZm9yd2FyZCkge1xuICAgIGxldCBsaW5lID0gdmlldy52aXN1YWxMaW5lQXQoc3RhcnQuaGVhZCksIG1vdmVkID0gdmlldy5tb3ZlVG9MaW5lQm91bmRhcnkoc3RhcnQsIGZvcndhcmQpO1xuICAgIGlmIChtb3ZlZC5oZWFkID09IHN0YXJ0LmhlYWQgJiYgbW92ZWQuaGVhZCAhPSAoZm9yd2FyZCA/IGxpbmUudG8gOiBsaW5lLmZyb20pKVxuICAgICAgICBtb3ZlZCA9IHZpZXcubW92ZVRvTGluZUJvdW5kYXJ5KHN0YXJ0LCBmb3J3YXJkLCBmYWxzZSk7XG4gICAgaWYgKCFmb3J3YXJkICYmIG1vdmVkLmhlYWQgPT0gbGluZS5mcm9tICYmIGxpbmUubGVuZ3RoKSB7XG4gICAgICAgIGxldCBzcGFjZSA9IC9eXFxzKi8uZXhlYyh2aWV3LnN0YXRlLnNsaWNlRG9jKGxpbmUuZnJvbSwgTWF0aC5taW4obGluZS5mcm9tICsgMTAwLCBsaW5lLnRvKSkpWzBdLmxlbmd0aDtcbiAgICAgICAgaWYgKHNwYWNlICYmIHN0YXJ0LmhlYWQgIT0gbGluZS5mcm9tICsgc3BhY2UpXG4gICAgICAgICAgICBtb3ZlZCA9IHN0YXRlLkVkaXRvclNlbGVjdGlvbi5jdXJzb3IobGluZS5mcm9tICsgc3BhY2UpO1xuICAgIH1cbiAgICByZXR1cm4gbW92ZWQ7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgbmV4dCBsaW5lIHdyYXAgcG9pbnQsIG9yIHRvIHRoZSBlbmQgb2ZcbnRoZSBsaW5lIGlmIHRoZXJlIGlzbid0IG9uZSBsZWZ0IG9uIHRoaXMgbGluZS5cbiovXG5jb25zdCBjdXJzb3JMaW5lQm91bmRhcnlGb3J3YXJkID0gdmlldyA9PiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCByYW5nZSwgdHJ1ZSkpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gcHJldmlvdXMgbGluZSB3cmFwIHBvaW50LCBvciBmYWlsaW5nIHRoYXQgdG9cbnRoZSBzdGFydCBvZiB0aGUgbGluZS4gSWYgdGhlIGxpbmUgaXMgaW5kZW50ZWQsIGFuZCB0aGUgY3Vyc29yXG5pc24ndCBhbHJlYWR5IGF0IHRoZSBlbmQgb2YgdGhlIGluZGVudGF0aW9uLCB0aGlzIHdpbGwgbW92ZSB0byB0aGVcbmVuZCBvZiB0aGUgaW5kZW50YXRpb24gaW5zdGVhZCBvZiB0aGUgc3RhcnQgb2YgdGhlIGxpbmUuXG4qL1xuY29uc3QgY3Vyc29yTGluZUJvdW5kYXJ5QmFja3dhcmQgPSB2aWV3ID0+IG1vdmVTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5TGluZUJvdW5kYXJ5KHZpZXcsIHJhbmdlLCBmYWxzZSkpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIHN0YXJ0IG9mIHRoZSBsaW5lLlxuKi9cbmNvbnN0IGN1cnNvckxpbmVTdGFydCA9IHZpZXcgPT4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiBzdGF0ZS5FZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHZpZXcudmlzdWFsTGluZUF0KHJhbmdlLmhlYWQpLmZyb20sIDEpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBlbmQgb2YgdGhlIGxpbmUuXG4qL1xuY29uc3QgY3Vyc29yTGluZUVuZCA9IHZpZXcgPT4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiBzdGF0ZS5FZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHZpZXcudmlzdWFsTGluZUF0KHJhbmdlLmhlYWQpLnRvLCAtMSkpO1xuZnVuY3Rpb24gdG9NYXRjaGluZ0JyYWNrZXQoc3RhdGUkMSwgZGlzcGF0Y2gsIGV4dGVuZCkge1xuICAgIGxldCBmb3VuZCA9IGZhbHNlLCBzZWxlY3Rpb24gPSB1cGRhdGVTZWwoc3RhdGUkMS5zZWxlY3Rpb24sIHJhbmdlID0+IHtcbiAgICAgICAgbGV0IG1hdGNoaW5nID0gbWF0Y2hicmFja2V0cy5tYXRjaEJyYWNrZXRzKHN0YXRlJDEsIHJhbmdlLmhlYWQsIC0xKVxuICAgICAgICAgICAgfHwgbWF0Y2hicmFja2V0cy5tYXRjaEJyYWNrZXRzKHN0YXRlJDEsIHJhbmdlLmhlYWQsIDEpXG4gICAgICAgICAgICB8fCAocmFuZ2UuaGVhZCA+IDAgJiYgbWF0Y2hicmFja2V0cy5tYXRjaEJyYWNrZXRzKHN0YXRlJDEsIHJhbmdlLmhlYWQgLSAxLCAxKSlcbiAgICAgICAgICAgIHx8IChyYW5nZS5oZWFkIDwgc3RhdGUkMS5kb2MubGVuZ3RoICYmIG1hdGNoYnJhY2tldHMubWF0Y2hCcmFja2V0cyhzdGF0ZSQxLCByYW5nZS5oZWFkICsgMSwgLTEpKTtcbiAgICAgICAgaWYgKCFtYXRjaGluZyB8fCAhbWF0Y2hpbmcuZW5kKVxuICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgIGxldCBoZWFkID0gbWF0Y2hpbmcuc3RhcnQuZnJvbSA9PSByYW5nZS5oZWFkID8gbWF0Y2hpbmcuZW5kLnRvIDogbWF0Y2hpbmcuZW5kLmZyb207XG4gICAgICAgIHJldHVybiBleHRlbmQgPyBzdGF0ZS5FZGl0b3JTZWxlY3Rpb24ucmFuZ2UocmFuZ2UuYW5jaG9yLCBoZWFkKSA6IHN0YXRlLkVkaXRvclNlbGVjdGlvbi5jdXJzb3IoaGVhZCk7XG4gICAgfSk7XG4gICAgaWYgKCFmb3VuZClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHNldFNlbChzdGF0ZSQxLCBzZWxlY3Rpb24pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBicmFja2V0IG1hdGNoaW5nIHRoZSBvbmUgaXQgaXMgY3VycmVudGx5XG5vbiwgaWYgYW55LlxuKi9cbmNvbnN0IGN1cnNvck1hdGNoaW5nQnJhY2tldCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB0b01hdGNoaW5nQnJhY2tldChzdGF0ZSwgZGlzcGF0Y2gsIGZhbHNlKTtcbi8qKlxuRXh0ZW5kIHRoZSBzZWxlY3Rpb24gdG8gdGhlIGJyYWNrZXQgbWF0Y2hpbmcgdGhlIG9uZSB0aGUgc2VsZWN0aW9uXG5oZWFkIGlzIGN1cnJlbnRseSBvbiwgaWYgYW55LlxuKi9cbmNvbnN0IHNlbGVjdE1hdGNoaW5nQnJhY2tldCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB0b01hdGNoaW5nQnJhY2tldChzdGF0ZSwgZGlzcGF0Y2gsIHRydWUpO1xuZnVuY3Rpb24gZXh0ZW5kU2VsKHZpZXcsIGhvdykge1xuICAgIGxldCBzZWxlY3Rpb24gPSB1cGRhdGVTZWwodmlldy5zdGF0ZS5zZWxlY3Rpb24sIHJhbmdlID0+IHtcbiAgICAgICAgbGV0IGhlYWQgPSBob3cocmFuZ2UpO1xuICAgICAgICByZXR1cm4gc3RhdGUuRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHJhbmdlLmFuY2hvciwgaGVhZC5oZWFkLCBoZWFkLmdvYWxDb2x1bW4pO1xuICAgIH0pO1xuICAgIGlmIChzZWxlY3Rpb24uZXEodmlldy5zdGF0ZS5zZWxlY3Rpb24pKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmlldy5kaXNwYXRjaChzZXRTZWwodmlldy5zdGF0ZSwgc2VsZWN0aW9uKSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBzZWxlY3RCeUNoYXIodmlldywgZm9yd2FyZCkge1xuICAgIHJldHVybiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gdmlldy5tb3ZlQnlDaGFyKHJhbmdlLCBmb3J3YXJkKSk7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBjaGFyYWN0ZXIgdG8gdGhlIGxlZnQsIHdoaWxlIGxlYXZpbmdcbnRoZSBhbmNob3IgaW4gcGxhY2UuXG4qL1xuY29uc3Qgc2VsZWN0Q2hhckxlZnQgPSB2aWV3JDEgPT4gc2VsZWN0QnlDaGFyKHZpZXckMSwgdmlldyQxLnRleHREaXJlY3Rpb24gIT0gdmlldy5EaXJlY3Rpb24uTFRSKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGNoYXJhY3RlciB0byB0aGUgcmlnaHQuXG4qL1xuY29uc3Qgc2VsZWN0Q2hhclJpZ2h0ID0gdmlldyQxID0+IHNlbGVjdEJ5Q2hhcih2aWV3JDEsIHZpZXckMS50ZXh0RGlyZWN0aW9uID09IHZpZXcuRGlyZWN0aW9uLkxUUik7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBjaGFyYWN0ZXIgZm9yd2FyZC5cbiovXG5jb25zdCBzZWxlY3RDaGFyRm9yd2FyZCA9IHZpZXcgPT4gc2VsZWN0QnlDaGFyKHZpZXcsIHRydWUpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgY2hhcmFjdGVyIGJhY2t3YXJkLlxuKi9cbmNvbnN0IHNlbGVjdENoYXJCYWNrd2FyZCA9IHZpZXcgPT4gc2VsZWN0QnlDaGFyKHZpZXcsIGZhbHNlKTtcbmZ1bmN0aW9uIHNlbGVjdEJ5R3JvdXAodmlldywgZm9yd2FyZCkge1xuICAgIHJldHVybiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gdmlldy5tb3ZlQnlHcm91cChyYW5nZSwgZm9yd2FyZCkpO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgW2dyb3VwXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckdyb3VwTGVmdCkgdG9cbnRoZSBsZWZ0LlxuKi9cbmNvbnN0IHNlbGVjdEdyb3VwTGVmdCA9IHZpZXckMSA9PiBzZWxlY3RCeUdyb3VwKHZpZXckMSwgdmlldyQxLnRleHREaXJlY3Rpb24gIT0gdmlldy5EaXJlY3Rpb24uTFRSKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGdyb3VwIHRvIHRoZSByaWdodC5cbiovXG5jb25zdCBzZWxlY3RHcm91cFJpZ2h0ID0gdmlldyQxID0+IHNlbGVjdEJ5R3JvdXAodmlldyQxLCB2aWV3JDEudGV4dERpcmVjdGlvbiA9PSB2aWV3LkRpcmVjdGlvbi5MVFIpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgZ3JvdXAgZm9yd2FyZC5cbiovXG5jb25zdCBzZWxlY3RHcm91cEZvcndhcmQgPSB2aWV3ID0+IHNlbGVjdEJ5R3JvdXAodmlldywgdHJ1ZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBncm91cCBiYWNrd2FyZC5cbiovXG5jb25zdCBzZWxlY3RHcm91cEJhY2t3YXJkID0gdmlldyA9PiBzZWxlY3RCeUdyb3VwKHZpZXcsIGZhbHNlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb3ZlciB0aGUgbmV4dCBzeW50YWN0aWMgZWxlbWVudCB0byB0aGUgbGVmdC5cbiovXG5jb25zdCBzZWxlY3RTeW50YXhMZWZ0ID0gdmlldyQxID0+IGV4dGVuZFNlbCh2aWV3JDEsIHJhbmdlID0+IG1vdmVCeVN5bnRheCh2aWV3JDEuc3RhdGUsIHJhbmdlLCB2aWV3JDEudGV4dERpcmVjdGlvbiAhPSB2aWV3LkRpcmVjdGlvbi5MVFIpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb3ZlciB0aGUgbmV4dCBzeW50YWN0aWMgZWxlbWVudCB0byB0aGUgcmlnaHQuXG4qL1xuY29uc3Qgc2VsZWN0U3ludGF4UmlnaHQgPSB2aWV3JDEgPT4gZXh0ZW5kU2VsKHZpZXckMSwgcmFuZ2UgPT4gbW92ZUJ5U3ludGF4KHZpZXckMS5zdGF0ZSwgcmFuZ2UsIHZpZXckMS50ZXh0RGlyZWN0aW9uID09IHZpZXcuRGlyZWN0aW9uLkxUUikpO1xuZnVuY3Rpb24gc2VsZWN0QnlMaW5lKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IHZpZXcubW92ZVZlcnRpY2FsbHkocmFuZ2UsIGZvcndhcmQpKTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGxpbmUgdXAuXG4qL1xuY29uc3Qgc2VsZWN0TGluZVVwID0gdmlldyA9PiBzZWxlY3RCeUxpbmUodmlldywgZmFsc2UpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgbGluZSBkb3duLlxuKi9cbmNvbnN0IHNlbGVjdExpbmVEb3duID0gdmlldyA9PiBzZWxlY3RCeUxpbmUodmlldywgdHJ1ZSk7XG5mdW5jdGlvbiBzZWxlY3RCeVBhZ2UodmlldywgZm9yd2FyZCkge1xuICAgIHJldHVybiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gdmlldy5tb3ZlVmVydGljYWxseShyYW5nZSwgZm9yd2FyZCwgdmlldy5kb20uY2xpZW50SGVpZ2h0KSk7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBwYWdlIHVwLlxuKi9cbmNvbnN0IHNlbGVjdFBhZ2VVcCA9IHZpZXcgPT4gc2VsZWN0QnlQYWdlKHZpZXcsIGZhbHNlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIHBhZ2UgZG93bi5cbiovXG5jb25zdCBzZWxlY3RQYWdlRG93biA9IHZpZXcgPT4gc2VsZWN0QnlQYWdlKHZpZXcsIHRydWUpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCB0byB0aGUgbmV4dCBsaW5lIGJvdW5kYXJ5LlxuKi9cbmNvbnN0IHNlbGVjdExpbmVCb3VuZGFyeUZvcndhcmQgPSB2aWV3ID0+IGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlMaW5lQm91bmRhcnkodmlldywgcmFuZ2UsIHRydWUpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgdG8gdGhlIHByZXZpb3VzIGxpbmUgYm91bmRhcnkuXG4qL1xuY29uc3Qgc2VsZWN0TGluZUJvdW5kYXJ5QmFja3dhcmQgPSB2aWV3ID0+IGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlMaW5lQm91bmRhcnkodmlldywgcmFuZ2UsIGZhbHNlKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIHRvIHRoZSBzdGFydCBvZiB0aGUgbGluZS5cbiovXG5jb25zdCBzZWxlY3RMaW5lU3RhcnQgPSB2aWV3ID0+IGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiBzdGF0ZS5FZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHZpZXcudmlzdWFsTGluZUF0KHJhbmdlLmhlYWQpLmZyb20pKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgdG8gdGhlIGVuZCBvZiB0aGUgbGluZS5cbiovXG5jb25zdCBzZWxlY3RMaW5lRW5kID0gdmlldyA9PiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gc3RhdGUuRWRpdG9yU2VsZWN0aW9uLmN1cnNvcih2aWV3LnZpc3VhbExpbmVBdChyYW5nZS5oZWFkKS50bykpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIHN0YXJ0IG9mIHRoZSBkb2N1bWVudC5cbiovXG5jb25zdCBjdXJzb3JEb2NTdGFydCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgZGlzcGF0Y2goc2V0U2VsKHN0YXRlLCB7IGFuY2hvcjogMCB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIGVuZCBvZiB0aGUgZG9jdW1lbnQuXG4qL1xuY29uc3QgY3Vyc29yRG9jRW5kID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBkaXNwYXRjaChzZXRTZWwoc3RhdGUsIHsgYW5jaG9yOiBzdGF0ZS5kb2MubGVuZ3RoIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIHRvIHRoZSBzdGFydCBvZiB0aGUgZG9jdW1lbnQuXG4qL1xuY29uc3Qgc2VsZWN0RG9jU3RhcnQgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGRpc3BhdGNoKHNldFNlbChzdGF0ZSwgeyBhbmNob3I6IHN0YXRlLnNlbGVjdGlvbi5tYWluLmFuY2hvciwgaGVhZDogMCB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCB0byB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudC5cbiovXG5jb25zdCBzZWxlY3REb2NFbmQgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGRpc3BhdGNoKHNldFNlbChzdGF0ZSwgeyBhbmNob3I6IHN0YXRlLnNlbGVjdGlvbi5tYWluLmFuY2hvciwgaGVhZDogc3RhdGUuZG9jLmxlbmd0aCB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5TZWxlY3QgdGhlIGVudGlyZSBkb2N1bWVudC5cbiovXG5jb25zdCBzZWxlY3RBbGwgPSAoeyBzdGF0ZTogc3RhdGUkMSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGRpc3BhdGNoKHN0YXRlJDEudXBkYXRlKHsgc2VsZWN0aW9uOiB7IGFuY2hvcjogMCwgaGVhZDogc3RhdGUkMS5kb2MubGVuZ3RoIH0sIGFubm90YXRpb25zOiBzdGF0ZS5UcmFuc2FjdGlvbi51c2VyRXZlbnQub2YoXCJrZXlib2FyZHNlbGVjdGlvblwiKSB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5FeHBhbmQgdGhlIHNlbGVjdGlvbiB0byBjb3ZlciBlbnRpcmUgbGluZXMuXG4qL1xuY29uc3Qgc2VsZWN0TGluZSA9ICh7IHN0YXRlOiBzdGF0ZSQxLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgbGV0IHJhbmdlcyA9IHNlbGVjdGVkTGluZUJsb2NrcyhzdGF0ZSQxKS5tYXAoKHsgZnJvbSwgdG8gfSkgPT4gc3RhdGUuRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGZyb20sIE1hdGgubWluKHRvICsgMSwgc3RhdGUkMS5kb2MubGVuZ3RoKSkpO1xuICAgIGRpc3BhdGNoKHN0YXRlJDEudXBkYXRlKHsgc2VsZWN0aW9uOiBzdGF0ZS5FZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcyksIGFubm90YXRpb25zOiBzdGF0ZS5UcmFuc2FjdGlvbi51c2VyRXZlbnQub2YoXCJrZXlib2FyZHNlbGVjdGlvblwiKSB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5TZWxlY3QgdGhlIG5leHQgc3ludGFjdGljIGNvbnN0cnVjdCB0aGF0IGlzIGxhcmdlciB0aGFuIHRoZVxuc2VsZWN0aW9uLiBOb3RlIHRoYXQgdGhpcyB3aWxsIG9ubHkgd29yayBpbnNvZmFyIGFzIHRoZSBsYW5ndWFnZVxuW3Byb3ZpZGVyXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmxhbmd1YWdlKSB5b3UgdXNlIGJ1aWxkcyB1cCBhIGZ1bGxcbnN5bnRheCB0cmVlLlxuKi9cbmNvbnN0IHNlbGVjdFBhcmVudFN5bnRheCA9ICh7IHN0YXRlOiBzdGF0ZSQxLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgbGV0IHNlbGVjdGlvbiA9IHVwZGF0ZVNlbChzdGF0ZSQxLnNlbGVjdGlvbiwgcmFuZ2UgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBjb250ZXh0ID0gbGFuZ3VhZ2Uuc3ludGF4VHJlZShzdGF0ZSQxKS5yZXNvbHZlKHJhbmdlLmhlYWQsIDEpO1xuICAgICAgICB3aGlsZSAoISgoY29udGV4dC5mcm9tIDwgcmFuZ2UuZnJvbSAmJiBjb250ZXh0LnRvID49IHJhbmdlLnRvKSB8fFxuICAgICAgICAgICAgKGNvbnRleHQudG8gPiByYW5nZS50byAmJiBjb250ZXh0LmZyb20gPD0gcmFuZ2UuZnJvbSkgfHxcbiAgICAgICAgICAgICEoKF9hID0gY29udGV4dC5wYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXJlbnQpKSlcbiAgICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0LnBhcmVudDtcbiAgICAgICAgcmV0dXJuIHN0YXRlLkVkaXRvclNlbGVjdGlvbi5yYW5nZShjb250ZXh0LnRvLCBjb250ZXh0LmZyb20pO1xuICAgIH0pO1xuICAgIGRpc3BhdGNoKHNldFNlbChzdGF0ZSQxLCBzZWxlY3Rpb24pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcblNpbXBsaWZ5IHRoZSBjdXJyZW50IHNlbGVjdGlvbi4gV2hlbiBtdWx0aXBsZSByYW5nZXMgYXJlIHNlbGVjdGVkLFxucmVkdWNlIGl0IHRvIGl0cyBtYWluIHJhbmdlLiBPdGhlcndpc2UsIGlmIHRoZSBzZWxlY3Rpb24gaXNcbm5vbi1lbXB0eSwgY29udmVydCBpdCB0byBhIGN1cnNvciBzZWxlY3Rpb24uXG4qL1xuY29uc3Qgc2ltcGxpZnlTZWxlY3Rpb24gPSAoeyBzdGF0ZTogc3RhdGUkMSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGxldCBjdXIgPSBzdGF0ZSQxLnNlbGVjdGlvbiwgc2VsZWN0aW9uID0gbnVsbDtcbiAgICBpZiAoY3VyLnJhbmdlcy5sZW5ndGggPiAxKVxuICAgICAgICBzZWxlY3Rpb24gPSBzdGF0ZS5FZGl0b3JTZWxlY3Rpb24uY3JlYXRlKFtjdXIubWFpbl0pO1xuICAgIGVsc2UgaWYgKCFjdXIubWFpbi5lbXB0eSlcbiAgICAgICAgc2VsZWN0aW9uID0gc3RhdGUuRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShbc3RhdGUuRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihjdXIubWFpbi5oZWFkKV0pO1xuICAgIGlmICghc2VsZWN0aW9uKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc2V0U2VsKHN0YXRlJDEsIHNlbGVjdGlvbikpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIGRlbGV0ZUJ5KHsgc3RhdGU6IHN0YXRlJDEsIGRpc3BhdGNoIH0sIGJ5KSB7XG4gICAgbGV0IGNoYW5nZXMgPSBzdGF0ZSQxLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gcmFuZ2U7XG4gICAgICAgIGlmIChmcm9tID09IHRvKSB7XG4gICAgICAgICAgICBsZXQgdG93YXJkcyA9IGJ5KGZyb20pO1xuICAgICAgICAgICAgZnJvbSA9IE1hdGgubWluKGZyb20sIHRvd2FyZHMpO1xuICAgICAgICAgICAgdG8gPSBNYXRoLm1heCh0bywgdG93YXJkcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZyb20gPT0gdG8gPyB7IHJhbmdlIH0gOiB7IGNoYW5nZXM6IHsgZnJvbSwgdG8gfSwgcmFuZ2U6IHN0YXRlLkVkaXRvclNlbGVjdGlvbi5jdXJzb3IoZnJvbSkgfTtcbiAgICB9KTtcbiAgICBpZiAoY2hhbmdlcy5jaGFuZ2VzLmVtcHR5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc3RhdGUkMS51cGRhdGUoY2hhbmdlcywgeyBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgYW5ub3RhdGlvbnM6IHN0YXRlLlRyYW5zYWN0aW9uLnVzZXJFdmVudC5vZihcImRlbGV0ZVwiKSB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5jb25zdCBkZWxldGVCeUNoYXIgPSAodGFyZ2V0LCBmb3J3YXJkLCBjb2RlUG9pbnQpID0+IGRlbGV0ZUJ5KHRhcmdldCwgcG9zID0+IHtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdGFyZ2V0LCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChwb3MpLCBiZWZvcmU7XG4gICAgaWYgKCFmb3J3YXJkICYmIHBvcyA+IGxpbmUuZnJvbSAmJiBwb3MgPCBsaW5lLmZyb20gKyAyMDAgJiZcbiAgICAgICAgIS9bXiBcXHRdLy50ZXN0KGJlZm9yZSA9IGxpbmUudGV4dC5zbGljZSgwLCBwb3MgLSBsaW5lLmZyb20pKSkge1xuICAgICAgICBpZiAoYmVmb3JlW2JlZm9yZS5sZW5ndGggLSAxXSA9PSBcIlxcdFwiKVxuICAgICAgICAgICAgcmV0dXJuIHBvcyAtIDE7XG4gICAgICAgIGxldCBjb2wgPSB0ZXh0LmNvdW50Q29sdW1uKGJlZm9yZSwgMCwgc3RhdGUudGFiU2l6ZSksIGRyb3AgPSBjb2wgJSBsYW5ndWFnZS5nZXRJbmRlbnRVbml0KHN0YXRlKSB8fCBsYW5ndWFnZS5nZXRJbmRlbnRVbml0KHN0YXRlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkcm9wICYmIGJlZm9yZVtiZWZvcmUubGVuZ3RoIC0gMSAtIGldID09IFwiIFwiOyBpKyspXG4gICAgICAgICAgICBwb3MtLTtcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgbGV0IHRhcmdldFBvcztcbiAgICBpZiAoY29kZVBvaW50KSB7XG4gICAgICAgIGxldCBuZXh0ID0gbGluZS50ZXh0LnNsaWNlKHBvcyAtIGxpbmUuZnJvbSArIChmb3J3YXJkID8gMCA6IC0yKSwgcG9zIC0gbGluZS5mcm9tICsgKGZvcndhcmQgPyAyIDogMCkpO1xuICAgICAgICBsZXQgc2l6ZSA9IG5leHQgPyB0ZXh0LmNvZGVQb2ludFNpemUodGV4dC5jb2RlUG9pbnRBdChuZXh0LCAwKSkgOiAxO1xuICAgICAgICB0YXJnZXRQb3MgPSBmb3J3YXJkID8gTWF0aC5taW4oc3RhdGUuZG9jLmxlbmd0aCwgcG9zICsgc2l6ZSkgOiBNYXRoLm1heCgwLCBwb3MgLSBzaXplKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRhcmdldFBvcyA9IHRleHQuZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIHBvcyAtIGxpbmUuZnJvbSwgZm9yd2FyZCkgKyBsaW5lLmZyb207XG4gICAgfVxuICAgIGlmICh0YXJnZXRQb3MgPT0gcG9zICYmIGxpbmUubnVtYmVyICE9IChmb3J3YXJkID8gc3RhdGUuZG9jLmxpbmVzIDogMSkpXG4gICAgICAgIHRhcmdldFBvcyArPSBmb3J3YXJkID8gMSA6IC0xO1xuICAgIHJldHVybiB0YXJnZXRQb3M7XG59KTtcbi8qKlxuRGVsZXRlIHRoZSBzZWxlY3Rpb24sIG9yLCBmb3IgY3Vyc29yIHNlbGVjdGlvbnMsIHRoZSBjb2RlIHBvaW50XG5iZWZvcmUgdGhlIGN1cnNvci5cbiovXG5jb25zdCBkZWxldGVDb2RlUG9pbnRCYWNrd2FyZCA9IHZpZXcgPT4gZGVsZXRlQnlDaGFyKHZpZXcsIGZhbHNlLCB0cnVlKTtcbi8qKlxuRGVsZXRlIHRoZSBzZWxlY3Rpb24sIG9yLCBmb3IgY3Vyc29yIHNlbGVjdGlvbnMsIHRoZSBjb2RlIHBvaW50XG5hZnRlciB0aGUgY3Vyc29yLlxuKi9cbmNvbnN0IGRlbGV0ZUNvZGVQb2ludEZvcndhcmQgPSB2aWV3ID0+IGRlbGV0ZUJ5Q2hhcih2aWV3LCB0cnVlLCB0cnVlKTtcbi8qKlxuRGVsZXRlIHRoZSBzZWxlY3Rpb24sIG9yLCBmb3IgY3Vyc29yIHNlbGVjdGlvbnMsIHRoZSBjaGFyYWN0ZXJcbmJlZm9yZSB0aGUgY3Vyc29yLlxuKi9cbmNvbnN0IGRlbGV0ZUNoYXJCYWNrd2FyZCA9IHZpZXcgPT4gZGVsZXRlQnlDaGFyKHZpZXcsIGZhbHNlLCBmYWxzZSk7XG4vKipcbkRlbGV0ZSB0aGUgc2VsZWN0aW9uIG9yIHRoZSBjaGFyYWN0ZXIgYWZ0ZXIgdGhlIGN1cnNvci5cbiovXG5jb25zdCBkZWxldGVDaGFyRm9yd2FyZCA9IHZpZXcgPT4gZGVsZXRlQnlDaGFyKHZpZXcsIHRydWUsIGZhbHNlKTtcbmNvbnN0IGRlbGV0ZUJ5R3JvdXAgPSAodGFyZ2V0LCBmb3J3YXJkKSA9PiBkZWxldGVCeSh0YXJnZXQsIHN0YXJ0ID0+IHtcbiAgICBsZXQgcG9zID0gc3RhcnQsIHsgc3RhdGUgfSA9IHRhcmdldCwgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocG9zKTtcbiAgICBsZXQgY2F0ZWdvcml6ZSA9IHN0YXRlLmNoYXJDYXRlZ29yaXplcihwb3MpO1xuICAgIGZvciAobGV0IGNhdCA9IG51bGw7Oykge1xuICAgICAgICBpZiAocG9zID09IChmb3J3YXJkID8gbGluZS50byA6IGxpbmUuZnJvbSkpIHtcbiAgICAgICAgICAgIGlmIChwb3MgPT0gc3RhcnQgJiYgbGluZS5udW1iZXIgIT0gKGZvcndhcmQgPyBzdGF0ZS5kb2MubGluZXMgOiAxKSlcbiAgICAgICAgICAgICAgICBwb3MgKz0gZm9yd2FyZCA/IDEgOiAtMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuZXh0ID0gdGV4dC5maW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgcG9zIC0gbGluZS5mcm9tLCBmb3J3YXJkKSArIGxpbmUuZnJvbTtcbiAgICAgICAgbGV0IG5leHRDaGFyID0gbGluZS50ZXh0LnNsaWNlKE1hdGgubWluKHBvcywgbmV4dCkgLSBsaW5lLmZyb20sIE1hdGgubWF4KHBvcywgbmV4dCkgLSBsaW5lLmZyb20pO1xuICAgICAgICBsZXQgbmV4dENhdCA9IGNhdGVnb3JpemUobmV4dENoYXIpO1xuICAgICAgICBpZiAoY2F0ICE9IG51bGwgJiYgbmV4dENhdCAhPSBjYXQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKG5leHRDaGFyICE9IFwiIFwiIHx8IHBvcyAhPSBzdGFydClcbiAgICAgICAgICAgIGNhdCA9IG5leHRDYXQ7XG4gICAgICAgIHBvcyA9IG5leHQ7XG4gICAgfVxuICAgIHJldHVybiBwb3M7XG59KTtcbi8qKlxuRGVsZXRlIHRoZSBzZWxlY3Rpb24gb3IgYmFja3dhcmQgdW50aWwgdGhlIGVuZCBvZiB0aGUgbmV4dFxuW2dyb3VwXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5tb3ZlQnlHcm91cCksIG9ubHkgc2tpcHBpbmcgZ3JvdXBzIG9mXG53aGl0ZXNwYWNlIHdoZW4gdGhleSBjb25zaXN0IG9mIGEgc2luZ2xlIHNwYWNlLlxuKi9cbmNvbnN0IGRlbGV0ZUdyb3VwQmFja3dhcmQgPSB0YXJnZXQgPT4gZGVsZXRlQnlHcm91cCh0YXJnZXQsIGZhbHNlKTtcbi8qKlxuRGVsZXRlIHRoZSBzZWxlY3Rpb24gb3IgZm9yd2FyZCB1bnRpbCB0aGUgZW5kIG9mIHRoZSBuZXh0IGdyb3VwLlxuKi9cbmNvbnN0IGRlbGV0ZUdyb3VwRm9yd2FyZCA9IHRhcmdldCA9PiBkZWxldGVCeUdyb3VwKHRhcmdldCwgdHJ1ZSk7XG4vKipcbkRlbGV0ZSB0aGUgc2VsZWN0aW9uLCBvciwgaWYgaXQgaXMgYSBjdXJzb3Igc2VsZWN0aW9uLCBkZWxldGUgdG9cbnRoZSBlbmQgb2YgdGhlIGxpbmUuIElmIHRoZSBjdXJzb3IgaXMgZGlyZWN0bHkgYXQgdGhlIGVuZCBvZiB0aGVcbmxpbmUsIGRlbGV0ZSB0aGUgbGluZSBicmVhayBhZnRlciBpdC5cbiovXG5jb25zdCBkZWxldGVUb0xpbmVFbmQgPSB2aWV3ID0+IGRlbGV0ZUJ5KHZpZXcsIHBvcyA9PiB7XG4gICAgbGV0IGxpbmVFbmQgPSB2aWV3LnZpc3VhbExpbmVBdChwb3MpLnRvO1xuICAgIGlmIChwb3MgPCBsaW5lRW5kKVxuICAgICAgICByZXR1cm4gbGluZUVuZDtcbiAgICByZXR1cm4gTWF0aC5taW4odmlldy5zdGF0ZS5kb2MubGVuZ3RoLCBwb3MgKyAxKTtcbn0pO1xuLyoqXG5EZWxldGUgdGhlIHNlbGVjdGlvbiwgb3IsIGlmIGl0IGlzIGEgY3Vyc29yIHNlbGVjdGlvbiwgZGVsZXRlIHRvXG50aGUgc3RhcnQgb2YgdGhlIGxpbmUuIElmIHRoZSBjdXJzb3IgaXMgZGlyZWN0bHkgYXQgdGhlIHN0YXJ0IG9mIHRoZVxubGluZSwgZGVsZXRlIHRoZSBsaW5lIGJyZWFrIGJlZm9yZSBpdC5cbiovXG5jb25zdCBkZWxldGVUb0xpbmVTdGFydCA9IHZpZXcgPT4gZGVsZXRlQnkodmlldywgcG9zID0+IHtcbiAgICBsZXQgbGluZVN0YXJ0ID0gdmlldy52aXN1YWxMaW5lQXQocG9zKS5mcm9tO1xuICAgIGlmIChwb3MgPiBsaW5lU3RhcnQpXG4gICAgICAgIHJldHVybiBsaW5lU3RhcnQ7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIHBvcyAtIDEpO1xufSk7XG4vKipcbkRlbGV0ZSBhbGwgd2hpdGVzcGFjZSBkaXJlY3RseSBiZWZvcmUgYSBsaW5lIGVuZCBmcm9tIHRoZVxuZG9jdW1lbnQuXG4qL1xuY29uc3QgZGVsZXRlVHJhaWxpbmdXaGl0ZXNwYWNlID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBsZXQgY2hhbmdlcyA9IFtdO1xuICAgIGZvciAobGV0IHBvcyA9IDAsIHByZXYgPSBcIlwiLCBpdGVyID0gc3RhdGUuZG9jLml0ZXIoKTs7KSB7XG4gICAgICAgIGl0ZXIubmV4dCgpO1xuICAgICAgICBpZiAoaXRlci5saW5lQnJlYWsgfHwgaXRlci5kb25lKSB7XG4gICAgICAgICAgICBsZXQgdHJhaWxpbmcgPSBwcmV2LnNlYXJjaCgvXFxzKyQvKTtcbiAgICAgICAgICAgIGlmICh0cmFpbGluZyA+IC0xKVxuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IHBvcyAtIChwcmV2Lmxlbmd0aCAtIHRyYWlsaW5nKSwgdG86IHBvcyB9KTtcbiAgICAgICAgICAgIGlmIChpdGVyLmRvbmUpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBwcmV2ID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByZXYgPSBpdGVyLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHBvcyArPSBpdGVyLnZhbHVlLmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKCFjaGFuZ2VzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7IGNoYW5nZXMgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuUmVwbGFjZSBlYWNoIHNlbGVjdGlvbiByYW5nZSB3aXRoIGEgbGluZSBicmVhaywgbGVhdmluZyB0aGUgY3Vyc29yXG5vbiB0aGUgbGluZSBiZWZvcmUgdGhlIGJyZWFrLlxuKi9cbmNvbnN0IHNwbGl0TGluZSA9ICh7IHN0YXRlOiBzdGF0ZSQxLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgbGV0IGNoYW5nZXMgPSBzdGF0ZSQxLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGZyb206IHJhbmdlLmZyb20sIHRvOiByYW5nZS50bywgaW5zZXJ0OiB0ZXh0LlRleHQub2YoW1wiXCIsIFwiXCJdKSB9LFxuICAgICAgICAgICAgcmFuZ2U6IHN0YXRlLkVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuZnJvbSkgfTtcbiAgICB9KTtcbiAgICBkaXNwYXRjaChzdGF0ZSQxLnVwZGF0ZShjaGFuZ2VzLCB7IHNjcm9sbEludG9WaWV3OiB0cnVlLCBhbm5vdGF0aW9uczogc3RhdGUuVHJhbnNhY3Rpb24udXNlckV2ZW50Lm9mKFwiaW5wdXRcIikgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuRmxpcCB0aGUgY2hhcmFjdGVycyBiZWZvcmUgYW5kIGFmdGVyIHRoZSBjdXJzb3IocykuXG4qL1xuY29uc3QgdHJhbnNwb3NlQ2hhcnMgPSAoeyBzdGF0ZTogc3RhdGUkMSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGxldCBjaGFuZ2VzID0gc3RhdGUkMS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSB8fCByYW5nZS5mcm9tID09IDAgfHwgcmFuZ2UuZnJvbSA9PSBzdGF0ZSQxLmRvYy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4geyByYW5nZSB9O1xuICAgICAgICBsZXQgcG9zID0gcmFuZ2UuZnJvbSwgbGluZSA9IHN0YXRlJDEuZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICBsZXQgZnJvbSA9IHBvcyA9PSBsaW5lLmZyb20gPyBwb3MgLSAxIDogdGV4dC5maW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgcG9zIC0gbGluZS5mcm9tLCBmYWxzZSkgKyBsaW5lLmZyb207XG4gICAgICAgIGxldCB0byA9IHBvcyA9PSBsaW5lLnRvID8gcG9zICsgMSA6IHRleHQuZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIHBvcyAtIGxpbmUuZnJvbSwgdHJ1ZSkgKyBsaW5lLmZyb207XG4gICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgZnJvbSwgdG8sIGluc2VydDogc3RhdGUkMS5kb2Muc2xpY2UocG9zLCB0bykuYXBwZW5kKHN0YXRlJDEuZG9jLnNsaWNlKGZyb20sIHBvcykpIH0sXG4gICAgICAgICAgICByYW5nZTogc3RhdGUuRWRpdG9yU2VsZWN0aW9uLmN1cnNvcih0bykgfTtcbiAgICB9KTtcbiAgICBpZiAoY2hhbmdlcy5jaGFuZ2VzLmVtcHR5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc3RhdGUkMS51cGRhdGUoY2hhbmdlcywgeyBzY3JvbGxJbnRvVmlldzogdHJ1ZSB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gc2VsZWN0ZWRMaW5lQmxvY2tzKHN0YXRlKSB7XG4gICAgbGV0IGJsb2NrcyA9IFtdLCB1cHRvID0gLTE7XG4gICAgZm9yIChsZXQgcmFuZ2Ugb2Ygc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgICAgICBsZXQgc3RhcnRMaW5lID0gc3RhdGUuZG9jLmxpbmVBdChyYW5nZS5mcm9tKSwgZW5kTGluZSA9IHN0YXRlLmRvYy5saW5lQXQocmFuZ2UudG8pO1xuICAgICAgICBpZiAodXB0byA9PSBzdGFydExpbmUubnVtYmVyKVxuICAgICAgICAgICAgYmxvY2tzW2Jsb2Nrcy5sZW5ndGggLSAxXS50byA9IGVuZExpbmUudG87XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJsb2Nrcy5wdXNoKHsgZnJvbTogc3RhcnRMaW5lLmZyb20sIHRvOiBlbmRMaW5lLnRvIH0pO1xuICAgICAgICB1cHRvID0gZW5kTGluZS5udW1iZXI7XG4gICAgfVxuICAgIHJldHVybiBibG9ja3M7XG59XG5mdW5jdGlvbiBtb3ZlTGluZShzdGF0ZSwgZGlzcGF0Y2gsIGZvcndhcmQpIHtcbiAgICBsZXQgY2hhbmdlcyA9IFtdO1xuICAgIGZvciAobGV0IGJsb2NrIG9mIHNlbGVjdGVkTGluZUJsb2NrcyhzdGF0ZSkpIHtcbiAgICAgICAgaWYgKGZvcndhcmQgPyBibG9jay50byA9PSBzdGF0ZS5kb2MubGVuZ3RoIDogYmxvY2suZnJvbSA9PSAwKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGxldCBuZXh0TGluZSA9IHN0YXRlLmRvYy5saW5lQXQoZm9yd2FyZCA/IGJsb2NrLnRvICsgMSA6IGJsb2NrLmZyb20gLSAxKTtcbiAgICAgICAgaWYgKGZvcndhcmQpXG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBibG9jay50bywgdG86IG5leHRMaW5lLnRvIH0sIHsgZnJvbTogYmxvY2suZnJvbSwgaW5zZXJ0OiBuZXh0TGluZS50ZXh0ICsgc3RhdGUubGluZUJyZWFrIH0pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBuZXh0TGluZS5mcm9tLCB0bzogYmxvY2suZnJvbSB9LCB7IGZyb206IGJsb2NrLnRvLCBpbnNlcnQ6IHN0YXRlLmxpbmVCcmVhayArIG5leHRMaW5lLnRleHQgfSk7XG4gICAgfVxuICAgIGlmICghY2hhbmdlcy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoeyBjaGFuZ2VzLCBzY3JvbGxJbnRvVmlldzogdHJ1ZSB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGVkIGxpbmVzIHVwIG9uZSBsaW5lLlxuKi9cbmNvbnN0IG1vdmVMaW5lVXAgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4gbW92ZUxpbmUoc3RhdGUsIGRpc3BhdGNoLCBmYWxzZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGVkIGxpbmVzIGRvd24gb25lIGxpbmUuXG4qL1xuY29uc3QgbW92ZUxpbmVEb3duID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IG1vdmVMaW5lKHN0YXRlLCBkaXNwYXRjaCwgdHJ1ZSk7XG5mdW5jdGlvbiBjb3B5TGluZShzdGF0ZSwgZGlzcGF0Y2gsIGZvcndhcmQpIHtcbiAgICBsZXQgY2hhbmdlcyA9IFtdO1xuICAgIGZvciAobGV0IGJsb2NrIG9mIHNlbGVjdGVkTGluZUJsb2NrcyhzdGF0ZSkpIHtcbiAgICAgICAgaWYgKGZvcndhcmQpXG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBibG9jay5mcm9tLCBpbnNlcnQ6IHN0YXRlLmRvYy5zbGljZShibG9jay5mcm9tLCBibG9jay50bykgKyBzdGF0ZS5saW5lQnJlYWsgfSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IGJsb2NrLnRvLCBpbnNlcnQ6IHN0YXRlLmxpbmVCcmVhayArIHN0YXRlLmRvYy5zbGljZShibG9jay5mcm9tLCBibG9jay50bykgfSk7XG4gICAgfVxuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7IGNoYW5nZXMsIHNjcm9sbEludG9WaWV3OiB0cnVlIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuQ3JlYXRlIGEgY29weSBvZiB0aGUgc2VsZWN0ZWQgbGluZXMuIEtlZXAgdGhlIHNlbGVjdGlvbiBpbiB0aGUgdG9wIGNvcHkuXG4qL1xuY29uc3QgY29weUxpbmVVcCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiBjb3B5TGluZShzdGF0ZSwgZGlzcGF0Y2gsIGZhbHNlKTtcbi8qKlxuQ3JlYXRlIGEgY29weSBvZiB0aGUgc2VsZWN0ZWQgbGluZXMuIEtlZXAgdGhlIHNlbGVjdGlvbiBpbiB0aGUgYm90dG9tIGNvcHkuXG4qL1xuY29uc3QgY29weUxpbmVEb3duID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IGNvcHlMaW5lKHN0YXRlLCBkaXNwYXRjaCwgdHJ1ZSk7XG4vKipcbkRlbGV0ZSBzZWxlY3RlZCBsaW5lcy5cbiovXG5jb25zdCBkZWxldGVMaW5lID0gdmlldyA9PiB7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VzKHNlbGVjdGVkTGluZUJsb2NrcyhzdGF0ZSkubWFwKCh7IGZyb20sIHRvIH0pID0+IHtcbiAgICAgICAgaWYgKGZyb20gPiAwKVxuICAgICAgICAgICAgZnJvbS0tO1xuICAgICAgICBlbHNlIGlmICh0byA8IHN0YXRlLmRvYy5sZW5ndGgpXG4gICAgICAgICAgICB0bysrO1xuICAgICAgICByZXR1cm4geyBmcm9tLCB0byB9O1xuICAgIH0pKTtcbiAgICBsZXQgc2VsZWN0aW9uID0gdXBkYXRlU2VsKHN0YXRlLnNlbGVjdGlvbiwgcmFuZ2UgPT4gdmlldy5tb3ZlVmVydGljYWxseShyYW5nZSwgdHJ1ZSkpLm1hcChjaGFuZ2VzKTtcbiAgICB2aWV3LmRpc3BhdGNoKHsgY2hhbmdlcywgc2VsZWN0aW9uLCBzY3JvbGxJbnRvVmlldzogdHJ1ZSB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcblJlcGxhY2UgdGhlIHNlbGVjdGlvbiB3aXRoIGEgbmV3bGluZS5cbiovXG5jb25zdCBpbnNlcnROZXdsaW5lID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoc3RhdGUucmVwbGFjZVNlbGVjdGlvbihzdGF0ZS5saW5lQnJlYWspLCB7IHNjcm9sbEludG9WaWV3OiB0cnVlIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBpc0JldHdlZW5CcmFja2V0cyhzdGF0ZSwgcG9zKSB7XG4gICAgaWYgKC9cXChcXCl8XFxbXFxdfFxce1xcfS8udGVzdChzdGF0ZS5zbGljZURvYyhwb3MgLSAxLCBwb3MgKyAxKSkpXG4gICAgICAgIHJldHVybiB7IGZyb206IHBvcywgdG86IHBvcyB9O1xuICAgIGxldCBjb250ZXh0ID0gbGFuZ3VhZ2Uuc3ludGF4VHJlZShzdGF0ZSkucmVzb2x2ZShwb3MpO1xuICAgIGxldCBiZWZvcmUgPSBjb250ZXh0LmNoaWxkQmVmb3JlKHBvcyksIGFmdGVyID0gY29udGV4dC5jaGlsZEFmdGVyKHBvcyksIGNsb3NlZEJ5O1xuICAgIGlmIChiZWZvcmUgJiYgYWZ0ZXIgJiYgYmVmb3JlLnRvIDw9IHBvcyAmJiBhZnRlci5mcm9tID49IHBvcyAmJlxuICAgICAgICAoY2xvc2VkQnkgPSBiZWZvcmUudHlwZS5wcm9wKGxlemVyVHJlZS5Ob2RlUHJvcC5jbG9zZWRCeSkpICYmIGNsb3NlZEJ5LmluZGV4T2YoYWZ0ZXIubmFtZSkgPiAtMSAmJlxuICAgICAgICBzdGF0ZS5kb2MubGluZUF0KGJlZm9yZS50bykuZnJvbSA9PSBzdGF0ZS5kb2MubGluZUF0KGFmdGVyLmZyb20pLmZyb20pXG4gICAgICAgIHJldHVybiB7IGZyb206IGJlZm9yZS50bywgdG86IGFmdGVyLmZyb20gfTtcbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuUmVwbGFjZSB0aGUgc2VsZWN0aW9uIHdpdGggYSBuZXdsaW5lIGFuZCBpbmRlbnQgdGhlIG5ld2x5IGNyZWF0ZWRcbmxpbmUocykuIElmIHRoZSBjdXJyZW50IGxpbmUgY29uc2lzdHMgb25seSBvZiB3aGl0ZXNwYWNlLCB0aGlzXG53aWxsIGFsc28gZGVsZXRlIHRoYXQgd2hpdGVzcGFjZS4gV2hlbiB0aGUgY3Vyc29yIGlzIGJldHdlZW5cbm1hdGNoaW5nIGJyYWNrZXRzLCBhbiBhZGRpdGlvbmFsIG5ld2xpbmUgd2lsbCBiZSBpbnNlcnRlZCBhZnRlclxudGhlIGN1cnNvci5cbiovXG5jb25zdCBpbnNlcnROZXdsaW5lQW5kSW5kZW50ID0gKHsgc3RhdGU6IHN0YXRlJDEsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBsZXQgY2hhbmdlcyA9IHN0YXRlJDEuY2hhbmdlQnlSYW5nZSgoeyBmcm9tLCB0byB9KSA9PiB7XG4gICAgICAgIGxldCBleHBsb2RlID0gZnJvbSA9PSB0byAmJiBpc0JldHdlZW5CcmFja2V0cyhzdGF0ZSQxLCBmcm9tKTtcbiAgICAgICAgbGV0IGN4ID0gbmV3IGxhbmd1YWdlLkluZGVudENvbnRleHQoc3RhdGUkMSwgeyBzaW11bGF0ZUJyZWFrOiBmcm9tLCBzaW11bGF0ZURvdWJsZUJyZWFrOiAhIWV4cGxvZGUgfSk7XG4gICAgICAgIGxldCBpbmRlbnQgPSBsYW5ndWFnZS5nZXRJbmRlbnRhdGlvbihjeCwgZnJvbSk7XG4gICAgICAgIGlmIChpbmRlbnQgPT0gbnVsbClcbiAgICAgICAgICAgIGluZGVudCA9IC9eXFxzKi8uZXhlYyhzdGF0ZSQxLmRvYy5saW5lQXQoZnJvbSkudGV4dClbMF0ubGVuZ3RoO1xuICAgICAgICBsZXQgbGluZSA9IHN0YXRlJDEuZG9jLmxpbmVBdChmcm9tKTtcbiAgICAgICAgd2hpbGUgKHRvIDwgbGluZS50byAmJiAvXFxzLy50ZXN0KGxpbmUudGV4dC5zbGljZSh0byAtIGxpbmUuZnJvbSwgdG8gKyAxIC0gbGluZS5mcm9tKSkpXG4gICAgICAgICAgICB0bysrO1xuICAgICAgICBpZiAoZXhwbG9kZSlcbiAgICAgICAgICAgICh7IGZyb20sIHRvIH0gPSBleHBsb2RlKTtcbiAgICAgICAgZWxzZSBpZiAoZnJvbSA+IGxpbmUuZnJvbSAmJiBmcm9tIDwgbGluZS5mcm9tICsgMTAwICYmICEvXFxTLy50ZXN0KGxpbmUudGV4dC5zbGljZSgwLCBmcm9tKSkpXG4gICAgICAgICAgICBmcm9tID0gbGluZS5mcm9tO1xuICAgICAgICBsZXQgaW5zZXJ0ID0gW1wiXCIsIGxhbmd1YWdlLmluZGVudFN0cmluZyhzdGF0ZSQxLCBpbmRlbnQpXTtcbiAgICAgICAgaWYgKGV4cGxvZGUpXG4gICAgICAgICAgICBpbnNlcnQucHVzaChsYW5ndWFnZS5pbmRlbnRTdHJpbmcoc3RhdGUkMSwgY3gubGluZUluZGVudChsaW5lKSkpO1xuICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGZyb20sIHRvLCBpbnNlcnQ6IHRleHQuVGV4dC5vZihpbnNlcnQpIH0sXG4gICAgICAgICAgICByYW5nZTogc3RhdGUuRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihmcm9tICsgMSArIGluc2VydFsxXS5sZW5ndGgpIH07XG4gICAgfSk7XG4gICAgZGlzcGF0Y2goc3RhdGUkMS51cGRhdGUoY2hhbmdlcywgeyBzY3JvbGxJbnRvVmlldzogdHJ1ZSB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gY2hhbmdlQnlTZWxlY3RlZExpbmUoc3RhdGUkMSwgZikge1xuICAgIGxldCBhdExpbmUgPSAtMTtcbiAgICByZXR1cm4gc3RhdGUkMS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgbGV0IGNoYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gcmFuZ2UuZnJvbTsgcG9zIDw9IHJhbmdlLnRvOykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBzdGF0ZSQxLmRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgICAgIGlmIChsaW5lLm51bWJlciA+IGF0TGluZSAmJiAocmFuZ2UuZW1wdHkgfHwgcmFuZ2UudG8gPiBsaW5lLmZyb20pKSB7XG4gICAgICAgICAgICAgICAgZihsaW5lLCBjaGFuZ2VzLCByYW5nZSk7XG4gICAgICAgICAgICAgICAgYXRMaW5lID0gbGluZS5udW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgPSBsaW5lLnRvICsgMTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2hhbmdlU2V0ID0gc3RhdGUkMS5jaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICByZXR1cm4geyBjaGFuZ2VzLFxuICAgICAgICAgICAgcmFuZ2U6IHN0YXRlLkVkaXRvclNlbGVjdGlvbi5yYW5nZShjaGFuZ2VTZXQubWFwUG9zKHJhbmdlLmFuY2hvciwgMSksIGNoYW5nZVNldC5tYXBQb3MocmFuZ2UuaGVhZCwgMSkpIH07XG4gICAgfSk7XG59XG4vKipcbkF1dG8taW5kZW50IHRoZSBzZWxlY3RlZCBsaW5lcy4gVGhpcyB1c2VzIHRoZSBbaW5kZW50YXRpb24gc2VydmljZVxuZmFjZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50U2VydmljZSkgYXMgc291cmNlIGZvciBhdXRvLWluZGVudFxuaW5mb3JtYXRpb24uXG4qL1xuY29uc3QgaW5kZW50U2VsZWN0aW9uID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBsZXQgdXBkYXRlZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbGV0IGNvbnRleHQgPSBuZXcgbGFuZ3VhZ2UuSW5kZW50Q29udGV4dChzdGF0ZSwgeyBvdmVycmlkZUluZGVudGF0aW9uOiBzdGFydCA9PiB7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSB1cGRhdGVkW3N0YXJ0XTtcbiAgICAgICAgICAgIHJldHVybiBmb3VuZCA9PSBudWxsID8gLTEgOiBmb3VuZDtcbiAgICAgICAgfSB9KTtcbiAgICBsZXQgY2hhbmdlcyA9IGNoYW5nZUJ5U2VsZWN0ZWRMaW5lKHN0YXRlLCAobGluZSwgY2hhbmdlcywgcmFuZ2UpID0+IHtcbiAgICAgICAgbGV0IGluZGVudCA9IGxhbmd1YWdlLmdldEluZGVudGF0aW9uKGNvbnRleHQsIGxpbmUuZnJvbSk7XG4gICAgICAgIGlmIChpbmRlbnQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGN1ciA9IC9eXFxzKi8uZXhlYyhsaW5lLnRleHQpWzBdO1xuICAgICAgICBsZXQgbm9ybSA9IGxhbmd1YWdlLmluZGVudFN0cmluZyhzdGF0ZSwgaW5kZW50KTtcbiAgICAgICAgaWYgKGN1ciAhPSBub3JtIHx8IHJhbmdlLmZyb20gPCBsaW5lLmZyb20gKyBjdXIubGVuZ3RoKSB7XG4gICAgICAgICAgICB1cGRhdGVkW2xpbmUuZnJvbV0gPSBpbmRlbnQ7XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBsaW5lLmZyb20sIHRvOiBsaW5lLmZyb20gKyBjdXIubGVuZ3RoLCBpbnNlcnQ6IG5vcm0gfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIWNoYW5nZXMuY2hhbmdlcy5lbXB0eSlcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKGNoYW5nZXMpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkFkZCBhIFt1bml0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFVuaXQpIG9mIGluZGVudGF0aW9uIHRvIGFsbCBzZWxlY3RlZFxubGluZXMuXG4qL1xuY29uc3QgaW5kZW50TW9yZSA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKGNoYW5nZUJ5U2VsZWN0ZWRMaW5lKHN0YXRlLCAobGluZSwgY2hhbmdlcykgPT4ge1xuICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBsaW5lLmZyb20sIGluc2VydDogc3RhdGUuZmFjZXQobGFuZ3VhZ2UuaW5kZW50VW5pdCkgfSk7XG4gICAgfSkpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcblJlbW92ZSBhIFt1bml0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFVuaXQpIG9mIGluZGVudGF0aW9uIGZyb20gYWxsXG5zZWxlY3RlZCBsaW5lcy5cbiovXG5jb25zdCBpbmRlbnRMZXNzID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlQnlTZWxlY3RlZExpbmUoc3RhdGUsIChsaW5lLCBjaGFuZ2VzKSA9PiB7XG4gICAgICAgIGxldCBzcGFjZSA9IC9eXFxzKi8uZXhlYyhsaW5lLnRleHQpWzBdO1xuICAgICAgICBpZiAoIXNwYWNlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgY29sID0gdGV4dC5jb3VudENvbHVtbihzcGFjZSwgMCwgc3RhdGUudGFiU2l6ZSksIGtlZXAgPSAwO1xuICAgICAgICBsZXQgaW5zZXJ0ID0gbGFuZ3VhZ2UuaW5kZW50U3RyaW5nKHN0YXRlLCBNYXRoLm1heCgwLCBjb2wgLSBsYW5ndWFnZS5nZXRJbmRlbnRVbml0KHN0YXRlKSkpO1xuICAgICAgICB3aGlsZSAoa2VlcCA8IHNwYWNlLmxlbmd0aCAmJiBrZWVwIDwgaW5zZXJ0Lmxlbmd0aCAmJiBzcGFjZS5jaGFyQ29kZUF0KGtlZXApID09IGluc2VydC5jaGFyQ29kZUF0KGtlZXApKVxuICAgICAgICAgICAga2VlcCsrO1xuICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBsaW5lLmZyb20gKyBrZWVwLCB0bzogbGluZS5mcm9tICsgc3BhY2UubGVuZ3RoLCBpbnNlcnQ6IGluc2VydC5zbGljZShrZWVwKSB9KTtcbiAgICB9KSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuSW5zZXJ0IGEgdGFiIGNoYXJhY3RlciBhdCB0aGUgY3Vyc29yIG9yLCBpZiBzb21ldGhpbmcgaXMgc2VsZWN0ZWQsXG51c2UgW2BpbmRlbnRNb3JlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5pbmRlbnRNb3JlKSB0byBpbmRlbnQgdGhlIGVudGlyZVxuc2VsZWN0aW9uLlxuKi9cbmNvbnN0IGluc2VydFRhYiA9ICh7IHN0YXRlOiBzdGF0ZSQxLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgaWYgKHN0YXRlJDEuc2VsZWN0aW9uLnJhbmdlcy5zb21lKHIgPT4gIXIuZW1wdHkpKVxuICAgICAgICByZXR1cm4gaW5kZW50TW9yZSh7IHN0YXRlOiBzdGF0ZSQxLCBkaXNwYXRjaCB9KTtcbiAgICBkaXNwYXRjaChzdGF0ZSQxLnVwZGF0ZShzdGF0ZSQxLnJlcGxhY2VTZWxlY3Rpb24oXCJcXHRcIiksIHsgc2Nyb2xsSW50b1ZpZXc6IHRydWUsIGFubm90YXRpb25zOiBzdGF0ZS5UcmFuc2FjdGlvbi51c2VyRXZlbnQub2YoXCJpbnB1dFwiKSB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5BcnJheSBvZiBrZXkgYmluZGluZ3MgY29udGFpbmluZyB0aGUgRW1hY3Mtc3R5bGUgYmluZGluZ3MgdGhhdCBhcmVcbmF2YWlsYWJsZSBvbiBtYWNPUyBieSBkZWZhdWx0LlxuXG4gLSBDdHJsLWI6IFtgY3Vyc29yQ2hhckxlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckNoYXJMZWZ0KSAoW2BzZWxlY3RDaGFyTGVmdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0Q2hhckxlZnQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLWY6IFtgY3Vyc29yQ2hhclJpZ2h0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JDaGFyUmlnaHQpIChbYHNlbGVjdENoYXJSaWdodGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0Q2hhclJpZ2h0KSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1wOiBbYGN1cnNvckxpbmVVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZVVwKSAoW2BzZWxlY3RMaW5lVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVVcCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtbjogW2BjdXJzb3JMaW5lRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZURvd24pIChbYHNlbGVjdExpbmVEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lRG93bikgd2l0aCBTaGlmdClcbiAtIEN0cmwtYTogW2BjdXJzb3JMaW5lU3RhcnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVTdGFydCkgKFtgc2VsZWN0TGluZVN0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lU3RhcnQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLWU6IFtgY3Vyc29yTGluZUVuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZUVuZCkgKFtgc2VsZWN0TGluZUVuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZUVuZCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtZDogW2BkZWxldGVDaGFyRm9yd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlQ2hhckZvcndhcmQpXG4gLSBDdHJsLWg6IFtgZGVsZXRlQ2hhckJhY2t3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVDaGFyQmFja3dhcmQpXG4gLSBDdHJsLWs6IFtgZGVsZXRlVG9MaW5lRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVUb0xpbmVFbmQpXG4gLSBBbHQtZDogW2BkZWxldGVHcm91cEZvcndhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUdyb3VwRm9yd2FyZClcbiAtIEN0cmwtQWx0LWg6IFtgZGVsZXRlR3JvdXBCYWNrd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlR3JvdXBCYWNrd2FyZClcbiAtIEN0cmwtbzogW2BzcGxpdExpbmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNwbGl0TGluZSlcbiAtIEN0cmwtdDogW2B0cmFuc3Bvc2VDaGFyc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMudHJhbnNwb3NlQ2hhcnMpXG4gLSBBbHQtZjogW2BjdXJzb3JHcm91cEZvcndhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckdyb3VwRm9yd2FyZCkgKFtgc2VsZWN0R3JvdXBGb3J3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RHcm91cEZvcndhcmQpIHdpdGggU2hpZnQpXG4gLSBBbHQtYjogW2BjdXJzb3JHcm91cEJhY2t3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JHcm91cEJhY2t3YXJkKSAoW2BzZWxlY3RHcm91cEJhY2t3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RHcm91cEJhY2t3YXJkKSB3aXRoIFNoaWZ0KVxuIC0gQWx0LTw6IFtgY3Vyc29yRG9jU3RhcnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckRvY1N0YXJ0KVxuIC0gQWx0LT46IFtgY3Vyc29yRG9jRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JEb2NFbmQpXG4gLSBDdHJsLXY6IFtgY3Vyc29yUGFnZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvclBhZ2VEb3duKVxuIC0gQWx0LXY6IFtgY3Vyc29yUGFnZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JQYWdlVXApXG4qL1xuY29uc3QgZW1hY3NTdHlsZUtleW1hcCA9IFtcbiAgICB7IGtleTogXCJDdHJsLWJcIiwgcnVuOiBjdXJzb3JDaGFyTGVmdCwgc2hpZnQ6IHNlbGVjdENoYXJMZWZ0IH0sXG4gICAgeyBrZXk6IFwiQ3RybC1mXCIsIHJ1bjogY3Vyc29yQ2hhclJpZ2h0LCBzaGlmdDogc2VsZWN0Q2hhclJpZ2h0IH0sXG4gICAgeyBrZXk6IFwiQ3RybC1wXCIsIHJ1bjogY3Vyc29yTGluZVVwLCBzaGlmdDogc2VsZWN0TGluZVVwIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1uXCIsIHJ1bjogY3Vyc29yTGluZURvd24sIHNoaWZ0OiBzZWxlY3RMaW5lRG93biB9LFxuICAgIHsga2V5OiBcIkN0cmwtYVwiLCBydW46IGN1cnNvckxpbmVTdGFydCwgc2hpZnQ6IHNlbGVjdExpbmVTdGFydCB9LFxuICAgIHsga2V5OiBcIkN0cmwtZVwiLCBydW46IGN1cnNvckxpbmVFbmQsIHNoaWZ0OiBzZWxlY3RMaW5lRW5kIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1kXCIsIHJ1bjogZGVsZXRlQ2hhckZvcndhcmQgfSxcbiAgICB7IGtleTogXCJDdHJsLWhcIiwgcnVuOiBkZWxldGVDaGFyQmFja3dhcmQgfSxcbiAgICB7IGtleTogXCJDdHJsLWtcIiwgcnVuOiBkZWxldGVUb0xpbmVFbmQgfSxcbiAgICB7IGtleTogXCJBbHQtZFwiLCBydW46IGRlbGV0ZUdyb3VwRm9yd2FyZCB9LFxuICAgIHsga2V5OiBcIkN0cmwtQWx0LWhcIiwgcnVuOiBkZWxldGVHcm91cEJhY2t3YXJkIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1vXCIsIHJ1bjogc3BsaXRMaW5lIH0sXG4gICAgeyBrZXk6IFwiQ3RybC10XCIsIHJ1bjogdHJhbnNwb3NlQ2hhcnMgfSxcbiAgICB7IGtleTogXCJBbHQtZlwiLCBydW46IGN1cnNvckdyb3VwRm9yd2FyZCwgc2hpZnQ6IHNlbGVjdEdyb3VwRm9yd2FyZCB9LFxuICAgIHsga2V5OiBcIkFsdC1iXCIsIHJ1bjogY3Vyc29yR3JvdXBCYWNrd2FyZCwgc2hpZnQ6IHNlbGVjdEdyb3VwQmFja3dhcmQgfSxcbiAgICB7IGtleTogXCJBbHQtPFwiLCBydW46IGN1cnNvckRvY1N0YXJ0IH0sXG4gICAgeyBrZXk6IFwiQWx0LT5cIiwgcnVuOiBjdXJzb3JEb2NFbmQgfSxcbiAgICB7IGtleTogXCJDdHJsLXZcIiwgcnVuOiBjdXJzb3JQYWdlRG93biB9LFxuICAgIHsga2V5OiBcIkFsdC12XCIsIHJ1bjogY3Vyc29yUGFnZVVwIH0sXG5dO1xuLyoqXG5BbiBhcnJheSBvZiBrZXkgYmluZGluZ3MgY2xvc2VseSBzdGlja2luZyB0byBwbGF0Zm9ybS1zdGFuZGFyZCBvclxud2lkZWx5IHVzZWQgYmluZGluZ3MuIChUaGlzIGluY2x1ZGVzIHRoZSBiaW5kaW5ncyBmcm9tXG5bYGVtYWNzU3R5bGVLZXltYXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmVtYWNzU3R5bGVLZXltYXApLCB3aXRoIHRoZWlyIGBrZXlgXG5wcm9wZXJ0eSBjaGFuZ2VkIHRvIGBtYWNgLilcblxuIC0gQXJyb3dMZWZ0OiBbYGN1cnNvckNoYXJMZWZ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JDaGFyTGVmdCkgKFtgc2VsZWN0Q2hhckxlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdENoYXJMZWZ0KSB3aXRoIFNoaWZ0KVxuIC0gQXJyb3dSaWdodDogW2BjdXJzb3JDaGFyUmlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckNoYXJSaWdodCkgKFtgc2VsZWN0Q2hhclJpZ2h0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RDaGFyUmlnaHQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLUFycm93TGVmdCAoQWx0LUFycm93TGVmdCBvbiBtYWNPUyk6IFtgY3Vyc29yR3JvdXBMZWZ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JHcm91cExlZnQpIChbYHNlbGVjdEdyb3VwTGVmdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0R3JvdXBMZWZ0KSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1BcnJvd1JpZ2h0IChBbHQtQXJyb3dSaWdodCBvbiBtYWNPUyk6IFtgY3Vyc29yR3JvdXBSaWdodGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yR3JvdXBSaWdodCkgKFtgc2VsZWN0R3JvdXBSaWdodGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0R3JvdXBSaWdodCkgd2l0aCBTaGlmdClcbiAtIENtZC1BcnJvd0xlZnQgKG9uIG1hY09TKTogW2BjdXJzb3JMaW5lU3RhcnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVTdGFydCkgKFtgc2VsZWN0TGluZVN0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lU3RhcnQpIHdpdGggU2hpZnQpXG4gLSBDbWQtQXJyb3dSaWdodCAob24gbWFjT1MpOiBbYGN1cnNvckxpbmVFbmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVFbmQpIChbYHNlbGVjdExpbmVFbmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVFbmQpIHdpdGggU2hpZnQpXG4gLSBBcnJvd1VwOiBbYGN1cnNvckxpbmVVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZVVwKSAoW2BzZWxlY3RMaW5lVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVVcCkgd2l0aCBTaGlmdClcbiAtIEFycm93RG93bjogW2BjdXJzb3JMaW5lRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZURvd24pIChbYHNlbGVjdExpbmVEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lRG93bikgd2l0aCBTaGlmdClcbiAtIENtZC1BcnJvd1VwIChvbiBtYWNPUyk6IFtgY3Vyc29yRG9jU3RhcnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckRvY1N0YXJ0KSAoW2BzZWxlY3REb2NTdGFydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0RG9jU3RhcnQpIHdpdGggU2hpZnQpXG4gLSBDbWQtQXJyb3dEb3duIChvbiBtYWNPUyk6IFtgY3Vyc29yRG9jRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JEb2NFbmQpIChbYHNlbGVjdERvY0VuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0RG9jRW5kKSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1BcnJvd1VwIChvbiBtYWNPUyk6IFtgY3Vyc29yUGFnZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JQYWdlVXApIChbYHNlbGVjdFBhZ2VVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0UGFnZVVwKSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1BcnJvd0Rvd24gKG9uIG1hY09TKTogW2BjdXJzb3JQYWdlRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yUGFnZURvd24pIChbYHNlbGVjdFBhZ2VEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RQYWdlRG93bikgd2l0aCBTaGlmdClcbiAtIFBhZ2VVcDogW2BjdXJzb3JQYWdlVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvclBhZ2VVcCkgKFtgc2VsZWN0UGFnZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RQYWdlVXApIHdpdGggU2hpZnQpXG4gLSBQYWdlRG93bjogW2BjdXJzb3JQYWdlRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yUGFnZURvd24pIChbYHNlbGVjdFBhZ2VEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RQYWdlRG93bikgd2l0aCBTaGlmdClcbiAtIEhvbWU6IFtgY3Vyc29yTGluZUJvdW5kYXJ5QmFja3dhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVCb3VuZGFyeUJhY2t3YXJkKSAoW2BzZWxlY3RMaW5lQm91bmRhcnlCYWNrd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZUJvdW5kYXJ5QmFja3dhcmQpIHdpdGggU2hpZnQpXG4gLSBFbmQ6IFtgY3Vyc29yTGluZUJvdW5kYXJ5Rm9yd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZUJvdW5kYXJ5Rm9yd2FyZCkgKFtgc2VsZWN0TGluZUJvdW5kYXJ5Rm9yd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZUJvdW5kYXJ5Rm9yd2FyZCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtSG9tZSAoQ21kLUhvbWUgb24gbWFjT1MpOiBbYGN1cnNvckRvY1N0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JEb2NTdGFydCkgKFtgc2VsZWN0RG9jU3RhcnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdERvY1N0YXJ0KSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1FbmQgKENtZC1Ib21lIG9uIG1hY09TKTogW2BjdXJzb3JEb2NFbmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckRvY0VuZCkgKFtgc2VsZWN0RG9jRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3REb2NFbmQpIHdpdGggU2hpZnQpXG4gLSBFbnRlcjogW2BpbnNlcnROZXdsaW5lQW5kSW5kZW50YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5pbnNlcnROZXdsaW5lQW5kSW5kZW50KVxuIC0gQ3RybC1hIChDbWQtYSBvbiBtYWNPUyk6IFtgc2VsZWN0QWxsYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RBbGwpXG4gLSBCYWNrc3BhY2U6IFtgZGVsZXRlQ29kZVBvaW50QmFja3dhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUNvZGVQb2ludEJhY2t3YXJkKVxuIC0gRGVsZXRlOiBbYGRlbGV0ZUNoYXJGb3J3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVDaGFyRm9yd2FyZClcbiAtIEN0cmwtQmFja3NwYWNlIChBbHQtQmFja3NwYWNlIG9uIG1hY09TKTogW2BkZWxldGVHcm91cEJhY2t3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVHcm91cEJhY2t3YXJkKVxuIC0gQ3RybC1EZWxldGUgKEFsdC1EZWxldGUgb24gbWFjT1MpOiBbYGRlbGV0ZUdyb3VwRm9yd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlR3JvdXBGb3J3YXJkKVxuIC0gQ21kLUJhY2tzcGFjZSAobWFjT1MpOiBbYGRlbGV0ZVRvTGluZVN0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVUb0xpbmVTdGFydCkuXG4gLSBDbWQtRGVsZXRlIChtYWNPUyk6IFtgZGVsZXRlVG9MaW5lRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVUb0xpbmVFbmQpLlxuKi9cbmNvbnN0IHN0YW5kYXJkS2V5bWFwID0gW1xuICAgIHsga2V5OiBcIkFycm93TGVmdFwiLCBydW46IGN1cnNvckNoYXJMZWZ0LCBzaGlmdDogc2VsZWN0Q2hhckxlZnQgfSxcbiAgICB7IGtleTogXCJNb2QtQXJyb3dMZWZ0XCIsIG1hYzogXCJBbHQtQXJyb3dMZWZ0XCIsIHJ1bjogY3Vyc29yR3JvdXBMZWZ0LCBzaGlmdDogc2VsZWN0R3JvdXBMZWZ0IH0sXG4gICAgeyBtYWM6IFwiQ21kLUFycm93TGVmdFwiLCBydW46IGN1cnNvckxpbmVTdGFydCwgc2hpZnQ6IHNlbGVjdExpbmVTdGFydCB9LFxuICAgIHsga2V5OiBcIkFycm93UmlnaHRcIiwgcnVuOiBjdXJzb3JDaGFyUmlnaHQsIHNoaWZ0OiBzZWxlY3RDaGFyUmlnaHQgfSxcbiAgICB7IGtleTogXCJNb2QtQXJyb3dSaWdodFwiLCBtYWM6IFwiQWx0LUFycm93UmlnaHRcIiwgcnVuOiBjdXJzb3JHcm91cFJpZ2h0LCBzaGlmdDogc2VsZWN0R3JvdXBSaWdodCB9LFxuICAgIHsgbWFjOiBcIkNtZC1BcnJvd1JpZ2h0XCIsIHJ1bjogY3Vyc29yTGluZUVuZCwgc2hpZnQ6IHNlbGVjdExpbmVFbmQgfSxcbiAgICB7IGtleTogXCJBcnJvd1VwXCIsIHJ1bjogY3Vyc29yTGluZVVwLCBzaGlmdDogc2VsZWN0TGluZVVwIH0sXG4gICAgeyBtYWM6IFwiQ21kLUFycm93VXBcIiwgcnVuOiBjdXJzb3JEb2NTdGFydCwgc2hpZnQ6IHNlbGVjdERvY1N0YXJ0IH0sXG4gICAgeyBtYWM6IFwiQ3RybC1BcnJvd1VwXCIsIHJ1bjogY3Vyc29yUGFnZVVwLCBzaGlmdDogc2VsZWN0UGFnZVVwIH0sXG4gICAgeyBrZXk6IFwiQXJyb3dEb3duXCIsIHJ1bjogY3Vyc29yTGluZURvd24sIHNoaWZ0OiBzZWxlY3RMaW5lRG93biB9LFxuICAgIHsgbWFjOiBcIkNtZC1BcnJvd0Rvd25cIiwgcnVuOiBjdXJzb3JEb2NFbmQsIHNoaWZ0OiBzZWxlY3REb2NFbmQgfSxcbiAgICB7IG1hYzogXCJDdHJsLUFycm93RG93blwiLCBydW46IGN1cnNvclBhZ2VEb3duLCBzaGlmdDogc2VsZWN0UGFnZURvd24gfSxcbiAgICB7IGtleTogXCJQYWdlVXBcIiwgcnVuOiBjdXJzb3JQYWdlVXAsIHNoaWZ0OiBzZWxlY3RQYWdlVXAgfSxcbiAgICB7IGtleTogXCJQYWdlRG93blwiLCBydW46IGN1cnNvclBhZ2VEb3duLCBzaGlmdDogc2VsZWN0UGFnZURvd24gfSxcbiAgICB7IGtleTogXCJIb21lXCIsIHJ1bjogY3Vyc29yTGluZUJvdW5kYXJ5QmFja3dhcmQsIHNoaWZ0OiBzZWxlY3RMaW5lQm91bmRhcnlCYWNrd2FyZCB9LFxuICAgIHsga2V5OiBcIk1vZC1Ib21lXCIsIHJ1bjogY3Vyc29yRG9jU3RhcnQsIHNoaWZ0OiBzZWxlY3REb2NTdGFydCB9LFxuICAgIHsga2V5OiBcIkVuZFwiLCBydW46IGN1cnNvckxpbmVCb3VuZGFyeUZvcndhcmQsIHNoaWZ0OiBzZWxlY3RMaW5lQm91bmRhcnlGb3J3YXJkIH0sXG4gICAgeyBrZXk6IFwiTW9kLUVuZFwiLCBydW46IGN1cnNvckRvY0VuZCwgc2hpZnQ6IHNlbGVjdERvY0VuZCB9LFxuICAgIHsga2V5OiBcIkVudGVyXCIsIHJ1bjogaW5zZXJ0TmV3bGluZUFuZEluZGVudCB9LFxuICAgIHsga2V5OiBcIk1vZC1hXCIsIHJ1bjogc2VsZWN0QWxsIH0sXG4gICAgeyBrZXk6IFwiQmFja3NwYWNlXCIsIHJ1bjogZGVsZXRlQ29kZVBvaW50QmFja3dhcmQsIHNoaWZ0OiBkZWxldGVDb2RlUG9pbnRCYWNrd2FyZCB9LFxuICAgIHsga2V5OiBcIkRlbGV0ZVwiLCBydW46IGRlbGV0ZUNoYXJGb3J3YXJkLCBzaGlmdDogZGVsZXRlQ2hhckZvcndhcmQgfSxcbiAgICB7IGtleTogXCJNb2QtQmFja3NwYWNlXCIsIG1hYzogXCJBbHQtQmFja3NwYWNlXCIsIHJ1bjogZGVsZXRlR3JvdXBCYWNrd2FyZCB9LFxuICAgIHsga2V5OiBcIk1vZC1EZWxldGVcIiwgbWFjOiBcIkFsdC1EZWxldGVcIiwgcnVuOiBkZWxldGVHcm91cEZvcndhcmQgfSxcbiAgICB7IG1hYzogXCJNb2QtQmFja3NwYWNlXCIsIHJ1bjogZGVsZXRlVG9MaW5lU3RhcnQgfSxcbiAgICB7IG1hYzogXCJNb2QtRGVsZXRlXCIsIHJ1bjogZGVsZXRlVG9MaW5lRW5kIH1cbl0uY29uY2F0KGVtYWNzU3R5bGVLZXltYXAubWFwKGIgPT4gKHsgbWFjOiBiLmtleSwgcnVuOiBiLnJ1biwgc2hpZnQ6IGIuc2hpZnQgfSkpKTtcbi8qKlxuVGhlIGRlZmF1bHQga2V5bWFwLiBJbmNsdWRlcyBhbGwgYmluZGluZ3MgZnJvbVxuW2BzdGFuZGFyZEtleW1hcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc3RhbmRhcmRLZXltYXApIHBsdXMgdGhlIGZvbGxvd2luZzpcblxuLSBBbHQtQXJyb3dMZWZ0IChDdHJsLUFycm93TGVmdCBvbiBtYWNPUyk6IFtgY3Vyc29yU3ludGF4TGVmdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yU3ludGF4TGVmdCkgKFtgc2VsZWN0U3ludGF4TGVmdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0U3ludGF4TGVmdCkgd2l0aCBTaGlmdClcbi0gQWx0LUFycm93UmlnaHQgKEN0cmwtQXJyb3dSaWdodCBvbiBtYWNPUyk6IFtgY3Vyc29yU3ludGF4UmlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvclN5bnRheFJpZ2h0KSAoW2BzZWxlY3RTeW50YXhSaWdodGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0U3ludGF4UmlnaHQpIHdpdGggU2hpZnQpXG4tIEFsdC1BcnJvd1VwOiBbYG1vdmVMaW5lVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLm1vdmVMaW5lVXApXG4tIEFsdC1BcnJvd0Rvd246IFtgbW92ZUxpbmVEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5tb3ZlTGluZURvd24pXG4tIFNoaWZ0LUFsdC1BcnJvd1VwOiBbYGNvcHlMaW5lVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmNvcHlMaW5lVXApXG4tIFNoaWZ0LUFsdC1BcnJvd0Rvd246IFtgY29weUxpbmVEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jb3B5TGluZURvd24pXG4tIEVzY2FwZTogW2BzaW1wbGlmeVNlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2ltcGxpZnlTZWxlY3Rpb24pXG4tIEFsdC1sOiBbYHNlbGVjdExpbmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmUpXG4tIEN0cmwtaSAoQ21kLWkgb24gbWFjT1MpOiBbYHNlbGVjdFBhcmVudFN5bnRheGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0UGFyZW50U3ludGF4KVxuLSBDdHJsLVsgKENtZC1bIG9uIG1hY09TKTogW2BpbmRlbnRMZXNzYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5pbmRlbnRMZXNzKVxuLSBDdHJsLV0gKENtZC1dIG9uIG1hY09TKTogW2BpbmRlbnRNb3JlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5pbmRlbnRNb3JlKVxuLSBDdHJsLUFsdC1cXFxcIChDbWQtQWx0LVxcXFwgb24gbWFjT1MpOiBbYGluZGVudFNlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuaW5kZW50U2VsZWN0aW9uKVxuLSBTaGlmdC1DdHJsLWsgKFNoaWZ0LUNtZC1rIG9uIG1hY09TKTogW2BkZWxldGVMaW5lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVMaW5lKVxuLSBTaGlmdC1DdHJsLVxcXFwgKFNoaWZ0LUNtZC1cXFxcIG9uIG1hY09TKTogW2BjdXJzb3JNYXRjaGluZ0JyYWNrZXRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvck1hdGNoaW5nQnJhY2tldClcbiovXG5jb25zdCBkZWZhdWx0S2V5bWFwID0gW1xuICAgIHsga2V5OiBcIkFsdC1BcnJvd0xlZnRcIiwgbWFjOiBcIkN0cmwtQXJyb3dMZWZ0XCIsIHJ1bjogY3Vyc29yU3ludGF4TGVmdCwgc2hpZnQ6IHNlbGVjdFN5bnRheExlZnQgfSxcbiAgICB7IGtleTogXCJBbHQtQXJyb3dSaWdodFwiLCBtYWM6IFwiQ3RybC1BcnJvd1JpZ2h0XCIsIHJ1bjogY3Vyc29yU3ludGF4UmlnaHQsIHNoaWZ0OiBzZWxlY3RTeW50YXhSaWdodCB9LFxuICAgIHsga2V5OiBcIkFsdC1BcnJvd1VwXCIsIHJ1bjogbW92ZUxpbmVVcCB9LFxuICAgIHsga2V5OiBcIlNoaWZ0LUFsdC1BcnJvd1VwXCIsIHJ1bjogY29weUxpbmVVcCB9LFxuICAgIHsga2V5OiBcIkFsdC1BcnJvd0Rvd25cIiwgcnVuOiBtb3ZlTGluZURvd24gfSxcbiAgICB7IGtleTogXCJTaGlmdC1BbHQtQXJyb3dEb3duXCIsIHJ1bjogY29weUxpbmVEb3duIH0sXG4gICAgeyBrZXk6IFwiRXNjYXBlXCIsIHJ1bjogc2ltcGxpZnlTZWxlY3Rpb24gfSxcbiAgICB7IGtleTogXCJBbHQtbFwiLCBydW46IHNlbGVjdExpbmUgfSxcbiAgICB7IGtleTogXCJNb2QtaVwiLCBydW46IHNlbGVjdFBhcmVudFN5bnRheCB9LFxuICAgIHsga2V5OiBcIk1vZC1bXCIsIHJ1bjogaW5kZW50TGVzcyB9LFxuICAgIHsga2V5OiBcIk1vZC1dXCIsIHJ1bjogaW5kZW50TW9yZSB9LFxuICAgIHsga2V5OiBcIk1vZC1BbHQtXFxcXFwiLCBydW46IGluZGVudFNlbGVjdGlvbiB9LFxuICAgIHsga2V5OiBcIlNoaWZ0LU1vZC1rXCIsIHJ1bjogZGVsZXRlTGluZSB9LFxuICAgIHsga2V5OiBcIlNoaWZ0LU1vZC1cXFxcXCIsIHJ1bjogY3Vyc29yTWF0Y2hpbmdCcmFja2V0IH1cbl0uY29uY2F0KHN0YW5kYXJkS2V5bWFwKTtcbi8qKlxuQSBiaW5kaW5nIHRoYXQgYmluZHMgVGFiIHRvIFtgaW5zZXJ0VGFiYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5pbnNlcnRUYWIpIGFuZFxuU2hpZnQtVGFiIHRvIFtgaW5kZW50U2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5pbmRlbnRTZWxlY3Rpb24pLlxuUGxlYXNlIHNlZSB0aGUgW1RhYiBleGFtcGxlXSguLi8uLi9leGFtcGxlcy90YWIvKSBiZWZvcmUgdXNpbmdcbnRoaXMuXG4qL1xuY29uc3QgZGVmYXVsdFRhYkJpbmRpbmcgPSB7IGtleTogXCJUYWJcIiwgcnVuOiBpbnNlcnRUYWIsIHNoaWZ0OiBpbmRlbnRTZWxlY3Rpb24gfTtcblxuZXhwb3J0cy5jb3B5TGluZURvd24gPSBjb3B5TGluZURvd247XG5leHBvcnRzLmNvcHlMaW5lVXAgPSBjb3B5TGluZVVwO1xuZXhwb3J0cy5jdXJzb3JDaGFyQmFja3dhcmQgPSBjdXJzb3JDaGFyQmFja3dhcmQ7XG5leHBvcnRzLmN1cnNvckNoYXJGb3J3YXJkID0gY3Vyc29yQ2hhckZvcndhcmQ7XG5leHBvcnRzLmN1cnNvckNoYXJMZWZ0ID0gY3Vyc29yQ2hhckxlZnQ7XG5leHBvcnRzLmN1cnNvckNoYXJSaWdodCA9IGN1cnNvckNoYXJSaWdodDtcbmV4cG9ydHMuY3Vyc29yRG9jRW5kID0gY3Vyc29yRG9jRW5kO1xuZXhwb3J0cy5jdXJzb3JEb2NTdGFydCA9IGN1cnNvckRvY1N0YXJ0O1xuZXhwb3J0cy5jdXJzb3JHcm91cEJhY2t3YXJkID0gY3Vyc29yR3JvdXBCYWNrd2FyZDtcbmV4cG9ydHMuY3Vyc29yR3JvdXBGb3J3YXJkID0gY3Vyc29yR3JvdXBGb3J3YXJkO1xuZXhwb3J0cy5jdXJzb3JHcm91cExlZnQgPSBjdXJzb3JHcm91cExlZnQ7XG5leHBvcnRzLmN1cnNvckdyb3VwUmlnaHQgPSBjdXJzb3JHcm91cFJpZ2h0O1xuZXhwb3J0cy5jdXJzb3JMaW5lQm91bmRhcnlCYWNrd2FyZCA9IGN1cnNvckxpbmVCb3VuZGFyeUJhY2t3YXJkO1xuZXhwb3J0cy5jdXJzb3JMaW5lQm91bmRhcnlGb3J3YXJkID0gY3Vyc29yTGluZUJvdW5kYXJ5Rm9yd2FyZDtcbmV4cG9ydHMuY3Vyc29yTGluZURvd24gPSBjdXJzb3JMaW5lRG93bjtcbmV4cG9ydHMuY3Vyc29yTGluZUVuZCA9IGN1cnNvckxpbmVFbmQ7XG5leHBvcnRzLmN1cnNvckxpbmVTdGFydCA9IGN1cnNvckxpbmVTdGFydDtcbmV4cG9ydHMuY3Vyc29yTGluZVVwID0gY3Vyc29yTGluZVVwO1xuZXhwb3J0cy5jdXJzb3JNYXRjaGluZ0JyYWNrZXQgPSBjdXJzb3JNYXRjaGluZ0JyYWNrZXQ7XG5leHBvcnRzLmN1cnNvclBhZ2VEb3duID0gY3Vyc29yUGFnZURvd247XG5leHBvcnRzLmN1cnNvclBhZ2VVcCA9IGN1cnNvclBhZ2VVcDtcbmV4cG9ydHMuY3Vyc29yU3ludGF4TGVmdCA9IGN1cnNvclN5bnRheExlZnQ7XG5leHBvcnRzLmN1cnNvclN5bnRheFJpZ2h0ID0gY3Vyc29yU3ludGF4UmlnaHQ7XG5leHBvcnRzLmRlZmF1bHRLZXltYXAgPSBkZWZhdWx0S2V5bWFwO1xuZXhwb3J0cy5kZWZhdWx0VGFiQmluZGluZyA9IGRlZmF1bHRUYWJCaW5kaW5nO1xuZXhwb3J0cy5kZWxldGVDaGFyQmFja3dhcmQgPSBkZWxldGVDaGFyQmFja3dhcmQ7XG5leHBvcnRzLmRlbGV0ZUNoYXJGb3J3YXJkID0gZGVsZXRlQ2hhckZvcndhcmQ7XG5leHBvcnRzLmRlbGV0ZUNvZGVQb2ludEJhY2t3YXJkID0gZGVsZXRlQ29kZVBvaW50QmFja3dhcmQ7XG5leHBvcnRzLmRlbGV0ZUNvZGVQb2ludEZvcndhcmQgPSBkZWxldGVDb2RlUG9pbnRGb3J3YXJkO1xuZXhwb3J0cy5kZWxldGVHcm91cEJhY2t3YXJkID0gZGVsZXRlR3JvdXBCYWNrd2FyZDtcbmV4cG9ydHMuZGVsZXRlR3JvdXBGb3J3YXJkID0gZGVsZXRlR3JvdXBGb3J3YXJkO1xuZXhwb3J0cy5kZWxldGVMaW5lID0gZGVsZXRlTGluZTtcbmV4cG9ydHMuZGVsZXRlVG9MaW5lRW5kID0gZGVsZXRlVG9MaW5lRW5kO1xuZXhwb3J0cy5kZWxldGVUb0xpbmVTdGFydCA9IGRlbGV0ZVRvTGluZVN0YXJ0O1xuZXhwb3J0cy5kZWxldGVUcmFpbGluZ1doaXRlc3BhY2UgPSBkZWxldGVUcmFpbGluZ1doaXRlc3BhY2U7XG5leHBvcnRzLmVtYWNzU3R5bGVLZXltYXAgPSBlbWFjc1N0eWxlS2V5bWFwO1xuZXhwb3J0cy5pbmRlbnRMZXNzID0gaW5kZW50TGVzcztcbmV4cG9ydHMuaW5kZW50TW9yZSA9IGluZGVudE1vcmU7XG5leHBvcnRzLmluZGVudFNlbGVjdGlvbiA9IGluZGVudFNlbGVjdGlvbjtcbmV4cG9ydHMuaW5zZXJ0TmV3bGluZSA9IGluc2VydE5ld2xpbmU7XG5leHBvcnRzLmluc2VydE5ld2xpbmVBbmRJbmRlbnQgPSBpbnNlcnROZXdsaW5lQW5kSW5kZW50O1xuZXhwb3J0cy5pbnNlcnRUYWIgPSBpbnNlcnRUYWI7XG5leHBvcnRzLm1vdmVMaW5lRG93biA9IG1vdmVMaW5lRG93bjtcbmV4cG9ydHMubW92ZUxpbmVVcCA9IG1vdmVMaW5lVXA7XG5leHBvcnRzLnNlbGVjdEFsbCA9IHNlbGVjdEFsbDtcbmV4cG9ydHMuc2VsZWN0Q2hhckJhY2t3YXJkID0gc2VsZWN0Q2hhckJhY2t3YXJkO1xuZXhwb3J0cy5zZWxlY3RDaGFyRm9yd2FyZCA9IHNlbGVjdENoYXJGb3J3YXJkO1xuZXhwb3J0cy5zZWxlY3RDaGFyTGVmdCA9IHNlbGVjdENoYXJMZWZ0O1xuZXhwb3J0cy5zZWxlY3RDaGFyUmlnaHQgPSBzZWxlY3RDaGFyUmlnaHQ7XG5leHBvcnRzLnNlbGVjdERvY0VuZCA9IHNlbGVjdERvY0VuZDtcbmV4cG9ydHMuc2VsZWN0RG9jU3RhcnQgPSBzZWxlY3REb2NTdGFydDtcbmV4cG9ydHMuc2VsZWN0R3JvdXBCYWNrd2FyZCA9IHNlbGVjdEdyb3VwQmFja3dhcmQ7XG5leHBvcnRzLnNlbGVjdEdyb3VwRm9yd2FyZCA9IHNlbGVjdEdyb3VwRm9yd2FyZDtcbmV4cG9ydHMuc2VsZWN0R3JvdXBMZWZ0ID0gc2VsZWN0R3JvdXBMZWZ0O1xuZXhwb3J0cy5zZWxlY3RHcm91cFJpZ2h0ID0gc2VsZWN0R3JvdXBSaWdodDtcbmV4cG9ydHMuc2VsZWN0TGluZSA9IHNlbGVjdExpbmU7XG5leHBvcnRzLnNlbGVjdExpbmVCb3VuZGFyeUJhY2t3YXJkID0gc2VsZWN0TGluZUJvdW5kYXJ5QmFja3dhcmQ7XG5leHBvcnRzLnNlbGVjdExpbmVCb3VuZGFyeUZvcndhcmQgPSBzZWxlY3RMaW5lQm91bmRhcnlGb3J3YXJkO1xuZXhwb3J0cy5zZWxlY3RMaW5lRG93biA9IHNlbGVjdExpbmVEb3duO1xuZXhwb3J0cy5zZWxlY3RMaW5lRW5kID0gc2VsZWN0TGluZUVuZDtcbmV4cG9ydHMuc2VsZWN0TGluZVN0YXJ0ID0gc2VsZWN0TGluZVN0YXJ0O1xuZXhwb3J0cy5zZWxlY3RMaW5lVXAgPSBzZWxlY3RMaW5lVXA7XG5leHBvcnRzLnNlbGVjdE1hdGNoaW5nQnJhY2tldCA9IHNlbGVjdE1hdGNoaW5nQnJhY2tldDtcbmV4cG9ydHMuc2VsZWN0UGFnZURvd24gPSBzZWxlY3RQYWdlRG93bjtcbmV4cG9ydHMuc2VsZWN0UGFnZVVwID0gc2VsZWN0UGFnZVVwO1xuZXhwb3J0cy5zZWxlY3RQYXJlbnRTeW50YXggPSBzZWxlY3RQYXJlbnRTeW50YXg7XG5leHBvcnRzLnNlbGVjdFN5bnRheExlZnQgPSBzZWxlY3RTeW50YXhMZWZ0O1xuZXhwb3J0cy5zZWxlY3RTeW50YXhSaWdodCA9IHNlbGVjdFN5bnRheFJpZ2h0O1xuZXhwb3J0cy5zaW1wbGlmeVNlbGVjdGlvbiA9IHNpbXBsaWZ5U2VsZWN0aW9uO1xuZXhwb3J0cy5zcGxpdExpbmUgPSBzcGxpdExpbmU7XG5leHBvcnRzLnN0YW5kYXJkS2V5bWFwID0gc3RhbmRhcmRLZXltYXA7XG5leHBvcnRzLnRyYW5zcG9zZUNoYXJzID0gdHJhbnNwb3NlQ2hhcnM7XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBzdGF0ZSA9IHJlcXVpcmUoJ0Bjb2RlbWlycm9yL3N0YXRlJyk7XG5cbi8vLyBDb21tZW50IG9yIHVuY29tbWVudCB0aGUgY3VycmVudCBzZWxlY3Rpb24uIFdpbGwgdXNlIGxpbmUgY29tbWVudHNcbi8vLyBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBmYWxsaW5nIGJhY2sgdG8gYmxvY2sgY29tbWVudHMuXG5jb25zdCB0b2dnbGVDb21tZW50ID0gdGFyZ2V0ID0+IHtcbiAgICBsZXQgY29uZmlnID0gZ2V0Q29uZmlnKHRhcmdldC5zdGF0ZSk7XG4gICAgcmV0dXJuIGNvbmZpZy5saW5lID8gdG9nZ2xlTGluZUNvbW1lbnQodGFyZ2V0KSA6IGNvbmZpZy5ibG9jayA/IHRvZ2dsZUJsb2NrQ29tbWVudCh0YXJnZXQpIDogZmFsc2U7XG59O1xuZnVuY3Rpb24gY29tbWFuZChmLCBvcHRpb24pIHtcbiAgICByZXR1cm4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICAgICAgbGV0IHRyID0gZihvcHRpb24sIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMsIHN0YXRlKTtcbiAgICAgICAgaWYgKCF0cilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHRyKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vLy8gQ29tbWVudCBvciB1bmNvbW1lbnQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHVzaW5nIGxpbmUgY29tbWVudHMuXG4vLy8gVGhlIGxpbmUgY29tbWVudCBzeW50YXggaXMgdGFrZW4gZnJvbSB0aGVcbi8vLyBbYGNvbW1lbnRUb2tlbnNgXSgjY29tbWVudC5Db21tZW50VG9rZW5zKSBbbGFuZ3VhZ2Vcbi8vLyBkYXRhXSgjc3RhdGUuRWRpdG9yU3RhdGUubGFuZ3VhZ2VEYXRhQXQpLlxuY29uc3QgdG9nZ2xlTGluZUNvbW1lbnQgPSBjb21tYW5kKGNoYW5nZUxpbmVDb21tZW50LCAwIC8qIFRvZ2dsZSAqLyk7XG4vLy8gQ29tbWVudCB0aGUgY3VycmVudCBzZWxlY3Rpb24gdXNpbmcgbGluZSBjb21tZW50cy5cbmNvbnN0IGxpbmVDb21tZW50ID0gY29tbWFuZChjaGFuZ2VMaW5lQ29tbWVudCwgMSAvKiBDb21tZW50ICovKTtcbi8vLyBVbmNvbW1lbnQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHVzaW5nIGxpbmUgY29tbWVudHMuXG5jb25zdCBsaW5lVW5jb21tZW50ID0gY29tbWFuZChjaGFuZ2VMaW5lQ29tbWVudCwgMiAvKiBVbmNvbW1lbnQgKi8pO1xuLy8vIENvbW1lbnQgb3IgdW5jb21tZW50IHRoZSBjdXJyZW50IHNlbGVjdGlvbiB1c2luZyBibG9jayBjb21tZW50cy5cbi8vLyBUaGUgYmxvY2sgY29tbWVudCBzeW50YXggaXMgdGFrZW4gZnJvbSB0aGVcbi8vLyBbYGNvbW1lbnRUb2tlbnNgXSgjY29tbWVudC5Db21tZW50VG9rZW5zKSBbbGFuZ3VhZ2Vcbi8vLyBkYXRhXSgjc3RhdGUuRWRpdG9yU3RhdGUubGFuZ3VhZ2VEYXRhQXQpLlxuY29uc3QgdG9nZ2xlQmxvY2tDb21tZW50ID0gY29tbWFuZChjaGFuZ2VCbG9ja0NvbW1lbnQsIDAgLyogVG9nZ2xlICovKTtcbi8vLyBDb21tZW50IHRoZSBjdXJyZW50IHNlbGVjdGlvbiB1c2luZyBibG9jayBjb21tZW50cy5cbmNvbnN0IGJsb2NrQ29tbWVudCA9IGNvbW1hbmQoY2hhbmdlQmxvY2tDb21tZW50LCAxIC8qIENvbW1lbnQgKi8pO1xuLy8vIFVuY29tbWVudCB0aGUgY3VycmVudCBzZWxlY3Rpb24gdXNpbmcgYmxvY2sgY29tbWVudHMuXG5jb25zdCBibG9ja1VuY29tbWVudCA9IGNvbW1hbmQoY2hhbmdlQmxvY2tDb21tZW50LCAyIC8qIFVuY29tbWVudCAqLyk7XG4vLy8gRGVmYXVsdCBrZXkgYmluZGluZ3MgZm9yIHRoaXMgcGFja2FnZS5cbi8vL1xuLy8vICAtIEN0cmwtLyAoQ21kLS8gb24gbWFjT1MpOiBbYHRvZ2dsZUNvbW1lbnRgXSgjY29tbWVudC50b2dnbGVDb21tZW50KS5cbi8vLyAgLSBTaGlmdC1BbHQtYTogW2B0b2dnbGVCbG9ja0NvbW1lbnRgXSgjY29tbWVudC50b2dnbGVCbG9ja0NvbW1lbnQpLlxuY29uc3QgY29tbWVudEtleW1hcCA9IFtcbiAgICB7IGtleTogXCJNb2QtL1wiLCBydW46IHRvZ2dsZUNvbW1lbnQgfSxcbiAgICB7IGtleTogXCJBbHQtQVwiLCBydW46IHRvZ2dsZUJsb2NrQ29tbWVudCB9XG5dO1xuZnVuY3Rpb24gZ2V0Q29uZmlnKHN0YXRlLCBwb3MgPSBzdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKSB7XG4gICAgbGV0IGRhdGEgPSBzdGF0ZS5sYW5ndWFnZURhdGFBdChcImNvbW1lbnRUb2tlbnNcIiwgcG9zKTtcbiAgICByZXR1cm4gZGF0YS5sZW5ndGggPyBkYXRhWzBdIDoge307XG59XG5jb25zdCBTZWFyY2hNYXJnaW4gPSA1MDtcbi8vLyBEZXRlcm1pbmVzIGlmIHRoZSBnaXZlbiByYW5nZSBpcyBibG9jay1jb21tZW50ZWQgaW4gdGhlIGdpdmVuXG4vLy8gc3RhdGUuXG5mdW5jdGlvbiBmaW5kQmxvY2tDb21tZW50KHN0YXRlLCB7IG9wZW4sIGNsb3NlIH0sIGZyb20sIHRvKSB7XG4gICAgbGV0IHRleHRCZWZvcmUgPSBzdGF0ZS5zbGljZURvYyhmcm9tIC0gU2VhcmNoTWFyZ2luLCBmcm9tKTtcbiAgICBsZXQgdGV4dEFmdGVyID0gc3RhdGUuc2xpY2VEb2ModG8sIHRvICsgU2VhcmNoTWFyZ2luKTtcbiAgICBsZXQgc3BhY2VCZWZvcmUgPSAvXFxzKiQvLmV4ZWModGV4dEJlZm9yZSlbMF0ubGVuZ3RoLCBzcGFjZUFmdGVyID0gL15cXHMqLy5leGVjKHRleHRBZnRlcilbMF0ubGVuZ3RoO1xuICAgIGxldCBiZWZvcmVPZmYgPSB0ZXh0QmVmb3JlLmxlbmd0aCAtIHNwYWNlQmVmb3JlO1xuICAgIGlmICh0ZXh0QmVmb3JlLnNsaWNlKGJlZm9yZU9mZiAtIG9wZW4ubGVuZ3RoLCBiZWZvcmVPZmYpID09IG9wZW4gJiZcbiAgICAgICAgdGV4dEFmdGVyLnNsaWNlKHNwYWNlQWZ0ZXIsIHNwYWNlQWZ0ZXIgKyBjbG9zZS5sZW5ndGgpID09IGNsb3NlKSB7XG4gICAgICAgIHJldHVybiB7IG9wZW46IHsgcG9zOiBmcm9tIC0gc3BhY2VCZWZvcmUsIG1hcmdpbjogc3BhY2VCZWZvcmUgJiYgMSB9LFxuICAgICAgICAgICAgY2xvc2U6IHsgcG9zOiB0byArIHNwYWNlQWZ0ZXIsIG1hcmdpbjogc3BhY2VBZnRlciAmJiAxIH0gfTtcbiAgICB9XG4gICAgbGV0IHN0YXJ0VGV4dCwgZW5kVGV4dDtcbiAgICBpZiAodG8gLSBmcm9tIDw9IDIgKiBTZWFyY2hNYXJnaW4pIHtcbiAgICAgICAgc3RhcnRUZXh0ID0gZW5kVGV4dCA9IHN0YXRlLnNsaWNlRG9jKGZyb20sIHRvKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0YXJ0VGV4dCA9IHN0YXRlLnNsaWNlRG9jKGZyb20sIGZyb20gKyBTZWFyY2hNYXJnaW4pO1xuICAgICAgICBlbmRUZXh0ID0gc3RhdGUuc2xpY2VEb2ModG8gLSBTZWFyY2hNYXJnaW4sIHRvKTtcbiAgICB9XG4gICAgbGV0IHN0YXJ0U3BhY2UgPSAvXlxccyovLmV4ZWMoc3RhcnRUZXh0KVswXS5sZW5ndGgsIGVuZFNwYWNlID0gL1xccyokLy5leGVjKGVuZFRleHQpWzBdLmxlbmd0aDtcbiAgICBsZXQgZW5kT2ZmID0gZW5kVGV4dC5sZW5ndGggLSBlbmRTcGFjZSAtIGNsb3NlLmxlbmd0aDtcbiAgICBpZiAoc3RhcnRUZXh0LnNsaWNlKHN0YXJ0U3BhY2UsIHN0YXJ0U3BhY2UgKyBvcGVuLmxlbmd0aCkgPT0gb3BlbiAmJlxuICAgICAgICBlbmRUZXh0LnNsaWNlKGVuZE9mZiwgZW5kT2ZmICsgY2xvc2UubGVuZ3RoKSA9PSBjbG9zZSkge1xuICAgICAgICByZXR1cm4geyBvcGVuOiB7IHBvczogZnJvbSArIHN0YXJ0U3BhY2UgKyBvcGVuLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBtYXJnaW46IC9cXHMvLnRlc3Qoc3RhcnRUZXh0LmNoYXJBdChzdGFydFNwYWNlICsgb3Blbi5sZW5ndGgpKSA/IDEgOiAwIH0sXG4gICAgICAgICAgICBjbG9zZTogeyBwb3M6IHRvIC0gZW5kU3BhY2UgLSBjbG9zZS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAvXFxzLy50ZXN0KGVuZFRleHQuY2hhckF0KGVuZE9mZiAtIDEpKSA/IDEgOiAwIH0gfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vLyBQZXJmb3JtcyB0b2dnbGUsIGNvbW1lbnQgYW5kIHVuY29tbWVudCBvZiBibG9jayBjb21tZW50cyBpblxuLy8gbGFuZ3VhZ2VzIHRoYXQgc3VwcG9ydCB0aGVtLlxuZnVuY3Rpb24gY2hhbmdlQmxvY2tDb21tZW50KG9wdGlvbiwgcmFuZ2VzLCBzdGF0ZSQxKSB7XG4gICAgbGV0IHRva2VucyA9IHJhbmdlcy5tYXAociA9PiBnZXRDb25maWcoc3RhdGUkMSwgci5mcm9tKS5ibG9jayk7XG4gICAgaWYgKCF0b2tlbnMuZXZlcnkoYyA9PiBjKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGNvbW1lbnRzID0gcmFuZ2VzLm1hcCgociwgaSkgPT4gZmluZEJsb2NrQ29tbWVudChzdGF0ZSQxLCB0b2tlbnNbaV0sIHIuZnJvbSwgci50bykpO1xuICAgIGlmIChvcHRpb24gIT0gMiAvKiBVbmNvbW1lbnQgKi8gJiYgIWNvbW1lbnRzLmV2ZXJ5KGMgPT4gYykpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuIHN0YXRlJDEuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgICAgICBsZXQgeyBvcGVuLCBjbG9zZSB9ID0gdG9rZW5zW2luZGV4KytdO1xuICAgICAgICAgICAgaWYgKGNvbW1lbnRzW2luZGV4XSlcbiAgICAgICAgICAgICAgICByZXR1cm4geyByYW5nZSB9O1xuICAgICAgICAgICAgbGV0IHNoaWZ0ID0gb3Blbi5sZW5ndGggKyAxO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzOiBbeyBmcm9tOiByYW5nZS5mcm9tLCBpbnNlcnQ6IG9wZW4gKyBcIiBcIiB9LCB7IGZyb206IHJhbmdlLnRvLCBpbnNlcnQ6IFwiIFwiICsgY2xvc2UgfV0sXG4gICAgICAgICAgICAgICAgcmFuZ2U6IHN0YXRlLkVkaXRvclNlbGVjdGlvbi5yYW5nZShyYW5nZS5hbmNob3IgKyBzaGlmdCwgcmFuZ2UuaGVhZCArIHNoaWZ0KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wdGlvbiAhPSAxIC8qIENvbW1lbnQgKi8gJiYgY29tbWVudHMuc29tZShjID0+IGMpKSB7XG4gICAgICAgIGxldCBjaGFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBjb21tZW50OyBpIDwgY29tbWVudHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoY29tbWVudCA9IGNvbW1lbnRzW2ldKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRva2VuID0gdG9rZW5zW2ldLCB7IG9wZW4sIGNsb3NlIH0gPSBjb21tZW50O1xuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IG9wZW4ucG9zIC0gdG9rZW4ub3Blbi5sZW5ndGgsIHRvOiBvcGVuLnBvcyArIG9wZW4ubWFyZ2luIH0sIHsgZnJvbTogY2xvc2UucG9zIC0gY2xvc2UubWFyZ2luLCB0bzogY2xvc2UucG9zICsgdG9rZW4uY2xvc2UubGVuZ3RoIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBjaGFuZ2VzIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLy8gUGVyZm9ybXMgdG9nZ2xlLCBjb21tZW50IGFuZCB1bmNvbW1lbnQgb2YgbGluZSBjb21tZW50cy5cbmZ1bmN0aW9uIGNoYW5nZUxpbmVDb21tZW50KG9wdGlvbiwgcmFuZ2VzLCBzdGF0ZSkge1xuICAgIGxldCBsaW5lcyA9IFtdO1xuICAgIGxldCBwcmV2TGluZSA9IC0xO1xuICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiByYW5nZXMpIHtcbiAgICAgICAgbGV0IHN0YXJ0SSA9IGxpbmVzLmxlbmd0aCwgbWluSW5kZW50ID0gMWU5O1xuICAgICAgICBmb3IgKGxldCBwb3MgPSBmcm9tOyBwb3MgPD0gdG87KSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgICAgIGlmIChsaW5lLmZyb20gPiBwcmV2TGluZSAmJiAoZnJvbSA9PSB0byB8fCB0byA+IGxpbmUuZnJvbSkpIHtcbiAgICAgICAgICAgICAgICBwcmV2TGluZSA9IGxpbmUuZnJvbTtcbiAgICAgICAgICAgICAgICBsZXQgdG9rZW4gPSBnZXRDb25maWcoc3RhdGUsIHBvcykubGluZTtcbiAgICAgICAgICAgICAgICBpZiAoIXRva2VuKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBsZXQgaW5kZW50ID0gL15cXHMqLy5leGVjKGxpbmUudGV4dClbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxldCBjb21tZW50ID0gbGluZS50ZXh0LnNsaWNlKGluZGVudCwgaW5kZW50ICsgdG9rZW4ubGVuZ3RoKSA9PSB0b2tlbiA/IGluZGVudCA6IC0xO1xuICAgICAgICAgICAgICAgIGlmIChpbmRlbnQgPCBsaW5lLnRleHQubGVuZ3RoICYmIGluZGVudCA8IG1pbkluZGVudClcbiAgICAgICAgICAgICAgICAgICAgbWluSW5kZW50ID0gaW5kZW50O1xuICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goeyBsaW5lLCBjb21tZW50LCB0b2tlbiwgaW5kZW50LCBzaW5nbGU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zID0gbGluZS50byArIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbkluZGVudCA8IDFlOSlcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBzdGFydEk7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAobGluZXNbaV0uaW5kZW50IDwgbGluZXNbaV0ubGluZS50ZXh0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgbGluZXNbaV0uaW5kZW50ID0gbWluSW5kZW50O1xuICAgICAgICBpZiAobGluZXMubGVuZ3RoID09IHN0YXJ0SSArIDEpXG4gICAgICAgICAgICBsaW5lc1tzdGFydEldLnNpbmdsZSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChvcHRpb24gIT0gMSAvKiBDb21tZW50ICovICYmIGxpbmVzLnNvbWUobCA9PiBsLmNvbW1lbnQgPj0gMCkpIHtcbiAgICAgICAgbGV0IGNoYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgeyBsaW5lLCBjb21tZW50LCB0b2tlbiB9IG9mIGxpbmVzKVxuICAgICAgICAgICAgaWYgKGNvbW1lbnQgPj0gMCkge1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gbGluZS5mcm9tICsgY29tbWVudCwgdG8gPSBmcm9tICsgdG9rZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChsaW5lLnRleHRbdG8gLSBsaW5lLmZyb21dID09IFwiIFwiKVxuICAgICAgICAgICAgICAgICAgICB0bysrO1xuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb20sIHRvIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBjaGFuZ2VzIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wdGlvbiAhPSAyIC8qIFVuY29tbWVudCAqLyAmJiBsaW5lcy5zb21lKGwgPT4gbC5jb21tZW50IDwgMCkpIHtcbiAgICAgICAgbGV0IGNoYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgeyBsaW5lLCBjb21tZW50LCB0b2tlbiwgaW5kZW50LCBzaW5nbGUgfSBvZiBsaW5lcylcbiAgICAgICAgICAgIGlmIChjb21tZW50ICE9IGluZGVudCAmJiAoc2luZ2xlIHx8IC9cXFMvLnRlc3QobGluZS50ZXh0KSkpXG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogbGluZS5mcm9tICsgaW5kZW50LCBpbnNlcnQ6IHRva2VuICsgXCIgXCIgfSk7XG4gICAgICAgIGxldCBjaGFuZ2VTZXQgPSBzdGF0ZS5jaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiBjaGFuZ2VTZXQsIHNlbGVjdGlvbjogc3RhdGUuc2VsZWN0aW9uLm1hcChjaGFuZ2VTZXQsIDEpIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5leHBvcnRzLmJsb2NrQ29tbWVudCA9IGJsb2NrQ29tbWVudDtcbmV4cG9ydHMuYmxvY2tVbmNvbW1lbnQgPSBibG9ja1VuY29tbWVudDtcbmV4cG9ydHMuY29tbWVudEtleW1hcCA9IGNvbW1lbnRLZXltYXA7XG5leHBvcnRzLmxpbmVDb21tZW50ID0gbGluZUNvbW1lbnQ7XG5leHBvcnRzLmxpbmVVbmNvbW1lbnQgPSBsaW5lVW5jb21tZW50O1xuZXhwb3J0cy50b2dnbGVCbG9ja0NvbW1lbnQgPSB0b2dnbGVCbG9ja0NvbW1lbnQ7XG5leHBvcnRzLnRvZ2dsZUNvbW1lbnQgPSB0b2dnbGVDb21tZW50O1xuZXhwb3J0cy50b2dnbGVMaW5lQ29tbWVudCA9IHRvZ2dsZUxpbmVDb21tZW50O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgc3RhdGUgPSByZXF1aXJlKCdAY29kZW1pcnJvci9zdGF0ZScpO1xudmFyIHZpZXcgPSByZXF1aXJlKCdAY29kZW1pcnJvci92aWV3Jyk7XG52YXIgbGFuZ3VhZ2UgPSByZXF1aXJlKCdAY29kZW1pcnJvci9sYW5ndWFnZScpO1xudmFyIGd1dHRlciA9IHJlcXVpcmUoJ0Bjb2RlbWlycm9yL2d1dHRlcicpO1xudmFyIHJhbmdlc2V0ID0gcmVxdWlyZSgnQGNvZGVtaXJyb3IvcmFuZ2VzZXQnKTtcblxuZnVuY3Rpb24gbWFwUmFuZ2UocmFuZ2UsIG1hcHBpbmcpIHtcbiAgICBsZXQgZnJvbSA9IG1hcHBpbmcubWFwUG9zKHJhbmdlLmZyb20sIDEpLCB0byA9IG1hcHBpbmcubWFwUG9zKHJhbmdlLnRvLCAtMSk7XG4gICAgcmV0dXJuIGZyb20gPj0gdG8gPyB1bmRlZmluZWQgOiB7IGZyb20sIHRvIH07XG59XG5jb25zdCBmb2xkRWZmZWN0ID0gc3RhdGUuU3RhdGVFZmZlY3QuZGVmaW5lKHsgbWFwOiBtYXBSYW5nZSB9KTtcbmNvbnN0IHVuZm9sZEVmZmVjdCA9IHN0YXRlLlN0YXRlRWZmZWN0LmRlZmluZSh7IG1hcDogbWFwUmFuZ2UgfSk7XG5mdW5jdGlvbiBzZWxlY3RlZExpbmVzKHZpZXcpIHtcbiAgICBsZXQgbGluZXMgPSBbXTtcbiAgICBmb3IgKGxldCB7IGhlYWQgfSBvZiB2aWV3LnN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgaWYgKGxpbmVzLnNvbWUobCA9PiBsLmZyb20gPD0gaGVhZCAmJiBsLnRvID49IGhlYWQpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGxpbmVzLnB1c2godmlldy52aXN1YWxMaW5lQXQoaGVhZCkpO1xuICAgIH1cbiAgICByZXR1cm4gbGluZXM7XG59XG5jb25zdCBmb2xkU3RhdGUgPSBzdGF0ZS5TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkge1xuICAgICAgICByZXR1cm4gdmlldy5EZWNvcmF0aW9uLm5vbmU7XG4gICAgfSxcbiAgICB1cGRhdGUoZm9sZGVkLCB0cikge1xuICAgICAgICBmb2xkZWQgPSBmb2xkZWQubWFwKHRyLmNoYW5nZXMpO1xuICAgICAgICBmb3IgKGxldCBlIG9mIHRyLmVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlLmlzKGZvbGRFZmZlY3QpICYmICFmb2xkRXhpc3RzKGZvbGRlZCwgZS52YWx1ZS5mcm9tLCBlLnZhbHVlLnRvKSlcbiAgICAgICAgICAgICAgICBmb2xkZWQgPSBmb2xkZWQudXBkYXRlKHsgYWRkOiBbZm9sZFdpZGdldC5yYW5nZShlLnZhbHVlLmZyb20sIGUudmFsdWUudG8pXSB9KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGUuaXModW5mb2xkRWZmZWN0KSkge1xuICAgICAgICAgICAgICAgIGZvbGRlZCA9IGZvbGRlZC51cGRhdGUoeyBmaWx0ZXI6IChmcm9tLCB0bykgPT4gZS52YWx1ZS5mcm9tICE9IGZyb20gfHwgZS52YWx1ZS50byAhPSB0byxcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyRnJvbTogZS52YWx1ZS5mcm9tLCBmaWx0ZXJUbzogZS52YWx1ZS50byB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDbGVhciBmb2xkZWQgcmFuZ2VzIHRoYXQgY292ZXIgdGhlIHNlbGVjdGlvbiBoZWFkXG4gICAgICAgIGlmICh0ci5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGxldCBvblNlbGVjdGlvbiA9IGZhbHNlLCB7IGhlYWQgfSA9IHRyLnNlbGVjdGlvbi5tYWluO1xuICAgICAgICAgICAgZm9sZGVkLmJldHdlZW4oaGVhZCwgaGVhZCwgKGEsIGIpID0+IHsgaWYgKGEgPCBoZWFkICYmIGIgPiBoZWFkKVxuICAgICAgICAgICAgICAgIG9uU2VsZWN0aW9uID0gdHJ1ZTsgfSk7XG4gICAgICAgICAgICBpZiAob25TZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgZm9sZGVkID0gZm9sZGVkLnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlckZyb206IGhlYWQsXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlclRvOiBoZWFkLFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IChhLCBiKSA9PiBiIDw9IGhlYWQgfHwgYSA+PSBoZWFkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvbGRlZDtcbiAgICB9LFxuICAgIHByb3ZpZGU6IGYgPT4gdmlldy5FZGl0b3JWaWV3LmRlY29yYXRpb25zLmNvbXB1dGUoW2ZdLCBzID0+IHMuZmllbGQoZikpXG59KTtcbmZ1bmN0aW9uIGZvbGRJbnNpZGUoc3RhdGUsIGZyb20sIHRvKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBmb3VuZCA9IG51bGw7XG4gICAgKF9hID0gc3RhdGUuZmllbGQoZm9sZFN0YXRlLCBmYWxzZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5iZXR3ZWVuKGZyb20sIHRvLCAoZnJvbSwgdG8pID0+IHtcbiAgICAgICAgaWYgKCFmb3VuZCB8fCBmb3VuZC5mcm9tID4gZnJvbSlcbiAgICAgICAgICAgIGZvdW5kID0geyBmcm9tLCB0byB9O1xuICAgIH0pO1xuICAgIHJldHVybiBmb3VuZDtcbn1cbmZ1bmN0aW9uIGZvbGRFeGlzdHMoZm9sZGVkLCBmcm9tLCB0bykge1xuICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgIGZvbGRlZC5iZXR3ZWVuKGZyb20sIGZyb20sIChhLCBiKSA9PiB7IGlmIChhID09IGZyb20gJiYgYiA9PSB0bylcbiAgICAgICAgZm91bmQgPSB0cnVlOyB9KTtcbiAgICByZXR1cm4gZm91bmQ7XG59XG5mdW5jdGlvbiBtYXliZUVuYWJsZShzdGF0ZSQxLCBvdGhlcikge1xuICAgIHJldHVybiBzdGF0ZSQxLmZpZWxkKGZvbGRTdGF0ZSwgZmFsc2UpID8gb3RoZXIgOiBvdGhlci5jb25jYXQoc3RhdGUuU3RhdGVFZmZlY3QuYXBwZW5kQ29uZmlnLm9mKGNvZGVGb2xkaW5nKCkpKTtcbn1cbi8vLyBGb2xkIHRoZSBsaW5lcyB0aGF0IGFyZSBzZWxlY3RlZCwgaWYgcG9zc2libGUuXG5jb25zdCBmb2xkQ29kZSA9IHZpZXcgPT4ge1xuICAgIGZvciAobGV0IGxpbmUgb2Ygc2VsZWN0ZWRMaW5lcyh2aWV3KSkge1xuICAgICAgICBsZXQgcmFuZ2UgPSBsYW5ndWFnZS5mb2xkYWJsZSh2aWV3LnN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pO1xuICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBtYXliZUVuYWJsZSh2aWV3LnN0YXRlLCBbZm9sZEVmZmVjdC5vZihyYW5nZSksIGFubm91bmNlRm9sZCh2aWV3LCByYW5nZSldKSB9KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG4vLy8gVW5mb2xkIGZvbGRlZCByYW5nZXMgb24gc2VsZWN0ZWQgbGluZXMuXG5jb25zdCB1bmZvbGRDb2RlID0gdmlldyA9PiB7XG4gICAgaWYgKCF2aWV3LnN0YXRlLmZpZWxkKGZvbGRTdGF0ZSwgZmFsc2UpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGVmZmVjdHMgPSBbXTtcbiAgICBmb3IgKGxldCBsaW5lIG9mIHNlbGVjdGVkTGluZXModmlldykpIHtcbiAgICAgICAgbGV0IGZvbGRlZCA9IGZvbGRJbnNpZGUodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgaWYgKGZvbGRlZClcbiAgICAgICAgICAgIGVmZmVjdHMucHVzaCh1bmZvbGRFZmZlY3Qub2YoZm9sZGVkKSwgYW5ub3VuY2VGb2xkKHZpZXcsIGZvbGRlZCwgZmFsc2UpKTtcbiAgICB9XG4gICAgaWYgKGVmZmVjdHMubGVuZ3RoKVxuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0cyB9KTtcbiAgICByZXR1cm4gZWZmZWN0cy5sZW5ndGggPiAwO1xufTtcbmZ1bmN0aW9uIGFubm91bmNlRm9sZCh2aWV3JDEsIHJhbmdlLCBmb2xkID0gdHJ1ZSkge1xuICAgIGxldCBsaW5lRnJvbSA9IHZpZXckMS5zdGF0ZS5kb2MubGluZUF0KHJhbmdlLmZyb20pLm51bWJlciwgbGluZVRvID0gdmlldyQxLnN0YXRlLmRvYy5saW5lQXQocmFuZ2UudG8pLm51bWJlcjtcbiAgICByZXR1cm4gdmlldy5FZGl0b3JWaWV3LmFubm91bmNlLm9mKGAke3ZpZXckMS5zdGF0ZS5waHJhc2UoZm9sZCA/IFwiRm9sZGVkIGxpbmVzXCIgOiBcIlVuZm9sZGVkIGxpbmVzXCIpfSAke2xpbmVGcm9tfSAke3ZpZXckMS5zdGF0ZS5waHJhc2UoXCJ0b1wiKX0gJHtsaW5lVG99LmApO1xufVxuLy8vIEZvbGQgYWxsIHRvcC1sZXZlbCBmb2xkYWJsZSByYW5nZXMuXG5jb25zdCBmb2xkQWxsID0gdmlldyA9PiB7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIGVmZmVjdHMgPSBbXTtcbiAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBzdGF0ZS5kb2MubGVuZ3RoOykge1xuICAgICAgICBsZXQgbGluZSA9IHZpZXcudmlzdWFsTGluZUF0KHBvcyksIHJhbmdlID0gbGFuZ3VhZ2UuZm9sZGFibGUoc3RhdGUsIGxpbmUuZnJvbSwgbGluZS50byk7XG4gICAgICAgIGlmIChyYW5nZSlcbiAgICAgICAgICAgIGVmZmVjdHMucHVzaChmb2xkRWZmZWN0Lm9mKHJhbmdlKSk7XG4gICAgICAgIHBvcyA9IChyYW5nZSA/IHZpZXcudmlzdWFsTGluZUF0KHJhbmdlLnRvKSA6IGxpbmUpLnRvICsgMTtcbiAgICB9XG4gICAgaWYgKGVmZmVjdHMubGVuZ3RoKVxuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogbWF5YmVFbmFibGUodmlldy5zdGF0ZSwgZWZmZWN0cykgfSk7XG4gICAgcmV0dXJuICEhZWZmZWN0cy5sZW5ndGg7XG59O1xuLy8vIFVuZm9sZCBhbGwgZm9sZGVkIGNvZGUuXG5jb25zdCB1bmZvbGRBbGwgPSB2aWV3ID0+IHtcbiAgICBsZXQgZmllbGQgPSB2aWV3LnN0YXRlLmZpZWxkKGZvbGRTdGF0ZSwgZmFsc2UpO1xuICAgIGlmICghZmllbGQgfHwgIWZpZWxkLnNpemUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgZWZmZWN0cyA9IFtdO1xuICAgIGZpZWxkLmJldHdlZW4oMCwgdmlldy5zdGF0ZS5kb2MubGVuZ3RoLCAoZnJvbSwgdG8pID0+IHsgZWZmZWN0cy5wdXNoKHVuZm9sZEVmZmVjdC5vZih7IGZyb20sIHRvIH0pKTsgfSk7XG4gICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHMgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLy8vIERlZmF1bHQgZm9sZC1yZWxhdGVkIGtleSBiaW5kaW5ncy5cbi8vL1xuLy8vICAtIEN0cmwtU2hpZnQtWyAoQ21kLUFsdC1bIG9uIG1hY09TKTogW2Bmb2xkQ29kZWBdKCNmb2xkLmZvbGRDb2RlKS5cbi8vLyAgLSBDdHJsLVNoaWZ0LV0gKENtZC1BbHQtXSBvbiBtYWNPUyk6IFtgdW5mb2xkQ29kZWBdKCNmb2xkLnVuZm9sZENvZGUpLlxuLy8vICAtIEN0cmwtQWx0LVs6IFtgZm9sZEFsbGBdKCNmb2xkLmZvbGRBbGwpLlxuLy8vICAtIEN0cmwtQWx0LV06IFtgdW5mb2xkQWxsYF0oI2ZvbGQudW5mb2xkQWxsKS5cbmNvbnN0IGZvbGRLZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiQ3RybC1TaGlmdC1bXCIsIG1hYzogXCJDbWQtQWx0LVtcIiwgcnVuOiBmb2xkQ29kZSB9LFxuICAgIHsga2V5OiBcIkN0cmwtU2hpZnQtXVwiLCBtYWM6IFwiQ21kLUFsdC1dXCIsIHJ1bjogdW5mb2xkQ29kZSB9LFxuICAgIHsga2V5OiBcIkN0cmwtQWx0LVtcIiwgcnVuOiBmb2xkQWxsIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1BbHQtXVwiLCBydW46IHVuZm9sZEFsbCB9XG5dO1xuY29uc3QgZGVmYXVsdENvbmZpZyA9IHtcbiAgICBwbGFjZWhvbGRlckRPTTogbnVsbCxcbiAgICBwbGFjZWhvbGRlclRleHQ6IFwi4oCmXCJcbn07XG5jb25zdCBmb2xkQ29uZmlnID0gc3RhdGUuRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKHZhbHVlcykgeyByZXR1cm4gc3RhdGUuY29tYmluZUNvbmZpZyh2YWx1ZXMsIGRlZmF1bHRDb25maWcpOyB9XG59KTtcbi8vLyBDcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgY29uZmlndXJlcyBjb2RlIGZvbGRpbmcuXG5mdW5jdGlvbiBjb2RlRm9sZGluZyhjb25maWcpIHtcbiAgICBsZXQgcmVzdWx0ID0gW2ZvbGRTdGF0ZSwgYmFzZVRoZW1lXTtcbiAgICBpZiAoY29uZmlnKVxuICAgICAgICByZXN1bHQucHVzaChmb2xkQ29uZmlnLm9mKGNvbmZpZykpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBmb2xkV2lkZ2V0ID0gdmlldy5EZWNvcmF0aW9uLnJlcGxhY2UoeyB3aWRnZXQ6IG5ldyBjbGFzcyBleHRlbmRzIHZpZXcuV2lkZ2V0VHlwZSB7XG4gICAgICAgIGlnbm9yZUV2ZW50cygpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgIHRvRE9NKHZpZXcpIHtcbiAgICAgICAgICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCBjb25mID0gc3RhdGUuZmFjZXQoZm9sZENvbmZpZyk7XG4gICAgICAgICAgICBpZiAoY29uZi5wbGFjZWhvbGRlckRPTSlcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uZi5wbGFjZWhvbGRlckRPTSgpO1xuICAgICAgICAgICAgbGV0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgICAgIGVsZW1lbnQudGV4dENvbnRlbnQgPSBjb25mLnBsYWNlaG9sZGVyVGV4dDtcbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBzdGF0ZS5waHJhc2UoXCJmb2xkZWQgY29kZVwiKSk7XG4gICAgICAgICAgICBlbGVtZW50LnRpdGxlID0gc3RhdGUucGhyYXNlKFwidW5mb2xkXCIpO1xuICAgICAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBcImNtLWZvbGRQbGFjZWhvbGRlclwiO1xuICAgICAgICAgICAgZWxlbWVudC5vbmNsaWNrID0gZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBsaW5lID0gdmlldy52aXN1YWxMaW5lQXQodmlldy5wb3NBdERPTShldmVudC50YXJnZXQpKTtcbiAgICAgICAgICAgICAgICBsZXQgZm9sZGVkID0gZm9sZEluc2lkZSh2aWV3LnN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pO1xuICAgICAgICAgICAgICAgIGlmIChmb2xkZWQpXG4gICAgICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiB1bmZvbGRFZmZlY3Qub2YoZm9sZGVkKSB9KTtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICB9XG4gICAgfSB9KTtcbmNvbnN0IGZvbGRHdXR0ZXJEZWZhdWx0cyA9IHtcbiAgICBvcGVuVGV4dDogXCLijIRcIixcbiAgICBjbG9zZWRUZXh0OiBcIuKAulwiXG59O1xuY2xhc3MgRm9sZE1hcmtlciBleHRlbmRzIGd1dHRlci5HdXR0ZXJNYXJrZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZywgb3Blbikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5vcGVuID0gb3BlbjtcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIHRoaXMuY29uZmlnID09IG90aGVyLmNvbmZpZyAmJiB0aGlzLm9wZW4gPT0gb3RoZXIub3BlbjsgfVxuICAgIHRvRE9NKHZpZXcpIHtcbiAgICAgICAgbGV0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgc3Bhbi50ZXh0Q29udGVudCA9IHRoaXMub3BlbiA/IHRoaXMuY29uZmlnLm9wZW5UZXh0IDogdGhpcy5jb25maWcuY2xvc2VkVGV4dDtcbiAgICAgICAgc3Bhbi50aXRsZSA9IHZpZXcuc3RhdGUucGhyYXNlKHRoaXMub3BlbiA/IFwiRm9sZCBsaW5lXCIgOiBcIlVuZm9sZCBsaW5lXCIpO1xuICAgICAgICByZXR1cm4gc3BhbjtcbiAgICB9XG59XG4vLy8gQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IHJlZ2lzdGVycyBhIGZvbGQgZ3V0dGVyLCB3aGljaCBzaG93cyBhXG4vLy8gZm9sZCBzdGF0dXMgaW5kaWNhdG9yIGJlZm9yZSBmb2xkYWJsZSBsaW5lcyAod2hpY2ggY2FuIGJlIGNsaWNrZWRcbi8vLyB0byBmb2xkIG9yIHVuZm9sZCB0aGUgbGluZSkuXG5mdW5jdGlvbiBmb2xkR3V0dGVyKGNvbmZpZyA9IHt9KSB7XG4gICAgbGV0IGZ1bGxDb25maWcgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGZvbGRHdXR0ZXJEZWZhdWx0cyksIGNvbmZpZyk7XG4gICAgbGV0IGNhbkZvbGQgPSBuZXcgRm9sZE1hcmtlcihmdWxsQ29uZmlnLCB0cnVlKSwgY2FuVW5mb2xkID0gbmV3IEZvbGRNYXJrZXIoZnVsbENvbmZpZywgZmFsc2UpO1xuICAgIGxldCBtYXJrZXJzID0gdmlldy5WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMuZnJvbSA9IHZpZXcudmlld3BvcnQuZnJvbTtcbiAgICAgICAgICAgIHRoaXMubWFya2VycyA9IHJhbmdlc2V0LlJhbmdlU2V0Lm9mKHRoaXMuYnVpbGRNYXJrZXJzKHZpZXcpKTtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgICAgICBsZXQgZmlyc3RDaGFuZ2UgPSAtMTtcbiAgICAgICAgICAgIHVwZGF0ZS5jaGFuZ2VzLml0ZXJDaGFuZ2VkUmFuZ2VzKGZyb20gPT4geyBpZiAoZmlyc3RDaGFuZ2UgPCAwKVxuICAgICAgICAgICAgICAgIGZpcnN0Q2hhbmdlID0gZnJvbTsgfSk7XG4gICAgICAgICAgICBsZXQgZm9sZENoYW5nZSA9IHVwZGF0ZS5zdGFydFN0YXRlLmZpZWxkKGZvbGRTdGF0ZSwgZmFsc2UpICE9IHVwZGF0ZS5zdGF0ZS5maWVsZChmb2xkU3RhdGUsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmICghZm9sZENoYW5nZSAmJiB1cGRhdGUuZG9jQ2hhbmdlZCAmJiB1cGRhdGUudmlldy52aWV3cG9ydC5mcm9tID09IHRoaXMuZnJvbSAmJiBmaXJzdENoYW5nZSA+IHRoaXMuZnJvbSkge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IHVwZGF0ZS52aWV3LnZpc3VhbExpbmVBdChmaXJzdENoYW5nZSkuZnJvbTtcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtlcnMgPSB0aGlzLm1hcmtlcnMudXBkYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiAoKSA9PiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyRnJvbTogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIGFkZDogdGhpcy5idWlsZE1hcmtlcnModXBkYXRlLnZpZXcsIHN0YXJ0KVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZm9sZENoYW5nZSB8fCB1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUudmlld3BvcnRDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcm9tID0gdXBkYXRlLnZpZXcudmlld3BvcnQuZnJvbTtcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtlcnMgPSByYW5nZXNldC5SYW5nZVNldC5vZih0aGlzLmJ1aWxkTWFya2Vycyh1cGRhdGUudmlldykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJ1aWxkTWFya2Vycyh2aWV3LCBmcm9tID0gMCkge1xuICAgICAgICAgICAgbGV0IHJhbmdlcyA9IFtdO1xuICAgICAgICAgICAgdmlldy52aWV3cG9ydExpbmVzKGxpbmUgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChsaW5lLmZyb20gPj0gZnJvbSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWFyayA9IGZvbGRJbnNpZGUodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKSA/IGNhblVuZm9sZFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBsYW5ndWFnZS5mb2xkYWJsZSh2aWV3LnN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pID8gY2FuRm9sZCA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXJrKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2gobWFyay5yYW5nZShsaW5lLmZyb20pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByYW5nZXM7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gW1xuICAgICAgICBtYXJrZXJzLFxuICAgICAgICBndXR0ZXIuZ3V0dGVyKHtcbiAgICAgICAgICAgIGNsYXNzOiBcImNtLWZvbGRHdXR0ZXJcIixcbiAgICAgICAgICAgIG1hcmtlcnModmlldykgeyB2YXIgX2E7IHJldHVybiAoKF9hID0gdmlldy5wbHVnaW4obWFya2VycykpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXJrZXJzKSB8fCByYW5nZXNldC5SYW5nZVNldC5lbXB0eTsgfSxcbiAgICAgICAgICAgIGluaXRpYWxTcGFjZXIoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGb2xkTWFya2VyKGZ1bGxDb25maWcsIGZhbHNlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkb21FdmVudEhhbmRsZXJzOiB7XG4gICAgICAgICAgICAgICAgY2xpY2s6ICh2aWV3LCBsaW5lKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmb2xkZWQgPSBmb2xkSW5zaWRlKHZpZXcuc3RhdGUsIGxpbmUuZnJvbSwgbGluZS50byk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb2xkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiB1bmZvbGRFZmZlY3Qub2YoZm9sZGVkKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCByYW5nZSA9IGxhbmd1YWdlLmZvbGRhYmxlKHZpZXcuc3RhdGUsIGxpbmUuZnJvbSwgbGluZS50byk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IGZvbGRFZmZlY3Qub2YocmFuZ2UpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIGNvZGVGb2xkaW5nKClcbiAgICBdO1xufVxuY29uc3QgYmFzZVRoZW1lID0gdmlldy5FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCIuY20tZm9sZFBsYWNlaG9sZGVyXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNlZWVcIixcbiAgICAgICAgYm9yZGVyOiBcIjFweCBzb2xpZCAjZGRkXCIsXG4gICAgICAgIGNvbG9yOiBcIiM4ODhcIixcbiAgICAgICAgYm9yZGVyUmFkaXVzOiBcIi4yZW1cIixcbiAgICAgICAgbWFyZ2luOiBcIjAgMXB4XCIsXG4gICAgICAgIHBhZGRpbmc6IFwiMCAxcHhcIixcbiAgICAgICAgY3Vyc29yOiBcInBvaW50ZXJcIlxuICAgIH0sXG4gICAgXCIuY20tZm9sZEd1dHRlciAuY20tZ3V0dGVyRWxlbWVudFwiOiB7XG4gICAgICAgIHBhZGRpbmc6IFwiMCAxcHhcIixcbiAgICAgICAgY3Vyc29yOiBcInBvaW50ZXJcIlxuICAgIH1cbn0pO1xuXG5leHBvcnRzLmNvZGVGb2xkaW5nID0gY29kZUZvbGRpbmc7XG5leHBvcnRzLmZvbGRBbGwgPSBmb2xkQWxsO1xuZXhwb3J0cy5mb2xkQ29kZSA9IGZvbGRDb2RlO1xuZXhwb3J0cy5mb2xkR3V0dGVyID0gZm9sZEd1dHRlcjtcbmV4cG9ydHMuZm9sZEtleW1hcCA9IGZvbGRLZXltYXA7XG5leHBvcnRzLnVuZm9sZEFsbCA9IHVuZm9sZEFsbDtcbmV4cG9ydHMudW5mb2xkQ29kZSA9IHVuZm9sZENvZGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciB2aWV3ID0gcmVxdWlyZSgnQGNvZGVtaXJyb3IvdmlldycpO1xudmFyIHJhbmdlc2V0ID0gcmVxdWlyZSgnQGNvZGVtaXJyb3IvcmFuZ2VzZXQnKTtcbnZhciBzdGF0ZSA9IHJlcXVpcmUoJ0Bjb2RlbWlycm9yL3N0YXRlJyk7XG5cbi8qKlxuQSBndXR0ZXIgbWFya2VyIHJlcHJlc2VudHMgYSBiaXQgb2YgaW5mb3JtYXRpb24gYXR0YWNoZWQgdG8gYSBsaW5lXG5pbiBhIHNwZWNpZmljIGd1dHRlci4gWW91ciBvd24gY3VzdG9tIG1hcmtlcnMgaGF2ZSB0byBleHRlbmQgdGhpc1xuY2xhc3MuXG4qL1xuY2xhc3MgR3V0dGVyTWFya2VyIGV4dGVuZHMgcmFuZ2VzZXQuUmFuZ2VWYWx1ZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb21wYXJlKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8IHRoaXMuY29uc3RydWN0b3IgPT0gb3RoZXIuY29uc3RydWN0b3IgJiYgdGhpcy5lcShvdGhlcik7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlbmRlciB0aGUgRE9NIG5vZGUgZm9yIHRoaXMgbWFya2VyLCBpZiBhbnkuXG4gICAgKi9cbiAgICB0b0RPTShfdmlldykgeyByZXR1cm4gbnVsbDsgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHJhbmdlIHRoYXQgcGxhY2VzIHRoaXMgbWFya2VyIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGF0KHBvcykgeyByZXR1cm4gdGhpcy5yYW5nZShwb3MpOyB9XG59XG5HdXR0ZXJNYXJrZXIucHJvdG90eXBlLmVsZW1lbnRDbGFzcyA9IFwiXCI7XG5HdXR0ZXJNYXJrZXIucHJvdG90eXBlLm1hcE1vZGUgPSBzdGF0ZS5NYXBNb2RlLlRyYWNrQmVmb3JlO1xuY29uc3QgZGVmYXVsdHMgPSB7XG4gICAgY2xhc3M6IFwiXCIsXG4gICAgcmVuZGVyRW1wdHlFbGVtZW50czogZmFsc2UsXG4gICAgZWxlbWVudFN0eWxlOiBcIlwiLFxuICAgIG1hcmtlcnM6ICgpID0+IHJhbmdlc2V0LlJhbmdlU2V0LmVtcHR5LFxuICAgIGxpbmVNYXJrZXI6ICgpID0+IG51bGwsXG4gICAgaW5pdGlhbFNwYWNlcjogbnVsbCxcbiAgICB1cGRhdGVTcGFjZXI6IG51bGwsXG4gICAgZG9tRXZlbnRIYW5kbGVyczoge31cbn07XG5jb25zdCBhY3RpdmVHdXR0ZXJzID0gc3RhdGUuRmFjZXQuZGVmaW5lKCk7XG4vKipcbkRlZmluZSBhbiBlZGl0b3IgZ3V0dGVyLiBUaGUgb3JkZXIgaW4gd2hpY2ggdGhlIGd1dHRlcnMgYXBwZWFyIGlzXG5kZXRlcm1pbmVkIGJ5IHRoZWlyIGV4dGVuc2lvbiBwcmlvcml0eS5cbiovXG5mdW5jdGlvbiBndXR0ZXIoY29uZmlnKSB7XG4gICAgcmV0dXJuIFtndXR0ZXJzKCksIGFjdGl2ZUd1dHRlcnMub2YoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cyksIGNvbmZpZykpXTtcbn1cbmNvbnN0IGJhc2VUaGVtZSA9IHZpZXcuRWRpdG9yVmlldy5iYXNlVGhlbWUoe1xuICAgIFwiLmNtLWd1dHRlcnNcIjoge1xuICAgICAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICAgICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgekluZGV4OiAyMDBcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1ndXR0ZXJzXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNmNWY1ZjVcIixcbiAgICAgICAgY29sb3I6IFwiIzk5OVwiLFxuICAgICAgICBib3JkZXJSaWdodDogXCIxcHggc29saWQgI2RkZFwiXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS1ndXR0ZXJzXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiMzMzMzMzhcIixcbiAgICAgICAgY29sb3I6IFwiI2NjY1wiXG4gICAgfSxcbiAgICBcIi5jbS1ndXR0ZXJcIjoge1xuICAgICAgICBkaXNwbGF5OiBcImZsZXggIWltcG9ydGFudFwiLFxuICAgICAgICBmbGV4RGlyZWN0aW9uOiBcImNvbHVtblwiLFxuICAgICAgICBmbGV4U2hyaW5rOiAwLFxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIlxuICAgIH0sXG4gICAgXCIuY20tZ3V0dGVyRWxlbWVudFwiOiB7XG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCJcbiAgICB9LFxuICAgIFwiLmNtLWxpbmVOdW1iZXJzIC5jbS1ndXR0ZXJFbGVtZW50XCI6IHtcbiAgICAgICAgcGFkZGluZzogXCIwIDNweCAwIDVweFwiLFxuICAgICAgICBtaW5XaWR0aDogXCIyMHB4XCIsXG4gICAgICAgIHRleHRBbGlnbjogXCJyaWdodFwiLFxuICAgICAgICB3aGl0ZVNwYWNlOiBcIm5vd3JhcFwiXG4gICAgfVxufSk7XG5jb25zdCB1bmZpeEd1dHRlcnMgPSBzdGF0ZS5GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMuc29tZSh4ID0+IHgpXG59KTtcbi8qKlxuVGhlIGd1dHRlci1kcmF3aW5nIHBsdWdpbiBpcyBhdXRvbWF0aWNhbGx5IGVuYWJsZWQgd2hlbiB5b3UgYWRkIGFcbmd1dHRlciwgYnV0IHlvdSBjYW4gdXNlIHRoaXMgZnVuY3Rpb24gdG8gZXhwbGljaXRseSBjb25maWd1cmUgaXQuXG5cblVubGVzcyBgZml4ZWRgIGlzIGV4cGxpY2l0bHkgc2V0IHRvIGBmYWxzZWAsIHRoZSBndXR0ZXJzIGFyZVxuZml4ZWQsIG1lYW5pbmcgdGhleSBkb24ndCBzY3JvbGwgYWxvbmcgd2l0aCB0aGUgY29udGVudFxuaG9yaXpvbnRhbGx5IChleGNlcHQgb24gSW50ZXJuZXQgRXhwbG9yZXIsIHdoaWNoIGRvZXNuJ3Qgc3VwcG9ydFxuQ1NTIFtgcG9zaXRpb246XG5zdGlja3lgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvcG9zaXRpb24jc3RpY2t5KSkuXG4qL1xuZnVuY3Rpb24gZ3V0dGVycyhjb25maWcpIHtcbiAgICBsZXQgcmVzdWx0ID0gW1xuICAgICAgICBndXR0ZXJWaWV3LFxuICAgICAgICBiYXNlVGhlbWVcbiAgICBdO1xuICAgIGlmIChjb25maWcgJiYgY29uZmlnLmZpeGVkID09PSBmYWxzZSlcbiAgICAgICAgcmVzdWx0LnB1c2godW5maXhHdXR0ZXJzLm9mKHRydWUpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgZ3V0dGVyVmlldyA9IHZpZXcuVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmRvbS5jbGFzc05hbWUgPSBcImNtLWd1dHRlcnNcIjtcbiAgICAgICAgdGhpcy5kb20uc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgICAgICB0aGlzLmd1dHRlcnMgPSB2aWV3LnN0YXRlLmZhY2V0KGFjdGl2ZUd1dHRlcnMpLm1hcChjb25mID0+IG5ldyBTaW5nbGVHdXR0ZXJWaWV3KHZpZXcsIGNvbmYpKTtcbiAgICAgICAgZm9yIChsZXQgZ3V0dGVyIG9mIHRoaXMuZ3V0dGVycylcbiAgICAgICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKGd1dHRlci5kb20pO1xuICAgICAgICB0aGlzLmZpeGVkID0gIXZpZXcuc3RhdGUuZmFjZXQodW5maXhHdXR0ZXJzKTtcbiAgICAgICAgaWYgKHRoaXMuZml4ZWQpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FIElFMTEgZmFsbGJhY2ssIHdoaWNoIGRvZXNuJ3Qgc3VwcG9ydCBwb3NpdGlvbjogc3RpY2t5LFxuICAgICAgICAgICAgLy8gYnkgdXNpbmcgcG9zaXRpb246IHJlbGF0aXZlICsgZXZlbnQgaGFuZGxlcnMgdGhhdCByZWFsaWduIHRoZVxuICAgICAgICAgICAgLy8gZ3V0dGVyIChvciBqdXN0IGZvcmNlIGZpeGVkPWZhbHNlIG9uIElFMTE/KVxuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUucG9zaXRpb24gPSBcInN0aWNreVwiO1xuICAgICAgICB9XG4gICAgICAgIHZpZXcuc2Nyb2xsRE9NLmluc2VydEJlZm9yZSh0aGlzLmRvbSwgdmlldy5jb250ZW50RE9NKTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAoIXRoaXMudXBkYXRlR3V0dGVycyh1cGRhdGUpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgY29udGV4dHMgPSB0aGlzLmd1dHRlcnMubWFwKGd1dHRlciA9PiBuZXcgVXBkYXRlQ29udGV4dChndXR0ZXIsIHRoaXMudmlldy52aWV3cG9ydCkpO1xuICAgICAgICB0aGlzLnZpZXcudmlld3BvcnRMaW5lcyhsaW5lID0+IHtcbiAgICAgICAgICAgIGxldCB0ZXh0O1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobGluZS50eXBlKSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGIgb2YgbGluZS50eXBlKVxuICAgICAgICAgICAgICAgICAgICBpZiAoYi50eXBlID09IHZpZXcuQmxvY2tUeXBlLlRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSBiO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRleHQgPSBsaW5lLnR5cGUgPT0gdmlldy5CbG9ja1R5cGUuVGV4dCA/IGxpbmUgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRleHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgZm9yIChsZXQgY3ggb2YgY29udGV4dHMpXG4gICAgICAgICAgICAgICAgY3gubGluZSh0aGlzLnZpZXcsIHRleHQpO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgZm9yIChsZXQgY3ggb2YgY29udGV4dHMpXG4gICAgICAgICAgICBjeC5maW5pc2goKTtcbiAgICAgICAgdGhpcy5kb20uc3R5bGUubWluSGVpZ2h0ID0gdGhpcy52aWV3LmNvbnRlbnRIZWlnaHQgKyBcInB4XCI7XG4gICAgICAgIGlmICh1cGRhdGUuc3RhdGUuZmFjZXQodW5maXhHdXR0ZXJzKSAhPSAhdGhpcy5maXhlZCkge1xuICAgICAgICAgICAgdGhpcy5maXhlZCA9ICF0aGlzLmZpeGVkO1xuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUucG9zaXRpb24gPSB0aGlzLmZpeGVkID8gXCJzdGlja3lcIiA6IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlR3V0dGVycyh1cGRhdGUpIHtcbiAgICAgICAgbGV0IHByZXYgPSB1cGRhdGUuc3RhcnRTdGF0ZS5mYWNldChhY3RpdmVHdXR0ZXJzKSwgY3VyID0gdXBkYXRlLnN0YXRlLmZhY2V0KGFjdGl2ZUd1dHRlcnMpO1xuICAgICAgICBsZXQgY2hhbmdlID0gdXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLmhlaWdodENoYW5nZWQgfHwgdXBkYXRlLnZpZXdwb3J0Q2hhbmdlZDtcbiAgICAgICAgaWYgKHByZXYgPT0gY3VyKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBndXR0ZXIgb2YgdGhpcy5ndXR0ZXJzKVxuICAgICAgICAgICAgICAgIGlmIChndXR0ZXIudXBkYXRlKHVwZGF0ZSkpXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IGd1dHRlcnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGNvbmYgb2YgY3VyKSB7XG4gICAgICAgICAgICAgICAgbGV0IGtub3duID0gcHJldi5pbmRleE9mKGNvbmYpO1xuICAgICAgICAgICAgICAgIGlmIChrbm93biA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ3V0dGVycy5wdXNoKG5ldyBTaW5nbGVHdXR0ZXJWaWV3KHRoaXMudmlldywgY29uZikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ndXR0ZXJzW2tub3duXS51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgZ3V0dGVycy5wdXNoKHRoaXMuZ3V0dGVyc1trbm93bl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGcgb2YgdGhpcy5ndXR0ZXJzKVxuICAgICAgICAgICAgICAgIGcuZG9tLnJlbW92ZSgpO1xuICAgICAgICAgICAgZm9yIChsZXQgZyBvZiBndXR0ZXJzKVxuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKGcuZG9tKTtcbiAgICAgICAgICAgIHRoaXMuZ3V0dGVycyA9IGd1dHRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kb20ucmVtb3ZlKCk7XG4gICAgfVxufSwge1xuICAgIHByb3ZpZGU6IHZpZXcuUGx1Z2luRmllbGQuc2Nyb2xsTWFyZ2lucy5mcm9tKHZhbHVlID0+IHtcbiAgICAgICAgaWYgKHZhbHVlLmd1dHRlcnMubGVuZ3RoID09IDAgfHwgIXZhbHVlLmZpeGVkKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiB2YWx1ZS52aWV3LnRleHREaXJlY3Rpb24gPT0gdmlldy5EaXJlY3Rpb24uTFRSID8geyBsZWZ0OiB2YWx1ZS5kb20ub2Zmc2V0V2lkdGggfSA6IHsgcmlnaHQ6IHZhbHVlLmRvbS5vZmZzZXRXaWR0aCB9O1xuICAgIH0pXG59KTtcbmZ1bmN0aW9uIGFzQXJyYXkodmFsKSB7IHJldHVybiAoQXJyYXkuaXNBcnJheSh2YWwpID8gdmFsIDogW3ZhbF0pOyB9XG5jbGFzcyBVcGRhdGVDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3RvcihndXR0ZXIsIHZpZXdwb3J0KSB7XG4gICAgICAgIHRoaXMuZ3V0dGVyID0gZ3V0dGVyO1xuICAgICAgICB0aGlzLmxvY2FsTWFya2VycyA9IFtdO1xuICAgICAgICB0aGlzLmkgPSAwO1xuICAgICAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gcmFuZ2VzZXQuUmFuZ2VTZXQuaXRlcihndXR0ZXIubWFya2Vycywgdmlld3BvcnQuZnJvbSk7XG4gICAgfVxuICAgIGxpbmUodmlldywgbGluZSkge1xuICAgICAgICBpZiAodGhpcy5sb2NhbE1hcmtlcnMubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5sb2NhbE1hcmtlcnMgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMuY3Vyc29yLnZhbHVlICYmIHRoaXMuY3Vyc29yLmZyb20gPD0gbGluZS5mcm9tKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJzb3IuZnJvbSA9PSBsaW5lLmZyb20pXG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhbE1hcmtlcnMucHVzaCh0aGlzLmN1cnNvci52YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLmN1cnNvci5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZvckxpbmUgPSB0aGlzLmd1dHRlci5jb25maWcubGluZU1hcmtlcih2aWV3LCBsaW5lLCB0aGlzLmxvY2FsTWFya2Vycyk7XG4gICAgICAgIGlmIChmb3JMaW5lKVxuICAgICAgICAgICAgdGhpcy5sb2NhbE1hcmtlcnMudW5zaGlmdChmb3JMaW5lKTtcbiAgICAgICAgbGV0IGd1dHRlciA9IHRoaXMuZ3V0dGVyO1xuICAgICAgICBpZiAodGhpcy5sb2NhbE1hcmtlcnMubGVuZ3RoID09IDAgJiYgIWd1dHRlci5jb25maWcucmVuZGVyRW1wdHlFbGVtZW50cylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGFib3ZlID0gbGluZS50b3AgLSB0aGlzLmhlaWdodDtcbiAgICAgICAgaWYgKHRoaXMuaSA9PSBndXR0ZXIuZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgbmV3RWx0ID0gbmV3IEd1dHRlckVsZW1lbnQodmlldywgbGluZS5oZWlnaHQsIGFib3ZlLCB0aGlzLmxvY2FsTWFya2Vycyk7XG4gICAgICAgICAgICBndXR0ZXIuZWxlbWVudHMucHVzaChuZXdFbHQpO1xuICAgICAgICAgICAgZ3V0dGVyLmRvbS5hcHBlbmRDaGlsZChuZXdFbHQuZG9tKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBtYXJrZXJzID0gdGhpcy5sb2NhbE1hcmtlcnMsIGVsdCA9IGd1dHRlci5lbGVtZW50c1t0aGlzLmldO1xuICAgICAgICAgICAgaWYgKHNhbWVNYXJrZXJzKG1hcmtlcnMsIGVsdC5tYXJrZXJzKSkge1xuICAgICAgICAgICAgICAgIG1hcmtlcnMgPSBlbHQubWFya2VycztcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2FsTWFya2Vycy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWx0LnVwZGF0ZSh2aWV3LCBsaW5lLmhlaWdodCwgYWJvdmUsIG1hcmtlcnMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gbGluZS5ib3R0b207XG4gICAgICAgIHRoaXMuaSsrO1xuICAgIH1cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIGxldCBndXR0ZXIgPSB0aGlzLmd1dHRlcjtcbiAgICAgICAgd2hpbGUgKGd1dHRlci5lbGVtZW50cy5sZW5ndGggPiB0aGlzLmkpXG4gICAgICAgICAgICBndXR0ZXIuZG9tLnJlbW92ZUNoaWxkKGd1dHRlci5lbGVtZW50cy5wb3AoKS5kb20pO1xuICAgIH1cbn1cbmNsYXNzIFNpbmdsZUd1dHRlclZpZXcge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIGNvbmZpZykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5lbGVtZW50cyA9IFtdO1xuICAgICAgICB0aGlzLnNwYWNlciA9IG51bGw7XG4gICAgICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5kb20uY2xhc3NOYW1lID0gXCJjbS1ndXR0ZXJcIiArICh0aGlzLmNvbmZpZy5jbGFzcyA/IFwiIFwiICsgdGhpcy5jb25maWcuY2xhc3MgOiBcIlwiKTtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBjb25maWcuZG9tRXZlbnRIYW5kbGVycykge1xuICAgICAgICAgICAgdGhpcy5kb20uYWRkRXZlbnRMaXN0ZW5lcihwcm9wLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgbGluZSA9IHZpZXcudmlzdWFsTGluZUF0SGVpZ2h0KGV2ZW50LmNsaWVudFksIHZpZXcuY29udGVudERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3ApO1xuICAgICAgICAgICAgICAgIGlmIChjb25maWcuZG9tRXZlbnRIYW5kbGVyc1twcm9wXSh2aWV3LCBsaW5lLCBldmVudCkpXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hcmtlcnMgPSBhc0FycmF5KGNvbmZpZy5tYXJrZXJzKHZpZXcpKTtcbiAgICAgICAgaWYgKGNvbmZpZy5pbml0aWFsU3BhY2VyKSB7XG4gICAgICAgICAgICB0aGlzLnNwYWNlciA9IG5ldyBHdXR0ZXJFbGVtZW50KHZpZXcsIDAsIDAsIFtjb25maWcuaW5pdGlhbFNwYWNlcih2aWV3KV0pO1xuICAgICAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQodGhpcy5zcGFjZXIuZG9tKTtcbiAgICAgICAgICAgIHRoaXMuc3BhY2VyLmRvbS5zdHlsZS5jc3NUZXh0ICs9IFwidmlzaWJpbGl0eTogaGlkZGVuOyBwb2ludGVyLWV2ZW50czogbm9uZVwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IHByZXZNYXJrZXJzID0gdGhpcy5tYXJrZXJzO1xuICAgICAgICB0aGlzLm1hcmtlcnMgPSBhc0FycmF5KHRoaXMuY29uZmlnLm1hcmtlcnModXBkYXRlLnZpZXcpKTtcbiAgICAgICAgaWYgKHRoaXMuc3BhY2VyICYmIHRoaXMuY29uZmlnLnVwZGF0ZVNwYWNlcikge1xuICAgICAgICAgICAgbGV0IHVwZGF0ZWQgPSB0aGlzLmNvbmZpZy51cGRhdGVTcGFjZXIodGhpcy5zcGFjZXIubWFya2Vyc1swXSwgdXBkYXRlKTtcbiAgICAgICAgICAgIGlmICh1cGRhdGVkICE9IHRoaXMuc3BhY2VyLm1hcmtlcnNbMF0pXG4gICAgICAgICAgICAgICAgdGhpcy5zcGFjZXIudXBkYXRlKHVwZGF0ZS52aWV3LCAwLCAwLCBbdXBkYXRlZF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm1hcmtlcnMgIT0gcHJldk1hcmtlcnM7XG4gICAgfVxufVxuY2xhc3MgR3V0dGVyRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IodmlldywgaGVpZ2h0LCBhYm92ZSwgbWFya2Vycykge1xuICAgICAgICB0aGlzLmhlaWdodCA9IC0xO1xuICAgICAgICB0aGlzLmFib3ZlID0gMDtcbiAgICAgICAgdGhpcy5kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLnVwZGF0ZSh2aWV3LCBoZWlnaHQsIGFib3ZlLCBtYXJrZXJzKTtcbiAgICB9XG4gICAgdXBkYXRlKHZpZXcsIGhlaWdodCwgYWJvdmUsIG1hcmtlcnMpIHtcbiAgICAgICAgaWYgKHRoaXMuaGVpZ2h0ICE9IGhlaWdodClcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLmhlaWdodCA9ICh0aGlzLmhlaWdodCA9IGhlaWdodCkgKyBcInB4XCI7XG4gICAgICAgIGlmICh0aGlzLmFib3ZlICE9IGFib3ZlKVxuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUubWFyZ2luVG9wID0gKHRoaXMuYWJvdmUgPSBhYm92ZSkgPyBhYm92ZSArIFwicHhcIiA6IFwiXCI7XG4gICAgICAgIGlmICh0aGlzLm1hcmtlcnMgIT0gbWFya2Vycykge1xuICAgICAgICAgICAgdGhpcy5tYXJrZXJzID0gbWFya2VycztcbiAgICAgICAgICAgIGZvciAobGV0IGNoOyBjaCA9IHRoaXMuZG9tLmxhc3RDaGlsZDspXG4gICAgICAgICAgICAgICAgY2gucmVtb3ZlKCk7XG4gICAgICAgICAgICBsZXQgY2xzID0gXCJjbS1ndXR0ZXJFbGVtZW50XCI7XG4gICAgICAgICAgICBmb3IgKGxldCBtIG9mIG1hcmtlcnMpIHtcbiAgICAgICAgICAgICAgICBsZXQgZG9tID0gbS50b0RPTSh2aWV3KTtcbiAgICAgICAgICAgICAgICBpZiAoZG9tKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZChkb20pO1xuICAgICAgICAgICAgICAgIGxldCBjID0gbS5lbGVtZW50Q2xhc3M7XG4gICAgICAgICAgICAgICAgaWYgKGMpXG4gICAgICAgICAgICAgICAgICAgIGNscyArPSBcIiBcIiArIGM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRvbS5jbGFzc05hbWUgPSBjbHM7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBzYW1lTWFya2VycyhhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoIWFbaV0uY29tcGFyZShiW2ldKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuRmFjZXQgdXNlZCB0byBwcm92aWRlIG1hcmtlcnMgdG8gdGhlIGxpbmUgbnVtYmVyIGd1dHRlci5cbiovXG5jb25zdCBsaW5lTnVtYmVyTWFya2VycyA9IHN0YXRlLkZhY2V0LmRlZmluZSgpO1xuY29uc3QgbGluZU51bWJlckNvbmZpZyA9IHN0YXRlLkZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZSh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlLmNvbWJpbmVDb25maWcodmFsdWVzLCB7IGZvcm1hdE51bWJlcjogU3RyaW5nLCBkb21FdmVudEhhbmRsZXJzOiB7fSB9LCB7XG4gICAgICAgICAgICBkb21FdmVudEhhbmRsZXJzKGEsIGIpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbih7fSwgYSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZXZlbnQgaW4gYikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZXhpc3RzID0gcmVzdWx0W2V2ZW50XSwgYWRkID0gYltldmVudF07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtldmVudF0gPSBleGlzdHMgPyAodmlldywgbGluZSwgZXZlbnQpID0+IGV4aXN0cyh2aWV3LCBsaW5lLCBldmVudCkgfHwgYWRkKHZpZXcsIGxpbmUsIGV2ZW50KSA6IGFkZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5jbGFzcyBOdW1iZXJNYXJrZXIgZXh0ZW5kcyBHdXR0ZXJNYXJrZXIge1xuICAgIGNvbnN0cnVjdG9yKG51bWJlcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm51bWJlciA9IG51bWJlcjtcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIHRoaXMubnVtYmVyID09IG90aGVyLm51bWJlcjsgfVxuICAgIHRvRE9NKCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5udW1iZXIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZvcm1hdE51bWJlcih2aWV3LCBudW1iZXIpIHtcbiAgICByZXR1cm4gdmlldy5zdGF0ZS5mYWNldChsaW5lTnVtYmVyQ29uZmlnKS5mb3JtYXROdW1iZXIobnVtYmVyLCB2aWV3LnN0YXRlKTtcbn1cbmNvbnN0IGxpbmVOdW1iZXJHdXR0ZXIgPSBndXR0ZXIoe1xuICAgIGNsYXNzOiBcImNtLWxpbmVOdW1iZXJzXCIsXG4gICAgbWFya2Vycyh2aWV3KSB7IHJldHVybiB2aWV3LnN0YXRlLmZhY2V0KGxpbmVOdW1iZXJNYXJrZXJzKTsgfSxcbiAgICBsaW5lTWFya2VyKHZpZXcsIGxpbmUsIG90aGVycykge1xuICAgICAgICBpZiAob3RoZXJzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IE51bWJlck1hcmtlcihmb3JtYXROdW1iZXIodmlldywgdmlldy5zdGF0ZS5kb2MubGluZUF0KGxpbmUuZnJvbSkubnVtYmVyKSk7XG4gICAgfSxcbiAgICBpbml0aWFsU3BhY2VyKHZpZXcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXJNYXJrZXIoZm9ybWF0TnVtYmVyKHZpZXcsIG1heExpbmVOdW1iZXIodmlldy5zdGF0ZS5kb2MubGluZXMpKSk7XG4gICAgfSxcbiAgICB1cGRhdGVTcGFjZXIoc3BhY2VyLCB1cGRhdGUpIHtcbiAgICAgICAgbGV0IG1heCA9IGZvcm1hdE51bWJlcih1cGRhdGUudmlldywgbWF4TGluZU51bWJlcih1cGRhdGUudmlldy5zdGF0ZS5kb2MubGluZXMpKTtcbiAgICAgICAgcmV0dXJuIG1heCA9PSBzcGFjZXIubnVtYmVyID8gc3BhY2VyIDogbmV3IE51bWJlck1hcmtlcihtYXgpO1xuICAgIH1cbn0pO1xuLyoqXG5DcmVhdGUgYSBsaW5lIG51bWJlciBndXR0ZXIgZXh0ZW5zaW9uLlxuKi9cbmZ1bmN0aW9uIGxpbmVOdW1iZXJzKGNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgbGluZU51bWJlckNvbmZpZy5vZihjb25maWcpLFxuICAgICAgICBsaW5lTnVtYmVyR3V0dGVyXG4gICAgXTtcbn1cbmZ1bmN0aW9uIG1heExpbmVOdW1iZXIobGluZXMpIHtcbiAgICBsZXQgbGFzdCA9IDk7XG4gICAgd2hpbGUgKGxhc3QgPCBsaW5lcylcbiAgICAgICAgbGFzdCA9IGxhc3QgKiAxMCArIDk7XG4gICAgcmV0dXJuIGxhc3Q7XG59XG5cbmV4cG9ydHMuR3V0dGVyTWFya2VyID0gR3V0dGVyTWFya2VyO1xuZXhwb3J0cy5ndXR0ZXIgPSBndXR0ZXI7XG5leHBvcnRzLmd1dHRlcnMgPSBndXR0ZXJzO1xuZXhwb3J0cy5saW5lTnVtYmVyTWFya2VycyA9IGxpbmVOdW1iZXJNYXJrZXJzO1xuZXhwb3J0cy5saW5lTnVtYmVycyA9IGxpbmVOdW1iZXJzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgbGV6ZXJUcmVlID0gcmVxdWlyZSgnbGV6ZXItdHJlZScpO1xudmFyIHN0eWxlTW9kID0gcmVxdWlyZSgnc3R5bGUtbW9kJyk7XG52YXIgdmlldyA9IHJlcXVpcmUoJ0Bjb2RlbWlycm9yL3ZpZXcnKTtcbnZhciBzdGF0ZSA9IHJlcXVpcmUoJ0Bjb2RlbWlycm9yL3N0YXRlJyk7XG52YXIgbGFuZ3VhZ2UgPSByZXF1aXJlKCdAY29kZW1pcnJvci9sYW5ndWFnZScpO1xudmFyIHJhbmdlc2V0ID0gcmVxdWlyZSgnQGNvZGVtaXJyb3IvcmFuZ2VzZXQnKTtcblxubGV0IG5leHRUYWdJRCA9IDA7XG4vLy8gSGlnaGxpZ2h0aW5nIHRhZ3MgYXJlIG1hcmtlcnMgdGhhdCBkZW5vdGUgYSBoaWdobGlnaHRpbmcgY2F0ZWdvcnkuXG4vLy8gVGhleSBhcmUgW2Fzc29jaWF0ZWRdKCNoaWdobGlnaHQuc3R5bGVUYWdzKSB3aXRoIHBhcnRzIG9mIGEgc3ludGF4XG4vLy8gdHJlZSBieSBhIGxhbmd1YWdlIG1vZGUsIGFuZCB0aGVuIG1hcHBlZCB0byBhbiBhY3R1YWwgQ1NTIHN0eWxlIGJ5XG4vLy8gYSBbaGlnaGxpZ2h0IHN0eWxlXSgjaGlnaGxpZ2h0LkhpZ2hsaWdodFN0eWxlKS5cbi8vL1xuLy8vIEJlY2F1c2Ugc3ludGF4IHRyZWUgbm9kZSB0eXBlcyBhbmQgaGlnaGxpZ2h0IHN0eWxlcyBoYXZlIHRvIGJlXG4vLy8gYWJsZSB0byB0YWxrIHRoZSBzYW1lIGxhbmd1YWdlLCBDb2RlTWlycm9yIHVzZXMgYSBtb3N0bHkgX2Nsb3NlZF9cbi8vLyBbdm9jYWJ1bGFyeV0oI2hpZ2hsaWdodC50YWdzKSBvZiBzeW50YXggdGFncyAoYXMgb3Bwb3NlZCB0b1xuLy8vIHRyYWRpdGlvbmFsIG9wZW4gc3RyaW5nLWJhc2VkIHN5c3RlbXMsIHdoaWNoIG1ha2UgaXQgaGFyZCBmb3Jcbi8vLyBoaWdobGlnaHRpbmcgdGhlbWVzIHRvIGNvdmVyIGFsbCB0aGUgdG9rZW5zIHByb2R1Y2VkIGJ5IHRoZVxuLy8vIHZhcmlvdXMgbGFuZ3VhZ2VzKS5cbi8vL1xuLy8vIEl0IF9pc18gcG9zc2libGUgdG8gW2RlZmluZV0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lKSB5b3VyIG93blxuLy8vIGhpZ2hsaWdodGluZyB0YWdzIGZvciBzeXN0ZW0taW50ZXJuYWwgdXNlICh3aGVyZSB5b3UgY29udHJvbCBib3RoXG4vLy8gdGhlIGxhbmd1YWdlIHBhY2thZ2UgYW5kIHRoZSBoaWdobGlnaHRlciksIGJ1dCBzdWNoIHRhZ3Mgd2lsbCBub3Rcbi8vLyBiZSBwaWNrZWQgdXAgYnkgcmVndWxhciBoaWdobGlnaHRlcnMgKHRob3VnaCB5b3UgY2FuIGRlcml2ZSB0aGVtXG4vLy8gZnJvbSBzdGFuZGFyZCB0YWdzIHRvIGFsbG93IGhpZ2hsaWdodGVycyB0byBmYWxsIGJhY2sgdG8gdGhvc2UpLlxuY2xhc3MgVGFnIHtcbiAgICAvLy8gQGludGVybmFsXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIFRoZSBzZXQgb2YgdGFncyB0aGF0IG1hdGNoIHRoaXMgdGFnLCBzdGFydGluZyB3aXRoIHRoaXMgb25lXG4gICAgLy8vIGl0c2VsZiwgc29ydGVkIGluIG9yZGVyIG9mIGRlY3JlYXNpbmcgc3BlY2lmaWNpdHkuIEBpbnRlcm5hbFxuICAgIHNldCwgXG4gICAgLy8vIFRoZSBiYXNlIHVubW9kaWZpZWQgdGFnIHRoYXQgdGhpcyBvbmUgaXMgYmFzZWQgb24sIGlmIGl0J3NcbiAgICAvLy8gbW9kaWZpZWQgQGludGVybmFsXG4gICAgYmFzZSwgXG4gICAgLy8vIFRoZSBtb2RpZmllcnMgYXBwbGllZCB0byB0aGlzLmJhc2UgQGludGVybmFsXG4gICAgbW9kaWZpZWQpIHtcbiAgICAgICAgdGhpcy5zZXQgPSBzZXQ7XG4gICAgICAgIHRoaXMuYmFzZSA9IGJhc2U7XG4gICAgICAgIHRoaXMubW9kaWZpZWQgPSBtb2RpZmllZDtcbiAgICAgICAgLy8vIEBpbnRlcm5hbFxuICAgICAgICB0aGlzLmlkID0gbmV4dFRhZ0lEKys7XG4gICAgfVxuICAgIC8vLyBEZWZpbmUgYSBuZXcgdGFnLiBJZiBgcGFyZW50YCBpcyBnaXZlbiwgdGhlIHRhZyBpcyB0cmVhdGVkIGFzIGFcbiAgICAvLy8gc3ViLXRhZyBvZiB0aGF0IHBhcmVudCwgYW5kIFtoaWdobGlnaHRcbiAgICAvLy8gc3R5bGVzXSgjaGlnaGxpZ2h0LkhpZ2hsaWdodFN0eWxlKSB0aGF0IGRvbid0IG1lbnRpb24gdGhpcyB0YWdcbiAgICAvLy8gd2lsbCB0cnkgdG8gZmFsbCBiYWNrIHRvIHRoZSBwYXJlbnQgdGFnIChvciBncmFuZHBhcmVudCB0YWcsXG4gICAgLy8vIGV0YykuXG4gICAgc3RhdGljIGRlZmluZShwYXJlbnQpIHtcbiAgICAgICAgaWYgKHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5iYXNlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBkZXJpdmUgZnJvbSBhIG1vZGlmaWVkIHRhZ1wiKTtcbiAgICAgICAgbGV0IHRhZyA9IG5ldyBUYWcoW10sIG51bGwsIFtdKTtcbiAgICAgICAgdGFnLnNldC5wdXNoKHRhZyk7XG4gICAgICAgIGlmIChwYXJlbnQpXG4gICAgICAgICAgICBmb3IgKGxldCB0IG9mIHBhcmVudC5zZXQpXG4gICAgICAgICAgICAgICAgdGFnLnNldC5wdXNoKHQpO1xuICAgICAgICByZXR1cm4gdGFnO1xuICAgIH1cbiAgICAvLy8gRGVmaW5lIGEgdGFnIF9tb2RpZmllcl8sIHdoaWNoIGlzIGEgZnVuY3Rpb24gdGhhdCwgZ2l2ZW4gYSB0YWcsXG4gICAgLy8vIHdpbGwgcmV0dXJuIGEgdGFnIHRoYXQgaXMgYSBzdWJ0YWcgb2YgdGhlIG9yaWdpbmFsLiBBcHBseWluZyB0aGVcbiAgICAvLy8gc2FtZSBtb2RpZmllciB0byBhIHR3aWNlIHRhZyB3aWxsIHJldHVybiB0aGUgc2FtZSB2YWx1ZSAoYG0xKHQxKVxuICAgIC8vLyA9PSBtMSh0MSlgKSBhbmQgYXBwbHlpbmcgbXVsdGlwbGUgbW9kaWZpZXJzIHdpbGwsIHJlZ2FyZGxlc3Mgb3JcbiAgICAvLy8gb3JkZXIsIHByb2R1Y2UgdGhlIHNhbWUgdGFnIChgbTEobTIodDEpKSA9PSBtMihtMSh0MSkpYCkuXG4gICAgLy8vXG4gICAgLy8vIFdoZW4gbXVsdGlwbGUgbW9kaWZpZXJzIGFyZSBhcHBsaWVkIHRvIGEgZ2l2ZW4gYmFzZSB0YWcsIGVhY2hcbiAgICAvLy8gc21hbGxlciBzZXQgb2YgbW9kaWZpZXJzIGlzIHJlZ2lzdGVyZWQgYXMgYSBwYXJlbnQsIHNvIHRoYXQgZm9yXG4gICAgLy8vIGV4YW1wbGUgYG0xKG0yKG0zKHQxKSkpYCBpcyBhIHN1YnR5cGUgb2YgYG0xKG0yKHQxKSlgLFxuICAgIC8vLyBgbTEobTModDEpYCwgYW5kIHNvIG9uLlxuICAgIHN0YXRpYyBkZWZpbmVNb2RpZmllcigpIHtcbiAgICAgICAgbGV0IG1vZCA9IG5ldyBNb2RpZmllcjtcbiAgICAgICAgcmV0dXJuICh0YWcpID0+IHtcbiAgICAgICAgICAgIGlmICh0YWcubW9kaWZpZWQuaW5kZXhPZihtb2QpID4gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhZztcbiAgICAgICAgICAgIHJldHVybiBNb2RpZmllci5nZXQodGFnLmJhc2UgfHwgdGFnLCB0YWcubW9kaWZpZWQuY29uY2F0KG1vZCkuc29ydCgoYSwgYikgPT4gYS5pZCAtIGIuaWQpKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5sZXQgbmV4dE1vZGlmaWVySUQgPSAwO1xuY2xhc3MgTW9kaWZpZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmluc3RhbmNlcyA9IFtdO1xuICAgICAgICB0aGlzLmlkID0gbmV4dE1vZGlmaWVySUQrKztcbiAgICB9XG4gICAgc3RhdGljIGdldChiYXNlLCBtb2RzKSB7XG4gICAgICAgIGlmICghbW9kcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgICAgbGV0IGV4aXN0cyA9IG1vZHNbMF0uaW5zdGFuY2VzLmZpbmQodCA9PiB0LmJhc2UgPT0gYmFzZSAmJiBzYW1lQXJyYXkobW9kcywgdC5tb2RpZmllZCkpO1xuICAgICAgICBpZiAoZXhpc3RzKVxuICAgICAgICAgICAgcmV0dXJuIGV4aXN0cztcbiAgICAgICAgbGV0IHNldCA9IFtdLCB0YWcgPSBuZXcgVGFnKHNldCwgYmFzZSwgbW9kcyk7XG4gICAgICAgIGZvciAobGV0IG0gb2YgbW9kcylcbiAgICAgICAgICAgIG0uaW5zdGFuY2VzLnB1c2godGFnKTtcbiAgICAgICAgbGV0IGNvbmZpZ3MgPSBwZXJtdXRlKG1vZHMpO1xuICAgICAgICBmb3IgKGxldCBwYXJlbnQgb2YgYmFzZS5zZXQpXG4gICAgICAgICAgICBmb3IgKGxldCBjb25maWcgb2YgY29uZmlncylcbiAgICAgICAgICAgICAgICBzZXQucHVzaChNb2RpZmllci5nZXQocGFyZW50LCBjb25maWcpKTtcbiAgICAgICAgcmV0dXJuIHRhZztcbiAgICB9XG59XG5mdW5jdGlvbiBzYW1lQXJyYXkoYSwgYikge1xuICAgIHJldHVybiBhLmxlbmd0aCA9PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KCh4LCBpKSA9PiB4ID09IGJbaV0pO1xufVxuZnVuY3Rpb24gcGVybXV0ZShhcnJheSkge1xuICAgIGxldCByZXN1bHQgPSBbYXJyYXldO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yIChsZXQgYSBvZiBwZXJtdXRlKGFycmF5LnNsaWNlKDAsIGkpLmNvbmNhdChhcnJheS5zbGljZShpICsgMSkpKSlcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGEpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBhZGQgYSBzZXQgb2YgdGFncyB0byBhIGxhbmd1YWdlIHN5bnRheFxuLy8vIHZpYVxuLy8vIFtgUGFyc2VyLmNvbmZpZ3VyZWBdKGh0dHBzOi8vbGV6ZXIuY29kZW1pcnJvci5uZXQvZG9jcy9yZWYjbGV6ZXIuUGFyc2VyLmNvbmZpZ3VyZSkuXG4vLy9cbi8vLyBUaGUgYXJndW1lbnQgb2JqZWN0IG1hcHMgbm9kZSBzZWxlY3RvcnMgdG8gW2hpZ2hsaWdodGluZ1xuLy8vIHRhZ3NdKCNoaWdobGlnaHQuVGFnKSBvciBhcnJheXMgb2YgdGFncy5cbi8vL1xuLy8vIE5vZGUgc2VsZWN0b3JzIG1heSBob2xkIG9uZSBvciBtb3JlIChzcGFjZS1zZXBhcmF0ZWQpIG5vZGUgcGF0aHMuXG4vLy8gU3VjaCBhIHBhdGggY2FuIGJlIGEgW25vZGVcbi8vLyBuYW1lXShodHRwczovL2xlemVyLmNvZGVtaXJyb3IubmV0L2RvY3MvcmVmI3RyZWUuTm9kZVR5cGUubmFtZSksXG4vLy8gb3IgbXVsdGlwbGUgbm9kZSBuYW1lcyAob3IgYCpgIHdpbGRjYXJkcykgc2VwYXJhdGVkIGJ5IHNsYXNoXG4vLy8gY2hhcmFjdGVycywgYXMgaW4gYFwiQmxvY2svRGVjbGFyYXRpb24vVmFyaWFibGVOYW1lXCJgLiBTdWNoIGEgcGF0aFxuLy8vIG1hdGNoZXMgdGhlIGZpbmFsIG5vZGUgYnV0IG9ubHkgaWYgaXRzIGRpcmVjdCBwYXJlbnQgbm9kZXMgYXJlIHRoZVxuLy8vIG90aGVyIG5vZGVzIG1lbnRpb25lZC4gQSBgKmAgaW4gc3VjaCBhIHBhdGggbWF0Y2hlcyBhbnkgcGFyZW50LFxuLy8vIGJ1dCBvbmx5IGEgc2luZ2xlIGxldmVs4oCUd2lsZGNhcmRzIHRoYXQgbWF0Y2ggbXVsdGlwbGUgcGFyZW50c1xuLy8vIGFyZW4ndCBzdXBwb3J0ZWQsIGJvdGggZm9yIGVmZmljaWVuY3kgcmVhc29ucyBhbmQgYmVjYXVzZSBMZXplclxuLy8vIHRyZWVzIG1ha2UgaXQgcmF0aGVyIGhhcmQgdG8gcmVhc29uIGFib3V0IHdoYXQgdGhleSB3b3VsZCBtYXRjaC4pXG4vLy9cbi8vLyBBIHBhdGggY2FuIGJlIGVuZGVkIHdpdGggYC8uLi5gIHRvIGluZGljYXRlIHRoYXQgdGhlIHRhZyBhc3NpZ25lZFxuLy8vIHRvIHRoZSBub2RlIHNob3VsZCBhbHNvIGFwcGx5IHRvIGFsbCBjaGlsZCBub2RlcywgZXZlbiBpZiB0aGV5XG4vLy8gbWF0Y2ggdGhlaXIgb3duIHN0eWxlIChieSBkZWZhdWx0LCBvbmx5IHRoZSBpbm5lcm1vc3Qgc3R5bGUgaXNcbi8vLyB1c2VkKS5cbi8vL1xuLy8vIFdoZW4gYSBwYXRoIGVuZHMgaW4gYCFgLCBhcyBpbiBgQXR0cmlidXRlIWAsIG5vIGZ1cnRoZXIgbWF0Y2hpbmdcbi8vLyBoYXBwZW5zIGZvciB0aGUgbm9kZSdzIGNoaWxkIG5vZGVzLCBhbmQgdGhlIGVudGlyZSBub2RlIGdldHMgdGhlXG4vLy8gZ2l2ZW4gc3R5bGUuXG4vLy9cbi8vLyBJbiB0aGlzIG5vdGF0aW9uLCBub2RlIG5hbWVzIHRoYXQgY29udGFpbiBgL2AsIGAhYCwgYCpgLCBvciBgLi4uYFxuLy8vIG11c3QgYmUgcXVvdGVkIGFzIEpTT04gc3RyaW5ncy5cbi8vL1xuLy8vIEZvciBleGFtcGxlOlxuLy8vXG4vLy8gYGBgamF2YXNjcmlwdFxuLy8vIHBhcnNlci53aXRoUHJvcHMoXG4vLy8gICBzdHlsZVRhZ3Moe1xuLy8vICAgICAvLyBTdHlsZSBOdW1iZXIgYW5kIEJpZ051bWJlciBub2Rlc1xuLy8vICAgICBcIk51bWJlciBCaWdOdW1iZXJcIjogdGFncy5udW1iZXIsXG4vLy8gICAgIC8vIFN0eWxlIEVzY2FwZSBub2RlcyB3aG9zZSBwYXJlbnQgaXMgU3RyaW5nXG4vLy8gICAgIFwiU3RyaW5nL0VzY2FwZVwiOiB0YWdzLmVzY2FwZSxcbi8vLyAgICAgLy8gU3R5bGUgYW55dGhpbmcgaW5zaWRlIEF0dHJpYnV0ZXMgbm9kZXNcbi8vLyAgICAgXCJBdHRyaWJ1dGVzIVwiOiB0YWdzLm1ldGEsXG4vLy8gICAgIC8vIEFkZCBhIHN0eWxlIHRvIGFsbCBjb250ZW50IGluc2lkZSBJdGFsaWMgbm9kZXNcbi8vLyAgICAgXCJJdGFsaWMvLi4uXCI6IHRhZ3MuZW1waGFzaXMsXG4vLy8gICAgIC8vIFN0eWxlIEludmFsaWRTdHJpbmcgbm9kZXMgYXMgYm90aCBgc3RyaW5nYCBhbmQgYGludmFsaWRgXG4vLy8gICAgIFwiSW52YWxpZFN0cmluZ1wiOiBbdGFncy5zdHJpbmcsIHRhZ3MuaW52YWxpZF0sXG4vLy8gICAgIC8vIFN0eWxlIHRoZSBub2RlIG5hbWVkIFwiL1wiIGFzIHB1bmN0dWF0aW9uXG4vLy8gICAgICdcIi9cIic6IHRhZ3MucHVuY3R1YXRpb25cbi8vLyAgIH0pXG4vLy8gKVxuLy8vIGBgYFxuZnVuY3Rpb24gc3R5bGVUYWdzKHNwZWMpIHtcbiAgICBsZXQgYnlOYW1lID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGxldCBwcm9wIGluIHNwZWMpIHtcbiAgICAgICAgbGV0IHRhZ3MgPSBzcGVjW3Byb3BdO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGFncykpXG4gICAgICAgICAgICB0YWdzID0gW3RhZ3NdO1xuICAgICAgICBmb3IgKGxldCBwYXJ0IG9mIHByb3Auc3BsaXQoXCIgXCIpKVxuICAgICAgICAgICAgaWYgKHBhcnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgcGllY2VzID0gW10sIG1vZGUgPSAyIC8qIE5vcm1hbCAqLywgcmVzdCA9IHBhcnQ7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcG9zID0gMDs7KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN0ID09IFwiLi4uXCIgJiYgcG9zID4gMCAmJiBwb3MgKyAzID09IHBhcnQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlID0gMSAvKiBJbmhlcml0ICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IG0gPSAvXlwiKD86W15cIlxcXFxdfFxcXFwuKSo/XCJ8W15cXC8hXSsvLmV4ZWMocmVzdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBwYXRoOiBcIiArIHBhcnQpO1xuICAgICAgICAgICAgICAgICAgICBwaWVjZXMucHVzaChtWzBdID09IFwiKlwiID8gbnVsbCA6IG1bMF1bMF0gPT0gJ1wiJyA/IEpTT04ucGFyc2UobVswXSkgOiBtWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgcG9zICs9IG1bMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zID09IHBhcnQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gcGFydFtwb3MrK107XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPT0gcGFydC5sZW5ndGggJiYgbmV4dCA9PSBcIiFcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9IDAgLyogT3BhcXVlICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgIT0gXCIvXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgcGF0aDogXCIgKyBwYXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdCA9IHBhcnQuc2xpY2UocG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGxhc3QgPSBwaWVjZXMubGVuZ3RoIC0gMSwgaW5uZXIgPSBwaWVjZXNbbGFzdF07XG4gICAgICAgICAgICAgICAgaWYgKCFpbm5lcilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHBhdGg6IFwiICsgcGFydCk7XG4gICAgICAgICAgICAgICAgbGV0IHJ1bGUgPSBuZXcgUnVsZSh0YWdzLCBtb2RlLCBsYXN0ID4gMCA/IHBpZWNlcy5zbGljZSgwLCBsYXN0KSA6IG51bGwpO1xuICAgICAgICAgICAgICAgIGJ5TmFtZVtpbm5lcl0gPSBydWxlLnNvcnQoYnlOYW1lW2lubmVyXSk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBydWxlTm9kZVByb3AuYWRkKGJ5TmFtZSk7XG59XG5jb25zdCBydWxlTm9kZVByb3AgPSBuZXcgbGV6ZXJUcmVlLk5vZGVQcm9wKCk7XG5jb25zdCBoaWdobGlnaHRTdHlsZSA9IHN0YXRlLkZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShzdHlsaW5ncykgeyByZXR1cm4gc3R5bGluZ3MubGVuZ3RoID8gSGlnaGxpZ2h0U3R5bGUuY29tYmluZWRNYXRjaChzdHlsaW5ncykgOiBudWxsOyB9XG59KTtcbmNvbnN0IGZhbGxiYWNrSGlnaGxpZ2h0U3R5bGUgPSBzdGF0ZS5GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUodmFsdWVzKSB7IHJldHVybiB2YWx1ZXMubGVuZ3RoID8gdmFsdWVzWzBdLm1hdGNoIDogbnVsbDsgfVxufSk7XG5mdW5jdGlvbiBub0hpZ2hsaWdodCgpIHsgcmV0dXJuIG51bGw7IH1cbmZ1bmN0aW9uIGdldEhpZ2hsaWdodFN0eWxlKHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlLmZhY2V0KGhpZ2hsaWdodFN0eWxlKSB8fCBzdGF0ZS5mYWNldChmYWxsYmFja0hpZ2hsaWdodFN0eWxlKSB8fCBub0hpZ2hsaWdodDtcbn1cbmNsYXNzIFJ1bGUge1xuICAgIGNvbnN0cnVjdG9yKHRhZ3MsIG1vZGUsIGNvbnRleHQsIG5leHQpIHtcbiAgICAgICAgdGhpcy50YWdzID0gdGFncztcbiAgICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5uZXh0ID0gbmV4dDtcbiAgICB9XG4gICAgc29ydChvdGhlcikge1xuICAgICAgICBpZiAoIW90aGVyIHx8IG90aGVyLmRlcHRoIDwgdGhpcy5kZXB0aCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0ID0gb3RoZXI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBvdGhlci5uZXh0ID0gdGhpcy5zb3J0KG90aGVyLm5leHQpO1xuICAgICAgICByZXR1cm4gb3RoZXI7XG4gICAgfVxuICAgIGdldCBkZXB0aCgpIHsgcmV0dXJuIHRoaXMuY29udGV4dCA/IHRoaXMuY29udGV4dC5sZW5ndGggOiAwOyB9XG59XG4vLy8gQSBoaWdobGlnaHQgc3R5bGUgYXNzb2NpYXRlcyBDU1Mgc3R5bGVzIHdpdGggaGlnbGlnaHRpbmdcbi8vLyBbdGFnc10oI2hpZ2hsaWdodC5UYWcpLlxuY2xhc3MgSGlnaGxpZ2h0U3R5bGUge1xuICAgIGNvbnN0cnVjdG9yKHNwZWMsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5tYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBsZXQgbW9kU3BlYztcbiAgICAgICAgZnVuY3Rpb24gZGVmKHNwZWMpIHtcbiAgICAgICAgICAgIGxldCBjbHMgPSBzdHlsZU1vZC5TdHlsZU1vZHVsZS5uZXdOYW1lKCk7XG4gICAgICAgICAgICAobW9kU3BlYyB8fCAobW9kU3BlYyA9IE9iamVjdC5jcmVhdGUobnVsbCkpKVtcIi5cIiArIGNsc10gPSBzcGVjO1xuICAgICAgICAgICAgcmV0dXJuIGNscztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFsbCA9IHR5cGVvZiBvcHRpb25zLmFsbCA9PSBcInN0cmluZ1wiID8gb3B0aW9ucy5hbGwgOiBvcHRpb25zLmFsbCA/IGRlZihvcHRpb25zLmFsbCkgOiBudWxsO1xuICAgICAgICBmb3IgKGxldCBzdHlsZSBvZiBzcGVjKSB7XG4gICAgICAgICAgICBsZXQgY2xzID0gKHN0eWxlLmNsYXNzIHx8IGRlZihPYmplY3QuYXNzaWduKHt9LCBzdHlsZSwgeyB0YWc6IG51bGwgfSkpKSArXG4gICAgICAgICAgICAgICAgKHRoaXMuYWxsID8gXCIgXCIgKyB0aGlzLmFsbCA6IFwiXCIpO1xuICAgICAgICAgICAgbGV0IHRhZ3MgPSBzdHlsZS50YWc7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGFncykpXG4gICAgICAgICAgICAgICAgdGhpcy5tYXBbdGFncy5pZF0gPSBjbHM7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgdGFnIG9mIHRhZ3MpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFwW3RhZy5pZF0gPSBjbHM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2R1bGUgPSBtb2RTcGVjID8gbmV3IHN0eWxlTW9kLlN0eWxlTW9kdWxlKG1vZFNwZWMpIDogbnVsbDtcbiAgICAgICAgdGhpcy5zY29wZSA9IG9wdGlvbnMuc2NvcGUgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5tYXRjaCA9IHRoaXMubWF0Y2guYmluZCh0aGlzKTtcbiAgICAgICAgbGV0IGV4dCA9IFt0cmVlSGlnaGxpZ2h0ZXJdO1xuICAgICAgICBpZiAodGhpcy5tb2R1bGUpXG4gICAgICAgICAgICBleHQucHVzaCh2aWV3LkVkaXRvclZpZXcuc3R5bGVNb2R1bGUub2YodGhpcy5tb2R1bGUpKTtcbiAgICAgICAgdGhpcy5leHRlbnNpb24gPSBleHQuY29uY2F0KGhpZ2hsaWdodFN0eWxlLm9mKHRoaXMpKTtcbiAgICAgICAgdGhpcy5mYWxsYmFjayA9IGV4dC5jb25jYXQoZmFsbGJhY2tIaWdobGlnaHRTdHlsZS5vZih0aGlzKSk7XG4gICAgfVxuICAgIC8vLyBSZXR1cm5zIHRoZSBDU1MgY2xhc3MgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiB0YWcsIGlmIGFueS5cbiAgICAvLy8gVGhpcyBtZXRob2QgaXMgYm91bmQgdG8gdGhlIGluc3RhbmNlIGJ5IHRoZSBjb25zdHJ1Y3Rvci5cbiAgICBtYXRjaCh0YWcsIHNjb3BlKSB7XG4gICAgICAgIGlmICh0aGlzLnNjb3BlICYmIHNjb3BlICE9IHRoaXMuc2NvcGUpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgdCBvZiB0YWcuc2V0KSB7XG4gICAgICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLm1hcFt0LmlkXTtcbiAgICAgICAgICAgIGlmIChtYXRjaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHQgIT0gdGFnKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcFt0YWcuaWRdID0gbWF0Y2g7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm1hcFt0YWcuaWRdID0gdGhpcy5hbGw7XG4gICAgfVxuICAgIC8vLyBDb21iaW5lcyBhbiBhcnJheSBvZiBoaWdobGlnaHQgc3R5bGVzIGludG8gYSBzaW5nbGUgbWF0Y2hcbiAgICAvLy8gZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFsbCBvZiB0aGUgY2xhc3NlcyBhc3NpZ25lZCBieSB0aGUgc3R5bGVzXG4gICAgLy8vIGZvciBhIGdpdmVuIHRhZy5cbiAgICBzdGF0aWMgY29tYmluZWRNYXRjaChzdHlsZXMpIHtcbiAgICAgICAgaWYgKHN0eWxlcy5sZW5ndGggPT0gMSlcbiAgICAgICAgICAgIHJldHVybiBzdHlsZXNbMF0ubWF0Y2g7XG4gICAgICAgIGxldCBjYWNoZSA9IHN0eWxlcy5zb21lKHMgPT4gcy5zY29wZSkgPyB1bmRlZmluZWQgOiBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICByZXR1cm4gKHRhZywgc2NvcGUpID0+IHtcbiAgICAgICAgICAgIGxldCBjYWNoZWQgPSBjYWNoZSAmJiBjYWNoZVt0YWcuaWRdO1xuICAgICAgICAgICAgaWYgKGNhY2hlZCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAobGV0IHN0eWxlIG9mIHN0eWxlcykge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHN0eWxlLm1hdGNoKHRhZywgc2NvcGUpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ID8gcmVzdWx0ICsgXCIgXCIgKyB2YWx1ZSA6IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhY2hlKVxuICAgICAgICAgICAgICAgIGNhY2hlW3RhZy5pZF0gPSByZXN1bHQ7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLy8gQ3JlYXRlIGEgaGlnaGxpZ2h0ZXIgc3R5bGUgdGhhdCBhc3NvY2lhdGVzIHRoZSBnaXZlbiBzdHlsZXMgdG9cbiAgICAvLy8gdGhlIGdpdmVuIHRhZ3MuIFRoZSBzcGVjIG11c3QgYmUgb2JqZWN0cyB0aGF0IGhvbGQgYSBzdHlsZSB0YWdcbiAgICAvLy8gb3IgYXJyYXkgb2YgdGFncyBpbiB0aGVpciBgdGFnYCBwcm9wZXJ0eSwgYW5kIGVpdGhlciBhIHNpbmdsZVxuICAgIC8vLyBgY2xhc3NgIHByb3BlcnR5IHByb3ZpZGluZyBhIHN0YXRpYyBDU1MgY2xhc3MgKGZvciBoaWdobGlnaHRlcnNcbiAgICAvLy8gbGlrZSBbYGNsYXNzSGlnaGxpZ2h0U3R5bGVgXSgjaGlnaGxpZ2h0LmNsYXNzSGlnaGxpZ2h0U3R5bGUpXG4gICAgLy8vIHRoYXQgcmVseSBvbiBleHRlcm5hbCBzdHlsaW5nKSwgb3IgYVxuICAgIC8vLyBbYHN0eWxlLW1vZGBdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJpam5oL3N0eWxlLW1vZCNkb2N1bWVudGF0aW9uKS1zdHlsZVxuICAgIC8vLyBzZXQgb2YgQ1NTIHByb3BlcnRpZXMgKHdoaWNoIGRlZmluZSB0aGUgc3R5bGluZyBmb3IgdGhvc2UgdGFncykuXG4gICAgLy8vXG4gICAgLy8vIFRoZSBDU1MgcnVsZXMgY3JlYXRlZCBmb3IgYSBoaWdobGlnaHRlciB3aWxsIGJlIGVtaXR0ZWQgaW4gdGhlXG4gICAgLy8vIG9yZGVyIG9mIHRoZSBzcGVjJ3MgcHJvcGVydGllcy4gVGhhdCBtZWFucyB0aGF0IGZvciBlbGVtZW50cyB0aGF0XG4gICAgLy8vIGhhdmUgbXVsdGlwbGUgdGFncyBhc3NvY2lhdGVkIHdpdGggdGhlbSwgc3R5bGVzIGRlZmluZWQgZnVydGhlclxuICAgIC8vLyBkb3duIGluIHRoZSBsaXN0IHdpbGwgaGF2ZSBhIGhpZ2hlciBDU1MgcHJlY2VkZW5jZSB0aGFuIHN0eWxlc1xuICAgIC8vLyBkZWZpbmVkIGVhcmxpZXIuXG4gICAgc3RhdGljIGRlZmluZShzcGVjcywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEhpZ2hsaWdodFN0eWxlKHNwZWNzLCBvcHRpb25zIHx8IHt9KTtcbiAgICB9XG4gICAgLy8vIFJldHVybnMgdGhlIENTUyBjbGFzc2VzIChpZiBhbnkpIHRoYXQgdGhlIGhpZ2hsaWdodCBzdHlsZXNcbiAgICAvLy8gYWN0aXZlIGluIHRoZSBnaXZlbiBzdGF0ZSB3b3VsZCBhc3NpZ24gdG8gdGhlIGdpdmVuIGEgc3R5bGVcbiAgICAvLy8gW3RhZ10oI2hpZ2hsaWdodC5UYWcpIGFuZCAob3B0aW9uYWwpIGxhbmd1YWdlXG4gICAgLy8vIFtzY29wZV0oI2hpZ2hsaWdodC5IaWdobGlnaHRTdHlsZV5kZWZpbmVeb3B0aW9ucy5zY29wZSkuXG4gICAgc3RhdGljIGdldChzdGF0ZSwgdGFnLCBzY29wZSkge1xuICAgICAgICByZXR1cm4gZ2V0SGlnaGxpZ2h0U3R5bGUoc3RhdGUpKHRhZywgc2NvcGUgfHwgbGV6ZXJUcmVlLk5vZGVUeXBlLm5vbmUpO1xuICAgIH1cbn1cbi8vLyBHaXZlbiBhIHN0cmluZyBvZiBjb2RlIGFuZCBhIGxhbmd1YWdlLCBwYXJzZSB0aGUgY29kZSBpbiB0aGF0XG4vLy8gbGFuZ3VhZ2UgYW5kIHJ1biB0aGUgdHJlZSBoaWdobGlnaHRlciBvdmVyIHRoZSByZXN1bHRpbmcgc3ludGF4XG4vLy8gdHJlZS5cbmZ1bmN0aW9uIGhpZ2hsaWdodFRyZWUodHJlZSwgXG4vLy8gR2V0IHRoZSBDU1MgY2xhc3NlcyB1c2VkIHRvIHN0eWxlIGEgZ2l2ZW4gW3RhZ10oI2hpZ2hsaWdodC5UYWcpLFxuLy8vIG9yIGBudWxsYCBpZiBpdCBpc24ndCBzdHlsZWQuIChZb3UnbGwgb2Z0ZW4gd2FudCB0byBwYXNzIGFcbi8vLyBoaWdobGlnaHQgc3R5bGUncyBbYG1hdGNoYF0oI2hpZ2hsaWdodC5IaWdobGlnaHRTdHlsZS5tYXRjaClcbi8vLyBtZXRob2QgaGVyZS4pXG5nZXRTdHlsZSwgXG4vLy8gQXNzaWduIHN0eWxpbmcgdG8gYSByZWdpb24gb2YgdGhlIHRleHQuIFdpbGwgYmUgY2FsbGVkLCBpbiBvcmRlclxuLy8vIG9mIHBvc2l0aW9uLCBmb3IgYW55IHJhbmdlcyB3aGVyZSBtb3JlIHRoYW4gemVybyBjbGFzc2VzIGFwcGx5LlxuLy8vIGBjbGFzc2VzYCBpcyBhIHNwYWNlIHNlcGFyYXRlZCBzdHJpbmcgb2YgQ1NTIGNsYXNzZXMuXG5wdXRTdHlsZSkge1xuICAgIGhpZ2hsaWdodFRyZWVSYW5nZSh0cmVlLCAwLCB0cmVlLmxlbmd0aCwgZ2V0U3R5bGUsIHB1dFN0eWxlKTtcbn1cbmNsYXNzIFRyZWVIaWdobGlnaHRlciB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLm1hcmtDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMudHJlZSA9IGxhbmd1YWdlLnN5bnRheFRyZWUodmlldy5zdGF0ZSk7XG4gICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmJ1aWxkRGVjbyh2aWV3LCBnZXRIaWdobGlnaHRTdHlsZSh2aWV3LnN0YXRlKSk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IHRyZWUgPSBsYW5ndWFnZS5zeW50YXhUcmVlKHVwZGF0ZS5zdGF0ZSksIHN0eWxlID0gZ2V0SGlnaGxpZ2h0U3R5bGUodXBkYXRlLnN0YXRlKTtcbiAgICAgICAgbGV0IHN0eWxlQ2hhbmdlID0gc3R5bGUgIT0gdXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQoaGlnaGxpZ2h0U3R5bGUpO1xuICAgICAgICBpZiAodHJlZS5sZW5ndGggPCB1cGRhdGUudmlldy52aWV3cG9ydC50byAmJiAhc3R5bGVDaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmRlY29yYXRpb25zLm1hcCh1cGRhdGUuY2hhbmdlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHJlZSAhPSB0aGlzLnRyZWUgfHwgdXBkYXRlLnZpZXdwb3J0Q2hhbmdlZCB8fCBzdHlsZUNoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmJ1aWxkRGVjbyh1cGRhdGUudmlldywgc3R5bGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJ1aWxkRGVjbyh2aWV3JDEsIG1hdGNoKSB7XG4gICAgICAgIGlmIChtYXRjaCA9PSBub0hpZ2hsaWdodCB8fCAhdGhpcy50cmVlLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB2aWV3LkRlY29yYXRpb24ubm9uZTtcbiAgICAgICAgbGV0IGJ1aWxkZXIgPSBuZXcgcmFuZ2VzZXQuUmFuZ2VTZXRCdWlsZGVyKCk7XG4gICAgICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiB2aWV3JDEudmlzaWJsZVJhbmdlcykge1xuICAgICAgICAgICAgaGlnaGxpZ2h0VHJlZVJhbmdlKHRoaXMudHJlZSwgZnJvbSwgdG8sIG1hdGNoLCAoZnJvbSwgdG8sIHN0eWxlKSA9PiB7XG4gICAgICAgICAgICAgICAgYnVpbGRlci5hZGQoZnJvbSwgdG8sIHRoaXMubWFya0NhY2hlW3N0eWxlXSB8fCAodGhpcy5tYXJrQ2FjaGVbc3R5bGVdID0gdmlldy5EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogc3R5bGUgfSkpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWlsZGVyLmZpbmlzaCgpO1xuICAgIH1cbn1cbi8vIFRoaXMgZXh0ZW5zaW9uIGluc3RhbGxzIGEgaGlnaGxpZ2h0ZXIgdGhhdCBoaWdobGlnaHRzIGJhc2VkIG9uIHRoZVxuLy8gc3ludGF4IHRyZWUgYW5kIGhpZ2hsaWdodCBzdHlsZS5cbmNvbnN0IHRyZWVIaWdobGlnaHRlciA9IHN0YXRlLlByZWMuZmFsbGJhY2sodmlldy5WaWV3UGx1Z2luLmZyb21DbGFzcyhUcmVlSGlnaGxpZ2h0ZXIsIHtcbiAgICBkZWNvcmF0aW9uczogdiA9PiB2LmRlY29yYXRpb25zXG59KSk7XG5jb25zdCBub2RlU3RhY2sgPSBbXCJcIl07XG5mdW5jdGlvbiBoaWdobGlnaHRUcmVlUmFuZ2UodHJlZSwgZnJvbSwgdG8sIHN0eWxlLCBzcGFuKSB7XG4gICAgbGV0IHNwYW5TdGFydCA9IGZyb20sIHNwYW5DbGFzcyA9IFwiXCI7XG4gICAgbGV0IGN1cnNvciA9IHRyZWUudG9wTm9kZS5jdXJzb3I7XG4gICAgZnVuY3Rpb24gbm9kZShpbmhlcml0ZWRDbGFzcywgZGVwdGgsIHNjb3BlKSB7XG4gICAgICAgIGxldCB7IHR5cGUsIGZyb206IHN0YXJ0LCB0bzogZW5kIH0gPSBjdXJzb3I7XG4gICAgICAgIGlmIChzdGFydCA+PSB0byB8fCBlbmQgPD0gZnJvbSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbm9kZVN0YWNrW2RlcHRoXSA9IHR5cGUubmFtZTtcbiAgICAgICAgaWYgKHR5cGUuaXNUb3ApXG4gICAgICAgICAgICBzY29wZSA9IHR5cGU7XG4gICAgICAgIGxldCBjbHMgPSBpbmhlcml0ZWRDbGFzcztcbiAgICAgICAgbGV0IHJ1bGUgPSB0eXBlLnByb3AocnVsZU5vZGVQcm9wKSwgb3BhcXVlID0gZmFsc2U7XG4gICAgICAgIHdoaWxlIChydWxlKSB7XG4gICAgICAgICAgICBpZiAoIXJ1bGUuY29udGV4dCB8fCBtYXRjaENvbnRleHQocnVsZS5jb250ZXh0LCBub2RlU3RhY2ssIGRlcHRoKSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHRhZyBvZiBydWxlLnRhZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0ID0gc3R5bGUodGFnLCBzY29wZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNscylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbHMgKz0gXCIgXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbHMgKz0gc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocnVsZS5tb2RlID09IDEgLyogSW5oZXJpdCAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmhlcml0ZWRDbGFzcyArPSAoaW5oZXJpdGVkQ2xhc3MgPyBcIiBcIiA6IFwiXCIpICsgc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChydWxlLm1vZGUgPT0gMCAvKiBPcGFxdWUgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BhcXVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJ1bGUgPSBydWxlLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNscyAhPSBzcGFuQ2xhc3MpIHtcbiAgICAgICAgICAgIGlmIChzdGFydCA+IHNwYW5TdGFydCAmJiBzcGFuQ2xhc3MpXG4gICAgICAgICAgICAgICAgc3BhbihzcGFuU3RhcnQsIGN1cnNvci5mcm9tLCBzcGFuQ2xhc3MpO1xuICAgICAgICAgICAgc3BhblN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICBzcGFuQ2xhc3MgPSBjbHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcGFxdWUgJiYgY3Vyc29yLmZpcnN0Q2hpbGQoKSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGxldCBlbmQgPSBjdXJzb3IudG87XG4gICAgICAgICAgICAgICAgbm9kZShpbmhlcml0ZWRDbGFzcywgZGVwdGggKyAxLCBzY29wZSk7XG4gICAgICAgICAgICAgICAgaWYgKHNwYW5DbGFzcyAhPSBjbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvcyA9IE1hdGgubWluKHRvLCBlbmQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zID4gc3BhblN0YXJ0ICYmIHNwYW5DbGFzcylcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYW4oc3BhblN0YXJ0LCBwb3MsIHNwYW5DbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgIHNwYW5TdGFydCA9IHBvcztcbiAgICAgICAgICAgICAgICAgICAgc3BhbkNsYXNzID0gY2xzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKGN1cnNvci5uZXh0U2libGluZygpKTtcbiAgICAgICAgICAgIGN1cnNvci5wYXJlbnQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBub2RlKFwiXCIsIDAsIHRyZWUudHlwZSk7XG59XG5mdW5jdGlvbiBtYXRjaENvbnRleHQoY29udGV4dCwgc3RhY2ssIGRlcHRoKSB7XG4gICAgaWYgKGNvbnRleHQubGVuZ3RoID4gZGVwdGggLSAxKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgZCA9IGRlcHRoIC0gMSwgaSA9IGNvbnRleHQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0sIGQtLSkge1xuICAgICAgICBsZXQgY2hlY2sgPSBjb250ZXh0W2ldO1xuICAgICAgICBpZiAoY2hlY2sgJiYgY2hlY2sgIT0gc3RhY2tbZF0pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuY29uc3QgdCA9IFRhZy5kZWZpbmU7XG5jb25zdCBjb21tZW50ID0gdCgpLCBuYW1lID0gdCgpLCB0eXBlTmFtZSA9IHQobmFtZSksIGxpdGVyYWwgPSB0KCksIHN0cmluZyA9IHQobGl0ZXJhbCksIG51bWJlciA9IHQobGl0ZXJhbCksIGNvbnRlbnQgPSB0KCksIGhlYWRpbmcgPSB0KGNvbnRlbnQpLCBrZXl3b3JkID0gdCgpLCBvcGVyYXRvciA9IHQoKSwgcHVuY3R1YXRpb24gPSB0KCksIGJyYWNrZXQgPSB0KHB1bmN0dWF0aW9uKSwgbWV0YSA9IHQoKTtcbi8vLyBUaGUgZGVmYXVsdCBzZXQgb2YgaGlnaGxpZ2h0aW5nIFt0YWdzXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmUpIHVzZWRcbi8vLyBieSByZWd1bGFyIGxhbmd1YWdlIHBhY2thZ2VzIGFuZCB0aGVtZXMuXG4vLy9cbi8vLyBUaGlzIGNvbGxlY3Rpb24gaXMgaGVhdmlseSBiaWFzZWQgdG93YXJkcyBwcm9ncmFtbWluZyBsYW5ndWFnZXMsXG4vLy8gYW5kIG5lY2Vzc2FyaWx5IGluY29tcGxldGUuIEEgZnVsbCBvbnRvbG9neSBvZiBzeW50YWN0aWNcbi8vLyBjb25zdHJ1Y3RzIHdvdWxkIGZpbGwgYSBzdGFjayBvZiBib29rcywgYW5kIGJlIGltcHJhY3RpY2FsIHRvXG4vLy8gd3JpdGUgdGhlbWVzIGZvci4gU28gdHJ5IHRvIG1ha2UgZG8gd2l0aCB0aGlzIHNldC4gSWYgYWxsIGVsc2Vcbi8vLyBmYWlscywgW29wZW4gYW5cbi8vLyBpc3N1ZV0oaHR0cHM6Ly9naXRodWIuY29tL2NvZGVtaXJyb3IvY29kZW1pcnJvci5uZXh0KSB0byBwcm9wb3NlIGFcbi8vLyBuZXcgdGFnLCBvciBbZGVmaW5lXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmUpIGEgbG9jYWwgY3VzdG9tIHRhZyBmb3Jcbi8vLyB5b3VyIHVzZSBjYXNlLlxuLy8vXG4vLy8gTm90ZSB0aGF0IGl0IGlzIG5vdCBvYmxpZ2F0b3J5IHRvIGFsd2F5cyBhdHRhY2ggdGhlIG1vc3Qgc3BlY2lmaWNcbi8vLyB0YWcgcG9zc2libGUgdG8gYW4gZWxlbWVudOKAlGlmIHlvdXIgZ3JhbW1hciBjYW4ndCBlYXNpbHlcbi8vLyBkaXN0aW5ndWlzaCBhIGNlcnRhaW4gdHlwZSBvZiBlbGVtZW50IChzdWNoIGFzIGEgbG9jYWwgdmFyaWFibGUpLFxuLy8vIGl0IGlzIG9rYXkgdG8gc3R5bGUgaXQgYXMgaXRzIG1vcmUgZ2VuZXJhbCB2YXJpYW50IChhIHZhcmlhYmxlKS5cbi8vLyBcbi8vLyBGb3IgdGFncyB0aGF0IGV4dGVuZCBzb21lIHBhcmVudCB0YWcsIHRoZSBkb2N1bWVudGF0aW9uIGxpbmtzIHRvXG4vLy8gdGhlIHBhcmVudC5cbmNvbnN0IHRhZ3MgPSB7XG4gICAgLy8vIEEgY29tbWVudC5cbiAgICBjb21tZW50LFxuICAgIC8vLyBBIGxpbmUgW2NvbW1lbnRdKCNoaWdobGlnaHQudGFncy5jb21tZW50KS5cbiAgICBsaW5lQ29tbWVudDogdChjb21tZW50KSxcbiAgICAvLy8gQSBibG9jayBbY29tbWVudF0oI2hpZ2hsaWdodC50YWdzLmNvbW1lbnQpLlxuICAgIGJsb2NrQ29tbWVudDogdChjb21tZW50KSxcbiAgICAvLy8gQSBkb2N1bWVudGF0aW9uIFtjb21tZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29tbWVudCkuXG4gICAgZG9jQ29tbWVudDogdChjb21tZW50KSxcbiAgICAvLy8gQW55IGtpbmQgb2YgaWRlbnRpZmllci5cbiAgICBuYW1lLFxuICAgIC8vLyBUaGUgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKSBvZiBhIHZhcmlhYmxlLlxuICAgIHZhcmlhYmxlTmFtZTogdChuYW1lKSxcbiAgICAvLy8gQSB0eXBlIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkuXG4gICAgdHlwZU5hbWU6IHR5cGVOYW1lLFxuICAgIC8vLyBBIHRhZyBuYW1lIChzdWJ0YWcgb2YgW2B0eXBlTmFtZWBdKCNoaWdobGlnaHQudGFncy50eXBlTmFtZSkpLlxuICAgIHRhZ05hbWU6IHQodHlwZU5hbWUpLFxuICAgIC8vLyBBIHByb3BlcnR5LCBmaWVsZCwgb3IgYXR0cmlidXRlIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkuXG4gICAgcHJvcGVydHlOYW1lOiB0KG5hbWUpLFxuICAgIC8vLyBUaGUgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKSBvZiBhIGNsYXNzLlxuICAgIGNsYXNzTmFtZTogdChuYW1lKSxcbiAgICAvLy8gQSBsYWJlbCBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpLlxuICAgIGxhYmVsTmFtZTogdChuYW1lKSxcbiAgICAvLy8gQSBuYW1lc3BhY2UgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKS5cbiAgICBuYW1lc3BhY2U6IHQobmFtZSksXG4gICAgLy8vIFRoZSBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpIG9mIGEgbWFjcm8uXG4gICAgbWFjcm9OYW1lOiB0KG5hbWUpLFxuICAgIC8vLyBBIGxpdGVyYWwgdmFsdWUuXG4gICAgbGl0ZXJhbCxcbiAgICAvLy8gQSBzdHJpbmcgW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICBzdHJpbmcsXG4gICAgLy8vIEEgZG9jdW1lbnRhdGlvbiBbc3RyaW5nXSgjaGlnaGxpZ2h0LnRhZ3Muc3RyaW5nKS5cbiAgICBkb2NTdHJpbmc6IHQoc3RyaW5nKSxcbiAgICAvLy8gQSBjaGFyYWN0ZXIgbGl0ZXJhbCAoc3VidGFnIG9mIFtzdHJpbmddKCNoaWdobGlnaHQudGFncy5zdHJpbmcpKS5cbiAgICBjaGFyYWN0ZXI6IHQoc3RyaW5nKSxcbiAgICAvLy8gQSBudW1iZXIgW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICBudW1iZXIsXG4gICAgLy8vIEFuIGludGVnZXIgW251bWJlcl0oI2hpZ2hsaWdodC50YWdzLm51bWJlcikgbGl0ZXJhbC5cbiAgICBpbnRlZ2VyOiB0KG51bWJlciksXG4gICAgLy8vIEEgZmxvYXRpbmctcG9pbnQgW251bWJlcl0oI2hpZ2hsaWdodC50YWdzLm51bWJlcikgbGl0ZXJhbC5cbiAgICBmbG9hdDogdChudW1iZXIpLFxuICAgIC8vLyBBIGJvb2xlYW4gW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICBib29sOiB0KGxpdGVyYWwpLFxuICAgIC8vLyBSZWd1bGFyIGV4cHJlc3Npb24gW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICByZWdleHA6IHQobGl0ZXJhbCksXG4gICAgLy8vIEFuIGVzY2FwZSBbbGl0ZXJhbF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLCBmb3IgZXhhbXBsZSBhXG4gICAgLy8vIGJhY2tzbGFzaCBlc2NhcGUgaW4gYSBzdHJpbmcuXG4gICAgZXNjYXBlOiB0KGxpdGVyYWwpLFxuICAgIC8vLyBBIGNvbG9yIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCkuXG4gICAgY29sb3I6IHQobGl0ZXJhbCksXG4gICAgLy8vIEEgVVJMIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCkuXG4gICAgdXJsOiB0KGxpdGVyYWwpLFxuICAgIC8vLyBBIGxhbmd1YWdlIGtleXdvcmQuXG4gICAga2V5d29yZCxcbiAgICAvLy8gVGhlIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgZm9yIHRoZSBzZWxmIG9yIHRoaXNcbiAgICAvLy8gb2JqZWN0LlxuICAgIHNlbGY6IHQoa2V5d29yZCksXG4gICAgLy8vIFRoZSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIGZvciBudWxsLlxuICAgIG51bGw6IHQoa2V5d29yZCksXG4gICAgLy8vIEEgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSBkZW5vdGluZyBzb21lIGF0b21pYyB2YWx1ZS5cbiAgICBhdG9tOiB0KGtleXdvcmQpLFxuICAgIC8vLyBBIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgdGhhdCByZXByZXNlbnRzIGEgdW5pdC5cbiAgICB1bml0OiB0KGtleXdvcmQpLFxuICAgIC8vLyBBIG1vZGlmaWVyIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkuXG4gICAgbW9kaWZpZXI6IHQoa2V5d29yZCksXG4gICAgLy8vIEEgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSB0aGF0IGFjdHMgYXMgYW4gb3BlcmF0b3IuXG4gICAgb3BlcmF0b3JLZXl3b3JkOiB0KGtleXdvcmQpLFxuICAgIC8vLyBBIGNvbnRyb2wtZmxvdyByZWxhdGVkIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkuXG4gICAgY29udHJvbEtleXdvcmQ6IHQoa2V5d29yZCksXG4gICAgLy8vIEEgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSB0aGF0IGRlZmluZXMgc29tZXRoaW5nLlxuICAgIGRlZmluaXRpb25LZXl3b3JkOiB0KGtleXdvcmQpLFxuICAgIC8vLyBBbiBvcGVyYXRvci5cbiAgICBvcGVyYXRvcixcbiAgICAvLy8gQW4gW29wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpIHRoYXQgZGVmaW5lcyBzb21ldGhpbmcuXG4gICAgZGVyZWZPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLy8vIEFyaXRobWV0aWMtcmVsYXRlZCBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikuXG4gICAgYXJpdGhtZXRpY09wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvLy8gTG9naWNhbCBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikuXG4gICAgbG9naWNPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLy8vIEJpdCBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikuXG4gICAgYml0d2lzZU9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvLy8gQ29tcGFyaXNvbiBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikuXG4gICAgY29tcGFyZU9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvLy8gW09wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpIHRoYXQgdXBkYXRlcyBpdHMgb3BlcmFuZC5cbiAgICB1cGRhdGVPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLy8vIFtPcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKSB0aGF0IGRlZmluZXMgc29tZXRoaW5nLlxuICAgIGRlZmluaXRpb25PcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLy8vIFR5cGUtcmVsYXRlZCBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikuXG4gICAgdHlwZU9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvLy8gQ29udHJvbC1mbG93IFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICBjb250cm9sT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxuICAgIC8vLyBQcm9ncmFtIG9yIG1hcmt1cCBwdW5jdHVhdGlvbi5cbiAgICBwdW5jdHVhdGlvbixcbiAgICAvLy8gW1B1bmN0dWF0aW9uXSgjaGlnaGxpZ2h0LnRhZ3MucHVuY3R1YXRpb24pIHRoYXQgc2VwYXJhdGVzXG4gICAgLy8vIHRoaW5ncy5cbiAgICBzZXBhcmF0b3I6IHQocHVuY3R1YXRpb24pLFxuICAgIC8vLyBCcmFja2V0LXN0eWxlIFtwdW5jdHVhdGlvbl0oI2hpZ2hsaWdodC50YWdzLnB1bmN0dWF0aW9uKS5cbiAgICBicmFja2V0LFxuICAgIC8vLyBBbmdsZSBbYnJhY2tldHNdKCNoaWdobGlnaHQudGFncy5icmFja2V0KSAodXN1YWxseSBgPGAgYW5kIGA+YFxuICAgIC8vLyB0b2tlbnMpLlxuICAgIGFuZ2xlQnJhY2tldDogdChicmFja2V0KSxcbiAgICAvLy8gU3F1YXJlIFticmFja2V0c10oI2hpZ2hsaWdodC50YWdzLmJyYWNrZXQpICh1c3VhbGx5IGBbYCBhbmQgYF1gXG4gICAgLy8vIHRva2VucykuXG4gICAgc3F1YXJlQnJhY2tldDogdChicmFja2V0KSxcbiAgICAvLy8gUGFyZW50aGVzZXMgKHVzdWFsbHkgYChgIGFuZCBgKWAgdG9rZW5zKS4gU3VidGFnIG9mXG4gICAgLy8vIFticmFja2V0XSgjaGlnaGxpZ2h0LnRhZ3MuYnJhY2tldCkuXG4gICAgcGFyZW46IHQoYnJhY2tldCksXG4gICAgLy8vIEJyYWNlcyAodXN1YWxseSBge2AgYW5kIGB9YCB0b2tlbnMpLiBTdWJ0YWcgb2ZcbiAgICAvLy8gW2JyYWNrZXRdKCNoaWdobGlnaHQudGFncy5icmFja2V0KS5cbiAgICBicmFjZTogdChicmFja2V0KSxcbiAgICAvLy8gQ29udGVudCwgZm9yIGV4YW1wbGUgcGxhaW4gdGV4dCBpbiBYTUwgb3IgbWFya3VwIGRvY3VtZW50cy5cbiAgICBjb250ZW50LFxuICAgIC8vLyBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgcmVwcmVzZW50cyBhIGhlYWRpbmcuXG4gICAgaGVhZGluZyxcbiAgICAvLy8gQSBsZXZlbCAxIFtoZWFkaW5nXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZykuXG4gICAgaGVhZGluZzE6IHQoaGVhZGluZyksXG4gICAgLy8vIEEgbGV2ZWwgMiBbaGVhZGluZ10oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpLlxuICAgIGhlYWRpbmcyOiB0KGhlYWRpbmcpLFxuICAgIC8vLyBBIGxldmVsIDMgW2hlYWRpbmddKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKS5cbiAgICBoZWFkaW5nMzogdChoZWFkaW5nKSxcbiAgICAvLy8gQSBsZXZlbCA0IFtoZWFkaW5nXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZykuXG4gICAgaGVhZGluZzQ6IHQoaGVhZGluZyksXG4gICAgLy8vIEEgbGV2ZWwgNSBbaGVhZGluZ10oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpLlxuICAgIGhlYWRpbmc1OiB0KGhlYWRpbmcpLFxuICAgIC8vLyBBIGxldmVsIDYgW2hlYWRpbmddKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKS5cbiAgICBoZWFkaW5nNjogdChoZWFkaW5nKSxcbiAgICAvLy8gQSBwcm9zZSBzZXBhcmF0b3IgKHN1Y2ggYXMgYSBob3Jpem9udGFsIHJ1bGUpLlxuICAgIGNvbnRlbnRTZXBhcmF0b3I6IHQoY29udGVudCksXG4gICAgLy8vIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCByZXByZXNlbnRzIGEgbGlzdC5cbiAgICBsaXN0OiB0KGNvbnRlbnQpLFxuICAgIC8vLyBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgcmVwcmVzZW50cyBhIHF1b3RlLlxuICAgIHF1b3RlOiB0KGNvbnRlbnQpLFxuICAgIC8vLyBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgaXMgZW1waGFzaXplZC5cbiAgICBlbXBoYXNpczogdChjb250ZW50KSxcbiAgICAvLy8gW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IGlzIHN0eWxlZCBzdHJvbmcuXG4gICAgc3Ryb25nOiB0KGNvbnRlbnQpLFxuICAgIC8vLyBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgaXMgcGFydCBvZiBhIGxpbmsuXG4gICAgbGluazogdChjb250ZW50KSxcbiAgICAvLy8gW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IGlzIHN0eWxlZCBhcyBjb2RlIG9yXG4gICAgLy8vIG1vbm9zcGFjZS5cbiAgICBtb25vc3BhY2U6IHQoY29udGVudCksXG4gICAgLy8vIEluc2VydGVkIHRleHQgaW4gYSBjaGFuZ2UtdHJhY2tpbmcgZm9ybWF0LlxuICAgIGluc2VydGVkOiB0KCksXG4gICAgLy8vIERlbGV0ZWQgdGV4dC5cbiAgICBkZWxldGVkOiB0KCksXG4gICAgLy8vIENoYW5nZWQgdGV4dC5cbiAgICBjaGFuZ2VkOiB0KCksXG4gICAgLy8vIEFuIGludmFsaWQgb3IgdW5zeW50YWN0aWMgZWxlbWVudC5cbiAgICBpbnZhbGlkOiB0KCksXG4gICAgLy8vIE1ldGFkYXRhIG9yIG1ldGEtaW5zdHJ1Y3Rpb24uXG4gICAgbWV0YSxcbiAgICAvLy8gW01ldGFkYXRhXSgjaGlnaGxpZ2h0LnRhZ3MubWV0YSkgdGhhdCBhcHBsaWVzIHRvIHRoZSBlbnRpcmVcbiAgICAvLy8gZG9jdW1lbnQuXG4gICAgZG9jdW1lbnRNZXRhOiB0KG1ldGEpLFxuICAgIC8vLyBbTWV0YWRhdGFdKCNoaWdobGlnaHQudGFncy5tZXRhKSB0aGF0IGFubm90YXRlcyBvciBhZGRzXG4gICAgLy8vIGF0dHJpYnV0ZXMgdG8gYSBnaXZlbiBzeW50YWN0aWMgZWxlbWVudC5cbiAgICBhbm5vdGF0aW9uOiB0KG1ldGEpLFxuICAgIC8vLyBQcm9jZXNzaW5nIGluc3RydWN0aW9uIG9yIHByZXByb2Nlc3NvciBkaXJlY3RpdmUuIFN1YnRhZyBvZlxuICAgIC8vLyBbbWV0YV0oI2hpZ2hsaWdodC50YWdzLm1ldGEpLlxuICAgIHByb2Nlc3NpbmdJbnN0cnVjdGlvbjogdChtZXRhKSxcbiAgICAvLy8gW01vZGlmaWVyXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdGhhdCBpbmRpY2F0ZXMgdGhhdCBhXG4gICAgLy8vIGdpdmVuIGVsZW1lbnQgaXMgYmVpbmcgZGVmaW5lZC4gRXhwZWN0ZWQgdG8gYmUgdXNlZCB3aXRoIHRoZVxuICAgIC8vLyB2YXJpb3VzIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkgdGFncy5cbiAgICBkZWZpbml0aW9uOiBUYWcuZGVmaW5lTW9kaWZpZXIoKSxcbiAgICAvLy8gW01vZGlmaWVyXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdGhhdCBpbmRpY2F0ZXMgdGhhdFxuICAgIC8vLyBzb21ldGhpbmcgaXMgY29uc3RhbnQuIE1vc3RseSBleHBlY3RlZCB0byBiZSB1c2VkIHdpdGhcbiAgICAvLy8gW3ZhcmlhYmxlIG5hbWVzXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKS5cbiAgICBjb25zdGFudDogVGFnLmRlZmluZU1vZGlmaWVyKCksXG4gICAgLy8vIFtNb2RpZmllcl0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lTW9kaWZpZXIpIHVzZWQgdG8gaW5kaWNhdGUgdGhhdFxuICAgIC8vLyBhIFt2YXJpYWJsZV0oI2hpZ2hsaWdodC50YWdzLnZhcmlhYmxlTmFtZSkgb3IgW3Byb3BlcnR5XG4gICAgLy8vIG5hbWVdKCNoaWdobGlnaHQudGFncy5wcm9wZXJ0eU5hbWUpIGlzIGJlaW5nIGNhbGxlZCBvciBkZWZpbmVkXG4gICAgLy8vIGFzIGEgZnVuY3Rpb24uXG4gICAgZnVuY3Rpb246IFRhZy5kZWZpbmVNb2RpZmllcigpLFxuICAgIC8vLyBbTW9kaWZpZXJdKCNoaWdobGlnaHQuVGFnXmRlZmluZU1vZGlmaWVyKSB0aGF0IGNhbiBiZSBhcHBsaWVkIHRvXG4gICAgLy8vIFtuYW1lc10oI2hpZ2hsaWdodC50YWdzLm5hbWUpIHRvIGluZGljYXRlIHRoYXQgdGhleSBiZWxvbmcgdG9cbiAgICAvLy8gdGhlIGxhbmd1YWdlJ3Mgc3RhbmRhcmQgZW52aXJvbm1lbnQuXG4gICAgc3RhbmRhcmQ6IFRhZy5kZWZpbmVNb2RpZmllcigpLFxuICAgIC8vLyBbTW9kaWZpZXJdKCNoaWdobGlnaHQuVGFnXmRlZmluZU1vZGlmaWVyKSB0aGF0IGluZGljYXRlcyBhIGdpdmVuXG4gICAgLy8vIFtuYW1lc10oI2hpZ2hsaWdodC50YWdzLm5hbWUpIGlzIGxvY2FsIHRvIHNvbWUgc2NvcGUuXG4gICAgbG9jYWw6IFRhZy5kZWZpbmVNb2RpZmllcigpLFxuICAgIC8vLyBBIGdlbmVyaWMgdmFyaWFudCBbbW9kaWZpZXJdKCNoaWdobGlnaHQuVGFnXmRlZmluZU1vZGlmaWVyKSB0aGF0XG4gICAgLy8vIGNhbiBiZSB1c2VkIHRvIHRhZyBsYW5ndWFnZS1zcGVjaWZpYyBhbHRlcm5hdGl2ZSB2YXJpYW50cyBvZlxuICAgIC8vLyBzb21lIGNvbW1vbiB0YWcuIEl0IGlzIHJlY29tbWVuZGVkIGZvciB0aGVtZXMgdG8gZGVmaW5lIHNwZWNpYWxcbiAgICAvLy8gZm9ybXMgb2YgYXQgbGVhc3QgdGhlIFtzdHJpbmddKCNoaWdobGlnaHQudGFncy5zdHJpbmcpIGFuZFxuICAgIC8vLyBbdmFyaWFibGUgbmFtZV0oI2hpZ2hsaWdodC50YWdzLnZhcmlhYmxlTmFtZSkgdGFncywgc2luY2UgdGhvc2VcbiAgICAvLy8gY29tZSB1cCBhIGxvdC5cbiAgICBzcGVjaWFsOiBUYWcuZGVmaW5lTW9kaWZpZXIoKVxufTtcbi8vLyBBIGRlZmF1bHQgaGlnaGxpZ2h0IHN0eWxlICh3b3JrcyB3ZWxsIHdpdGggbGlnaHQgdGhlbWVzKS5cbmNvbnN0IGRlZmF1bHRIaWdobGlnaHRTdHlsZSA9IEhpZ2hsaWdodFN0eWxlLmRlZmluZShbXG4gICAgeyB0YWc6IHRhZ3MubGluayxcbiAgICAgICAgdGV4dERlY29yYXRpb246IFwidW5kZXJsaW5lXCIgfSxcbiAgICB7IHRhZzogdGFncy5oZWFkaW5nLFxuICAgICAgICB0ZXh0RGVjb3JhdGlvbjogXCJ1bmRlcmxpbmVcIixcbiAgICAgICAgZm9udFdlaWdodDogXCJib2xkXCIgfSxcbiAgICB7IHRhZzogdGFncy5lbXBoYXNpcyxcbiAgICAgICAgZm9udFN0eWxlOiBcIml0YWxpY1wiIH0sXG4gICAgeyB0YWc6IHRhZ3Muc3Ryb25nLFxuICAgICAgICBmb250V2VpZ2h0OiBcImJvbGRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmtleXdvcmQsXG4gICAgICAgIGNvbG9yOiBcIiM3MDhcIiB9LFxuICAgIHsgdGFnOiBbdGFncy5hdG9tLCB0YWdzLmJvb2wsIHRhZ3MudXJsLCB0YWdzLmNvbnRlbnRTZXBhcmF0b3IsIHRhZ3MubGFiZWxOYW1lXSxcbiAgICAgICAgY29sb3I6IFwiIzIxOVwiIH0sXG4gICAgeyB0YWc6IFt0YWdzLmxpdGVyYWwsIHRhZ3MuaW5zZXJ0ZWRdLFxuICAgICAgICBjb2xvcjogXCIjMTY0XCIgfSxcbiAgICB7IHRhZzogW3RhZ3Muc3RyaW5nLCB0YWdzLmRlbGV0ZWRdLFxuICAgICAgICBjb2xvcjogXCIjYTExXCIgfSxcbiAgICB7IHRhZzogW3RhZ3MucmVnZXhwLCB0YWdzLmVzY2FwZSwgdGFncy5zcGVjaWFsKHRhZ3Muc3RyaW5nKV0sXG4gICAgICAgIGNvbG9yOiBcIiNlNDBcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmRlZmluaXRpb24odGFncy52YXJpYWJsZU5hbWUpLFxuICAgICAgICBjb2xvcjogXCIjMDBmXCIgfSxcbiAgICB7IHRhZzogdGFncy5sb2NhbCh0YWdzLnZhcmlhYmxlTmFtZSksXG4gICAgICAgIGNvbG9yOiBcIiMzMGFcIiB9LFxuICAgIHsgdGFnOiBbdGFncy50eXBlTmFtZSwgdGFncy5uYW1lc3BhY2VdLFxuICAgICAgICBjb2xvcjogXCIjMDg1XCIgfSxcbiAgICB7IHRhZzogdGFncy5jbGFzc05hbWUsXG4gICAgICAgIGNvbG9yOiBcIiMxNjdcIiB9LFxuICAgIHsgdGFnOiBbdGFncy5zcGVjaWFsKHRhZ3MudmFyaWFibGVOYW1lKSwgdGFncy5tYWNyb05hbWVdLFxuICAgICAgICBjb2xvcjogXCIjMjU2XCIgfSxcbiAgICB7IHRhZzogdGFncy5kZWZpbml0aW9uKHRhZ3MucHJvcGVydHlOYW1lKSxcbiAgICAgICAgY29sb3I6IFwiIzAwY1wiIH0sXG4gICAgeyB0YWc6IHRhZ3MuY29tbWVudCxcbiAgICAgICAgY29sb3I6IFwiIzk0MFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MubWV0YSxcbiAgICAgICAgY29sb3I6IFwiIzdhNzU3YVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuaW52YWxpZCxcbiAgICAgICAgY29sb3I6IFwiI2YwMFwiIH1cbl0pO1xuLy8vIFRoaXMgaXMgYSBoaWdobGlnaHQgc3R5bGUgdGhhdCBhZGRzIHN0YWJsZSwgcHJlZGljdGFibGUgY2xhc3NlcyB0b1xuLy8vIHRva2VucywgZm9yIHN0eWxpbmcgd2l0aCBleHRlcm5hbCBDU1MuXG4vLy9cbi8vLyBUaGVzZSB0YWdzIGFyZSBtYXBwZWQgdG8gdGhlaXIgbmFtZSBwcmVmaXhlZCB3aXRoIGBcImNtdC1cImAgKGZvclxuLy8vIGV4YW1wbGUgYFwiY210LWNvbW1lbnRcImApOlxuLy8vXG4vLy8gKiBbYGxpbmtgXSgjaGlnaGxpZ2h0LnRhZ3MubGluaylcbi8vLyAqIFtgaGVhZGluZ2BdKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKVxuLy8vICogW2BlbXBoYXNpc2BdKCNoaWdobGlnaHQudGFncy5lbXBoYXNpcylcbi8vLyAqIFtgc3Ryb25nYF0oI2hpZ2hsaWdodC50YWdzLnN0cm9uZylcbi8vLyAqIFtga2V5d29yZGBdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKVxuLy8vICogW2BhdG9tYF0oI2hpZ2hsaWdodC50YWdzLmF0b20pIFtgYm9vbGBdKCNoaWdobGlnaHQudGFncy5ib29sKVxuLy8vICogW2B1cmxgXSgjaGlnaGxpZ2h0LnRhZ3MudXJsKVxuLy8vICogW2BsYWJlbE5hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MubGFiZWxOYW1lKVxuLy8vICogW2BpbnNlcnRlZGBdKCNoaWdobGlnaHQudGFncy5pbnNlcnRlZClcbi8vLyAqIFtgZGVsZXRlZGBdKCNoaWdobGlnaHQudGFncy5kZWxldGVkKVxuLy8vICogW2BsaXRlcmFsYF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpXG4vLy8gKiBbYHN0cmluZ2BdKCNoaWdobGlnaHQudGFncy5zdHJpbmcpXG4vLy8gKiBbYG51bWJlcmBdKCNoaWdobGlnaHQudGFncy5udW1iZXIpXG4vLy8gKiBbYHZhcmlhYmxlTmFtZWBdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpXG4vLy8gKiBbYHR5cGVOYW1lYF0oI2hpZ2hsaWdodC50YWdzLnR5cGVOYW1lKVxuLy8vICogW2BuYW1lc3BhY2VgXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZXNwYWNlKVxuLy8vICogW2BtYWNyb05hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MubWFjcm9OYW1lKVxuLy8vICogW2Bwcm9wZXJ0eU5hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MucHJvcGVydHlOYW1lKVxuLy8vICogW2BvcGVyYXRvcmBdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcilcbi8vLyAqIFtgY29tbWVudGBdKCNoaWdobGlnaHQudGFncy5jb21tZW50KVxuLy8vICogW2BtZXRhYF0oI2hpZ2hsaWdodC50YWdzLm1ldGEpXG4vLy8gKiBbYHB1bmN0dWF0aW9uYF0oI2hpZ2hsaWdodC50YWdzLnB1bmN1dGF0aW9uKVxuLy8vICogW2BpbnZhbGlkYF0oI2hpZ2hsaWdodC50YWdzLmludmFsaWQpXG4vLy9cbi8vLyBJbiBhZGRpdGlvbiwgdGhlc2UgbWFwcGluZ3MgYXJlIHByb3ZpZGVkOlxuLy8vXG4vLy8gKiBbYHJlZ2V4cGBdKCNoaWdobGlnaHQudGFncy5yZWdleHApLFxuLy8vICAgW2Blc2NhcGVgXSgjaGlnaGxpZ2h0LnRhZ3MuZXNjYXBlKSwgYW5kXG4vLy8gICBbYHNwZWNpYWxgXSgjaGlnaGxpZ2h0LnRhZ3Muc3BlY2lhbClbYChzdHJpbmcpYF0oI2hpZ2hsaWdodC50YWdzLnN0cmluZylcbi8vLyAgIGFyZSBtYXBwZWQgdG8gYFwiY210LXN0cmluZzJcImBcbi8vLyAqIFtgc3BlY2lhbGBdKCNoaWdobGlnaHQudGFncy5zcGVjaWFsKVtgKHZhcmlhYmxlTmFtZSlgXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKVxuLy8vICAgdG8gYFwiY210LXZhcmlhYmxlTmFtZTJcImBcbi8vLyAqIFtgbG9jYWxgXSgjaGlnaGxpZ2h0LnRhZ3MubG9jYWwpW2AodmFyaWFibGVOYW1lKWBdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpXG4vLy8gICB0byBgXCJjbXQtdmFyaWFibGVOYW1lIGNtdC1sb2NhbFwiYFxuLy8vICogW2BkZWZpbml0aW9uYF0oI2hpZ2hsaWdodC50YWdzLmRlZmluaXRpb24pW2AodmFyaWFibGVOYW1lKWBdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpXG4vLy8gICB0byBgXCJjbXQtdmFyaWFibGVOYW1lIGNtdC1kZWZpbml0aW9uXCJgXG5jb25zdCBjbGFzc0hpZ2hsaWdodFN0eWxlID0gSGlnaGxpZ2h0U3R5bGUuZGVmaW5lKFtcbiAgICB7IHRhZzogdGFncy5saW5rLCBjbGFzczogXCJjbXQtbGlua1wiIH0sXG4gICAgeyB0YWc6IHRhZ3MuaGVhZGluZywgY2xhc3M6IFwiY210LWhlYWRpbmdcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmVtcGhhc2lzLCBjbGFzczogXCJjbXQtZW1waGFzaXNcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnN0cm9uZywgY2xhc3M6IFwiY210LXN0cm9uZ1wiIH0sXG4gICAgeyB0YWc6IHRhZ3Mua2V5d29yZCwgY2xhc3M6IFwiY210LWtleXdvcmRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmF0b20sIGNsYXNzOiBcImNtdC1hdG9tXCIgfSxcbiAgICB7IHRhZzogdGFncy5ib29sLCBjbGFzczogXCJjbXQtYm9vbFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MudXJsLCBjbGFzczogXCJjbXQtdXJsXCIgfSxcbiAgICB7IHRhZzogdGFncy5sYWJlbE5hbWUsIGNsYXNzOiBcImNtdC1sYWJlbE5hbWVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmluc2VydGVkLCBjbGFzczogXCJjbXQtaW5zZXJ0ZWRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmRlbGV0ZWQsIGNsYXNzOiBcImNtdC1kZWxldGVkXCIgfSxcbiAgICB7IHRhZzogdGFncy5saXRlcmFsLCBjbGFzczogXCJjbXQtbGl0ZXJhbFwiIH0sXG4gICAgeyB0YWc6IHRhZ3Muc3RyaW5nLCBjbGFzczogXCJjbXQtc3RyaW5nXCIgfSxcbiAgICB7IHRhZzogdGFncy5udW1iZXIsIGNsYXNzOiBcImNtdC1udW1iZXJcIiB9LFxuICAgIHsgdGFnOiBbdGFncy5yZWdleHAsIHRhZ3MuZXNjYXBlLCB0YWdzLnNwZWNpYWwodGFncy5zdHJpbmcpXSwgY2xhc3M6IFwiY210LXN0cmluZzJcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnZhcmlhYmxlTmFtZSwgY2xhc3M6IFwiY210LXZhcmlhYmxlTmFtZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MubG9jYWwodGFncy52YXJpYWJsZU5hbWUpLCBjbGFzczogXCJjbXQtdmFyaWFibGVOYW1lIGNtdC1sb2NhbFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuZGVmaW5pdGlvbih0YWdzLnZhcmlhYmxlTmFtZSksIGNsYXNzOiBcImNtdC12YXJpYWJsZU5hbWUgY210LWRlZmluaXRpb25cIiB9LFxuICAgIHsgdGFnOiB0YWdzLnNwZWNpYWwodGFncy52YXJpYWJsZU5hbWUpLCBjbGFzczogXCJjbXQtdmFyaWFibGVOYW1lMlwiIH0sXG4gICAgeyB0YWc6IHRhZ3MudHlwZU5hbWUsIGNsYXNzOiBcImNtdC10eXBlTmFtZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MubmFtZXNwYWNlLCBjbGFzczogXCJjbXQtbmFtZXNwYWNlXCIgfSxcbiAgICB7IHRhZzogdGFncy5tYWNyb05hbWUsIGNsYXNzOiBcImNtdC1tYWNyb05hbWVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnByb3BlcnR5TmFtZSwgY2xhc3M6IFwiY210LXByb3BlcnR5TmFtZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3Mub3BlcmF0b3IsIGNsYXNzOiBcImNtdC1vcGVyYXRvclwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuY29tbWVudCwgY2xhc3M6IFwiY210LWNvbW1lbnRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLm1ldGEsIGNsYXNzOiBcImNtdC1tZXRhXCIgfSxcbiAgICB7IHRhZzogdGFncy5pbnZhbGlkLCBjbGFzczogXCJjbXQtaW52YWxpZFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MucHVuY3R1YXRpb24sIGNsYXNzOiBcImNtdC1wdW5jdHVhdGlvblwiIH1cbl0pO1xuXG5leHBvcnRzLkhpZ2hsaWdodFN0eWxlID0gSGlnaGxpZ2h0U3R5bGU7XG5leHBvcnRzLlRhZyA9IFRhZztcbmV4cG9ydHMuY2xhc3NIaWdobGlnaHRTdHlsZSA9IGNsYXNzSGlnaGxpZ2h0U3R5bGU7XG5leHBvcnRzLmRlZmF1bHRIaWdobGlnaHRTdHlsZSA9IGRlZmF1bHRIaWdobGlnaHRTdHlsZTtcbmV4cG9ydHMuaGlnaGxpZ2h0VHJlZSA9IGhpZ2hsaWdodFRyZWU7XG5leHBvcnRzLnN0eWxlVGFncyA9IHN0eWxlVGFncztcbmV4cG9ydHMudGFncyA9IHRhZ3M7XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBzdGF0ZSA9IHJlcXVpcmUoJ0Bjb2RlbWlycm9yL3N0YXRlJyk7XG52YXIgdmlldyA9IHJlcXVpcmUoJ0Bjb2RlbWlycm9yL3ZpZXcnKTtcblxuY29uc3QgZnJvbUhpc3RvcnkgPSBzdGF0ZS5Bbm5vdGF0aW9uLmRlZmluZSgpO1xuLyoqXG5UcmFuc2FjdGlvbiBhbm5vdGF0aW9uIHRoYXQgd2lsbCBwcmV2ZW50IHRoYXQgdHJhbnNhY3Rpb24gZnJvbVxuYmVpbmcgY29tYmluZWQgd2l0aCBvdGhlciB0cmFuc2FjdGlvbnMgaW4gdGhlIHVuZG8gaGlzdG9yeS4gR2l2ZW5cbmBcImJlZm9yZVwiYCwgaXQnbGwgcHJldmVudCBtZXJnaW5nIHdpdGggcHJldmlvdXMgdHJhbnNhY3Rpb25zLiBXaXRoXG5gXCJhZnRlclwiYCwgc3Vic2VxdWVudCB0cmFuc2FjdGlvbnMgd29uJ3QgYmUgY29tYmluZWQgd2l0aCB0aGlzXG5vbmUuIFdpdGggYFwiZnVsbFwiYCwgdGhlIHRyYW5zYWN0aW9uIGlzIGlzb2xhdGVkIG9uIGJvdGggc2lkZXMuXG4qL1xuY29uc3QgaXNvbGF0ZUhpc3RvcnkgPSBzdGF0ZS5Bbm5vdGF0aW9uLmRlZmluZSgpO1xuLyoqXG5UaGlzIGZhY2V0IHByb3ZpZGVzIGEgd2F5IHRvIHJlZ2lzdGVyIGZ1bmN0aW9ucyB0aGF0LCBnaXZlbiBhXG50cmFuc2FjdGlvbiwgcHJvdmlkZSBhIHNldCBvZiBlZmZlY3RzIHRoYXQgdGhlIGhpc3Rvcnkgc2hvdWxkXG5zdG9yZSB3aGVuIGludmVydGluZyB0aGUgdHJhbnNhY3Rpb24uIFRoaXMgY2FuIGJlIHVzZWQgdG9cbmludGVncmF0ZSBzb21lIGtpbmRzIG9mIGVmZmVjdHMgaW4gdGhlIGhpc3RvcnksIHNvIHRoYXQgdGhleSBjYW5cbmJlIHVuZG9uZSAoYW5kIHJlZG9uZSBhZ2FpbikuXG4qL1xuY29uc3QgaW52ZXJ0ZWRFZmZlY3RzID0gc3RhdGUuRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBoaXN0b3J5Q29uZmlnID0gc3RhdGUuRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGNvbmZpZ3MpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlLmNvbWJpbmVDb25maWcoY29uZmlncywge1xuICAgICAgICAgICAgbWluRGVwdGg6IDEwMCxcbiAgICAgICAgICAgIG5ld0dyb3VwRGVsYXk6IDUwMFxuICAgICAgICB9LCB7IG1pbkRlcHRoOiBNYXRoLm1heCwgbmV3R3JvdXBEZWxheTogTWF0aC5taW4gfSk7XG4gICAgfVxufSk7XG5jb25zdCBoaXN0b3J5RmllbGRfID0gc3RhdGUuU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIEhpc3RvcnlTdGF0ZS5lbXB0eTtcbiAgICB9LFxuICAgIHVwZGF0ZShzdGF0ZSQxLCB0cikge1xuICAgICAgICBsZXQgY29uZmlnID0gdHIuc3RhdGUuZmFjZXQoaGlzdG9yeUNvbmZpZyk7XG4gICAgICAgIGxldCBmcm9tSGlzdCA9IHRyLmFubm90YXRpb24oZnJvbUhpc3RvcnkpO1xuICAgICAgICBpZiAoZnJvbUhpc3QpIHtcbiAgICAgICAgICAgIGxldCBpdGVtID0gSGlzdEV2ZW50LmZyb21UcmFuc2FjdGlvbih0ciksIGZyb20gPSBmcm9tSGlzdC5zaWRlO1xuICAgICAgICAgICAgbGV0IG90aGVyID0gZnJvbSA9PSAwIC8qIERvbmUgKi8gPyBzdGF0ZSQxLnVuZG9uZSA6IHN0YXRlJDEuZG9uZTtcbiAgICAgICAgICAgIGlmIChpdGVtKVxuICAgICAgICAgICAgICAgIG90aGVyID0gdXBkYXRlQnJhbmNoKG90aGVyLCBvdGhlci5sZW5ndGgsIGNvbmZpZy5taW5EZXB0aCwgaXRlbSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgb3RoZXIgPSBhZGRTZWxlY3Rpb24ob3RoZXIsIHRyLnN0YXJ0U3RhdGUuc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGZyb20gPT0gMCAvKiBEb25lICovID8gZnJvbUhpc3QucmVzdCA6IG90aGVyLCBmcm9tID09IDAgLyogRG9uZSAqLyA/IG90aGVyIDogZnJvbUhpc3QucmVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlzb2xhdGUgPSB0ci5hbm5vdGF0aW9uKGlzb2xhdGVIaXN0b3J5KTtcbiAgICAgICAgaWYgKGlzb2xhdGUgPT0gXCJmdWxsXCIgfHwgaXNvbGF0ZSA9PSBcImJlZm9yZVwiKVxuICAgICAgICAgICAgc3RhdGUkMSA9IHN0YXRlJDEuaXNvbGF0ZSgpO1xuICAgICAgICBpZiAodHIuYW5ub3RhdGlvbihzdGF0ZS5UcmFuc2FjdGlvbi5hZGRUb0hpc3RvcnkpID09PSBmYWxzZSlcbiAgICAgICAgICAgIHJldHVybiAhdHIuY2hhbmdlcy5lbXB0eSA/IHN0YXRlJDEuYWRkTWFwcGluZyh0ci5jaGFuZ2VzLmRlc2MpIDogc3RhdGUkMTtcbiAgICAgICAgbGV0IGV2ZW50ID0gSGlzdEV2ZW50LmZyb21UcmFuc2FjdGlvbih0cik7XG4gICAgICAgIGxldCB0aW1lID0gdHIuYW5ub3RhdGlvbihzdGF0ZS5UcmFuc2FjdGlvbi50aW1lKSwgdXNlckV2ZW50ID0gdHIuYW5ub3RhdGlvbihzdGF0ZS5UcmFuc2FjdGlvbi51c2VyRXZlbnQpO1xuICAgICAgICBpZiAoZXZlbnQpXG4gICAgICAgICAgICBzdGF0ZSQxID0gc3RhdGUkMS5hZGRDaGFuZ2VzKGV2ZW50LCB0aW1lLCB1c2VyRXZlbnQsIGNvbmZpZy5uZXdHcm91cERlbGF5LCBjb25maWcubWluRGVwdGgpO1xuICAgICAgICBlbHNlIGlmICh0ci5zZWxlY3Rpb24pXG4gICAgICAgICAgICBzdGF0ZSQxID0gc3RhdGUkMS5hZGRTZWxlY3Rpb24odHIuc3RhcnRTdGF0ZS5zZWxlY3Rpb24sIHRpbWUsIHVzZXJFdmVudCwgY29uZmlnLm5ld0dyb3VwRGVsYXkpO1xuICAgICAgICBpZiAoaXNvbGF0ZSA9PSBcImZ1bGxcIiB8fCBpc29sYXRlID09IFwiYWZ0ZXJcIilcbiAgICAgICAgICAgIHN0YXRlJDEgPSBzdGF0ZSQxLmlzb2xhdGUoKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlJDE7XG4gICAgfSxcbiAgICB0b0pTT04odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHsgZG9uZTogdmFsdWUuZG9uZS5tYXAoZSA9PiBlLnRvSlNPTigpKSwgdW5kb25lOiB2YWx1ZS51bmRvbmUubWFwKGUgPT4gZS50b0pTT04oKSkgfTtcbiAgICB9LFxuICAgIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoanNvbi5kb25lLm1hcChIaXN0RXZlbnQuZnJvbUpTT04pLCBqc29uLnVuZG9uZS5tYXAoSGlzdEV2ZW50LmZyb21KU09OKSk7XG4gICAgfVxufSk7XG4vKipcbkNyZWF0ZSBhIGhpc3RvcnkgZXh0ZW5zaW9uIHdpdGggdGhlIGdpdmVuIGNvbmZpZ3VyYXRpb24uXG4qL1xuZnVuY3Rpb24gaGlzdG9yeShjb25maWcgPSB7fSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGhpc3RvcnlGaWVsZF8sXG4gICAgICAgIGhpc3RvcnlDb25maWcub2YoY29uZmlnKSxcbiAgICAgICAgdmlldy5FZGl0b3JWaWV3LmRvbUV2ZW50SGFuZGxlcnMoe1xuICAgICAgICAgICAgYmVmb3JlaW5wdXQoZSwgdmlldykge1xuICAgICAgICAgICAgICAgIGlmIChlLmlucHV0VHlwZSA9PSBcImhpc3RvcnlVbmRvXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRvKHZpZXcpO1xuICAgICAgICAgICAgICAgIGlmIChlLmlucHV0VHlwZSA9PSBcImhpc3RvcnlSZWRvXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWRvKHZpZXcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICBdO1xufVxuLyoqXG5UaGUgc3RhdGUgZmllbGQgdXNlZCB0byBzdG9yZSB0aGUgaGlzdG9yeSBkYXRhLiBTaG91bGQgcHJvYmFibHlcbm9ubHkgYmUgdXNlZCB3aGVuIHlvdSB3YW50IHRvXG5bc2VyaWFsaXplXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnRvSlNPTikgb3JcbltkZXNlcmlhbGl6ZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5mcm9tSlNPTikgc3RhdGUgb2JqZWN0cyBpbiBhIHdheVxudGhhdCBwcmVzZXJ2ZXMgaGlzdG9yeS5cbiovXG5jb25zdCBoaXN0b3J5RmllbGQgPSBoaXN0b3J5RmllbGRfO1xuZnVuY3Rpb24gY21kKHNpZGUsIHNlbGVjdGlvbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkge1xuICAgICAgICBsZXQgaGlzdG9yeVN0YXRlID0gc3RhdGUuZmllbGQoaGlzdG9yeUZpZWxkXywgZmFsc2UpO1xuICAgICAgICBpZiAoIWhpc3RvcnlTdGF0ZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHRyID0gaGlzdG9yeVN0YXRlLnBvcChzaWRlLCBzdGF0ZSwgc2VsZWN0aW9uKTtcbiAgICAgICAgaWYgKCF0cilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZGlzcGF0Y2godHIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG5VbmRvIGEgc2luZ2xlIGdyb3VwIG9mIGhpc3RvcnkgZXZlbnRzLiBSZXR1cm5zIGZhbHNlIGlmIG5vIGdyb3VwXG53YXMgYXZhaWxhYmxlLlxuKi9cbmNvbnN0IHVuZG8gPSBjbWQoMCAvKiBEb25lICovLCBmYWxzZSk7XG4vKipcblJlZG8gYSBncm91cCBvZiBoaXN0b3J5IGV2ZW50cy4gUmV0dXJucyBmYWxzZSBpZiBubyBncm91cCB3YXNcbmF2YWlsYWJsZS5cbiovXG5jb25zdCByZWRvID0gY21kKDEgLyogVW5kb25lICovLCBmYWxzZSk7XG4vKipcblVuZG8gYSBzZWxlY3Rpb24gY2hhbmdlLlxuKi9cbmNvbnN0IHVuZG9TZWxlY3Rpb24gPSBjbWQoMCAvKiBEb25lICovLCB0cnVlKTtcbi8qKlxuUmVkbyBhIHNlbGVjdGlvbiBjaGFuZ2UuXG4qL1xuY29uc3QgcmVkb1NlbGVjdGlvbiA9IGNtZCgxIC8qIFVuZG9uZSAqLywgdHJ1ZSk7XG5mdW5jdGlvbiBkZXB0aChzaWRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICBsZXQgaGlzdFN0YXRlID0gc3RhdGUuZmllbGQoaGlzdG9yeUZpZWxkXywgZmFsc2UpO1xuICAgICAgICBpZiAoIWhpc3RTdGF0ZSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBsZXQgYnJhbmNoID0gc2lkZSA9PSAwIC8qIERvbmUgKi8gPyBoaXN0U3RhdGUuZG9uZSA6IGhpc3RTdGF0ZS51bmRvbmU7XG4gICAgICAgIHJldHVybiBicmFuY2gubGVuZ3RoIC0gKGJyYW5jaC5sZW5ndGggJiYgIWJyYW5jaFswXS5jaGFuZ2VzID8gMSA6IDApO1xuICAgIH07XG59XG4vKipcblRoZSBhbW91bnQgb2YgdW5kb2FibGUgY2hhbmdlIGV2ZW50cyBhdmFpbGFibGUgaW4gYSBnaXZlbiBzdGF0ZS5cbiovXG5jb25zdCB1bmRvRGVwdGggPSBkZXB0aCgwIC8qIERvbmUgKi8pO1xuLyoqXG5UaGUgYW1vdW50IG9mIHJlZG9hYmxlIGNoYW5nZSBldmVudHMgYXZhaWxhYmxlIGluIGEgZ2l2ZW4gc3RhdGUuXG4qL1xuY29uc3QgcmVkb0RlcHRoID0gZGVwdGgoMSAvKiBVbmRvbmUgKi8pO1xuLy8gSGlzdG9yeSBldmVudHMgc3RvcmUgZ3JvdXBzIG9mIGNoYW5nZXMgb3IgZWZmZWN0cyB0aGF0IG5lZWQgdG8gYmVcbi8vIHVuZG9uZS9yZWRvbmUgdG9nZXRoZXIuXG5jbGFzcyBIaXN0RXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vIFRoZSBjaGFuZ2VzIGluIHRoaXMgZXZlbnQuIE5vcm1hbCBldmVudHMgaG9sZCBhdCBsZWFzdCBvbmVcbiAgICAvLyBjaGFuZ2Ugb3IgZWZmZWN0LiBCdXQgaXQgbWF5IGJlIG5lY2Vzc2FyeSB0byBzdG9yZSBzZWxlY3Rpb25cbiAgICAvLyBldmVudHMgYmVmb3JlIHRoZSBmaXJzdCBjaGFuZ2UsIGluIHdoaWNoIGNhc2UgYSBzcGVjaWFsIHR5cGUgb2ZcbiAgICAvLyBpbnN0YW5jZSBpcyBjcmVhdGVkIHdoaWNoIGRvZXNuJ3QgaG9sZCBhbnkgY2hhbmdlcywgd2l0aFxuICAgIC8vIGNoYW5nZXMgPT0gc3RhcnRTZWxlY3Rpb24gPT0gdW5kZWZpbmVkXG4gICAgY2hhbmdlcywgXG4gICAgLy8gVGhlIGVmZmVjdHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZXZlbnRcbiAgICBlZmZlY3RzLCBtYXBwZWQsIFxuICAgIC8vIFRoZSBzZWxlY3Rpb24gYmVmb3JlIHRoaXMgZXZlbnRcbiAgICBzdGFydFNlbGVjdGlvbiwgXG4gICAgLy8gU3RvcmVzIHNlbGVjdGlvbiBjaGFuZ2VzIGFmdGVyIHRoaXMgZXZlbnQsIHRvIGJlIHVzZWQgZm9yXG4gICAgLy8gc2VsZWN0aW9uIHVuZG8vcmVkby5cbiAgICBzZWxlY3Rpb25zQWZ0ZXIpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gY2hhbmdlcztcbiAgICAgICAgdGhpcy5lZmZlY3RzID0gZWZmZWN0cztcbiAgICAgICAgdGhpcy5tYXBwZWQgPSBtYXBwZWQ7XG4gICAgICAgIHRoaXMuc3RhcnRTZWxlY3Rpb24gPSBzdGFydFNlbGVjdGlvbjtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25zQWZ0ZXIgPSBzZWxlY3Rpb25zQWZ0ZXI7XG4gICAgfVxuICAgIHNldFNlbEFmdGVyKGFmdGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdEV2ZW50KHRoaXMuY2hhbmdlcywgdGhpcy5lZmZlY3RzLCB0aGlzLm1hcHBlZCwgdGhpcy5zdGFydFNlbGVjdGlvbiwgYWZ0ZXIpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2hhbmdlczogKF9hID0gdGhpcy5jaGFuZ2VzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9KU09OKCksXG4gICAgICAgICAgICBtYXBwZWQ6IChfYiA9IHRoaXMubWFwcGVkKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudG9KU09OKCksXG4gICAgICAgICAgICBzdGFydFNlbGVjdGlvbjogKF9jID0gdGhpcy5zdGFydFNlbGVjdGlvbikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnRvSlNPTigpLFxuICAgICAgICAgICAgc2VsZWN0aW9uc0FmdGVyOiB0aGlzLnNlbGVjdGlvbnNBZnRlci5tYXAocyA9PiBzLnRvSlNPTigpKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgICAgICByZXR1cm4gbmV3IEhpc3RFdmVudChqc29uLmNoYW5nZXMgJiYgc3RhdGUuQ2hhbmdlU2V0LmZyb21KU09OKGpzb24uY2hhbmdlcyksIFtdLCBqc29uLm1hcHBlZCAmJiBzdGF0ZS5DaGFuZ2VEZXNjLmZyb21KU09OKGpzb24ubWFwcGVkKSwganNvbi5zdGFydFNlbGVjdGlvbiAmJiBzdGF0ZS5FZGl0b3JTZWxlY3Rpb24uZnJvbUpTT04oanNvbi5zdGFydFNlbGVjdGlvbiksIGpzb24uc2VsZWN0aW9uc0FmdGVyLm1hcChzdGF0ZS5FZGl0b3JTZWxlY3Rpb24uZnJvbUpTT04pKTtcbiAgICB9XG4gICAgLy8gVGhpcyBkb2VzIG5vdCBjaGVjayBgYWRkVG9IaXN0b3J5YCBhbmQgc3VjaCwgaXQgYXNzdW1lcyB0aGVcbiAgICAvLyB0cmFuc2FjdGlvbiBuZWVkcyB0byBiZSBjb252ZXJ0ZWQgdG8gYW4gaXRlbS4gUmV0dXJucyBudWxsIHdoZW5cbiAgICAvLyB0aGVyZSBhcmUgbm8gY2hhbmdlcyBvciBlZmZlY3RzIGluIHRoZSB0cmFuc2FjdGlvbi5cbiAgICBzdGF0aWMgZnJvbVRyYW5zYWN0aW9uKHRyKSB7XG4gICAgICAgIGxldCBlZmZlY3RzID0gbm9uZTtcbiAgICAgICAgZm9yIChsZXQgaW52ZXJ0IG9mIHRyLnN0YXJ0U3RhdGUuZmFjZXQoaW52ZXJ0ZWRFZmZlY3RzKSkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGludmVydCh0cik7XG4gICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICBlZmZlY3RzID0gZWZmZWN0cy5jb25jYXQocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWVmZmVjdHMubGVuZ3RoICYmIHRyLmNoYW5nZXMuZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0RXZlbnQodHIuY2hhbmdlcy5pbnZlcnQodHIuc3RhcnRTdGF0ZS5kb2MpLCBlZmZlY3RzLCB1bmRlZmluZWQsIHRyLnN0YXJ0U3RhdGUuc2VsZWN0aW9uLCBub25lKTtcbiAgICB9XG4gICAgc3RhdGljIHNlbGVjdGlvbihzZWxlY3Rpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdEV2ZW50KHVuZGVmaW5lZCwgbm9uZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHNlbGVjdGlvbnMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZUJyYW5jaChicmFuY2gsIHRvLCBtYXhMZW4sIG5ld0V2ZW50KSB7XG4gICAgbGV0IHN0YXJ0ID0gdG8gKyAxID4gbWF4TGVuICsgMjAgPyB0byAtIG1heExlbiAtIDEgOiAwO1xuICAgIGxldCBuZXdCcmFuY2ggPSBicmFuY2guc2xpY2Uoc3RhcnQsIHRvKTtcbiAgICBuZXdCcmFuY2gucHVzaChuZXdFdmVudCk7XG4gICAgcmV0dXJuIG5ld0JyYW5jaDtcbn1cbmZ1bmN0aW9uIGlzQWRqYWNlbnQoYSwgYikge1xuICAgIGxldCByYW5nZXMgPSBbXSwgaXNBZGphY2VudCA9IGZhbHNlO1xuICAgIGEuaXRlckNoYW5nZWRSYW5nZXMoKGYsIHQpID0+IHJhbmdlcy5wdXNoKGYsIHQpKTtcbiAgICBiLml0ZXJDaGFuZ2VkUmFuZ2VzKChfZiwgX3QsIGYsIHQpID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGZyb20gPSByYW5nZXNbaSsrXSwgdG8gPSByYW5nZXNbaSsrXTtcbiAgICAgICAgICAgIGlmICh0ID49IGZyb20gJiYgZiA8PSB0bylcbiAgICAgICAgICAgICAgICBpc0FkamFjZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBpc0FkamFjZW50O1xufVxuZnVuY3Rpb24gZXFTZWxlY3Rpb25TaGFwZShhLCBiKSB7XG4gICAgcmV0dXJuIGEucmFuZ2VzLmxlbmd0aCA9PSBiLnJhbmdlcy5sZW5ndGggJiZcbiAgICAgICAgYS5yYW5nZXMuZmlsdGVyKChyLCBpKSA9PiByLmVtcHR5ICE9IGIucmFuZ2VzW2ldLmVtcHR5KS5sZW5ndGggPT09IDA7XG59XG5mdW5jdGlvbiBjb25jKGEsIGIpIHtcbiAgICByZXR1cm4gIWEubGVuZ3RoID8gYiA6ICFiLmxlbmd0aCA/IGEgOiBhLmNvbmNhdChiKTtcbn1cbmNvbnN0IG5vbmUgPSBbXTtcbmNvbnN0IE1heFNlbGVjdGlvbnNQZXJFdmVudCA9IDIwMDtcbmZ1bmN0aW9uIGFkZFNlbGVjdGlvbihicmFuY2gsIHNlbGVjdGlvbikge1xuICAgIGlmICghYnJhbmNoLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW0hpc3RFdmVudC5zZWxlY3Rpb24oW3NlbGVjdGlvbl0pXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBsYXN0RXZlbnQgPSBicmFuY2hbYnJhbmNoLmxlbmd0aCAtIDFdO1xuICAgICAgICBsZXQgc2VscyA9IGxhc3RFdmVudC5zZWxlY3Rpb25zQWZ0ZXIuc2xpY2UoTWF0aC5tYXgoMCwgbGFzdEV2ZW50LnNlbGVjdGlvbnNBZnRlci5sZW5ndGggLSBNYXhTZWxlY3Rpb25zUGVyRXZlbnQpKTtcbiAgICAgICAgaWYgKHNlbHMubGVuZ3RoICYmIHNlbHNbc2Vscy5sZW5ndGggLSAxXS5lcShzZWxlY3Rpb24pKVxuICAgICAgICAgICAgcmV0dXJuIGJyYW5jaDtcbiAgICAgICAgc2Vscy5wdXNoKHNlbGVjdGlvbik7XG4gICAgICAgIHJldHVybiB1cGRhdGVCcmFuY2goYnJhbmNoLCBicmFuY2gubGVuZ3RoIC0gMSwgMWU5LCBsYXN0RXZlbnQuc2V0U2VsQWZ0ZXIoc2VscykpO1xuICAgIH1cbn1cbi8vIEFzc3VtZXMgdGhlIHRvcCBpdGVtIGhhcyBvbmUgb3IgbW9yZSBzZWxlY3Rpb25BZnRlciB2YWx1ZXNcbmZ1bmN0aW9uIHBvcFNlbGVjdGlvbihicmFuY2gpIHtcbiAgICBsZXQgbGFzdCA9IGJyYW5jaFticmFuY2gubGVuZ3RoIC0gMV07XG4gICAgbGV0IG5ld0JyYW5jaCA9IGJyYW5jaC5zbGljZSgpO1xuICAgIG5ld0JyYW5jaFticmFuY2gubGVuZ3RoIC0gMV0gPSBsYXN0LnNldFNlbEFmdGVyKGxhc3Quc2VsZWN0aW9uc0FmdGVyLnNsaWNlKDAsIGxhc3Quc2VsZWN0aW9uc0FmdGVyLmxlbmd0aCAtIDEpKTtcbiAgICByZXR1cm4gbmV3QnJhbmNoO1xufVxuLy8gQWRkIGEgbWFwcGluZyB0byB0aGUgdG9wIGV2ZW50IGluIHRoZSBnaXZlbiBicmFuY2guIElmIHRoaXMgbWFwc1xuLy8gYXdheSBhbGwgdGhlIGNoYW5nZXMgYW5kIGVmZmVjdHMgaW4gdGhhdCBpdGVtLCBkcm9wIGl0IGFuZFxuLy8gcHJvcGFnYXRlIHRoZSBtYXBwaW5nIHRvIHRoZSBuZXh0IGl0ZW0uXG5mdW5jdGlvbiBhZGRNYXBwaW5nVG9CcmFuY2goYnJhbmNoLCBtYXBwaW5nKSB7XG4gICAgaWYgKCFicmFuY2gubGVuZ3RoKVxuICAgICAgICByZXR1cm4gYnJhbmNoO1xuICAgIGxldCBsZW5ndGggPSBicmFuY2gubGVuZ3RoLCBzZWxlY3Rpb25zID0gbm9uZTtcbiAgICB3aGlsZSAobGVuZ3RoKSB7XG4gICAgICAgIGxldCBldmVudCA9IG1hcEV2ZW50KGJyYW5jaFtsZW5ndGggLSAxXSwgbWFwcGluZywgc2VsZWN0aW9ucyk7XG4gICAgICAgIGlmIChldmVudC5jaGFuZ2VzICYmICFldmVudC5jaGFuZ2VzLmVtcHR5IHx8IGV2ZW50LmVmZmVjdHMubGVuZ3RoKSB7IC8vIEV2ZW50IHN1cnZpdmVkIG1hcHBpbmdcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBicmFuY2guc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICAgICAgICAgIHJlc3VsdFtsZW5ndGggLSAxXSA9IGV2ZW50O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gRHJvcCB0aGlzIGV2ZW50LCBzaW5jZSB0aGVyZSdzIG5vIGNoYW5nZXMgb3IgZWZmZWN0cyBsZWZ0XG4gICAgICAgICAgICBtYXBwaW5nID0gZXZlbnQubWFwcGVkO1xuICAgICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgICAgICBzZWxlY3Rpb25zID0gZXZlbnQuc2VsZWN0aW9uc0FmdGVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3Rpb25zLmxlbmd0aCA/IFtIaXN0RXZlbnQuc2VsZWN0aW9uKHNlbGVjdGlvbnMpXSA6IG5vbmU7XG59XG5mdW5jdGlvbiBtYXBFdmVudChldmVudCwgbWFwcGluZywgZXh0cmFTZWxlY3Rpb25zKSB7XG4gICAgbGV0IHNlbGVjdGlvbnMgPSBjb25jKGV2ZW50LnNlbGVjdGlvbnNBZnRlci5sZW5ndGggPyBldmVudC5zZWxlY3Rpb25zQWZ0ZXIubWFwKHMgPT4gcy5tYXAobWFwcGluZykpIDogbm9uZSwgZXh0cmFTZWxlY3Rpb25zKTtcbiAgICAvLyBDaGFuZ2UtbGVzcyBldmVudHMgZG9uJ3Qgc3RvcmUgbWFwcGluZ3MgKHRoZXkgYXJlIGFsd2F5cyB0aGUgbGFzdCBldmVudCBpbiBhIGJyYW5jaClcbiAgICBpZiAoIWV2ZW50LmNoYW5nZXMpXG4gICAgICAgIHJldHVybiBIaXN0RXZlbnQuc2VsZWN0aW9uKHNlbGVjdGlvbnMpO1xuICAgIGxldCBtYXBwZWRDaGFuZ2VzID0gZXZlbnQuY2hhbmdlcy5tYXAobWFwcGluZyksIGJlZm9yZSA9IG1hcHBpbmcubWFwRGVzYyhldmVudC5jaGFuZ2VzLCB0cnVlKTtcbiAgICBsZXQgZnVsbE1hcHBpbmcgPSBldmVudC5tYXBwZWQgPyBldmVudC5tYXBwZWQuY29tcG9zZURlc2MoYmVmb3JlKSA6IGJlZm9yZTtcbiAgICByZXR1cm4gbmV3IEhpc3RFdmVudChtYXBwZWRDaGFuZ2VzLCBzdGF0ZS5TdGF0ZUVmZmVjdC5tYXBFZmZlY3RzKGV2ZW50LmVmZmVjdHMsIG1hcHBpbmcpLCBmdWxsTWFwcGluZywgZXZlbnQuc3RhcnRTZWxlY3Rpb24ubWFwKGJlZm9yZSksIHNlbGVjdGlvbnMpO1xufVxuY2xhc3MgSGlzdG9yeVN0YXRlIHtcbiAgICBjb25zdHJ1Y3Rvcihkb25lLCB1bmRvbmUsIHByZXZUaW1lID0gMCwgcHJldlVzZXJFdmVudCA9IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmRvbmUgPSBkb25lO1xuICAgICAgICB0aGlzLnVuZG9uZSA9IHVuZG9uZTtcbiAgICAgICAgdGhpcy5wcmV2VGltZSA9IHByZXZUaW1lO1xuICAgICAgICB0aGlzLnByZXZVc2VyRXZlbnQgPSBwcmV2VXNlckV2ZW50O1xuICAgIH1cbiAgICBpc29sYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmV2VGltZSA/IG5ldyBIaXN0b3J5U3RhdGUodGhpcy5kb25lLCB0aGlzLnVuZG9uZSkgOiB0aGlzO1xuICAgIH1cbiAgICBhZGRDaGFuZ2VzKGV2ZW50LCB0aW1lLCB1c2VyRXZlbnQsIG5ld0dyb3VwRGVsYXksIG1heExlbikge1xuICAgICAgICBsZXQgZG9uZSA9IHRoaXMuZG9uZSwgbGFzdEV2ZW50ID0gZG9uZVtkb25lLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAobGFzdEV2ZW50ICYmIGxhc3RFdmVudC5jaGFuZ2VzICYmXG4gICAgICAgICAgICB0aW1lIC0gdGhpcy5wcmV2VGltZSA8IG5ld0dyb3VwRGVsYXkgJiZcbiAgICAgICAgICAgICFsYXN0RXZlbnQuc2VsZWN0aW9uc0FmdGVyLmxlbmd0aCAmJlxuICAgICAgICAgICAgIWxhc3RFdmVudC5jaGFuZ2VzLmVtcHR5ICYmIGV2ZW50LmNoYW5nZXMgJiZcbiAgICAgICAgICAgIGlzQWRqYWNlbnQobGFzdEV2ZW50LmNoYW5nZXMsIGV2ZW50LmNoYW5nZXMpKSB7XG4gICAgICAgICAgICBkb25lID0gdXBkYXRlQnJhbmNoKGRvbmUsIGRvbmUubGVuZ3RoIC0gMSwgbWF4TGVuLCBuZXcgSGlzdEV2ZW50KGV2ZW50LmNoYW5nZXMuY29tcG9zZShsYXN0RXZlbnQuY2hhbmdlcyksIGNvbmMoZXZlbnQuZWZmZWN0cywgbGFzdEV2ZW50LmVmZmVjdHMpLCBsYXN0RXZlbnQubWFwcGVkLCBsYXN0RXZlbnQuc3RhcnRTZWxlY3Rpb24sIG5vbmUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRvbmUgPSB1cGRhdGVCcmFuY2goZG9uZSwgZG9uZS5sZW5ndGgsIG1heExlbiwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGRvbmUsIG5vbmUsIHRpbWUsIHVzZXJFdmVudCk7XG4gICAgfVxuICAgIGFkZFNlbGVjdGlvbihzZWxlY3Rpb24sIHRpbWUsIHVzZXJFdmVudCwgbmV3R3JvdXBEZWxheSkge1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMuZG9uZS5sZW5ndGggPyB0aGlzLmRvbmVbdGhpcy5kb25lLmxlbmd0aCAtIDFdLnNlbGVjdGlvbnNBZnRlciA6IG5vbmU7XG4gICAgICAgIGlmIChsYXN0Lmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgIHRpbWUgLSB0aGlzLnByZXZUaW1lIDwgbmV3R3JvdXBEZWxheSAmJlxuICAgICAgICAgICAgdXNlckV2ZW50ID09IFwia2V5Ym9hcmRzZWxlY3Rpb25cIiAmJiB0aGlzLnByZXZVc2VyRXZlbnQgPT0gdXNlckV2ZW50ICYmXG4gICAgICAgICAgICBlcVNlbGVjdGlvblNoYXBlKGxhc3RbbGFzdC5sZW5ndGggLSAxXSwgc2VsZWN0aW9uKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShhZGRTZWxlY3Rpb24odGhpcy5kb25lLCBzZWxlY3Rpb24pLCB0aGlzLnVuZG9uZSwgdGltZSwgdXNlckV2ZW50KTtcbiAgICB9XG4gICAgYWRkTWFwcGluZyhtYXBwaW5nKSB7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGFkZE1hcHBpbmdUb0JyYW5jaCh0aGlzLmRvbmUsIG1hcHBpbmcpLCBhZGRNYXBwaW5nVG9CcmFuY2godGhpcy51bmRvbmUsIG1hcHBpbmcpLCB0aGlzLnByZXZUaW1lLCB0aGlzLnByZXZVc2VyRXZlbnQpO1xuICAgIH1cbiAgICBwb3Aoc2lkZSwgc3RhdGUsIHNlbGVjdGlvbikge1xuICAgICAgICBsZXQgYnJhbmNoID0gc2lkZSA9PSAwIC8qIERvbmUgKi8gPyB0aGlzLmRvbmUgOiB0aGlzLnVuZG9uZTtcbiAgICAgICAgaWYgKGJyYW5jaC5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgZXZlbnQgPSBicmFuY2hbYnJhbmNoLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoc2VsZWN0aW9uICYmIGV2ZW50LnNlbGVjdGlvbnNBZnRlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS51cGRhdGUoe1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogZXZlbnQuc2VsZWN0aW9uc0FmdGVyW2V2ZW50LnNlbGVjdGlvbnNBZnRlci5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgICAgICBhbm5vdGF0aW9uczogZnJvbUhpc3Rvcnkub2YoeyBzaWRlLCByZXN0OiBwb3BTZWxlY3Rpb24oYnJhbmNoKSB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWV2ZW50LmNoYW5nZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHJlc3QgPSBicmFuY2gubGVuZ3RoID09IDEgPyBub25lIDogYnJhbmNoLnNsaWNlKDAsIGJyYW5jaC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIGlmIChldmVudC5tYXBwZWQpXG4gICAgICAgICAgICAgICAgcmVzdCA9IGFkZE1hcHBpbmdUb0JyYW5jaChyZXN0LCBldmVudC5tYXBwZWQpO1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgY2hhbmdlczogZXZlbnQuY2hhbmdlcyxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb246IGV2ZW50LnN0YXJ0U2VsZWN0aW9uLFxuICAgICAgICAgICAgICAgIGVmZmVjdHM6IGV2ZW50LmVmZmVjdHMsXG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbnM6IGZyb21IaXN0b3J5Lm9mKHsgc2lkZSwgcmVzdCB9KSxcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbkhpc3RvcnlTdGF0ZS5lbXB0eSA9IG5ldyBIaXN0b3J5U3RhdGUobm9uZSwgbm9uZSk7XG4vKipcbkRlZmF1bHQga2V5IGJpbmRpbmdzIGZvciB0aGUgdW5kbyBoaXN0b3J5LlxuXG4tIE1vZC16OiBbYHVuZG9gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2hpc3RvcnkudW5kbykuXG4tIE1vZC15IChNb2QtU2hpZnQteiBvbiBtYWNPUyk6IFtgcmVkb2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jaGlzdG9yeS5yZWRvKS5cbi0gTW9kLXU6IFtgdW5kb1NlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jaGlzdG9yeS51bmRvU2VsZWN0aW9uKS5cbi0gQWx0LXUgKE1vZC1TaGlmdC11IG9uIG1hY09TKTogW2ByZWRvU2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNoaXN0b3J5LnJlZG9TZWxlY3Rpb24pLlxuKi9cbmNvbnN0IGhpc3RvcnlLZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiTW9kLXpcIiwgcnVuOiB1bmRvLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIk1vZC15XCIsIG1hYzogXCJNb2QtU2hpZnQtelwiLCBydW46IHJlZG8sIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiTW9kLXVcIiwgcnVuOiB1bmRvU2VsZWN0aW9uLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIkFsdC11XCIsIG1hYzogXCJNb2QtU2hpZnQtdVwiLCBydW46IHJlZG9TZWxlY3Rpb24sIHByZXZlbnREZWZhdWx0OiB0cnVlIH1cbl07XG5cbmV4cG9ydHMuaGlzdG9yeSA9IGhpc3Rvcnk7XG5leHBvcnRzLmhpc3RvcnlGaWVsZCA9IGhpc3RvcnlGaWVsZDtcbmV4cG9ydHMuaGlzdG9yeUtleW1hcCA9IGhpc3RvcnlLZXltYXA7XG5leHBvcnRzLmludmVydGVkRWZmZWN0cyA9IGludmVydGVkRWZmZWN0cztcbmV4cG9ydHMuaXNvbGF0ZUhpc3RvcnkgPSBpc29sYXRlSGlzdG9yeTtcbmV4cG9ydHMucmVkbyA9IHJlZG87XG5leHBvcnRzLnJlZG9EZXB0aCA9IHJlZG9EZXB0aDtcbmV4cG9ydHMucmVkb1NlbGVjdGlvbiA9IHJlZG9TZWxlY3Rpb247XG5leHBvcnRzLnVuZG8gPSB1bmRvO1xuZXhwb3J0cy51bmRvRGVwdGggPSB1bmRvRGVwdGg7XG5leHBvcnRzLnVuZG9TZWxlY3Rpb24gPSB1bmRvU2VsZWN0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgbGV6ZXJUcmVlID0gcmVxdWlyZSgnbGV6ZXItdHJlZScpO1xudmFyIHRleHQgPSByZXF1aXJlKCdAY29kZW1pcnJvci90ZXh0Jyk7XG52YXIgc3RhdGUgPSByZXF1aXJlKCdAY29kZW1pcnJvci9zdGF0ZScpO1xudmFyIHZpZXcgPSByZXF1aXJlKCdAY29kZW1pcnJvci92aWV3Jyk7XG5cbi8qKlxuTm9kZSBwcm9wIHN0b3JlZCBpbiBhIGdyYW1tYXIncyB0b3Agc3ludGF4IG5vZGUgdG8gcHJvdmlkZSB0aGVcbmZhY2V0IHRoYXQgc3RvcmVzIGxhbmd1YWdlIGRhdGEgZm9yIHRoYXQgbGFuZ3VhZ2UuXG4qL1xuY29uc3QgbGFuZ3VhZ2VEYXRhUHJvcCA9IG5ldyBsZXplclRyZWUuTm9kZVByb3AoKTtcbi8qKlxuSGVscGVyIGZ1bmN0aW9uIHRvIGRlZmluZSBhIGZhY2V0ICh0byBiZSBhZGRlZCB0byB0aGUgdG9wIHN5bnRheFxubm9kZShzKSBmb3IgYSBsYW5ndWFnZSB2aWFcbltgbGFuZ3VhZ2VEYXRhUHJvcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UubGFuZ3VhZ2VEYXRhUHJvcCkpLCB0aGF0IHdpbGwgYmVcbnVzZWQgdG8gYXNzb2NpYXRlIGxhbmd1YWdlIGRhdGEgd2l0aCB0aGUgbGFuZ3VhZ2UuIFlvdVxucHJvYmFibHkgb25seSBuZWVkIHRoaXMgd2hlbiBzdWJjbGFzc2luZ1xuW2BMYW5ndWFnZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTGFuZ3VhZ2UpLlxuKi9cbmZ1bmN0aW9uIGRlZmluZUxhbmd1YWdlRmFjZXQoYmFzZURhdGEpIHtcbiAgICByZXR1cm4gc3RhdGUuRmFjZXQuZGVmaW5lKHtcbiAgICAgICAgY29tYmluZTogYmFzZURhdGEgPyB2YWx1ZXMgPT4gdmFsdWVzLmNvbmNhdChiYXNlRGF0YSkgOiB1bmRlZmluZWRcbiAgICB9KTtcbn1cbi8qKlxuQSBsYW5ndWFnZSBvYmplY3QgbWFuYWdlcyBwYXJzaW5nIGFuZCBwZXItbGFuZ3VhZ2VcblttZXRhZGF0YV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5sYW5ndWFnZURhdGFBdCkuIFBhcnNlIGRhdGEgaXNcbm1hbmFnZWQgYXMgYSBbTGV6ZXJdKGh0dHBzOi8vbGV6ZXIuY29kZW1pcnJvci5uZXQpIHRyZWUuIFlvdSdsbFxud2FudCB0byBzdWJjbGFzcyB0aGlzIGNsYXNzIGZvciBjdXN0b20gcGFyc2Vycywgb3IgdXNlIHRoZVxuW2BMZXplckxhbmd1YWdlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MZXplckxhbmd1YWdlKSBvclxuW2BTdHJlYW1MYW5ndWFnZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RyZWFtLXBhcnNlci5TdHJlYW1MYW5ndWFnZSkgYWJzdHJhY3Rpb25zIGZvclxuW0xlemVyXShodHRwczovL2xlemVyLmNvZGVtaXJyb3IubmV0Lykgb3Igc3RyZWFtIHBhcnNlcnMuXG4qL1xuY2xhc3MgTGFuZ3VhZ2Uge1xuICAgIC8qKlxuICAgIENvbnN0cnVjdCBhIGxhbmd1YWdlIG9iamVjdC4gWW91IHVzdWFsbHkgZG9uJ3QgbmVlZCB0byBpbnZva2VcbiAgICB0aGlzIGRpcmVjdGx5LiBCdXQgd2hlbiB5b3UgZG8sIG1ha2Ugc3VyZSB5b3UgdXNlXG4gICAgW2BkZWZpbmVMYW5ndWFnZUZhY2V0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5kZWZpbmVMYW5ndWFnZUZhY2V0KSB0byBjcmVhdGVcbiAgICB0aGUgZmlyc3QgYXJndW1lbnQuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgW2xhbmd1YWdlIGRhdGFdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUubGFuZ3VhZ2VEYXRhQXQpIGRhdGFcbiAgICBmYWNldCB1c2VkIGZvciB0aGlzIGxhbmd1YWdlLlxuICAgICovXG4gICAgZGF0YSwgcGFyc2VyLCBcbiAgICAvKipcbiAgICBUaGUgbm9kZSB0eXBlIG9mIHRoZSB0b3Agbm9kZSBvZiB0cmVlcyBwcm9kdWNlZCBieSB0aGlzIHBhcnNlci5cbiAgICAqL1xuICAgIHRvcE5vZGUsIGV4dHJhRXh0ZW5zaW9ucyA9IFtdKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMudG9wTm9kZSA9IHRvcE5vZGU7XG4gICAgICAgIC8vIEtsdWRnZSB0byBkZWZpbmUgRWRpdG9yU3RhdGUudHJlZSBhcyBhIGRlYnVnZ2luZyBoZWxwZXIsXG4gICAgICAgIC8vIHdpdGhvdXQgdGhlIEVkaXRvclN0YXRlIHBhY2thZ2UgYWN0dWFsbHkga25vd2luZyBhYm91dFxuICAgICAgICAvLyBsYW5ndWFnZXMgYW5kIGxlemVyIHRyZWVzLlxuICAgICAgICBpZiAoIXN0YXRlLkVkaXRvclN0YXRlLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShcInRyZWVcIikpXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3RhdGUuRWRpdG9yU3RhdGUucHJvdG90eXBlLCBcInRyZWVcIiwgeyBnZXQoKSB7IHJldHVybiBzeW50YXhUcmVlKHRoaXMpOyB9IH0pO1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5leHRlbnNpb24gPSBbXG4gICAgICAgICAgICBsYW5ndWFnZS5vZih0aGlzKSxcbiAgICAgICAgICAgIHN0YXRlLkVkaXRvclN0YXRlLmxhbmd1YWdlRGF0YS5vZigoc3RhdGUsIHBvcykgPT4gc3RhdGUuZmFjZXQobGFuZ3VhZ2VEYXRhRmFjZXRBdChzdGF0ZSwgcG9zKSkpXG4gICAgICAgIF0uY29uY2F0KGV4dHJhRXh0ZW5zaW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFF1ZXJ5IHdoZXRoZXIgdGhpcyBsYW5ndWFnZSBpcyBhY3RpdmUgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgaXNBY3RpdmVBdChzdGF0ZSwgcG9zKSB7XG4gICAgICAgIHJldHVybiBsYW5ndWFnZURhdGFGYWNldEF0KHN0YXRlLCBwb3MpID09IHRoaXMuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgZG9jdW1lbnQgcmVnaW9ucyB0aGF0IHdlcmUgcGFyc2VkIHVzaW5nIHRoaXMgbGFuZ3VhZ2UuXG4gICAgVGhlIHJldHVybmVkIHJlZ2lvbnMgd2lsbCBfaW5jbHVkZV8gYW55IG5lc3RlZCBsYW5ndWFnZXMgcm9vdGVkXG4gICAgaW4gdGhpcyBsYW5ndWFnZSwgd2hlbiB0aG9zZSBleGlzdC5cbiAgICAqL1xuICAgIGZpbmRSZWdpb25zKHN0YXRlKSB7XG4gICAgICAgIGxldCBsYW5nID0gc3RhdGUuZmFjZXQobGFuZ3VhZ2UpO1xuICAgICAgICBpZiAoKGxhbmcgPT09IG51bGwgfHwgbGFuZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFuZy5kYXRhKSA9PSB0aGlzLmRhdGEpXG4gICAgICAgICAgICByZXR1cm4gW3sgZnJvbTogMCwgdG86IHN0YXRlLmRvYy5sZW5ndGggfV07XG4gICAgICAgIGlmICghbGFuZyB8fCAhbGFuZy5hbGxvd3NOZXN0aW5nKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIHN5bnRheFRyZWUoc3RhdGUpLml0ZXJhdGUoe1xuICAgICAgICAgICAgZW50ZXI6ICh0eXBlLCBmcm9tLCB0bykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlLmlzVG9wICYmIHR5cGUucHJvcChsYW5ndWFnZURhdGFQcm9wKSA9PSB0aGlzLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBmcm9tLCB0byB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBsYW5ndWFnZSBhbGxvd3MgbmVzdGVkIGxhbmd1YWdlcy4gVGhlXG4gICAgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5zIHRydWUuXG4gICAgKi9cbiAgICBnZXQgYWxsb3dzTmVzdGluZygpIHsgcmV0dXJuIHRydWU7IH1cbiAgICAvKipcbiAgICBVc2UgdGhpcyBsYW5ndWFnZSB0byBwYXJzZSB0aGUgZ2l2ZW4gc3RyaW5nIGludG8gYSB0cmVlLlxuICAgICovXG4gICAgcGFyc2VTdHJpbmcoY29kZSkge1xuICAgICAgICBsZXQgZG9jID0gdGV4dC5UZXh0Lm9mKGNvZGUuc3BsaXQoXCJcXG5cIikpO1xuICAgICAgICBsZXQgcGFyc2UgPSB0aGlzLnBhcnNlci5zdGFydFBhcnNlKG5ldyBEb2NJbnB1dChkb2MpLCAwLCBuZXcgRWRpdG9yUGFyc2VDb250ZXh0KHRoaXMucGFyc2VyLCBzdGF0ZS5FZGl0b3JTdGF0ZS5jcmVhdGUoeyBkb2MgfSksIFtdLCBsZXplclRyZWUuVHJlZS5lbXB0eSwgeyBmcm9tOiAwLCB0bzogY29kZS5sZW5ndGggfSwgW10sIG51bGwpKTtcbiAgICAgICAgbGV0IHRyZWU7XG4gICAgICAgIHdoaWxlICghKHRyZWUgPSBwYXJzZS5hZHZhbmNlKCkpKSB7IH1cbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgfVxufVxuLyoqXG5AaW50ZXJuYWxcbiovXG5MYW5ndWFnZS5zZXRTdGF0ZSA9IHN0YXRlLlN0YXRlRWZmZWN0LmRlZmluZSgpO1xuZnVuY3Rpb24gbGFuZ3VhZ2VEYXRhRmFjZXRBdChzdGF0ZSwgcG9zKSB7XG4gICAgbGV0IHRvcExhbmcgPSBzdGF0ZS5mYWNldChsYW5ndWFnZSk7XG4gICAgaWYgKCF0b3BMYW5nKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAoIXRvcExhbmcuYWxsb3dzTmVzdGluZylcbiAgICAgICAgcmV0dXJuIHRvcExhbmcuZGF0YTtcbiAgICBsZXQgdHJlZSA9IHN5bnRheFRyZWUoc3RhdGUpO1xuICAgIGxldCB0YXJnZXQgPSB0cmVlLnJlc29sdmUocG9zLCAtMSk7XG4gICAgd2hpbGUgKHRhcmdldCkge1xuICAgICAgICBsZXQgZmFjZXQgPSB0YXJnZXQudHlwZS5wcm9wKGxhbmd1YWdlRGF0YVByb3ApO1xuICAgICAgICBpZiAoZmFjZXQpXG4gICAgICAgICAgICByZXR1cm4gZmFjZXQ7XG4gICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiB0b3BMYW5nLmRhdGE7XG59XG4vKipcbkEgc3ViY2xhc3Mgb2YgW2BMYW5ndWFnZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTGFuZ3VhZ2UpIGZvciB1c2Ugd2l0aFxuW0xlemVyXShodHRwczovL2xlemVyLmNvZGVtaXJyb3IubmV0L2RvY3MvcmVmI2xlemVyLlBhcnNlcilcbnBhcnNlcnMuXG4qL1xuY2xhc3MgTGV6ZXJMYW5ndWFnZSBleHRlbmRzIExhbmd1YWdlIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBwYXJzZXIpIHtcbiAgICAgICAgc3VwZXIoZGF0YSwgcGFyc2VyLCBwYXJzZXIudG9wTm9kZSk7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBsYW5ndWFnZSBmcm9tIGEgcGFyc2VyLlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZShzcGVjKSB7XG4gICAgICAgIGxldCBkYXRhID0gZGVmaW5lTGFuZ3VhZ2VGYWNldChzcGVjLmxhbmd1YWdlRGF0YSk7XG4gICAgICAgIHJldHVybiBuZXcgTGV6ZXJMYW5ndWFnZShkYXRhLCBzcGVjLnBhcnNlci5jb25maWd1cmUoe1xuICAgICAgICAgICAgcHJvcHM6IFtsYW5ndWFnZURhdGFQcm9wLmFkZCh0eXBlID0+IHR5cGUuaXNUb3AgPyBkYXRhIDogdW5kZWZpbmVkKV1cbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgdGhpcyBsYW5ndWFnZSB3aXRoIGEgcmVjb25maWd1cmVkXG4gICAgdmVyc2lvbiBvZiBpdHMgcGFyc2VyLlxuICAgICovXG4gICAgY29uZmlndXJlKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMZXplckxhbmd1YWdlKHRoaXMuZGF0YSwgdGhpcy5wYXJzZXIuY29uZmlndXJlKG9wdGlvbnMpKTtcbiAgICB9XG4gICAgZ2V0IGFsbG93c05lc3RpbmcoKSB7IHJldHVybiB0aGlzLnBhcnNlci5oYXNOZXN0ZWQ7IH1cbn1cbi8qKlxuR2V0IHRoZSBzeW50YXggdHJlZSBmb3IgYSBzdGF0ZSwgd2hpY2ggaXMgdGhlIGN1cnJlbnQgKHBvc3NpYmx5XG5pbmNvbXBsZXRlKSBwYXJzZSB0cmVlIG9mIGFjdGl2ZSBbbGFuZ3VhZ2VdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTGFuZ3VhZ2UpLFxub3IgdGhlIGVtcHR5IHRyZWUgaWYgdGhlcmUgaXMgbm8gbGFuZ3VhZ2UgYXZhaWxhYmxlLlxuKi9cbmZ1bmN0aW9uIHN5bnRheFRyZWUoc3RhdGUpIHtcbiAgICBsZXQgZmllbGQgPSBzdGF0ZS5maWVsZChMYW5ndWFnZS5zdGF0ZSwgZmFsc2UpO1xuICAgIHJldHVybiBmaWVsZCA/IGZpZWxkLnRyZWUgOiBsZXplclRyZWUuVHJlZS5lbXB0eTtcbn1cbi8qKlxuVHJ5IHRvIGdldCBhIHBhcnNlIHRyZWUgdGhhdCBzcGFucyBhdCBsZWFzdCB1cCB0byBgdXB0b2AuIFRoZVxubWV0aG9kIHdpbGwgZG8gYXQgbW9zdCBgdGltZW91dGAgbWlsbGlzZWNvbmRzIG9mIHdvcmsgdG8gcGFyc2VcbnVwIHRvIHRoYXQgcG9pbnQgaWYgdGhlIHRyZWUgaXNuJ3QgYWxyZWFkeSBhdmFpbGFibGUuXG4qL1xuZnVuY3Rpb24gZW5zdXJlU3ludGF4VHJlZShzdGF0ZSwgdXB0bywgdGltZW91dCA9IDUwKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBwYXJzZSA9IChfYSA9IHN0YXRlLmZpZWxkKExhbmd1YWdlLnN0YXRlLCBmYWxzZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250ZXh0O1xuICAgIHJldHVybiAhcGFyc2UgPyBudWxsIDogcGFyc2UudHJlZS5sZW5ndGggPj0gdXB0byB8fCBwYXJzZS53b3JrKHRpbWVvdXQsIHVwdG8pID8gcGFyc2UudHJlZSA6IG51bGw7XG59XG4vLyBMZXplci1zdHlsZSBJbnB1dCBvYmplY3QgZm9yIGEgVGV4dCBkb2N1bWVudC5cbmNsYXNzIERvY0lucHV0IHtcbiAgICBjb25zdHJ1Y3Rvcihkb2MsIGxlbmd0aCA9IGRvYy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0aGlzLmN1cnNvclBvcyA9IDA7XG4gICAgICAgIHRoaXMuc3RyaW5nID0gXCJcIjtcbiAgICAgICAgdGhpcy5wcmV2U3RyaW5nID0gXCJcIjtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBkb2MuaXRlcigpO1xuICAgIH1cbiAgICBzeW5jVG8ocG9zKSB7XG4gICAgICAgIGlmIChwb3MgPCB0aGlzLmN1cnNvclBvcykgeyAvLyBSZXNldCB0aGUgY3Vyc29yIGlmIHdlIGhhdmUgdG8gZ28gYmFja1xuICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSB0aGlzLmRvYy5pdGVyKCk7XG4gICAgICAgICAgICB0aGlzLmN1cnNvclBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmV2U3RyaW5nID0gcG9zID09IHRoaXMuY3Vyc29yUG9zID8gdGhpcy5zdHJpbmcgOiBcIlwiO1xuICAgICAgICB0aGlzLnN0cmluZyA9IHRoaXMuY3Vyc29yLm5leHQocG9zIC0gdGhpcy5jdXJzb3JQb3MpLnZhbHVlO1xuICAgICAgICB0aGlzLmN1cnNvclBvcyA9IHBvcyArIHRoaXMuc3RyaW5nLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3Vyc29yUG9zIC0gdGhpcy5zdHJpbmcubGVuZ3RoO1xuICAgIH1cbiAgICBnZXQocG9zKSB7XG4gICAgICAgIGlmIChwb3MgPj0gdGhpcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGxldCBzdHJpbmdTdGFydCA9IHRoaXMuY3Vyc29yUG9zIC0gdGhpcy5zdHJpbmcubGVuZ3RoO1xuICAgICAgICBpZiAocG9zIDwgc3RyaW5nU3RhcnQgfHwgcG9zID49IHRoaXMuY3Vyc29yUG9zKSB7XG4gICAgICAgICAgICBpZiAocG9zIDwgc3RyaW5nU3RhcnQgJiYgcG9zID49IHN0cmluZ1N0YXJ0IC0gdGhpcy5wcmV2U3RyaW5nLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcmV2U3RyaW5nLmNoYXJDb2RlQXQocG9zIC0gKHN0cmluZ1N0YXJ0IC0gdGhpcy5wcmV2U3RyaW5nLmxlbmd0aCkpO1xuICAgICAgICAgICAgc3RyaW5nU3RhcnQgPSB0aGlzLnN5bmNUbyhwb3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmluZy5jaGFyQ29kZUF0KHBvcyAtIHN0cmluZ1N0YXJ0KTtcbiAgICB9XG4gICAgbGluZUFmdGVyKHBvcykge1xuICAgICAgICBpZiAocG9zID49IHRoaXMubGVuZ3RoIHx8IHBvcyA8IDApXG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgbGV0IHN0cmluZ1N0YXJ0ID0gdGhpcy5jdXJzb3JQb3MgLSB0aGlzLnN0cmluZy5sZW5ndGg7XG4gICAgICAgIGlmIChwb3MgPCBzdHJpbmdTdGFydCB8fCBwb3MgPj0gdGhpcy5jdXJzb3JQb3MpXG4gICAgICAgICAgICBzdHJpbmdTdGFydCA9IHRoaXMuc3luY1RvKHBvcyk7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnNvci5saW5lQnJlYWsgPyBcIlwiIDogdGhpcy5zdHJpbmcuc2xpY2UocG9zIC0gc3RyaW5nU3RhcnQsIE1hdGgubWluKHRoaXMubGVuZ3RoIC0gc3RyaW5nU3RhcnQsIHRoaXMuc3RyaW5nLmxlbmd0aCkpO1xuICAgIH1cbiAgICByZWFkKGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBzdHJpbmdTdGFydCA9IHRoaXMuY3Vyc29yUG9zIC0gdGhpcy5zdHJpbmcubGVuZ3RoO1xuICAgICAgICBpZiAoZnJvbSA8IHN0cmluZ1N0YXJ0IHx8IHRvID49IHRoaXMuY3Vyc29yUG9zKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9jLnNsaWNlU3RyaW5nKGZyb20sIHRvKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKGZyb20gLSBzdHJpbmdTdGFydCwgdG8gLSBzdHJpbmdTdGFydCk7XG4gICAgfVxuICAgIGNsaXAoYXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEb2NJbnB1dCh0aGlzLmRvYywgYXQpO1xuICAgIH1cbn1cbi8qKlxuQSBwYXJzZSBjb250ZXh0IHByb3ZpZGVkIHRvIHBhcnNlcnMgd29ya2luZyBvbiB0aGUgZWRpdG9yIGNvbnRlbnQuXG4qL1xuY2xhc3MgRWRpdG9yUGFyc2VDb250ZXh0IHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgXG4gICAgLyoqXG4gICAgVGhlIGN1cnJlbnQgZWRpdG9yIHN0YXRlLlxuICAgICovXG4gICAgc3RhdGUsIFxuICAgIC8qKlxuICAgIFRyZWUgZnJhZ21lbnRzIHRoYXQgY2FuIGJlIHJldXNlZCBieSBpbmNyZW1lbnRhbCByZS1wYXJzZXMuXG4gICAgKi9cbiAgICBmcmFnbWVudHMgPSBbXSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0cmVlLCBcbiAgICAvKipcbiAgICBUaGUgY3VycmVudCBlZGl0b3Igdmlld3BvcnQgKG9yIHNvbWUgb3ZlcmFwcHJveGltYXRpb25cbiAgICB0aGVyZW9mKS4gSW50ZW5kZWQgdG8gYmUgdXNlZCBmb3Igb3Bwb3J0dW5pc3RpY2FsbHkgYXZvaWRpbmdcbiAgICB3b3JrIChpbiB3aGljaCBjYXNlXG4gICAgW2Bza2lwVW50aWxJblZpZXdgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkVkaXRvclBhcnNlQ29udGV4dC5za2lwVW50aWxJblZpZXcpXG4gICAgc2hvdWxkIGJlIGNhbGxlZCB0byBtYWtlIHN1cmUgdGhlIHBhcnNlciBpcyByZXN0YXJ0ZWQgd2hlbiB0aGVcbiAgICBza2lwcGVkIHJlZ2lvbiBiZWNvbWVzIHZpc2libGUpLlxuICAgICovXG4gICAgdmlld3BvcnQsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2tpcHBlZCwgXG4gICAgLyoqXG4gICAgVGhpcyBpcyB3aGVyZSBza2lwcGluZyBwYXJzZXJzIGNhbiByZWdpc3RlciBhIHByb21pc2UgdGhhdCxcbiAgICB3aGVuIHJlc29sdmVkLCB3aWxsIHNjaGVkdWxlIGEgbmV3IHBhcnNlLiBJdCBpcyBjbGVhcmVkIHdoZW5cbiAgICB0aGUgcGFyc2Ugd29ya2VyIHBpY2tzIHVwIHRoZSBwcm9taXNlLiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNjaGVkdWxlT24pIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHM7XG4gICAgICAgIHRoaXMudHJlZSA9IHRyZWU7XG4gICAgICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICAgICAgdGhpcy5za2lwcGVkID0gc2tpcHBlZDtcbiAgICAgICAgdGhpcy5zY2hlZHVsZU9uID0gc2NoZWR1bGVPbjtcbiAgICAgICAgdGhpcy5wYXJzZSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy50ZW1wU2tpcHBlZCA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHdvcmsodGltZSwgdXB0bykge1xuICAgICAgICBpZiAodGhpcy50cmVlICE9IGxlemVyVHJlZS5UcmVlLmVtcHR5ICYmICh1cHRvID09IG51bGwgPyB0aGlzLnRyZWUubGVuZ3RoID09IHRoaXMuc3RhdGUuZG9jLmxlbmd0aCA6IHRoaXMudHJlZS5sZW5ndGggPj0gdXB0bykpIHtcbiAgICAgICAgICAgIHRoaXMudGFrZVRyZWUoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5wYXJzZSlcbiAgICAgICAgICAgIHRoaXMucGFyc2UgPSB0aGlzLnBhcnNlci5zdGFydFBhcnNlKG5ldyBEb2NJbnB1dCh0aGlzLnN0YXRlLmRvYyksIDAsIHRoaXMpO1xuICAgICAgICBsZXQgZW5kVGltZSA9IERhdGUubm93KCkgKyB0aW1lO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgZG9uZSA9IHRoaXMucGFyc2UuYWR2YW5jZSgpO1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZyYWdtZW50cyA9IHRoaXMud2l0aG91dFRlbXBTa2lwcGVkKGxlemVyVHJlZS5UcmVlRnJhZ21lbnQuYWRkVHJlZShkb25lKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy50cmVlID0gZG9uZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHVwdG8gIT0gbnVsbCAmJiB0aGlzLnBhcnNlLnBvcyA+PSB1cHRvKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50YWtlVHJlZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKERhdGUubm93KCkgPiBlbmRUaW1lKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRha2VUcmVlKCkge1xuICAgICAgICBpZiAodGhpcy5wYXJzZSAmJiB0aGlzLnBhcnNlLnBvcyA+IHRoaXMudHJlZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMudHJlZSA9IHRoaXMucGFyc2UuZm9yY2VGaW5pc2goKTtcbiAgICAgICAgICAgIHRoaXMuZnJhZ21lbnRzID0gdGhpcy53aXRob3V0VGVtcFNraXBwZWQobGV6ZXJUcmVlLlRyZWVGcmFnbWVudC5hZGRUcmVlKHRoaXMudHJlZSwgdGhpcy5mcmFnbWVudHMsIHRydWUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3aXRob3V0VGVtcFNraXBwZWQoZnJhZ21lbnRzKSB7XG4gICAgICAgIGZvciAobGV0IHI7IHIgPSB0aGlzLnRlbXBTa2lwcGVkLnBvcCgpOylcbiAgICAgICAgICAgIGZyYWdtZW50cyA9IGN1dEZyYWdtZW50cyhmcmFnbWVudHMsIHIuZnJvbSwgci50byk7XG4gICAgICAgIHJldHVybiBmcmFnbWVudHM7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY2hhbmdlcyhjaGFuZ2VzLCBuZXdTdGF0ZSkge1xuICAgICAgICBsZXQgeyBmcmFnbWVudHMsIHRyZWUsIHZpZXdwb3J0LCBza2lwcGVkIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLnRha2VUcmVlKCk7XG4gICAgICAgIGlmICghY2hhbmdlcy5lbXB0eSkge1xuICAgICAgICAgICAgbGV0IHJhbmdlcyA9IFtdO1xuICAgICAgICAgICAgY2hhbmdlcy5pdGVyQ2hhbmdlZFJhbmdlcygoZnJvbUEsIHRvQSwgZnJvbUIsIHRvQikgPT4gcmFuZ2VzLnB1c2goeyBmcm9tQSwgdG9BLCBmcm9tQiwgdG9CIH0pKTtcbiAgICAgICAgICAgIGZyYWdtZW50cyA9IGxlemVyVHJlZS5UcmVlRnJhZ21lbnQuYXBwbHlDaGFuZ2VzKGZyYWdtZW50cywgcmFuZ2VzKTtcbiAgICAgICAgICAgIHRyZWUgPSBsZXplclRyZWUuVHJlZS5lbXB0eTtcbiAgICAgICAgICAgIHZpZXdwb3J0ID0geyBmcm9tOiBjaGFuZ2VzLm1hcFBvcyh2aWV3cG9ydC5mcm9tLCAtMSksIHRvOiBjaGFuZ2VzLm1hcFBvcyh2aWV3cG9ydC50bywgMSkgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNraXBwZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgc2tpcHBlZCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHIgb2YgdGhpcy5za2lwcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmcm9tID0gY2hhbmdlcy5tYXBQb3Moci5mcm9tLCAxKSwgdG8gPSBjaGFuZ2VzLm1hcFBvcyhyLnRvLCAtMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmcm9tIDwgdG8pXG4gICAgICAgICAgICAgICAgICAgICAgICBza2lwcGVkLnB1c2goeyBmcm9tLCB0byB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBFZGl0b3JQYXJzZUNvbnRleHQodGhpcy5wYXJzZXIsIG5ld1N0YXRlLCBmcmFnbWVudHMsIHRyZWUsIHZpZXdwb3J0LCBza2lwcGVkLCB0aGlzLnNjaGVkdWxlT24pO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHVwZGF0ZVZpZXdwb3J0KHZpZXdwb3J0KSB7XG4gICAgICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICAgICAgbGV0IHN0YXJ0TGVuID0gdGhpcy5za2lwcGVkLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNraXBwZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSB0aGlzLnNraXBwZWRbaV07XG4gICAgICAgICAgICBpZiAoZnJvbSA8IHZpZXdwb3J0LnRvICYmIHRvID4gdmlld3BvcnQuZnJvbSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZnJhZ21lbnRzID0gY3V0RnJhZ21lbnRzKHRoaXMuZnJhZ21lbnRzLCBmcm9tLCB0byk7XG4gICAgICAgICAgICAgICAgdGhpcy5za2lwcGVkLnNwbGljZShpLS0sIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNraXBwZWQubGVuZ3RoIDwgc3RhcnRMZW47XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLnRha2VUcmVlKCk7XG4gICAgICAgICAgICB0aGlzLnBhcnNlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBOb3RpZnkgdGhlIHBhcnNlIHNjaGVkdWxlciB0aGF0IHRoZSBnaXZlbiByZWdpb24gd2FzIHNraXBwZWRcbiAgICBiZWNhdXNlIGl0IHdhc24ndCBpbiB2aWV3LCBhbmQgdGhlIHBhcnNlIHNob3VsZCBiZSByZXN0YXJ0ZWRcbiAgICB3aGVuIGl0IGNvbWVzIGludG8gdmlldy5cbiAgICAqL1xuICAgIHNraXBVbnRpbEluVmlldyhmcm9tLCB0bykge1xuICAgICAgICB0aGlzLnNraXBwZWQucHVzaCh7IGZyb20sIHRvIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIGEgcGFyc2VyIGludGVuZGVkIHRvIGJlIHVzZWQgYXMgcGxhY2Vob2xkZXIgd2hlblxuICAgIGFzeW5jaHJvbm91c2x5IGxvYWRpbmcgYSBuZXN0ZWQgcGFyc2VyLiBJdCdsbCBza2lwIGl0cyBpbnB1dCBhbmRcbiAgICBtYXJrIGl0IGFzIG5vdC1yZWFsbHktcGFyc2VkLCBzbyB0aGF0IHRoZSBuZXh0IHVwZGF0ZSB3aWxsIHBhcnNlXG4gICAgaXQgYWdhaW4uXG4gICAgXG4gICAgV2hlbiBgdW50aWxgIGlzIGdpdmVuLCBhIHJlcGFyc2Ugd2lsbCBiZSBzY2hlZHVsZWQgd2hlbiB0aGF0XG4gICAgcHJvbWlzZSByZXNvbHZlcy5cbiAgICAqL1xuICAgIHN0YXRpYyBnZXRTa2lwcGluZ1BhcnNlcih1bnRpbCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhcnRQYXJzZShpbnB1dCwgc3RhcnRQb3MsIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBwb3M6IHN0YXJ0UG9zLFxuICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVjeCA9IGNvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBlY3gudGVtcFNraXBwZWQucHVzaCh7IGZyb206IHN0YXJ0UG9zLCB0bzogaW5wdXQubGVuZ3RoIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVudGlsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVjeC5zY2hlZHVsZU9uID0gZWN4LnNjaGVkdWxlT24gPyBQcm9taXNlLmFsbChbZWN4LnNjaGVkdWxlT24sIHVudGlsXSkgOiB1bnRpbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9zID0gaW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBsZXplclRyZWUuVHJlZShsZXplclRyZWUuTm9kZVR5cGUubm9uZSwgW10sIFtdLCBpbnB1dC5sZW5ndGggLSBzdGFydFBvcyk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGZvcmNlRmluaXNoKCkgeyByZXR1cm4gdGhpcy5hZHZhbmNlKCk7IH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG1vdmVkUGFzdChwb3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZS5sZW5ndGggPCBwb3MgJiYgdGhpcy5wYXJzZSAmJiB0aGlzLnBhcnNlLnBvcyA+PSBwb3M7XG4gICAgfVxufVxuLyoqXG5GSVhNRSBiYWNrd2FyZHMgY29tcGF0aWJsZSBzaGltLCByZW1vdmUgb24gbmV4dCBtYWpvciBAaW50ZXJuYWxcbiovXG5FZGl0b3JQYXJzZUNvbnRleHQuc2tpcHBpbmdQYXJzZXIgPSBFZGl0b3JQYXJzZUNvbnRleHQuZ2V0U2tpcHBpbmdQYXJzZXIoKTtcbmZ1bmN0aW9uIGN1dEZyYWdtZW50cyhmcmFnbWVudHMsIGZyb20sIHRvKSB7XG4gICAgcmV0dXJuIGxlemVyVHJlZS5UcmVlRnJhZ21lbnQuYXBwbHlDaGFuZ2VzKGZyYWdtZW50cywgW3sgZnJvbUE6IGZyb20sIHRvQTogdG8sIGZyb21COiBmcm9tLCB0b0I6IHRvIH1dKTtcbn1cbmNsYXNzIExhbmd1YWdlU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vIEEgbXV0YWJsZSBwYXJzZSBzdGF0ZSB0aGF0IGlzIHVzZWQgdG8gcHJlc2VydmUgd29yayBkb25lIGR1cmluZ1xuICAgIC8vIHRoZSBsaWZldGltZSBvZiBhIHN0YXRlIHdoZW4gbW92aW5nIHRvIHRoZSBuZXh0IHN0YXRlLlxuICAgIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy50cmVlID0gY29udGV4dC50cmVlO1xuICAgIH1cbiAgICBhcHBseSh0cikge1xuICAgICAgICBpZiAoIXRyLmRvY0NoYW5nZWQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgbGV0IG5ld0N4ID0gdGhpcy5jb250ZXh0LmNoYW5nZXModHIuY2hhbmdlcywgdHIuc3RhdGUpO1xuICAgICAgICAvLyBJZiB0aGUgcHJldmlvdXMgcGFyc2Ugd2Fzbid0IGRvbmUsIGdvIGZvcndhcmQgb25seSB1cCB0byBpdHNcbiAgICAgICAgLy8gZW5kIHBvc2l0aW9uIG9yIHRoZSBlbmQgb2YgdGhlIHZpZXdwb3J0LCB0byBhdm9pZCBzbG93aW5nIGRvd25cbiAgICAgICAgLy8gc3RhdGUgdXBkYXRlcyB3aXRoIHBhcnNlIHdvcmsgYmV5b25kIHRoZSB2aWV3cG9ydC5cbiAgICAgICAgbGV0IHVwdG8gPSB0aGlzLmNvbnRleHQudHJlZS5sZW5ndGggPT0gdHIuc3RhcnRTdGF0ZS5kb2MubGVuZ3RoID8gdW5kZWZpbmVkXG4gICAgICAgICAgICA6IE1hdGgubWF4KHRyLmNoYW5nZXMubWFwUG9zKHRoaXMuY29udGV4dC50cmVlLmxlbmd0aCksIG5ld0N4LnZpZXdwb3J0LnRvKTtcbiAgICAgICAgaWYgKCFuZXdDeC53b3JrKDI1IC8qIEFwcGx5ICovLCB1cHRvKSlcbiAgICAgICAgICAgIG5ld0N4LnRha2VUcmVlKCk7XG4gICAgICAgIHJldHVybiBuZXcgTGFuZ3VhZ2VTdGF0ZShuZXdDeCk7XG4gICAgfVxuICAgIHN0YXRpYyBpbml0KHN0YXRlKSB7XG4gICAgICAgIGxldCBwYXJzZVN0YXRlID0gbmV3IEVkaXRvclBhcnNlQ29udGV4dChzdGF0ZS5mYWNldChsYW5ndWFnZSkucGFyc2VyLCBzdGF0ZSwgW10sIGxlemVyVHJlZS5UcmVlLmVtcHR5LCB7IGZyb206IDAsIHRvOiBzdGF0ZS5kb2MubGVuZ3RoIH0sIFtdLCBudWxsKTtcbiAgICAgICAgaWYgKCFwYXJzZVN0YXRlLndvcmsoMjUgLyogQXBwbHkgKi8pKVxuICAgICAgICAgICAgcGFyc2VTdGF0ZS50YWtlVHJlZSgpO1xuICAgICAgICByZXR1cm4gbmV3IExhbmd1YWdlU3RhdGUocGFyc2VTdGF0ZSk7XG4gICAgfVxufVxuTGFuZ3VhZ2Uuc3RhdGUgPSBzdGF0ZS5TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlOiBMYW5ndWFnZVN0YXRlLmluaXQsXG4gICAgdXBkYXRlKHZhbHVlLCB0cikge1xuICAgICAgICBmb3IgKGxldCBlIG9mIHRyLmVmZmVjdHMpXG4gICAgICAgICAgICBpZiAoZS5pcyhMYW5ndWFnZS5zZXRTdGF0ZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGUudmFsdWU7XG4gICAgICAgIGlmICh0ci5zdGFydFN0YXRlLmZhY2V0KGxhbmd1YWdlKSAhPSB0ci5zdGF0ZS5mYWNldChsYW5ndWFnZSkpXG4gICAgICAgICAgICByZXR1cm4gTGFuZ3VhZ2VTdGF0ZS5pbml0KHRyLnN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmFwcGx5KHRyKTtcbiAgICB9XG59KTtcbmxldCByZXF1ZXN0SWRsZSA9IHR5cGVvZiB3aW5kb3cgIT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cucmVxdWVzdElkbGVDYWxsYmFjayB8fFxuICAgICgoY2FsbGJhY2ssIHsgdGltZW91dCB9KSA9PiBzZXRUaW1lb3V0KGNhbGxiYWNrLCB0aW1lb3V0KSk7XG5sZXQgY2FuY2VsSWRsZSA9IHR5cGVvZiB3aW5kb3cgIT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuY2FuY2VsSWRsZUNhbGxiYWNrIHx8IGNsZWFyVGltZW91dDtcbmNvbnN0IHBhcnNlV29ya2VyID0gdmlldy5WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyBQYXJzZVdvcmtlciB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLndvcmtpbmcgPSAtMTtcbiAgICAgICAgLy8gRW5kIG9mIHRoZSBjdXJyZW50IHRpbWUgY2h1bmtcbiAgICAgICAgdGhpcy5jaHVua0VuZCA9IC0xO1xuICAgICAgICAvLyBNaWxsaXNlY29uZHMgb2YgYnVkZ2V0IGxlZnQgZm9yIHRoaXMgY2h1bmtcbiAgICAgICAgdGhpcy5jaHVua0J1ZGdldCA9IC0xO1xuICAgICAgICB0aGlzLndvcmsgPSB0aGlzLndvcmsuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZVdvcmsoKTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgY3ggPSB0aGlzLnZpZXcuc3RhdGUuZmllbGQoTGFuZ3VhZ2Uuc3RhdGUpLmNvbnRleHQ7XG4gICAgICAgIGlmICh1cGRhdGUudmlld3BvcnRDaGFuZ2VkKSB7XG4gICAgICAgICAgICBpZiAoY3gudXBkYXRlVmlld3BvcnQodXBkYXRlLnZpZXcudmlld3BvcnQpKVxuICAgICAgICAgICAgICAgIGN4LnJlc2V0KCk7XG4gICAgICAgICAgICBpZiAodGhpcy52aWV3LnZpZXdwb3J0LnRvID4gY3gudHJlZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVdvcmsoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlLmRvY0NoYW5nZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnZpZXcuaGFzRm9jdXMpXG4gICAgICAgICAgICAgICAgdGhpcy5jaHVua0J1ZGdldCArPSA1MCAvKiBDaGFuZ2VCb251cyAqLztcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVXb3JrKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGVja0FzeW5jU2NoZWR1bGUoY3gpO1xuICAgIH1cbiAgICBzY2hlZHVsZVdvcmsoZm9yY2UgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy53b3JraW5nID4gLTEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB0aGlzLnZpZXcsIGZpZWxkID0gc3RhdGUuZmllbGQoTGFuZ3VhZ2Uuc3RhdGUpO1xuICAgICAgICBpZiAoIWZvcmNlICYmIGZpZWxkLnRyZWUubGVuZ3RoID49IHN0YXRlLmRvYy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMud29ya2luZyA9IHJlcXVlc3RJZGxlKHRoaXMud29yaywgeyB0aW1lb3V0OiA1MDAgLyogUGF1c2UgKi8gfSk7XG4gICAgfVxuICAgIHdvcmsoZGVhZGxpbmUpIHtcbiAgICAgICAgdGhpcy53b3JraW5nID0gLTE7XG4gICAgICAgIGxldCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAodGhpcy5jaHVua0VuZCA8IG5vdyAmJiAodGhpcy5jaHVua0VuZCA8IDAgfHwgdGhpcy52aWV3Lmhhc0ZvY3VzKSkgeyAvLyBTdGFydCBhIG5ldyBjaHVua1xuICAgICAgICAgICAgdGhpcy5jaHVua0VuZCA9IG5vdyArIDMwMDAwIC8qIENodW5rVGltZSAqLztcbiAgICAgICAgICAgIHRoaXMuY2h1bmtCdWRnZXQgPSAzMDAwIC8qIENodW5rQnVkZ2V0ICovO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNodW5rQnVkZ2V0IDw9IDApXG4gICAgICAgICAgICByZXR1cm47IC8vIE5vIG1vcmUgYnVkZ2V0XG4gICAgICAgIGxldCB7IHN0YXRlLCB2aWV3cG9ydDogeyB0bzogdnBUbyB9IH0gPSB0aGlzLnZpZXcsIGZpZWxkID0gc3RhdGUuZmllbGQoTGFuZ3VhZ2Uuc3RhdGUpO1xuICAgICAgICBpZiAoZmllbGQudHJlZS5sZW5ndGggPj0gdnBUbyArIDEwMDAwMDAgLyogTWF4UGFyc2VBaGVhZCAqLylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHRpbWUgPSBNYXRoLm1pbih0aGlzLmNodW5rQnVkZ2V0LCBkZWFkbGluZSA/IE1hdGgubWF4KDI1IC8qIE1pblNsaWNlICovLCBkZWFkbGluZS50aW1lUmVtYWluaW5nKCkpIDogMTAwIC8qIFNsaWNlICovKTtcbiAgICAgICAgbGV0IGRvbmUgPSBmaWVsZC5jb250ZXh0LndvcmsodGltZSwgdnBUbyArIDEwMDAwMDAgLyogTWF4UGFyc2VBaGVhZCAqLyk7XG4gICAgICAgIHRoaXMuY2h1bmtCdWRnZXQgLT0gRGF0ZS5ub3coKSAtIG5vdztcbiAgICAgICAgaWYgKGRvbmUgfHwgdGhpcy5jaHVua0J1ZGdldCA8PSAwIHx8IGZpZWxkLmNvbnRleHQubW92ZWRQYXN0KHZwVG8pKSB7XG4gICAgICAgICAgICBmaWVsZC5jb250ZXh0LnRha2VUcmVlKCk7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBMYW5ndWFnZS5zZXRTdGF0ZS5vZihuZXcgTGFuZ3VhZ2VTdGF0ZShmaWVsZC5jb250ZXh0KSkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkb25lICYmIHRoaXMuY2h1bmtCdWRnZXQgPiAwKVxuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVdvcmsoKTtcbiAgICAgICAgdGhpcy5jaGVja0FzeW5jU2NoZWR1bGUoZmllbGQuY29udGV4dCk7XG4gICAgfVxuICAgIGNoZWNrQXN5bmNTY2hlZHVsZShjeCkge1xuICAgICAgICBpZiAoY3guc2NoZWR1bGVPbikge1xuICAgICAgICAgICAgY3guc2NoZWR1bGVPbi50aGVuKCgpID0+IHRoaXMuc2NoZWR1bGVXb3JrKHRydWUpKTtcbiAgICAgICAgICAgIGN4LnNjaGVkdWxlT24gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLndvcmtpbmcgPj0gMClcbiAgICAgICAgICAgIGNhbmNlbElkbGUodGhpcy53b3JraW5nKTtcbiAgICB9XG59LCB7XG4gICAgZXZlbnRIYW5kbGVyczogeyBmb2N1cygpIHsgdGhpcy5zY2hlZHVsZVdvcmsoKTsgfSB9XG59KTtcbi8qKlxuVGhlIGZhY2V0IHVzZWQgdG8gYXNzb2NpYXRlIGEgbGFuZ3VhZ2Ugd2l0aCBhbiBlZGl0b3Igc3RhdGUuXG4qL1xuY29uc3QgbGFuZ3VhZ2UgPSBzdGF0ZS5GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUobGFuZ3VhZ2VzKSB7IHJldHVybiBsYW5ndWFnZXMubGVuZ3RoID8gbGFuZ3VhZ2VzWzBdIDogbnVsbDsgfSxcbiAgICBlbmFibGVzOiBbTGFuZ3VhZ2Uuc3RhdGUsIHBhcnNlV29ya2VyXVxufSk7XG4vKipcblRoaXMgY2xhc3MgYnVuZGxlcyBhIFtsYW5ndWFnZSBvYmplY3RdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTGFuZ3VhZ2UpIHdpdGggYW5cbm9wdGlvbmFsIHNldCBvZiBzdXBwb3J0aW5nIGV4dGVuc2lvbnMuIExhbmd1YWdlIHBhY2thZ2VzIGFyZVxuZW5jb3VyYWdlZCB0byBleHBvcnQgYSBmdW5jdGlvbiB0aGF0IG9wdGlvbmFsbHkgdGFrZXMgYVxuY29uZmlndXJhdGlvbiBvYmplY3QgYW5kIHJldHVybnMgYSBgTGFuZ3VhZ2VTdXBwb3J0YCBpbnN0YW5jZSwgYXNcbnRoZSBtYWluIHdheSBmb3IgY2xpZW50IGNvZGUgdG8gdXNlIHRoZSBwYWNrYWdlLlxuKi9cbmNsYXNzIExhbmd1YWdlU3VwcG9ydCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc3VwcG9ydCBvYmplY3QuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbGFuZ3VhZ2Ugb2JqZWN0LlxuICAgICovXG4gICAgbGFuZ3VhZ2UsIFxuICAgIC8qKlxuICAgIEFuIG9wdGlvbmFsIHNldCBvZiBzdXBwb3J0aW5nIGV4dGVuc2lvbnMuIFdoZW4gbmVzdGluZyBhXG4gICAgbGFuZ3VhZ2UgaW4gYW5vdGhlciBsYW5ndWFnZSwgdGhlIG91dGVyIGxhbmd1YWdlIGlzIGVuY291cmFnZWRcbiAgICB0byBpbmNsdWRlIHRoZSBzdXBwb3J0aW5nIGV4dGVuc2lvbnMgZm9yIGl0cyBpbm5lciBsYW5ndWFnZXNcbiAgICBpbiBpdHMgb3duIHNldCBvZiBzdXBwb3J0IGV4dGVuc2lvbnMuXG4gICAgKi9cbiAgICBzdXBwb3J0ID0gW10pIHtcbiAgICAgICAgdGhpcy5sYW5ndWFnZSA9IGxhbmd1YWdlO1xuICAgICAgICB0aGlzLnN1cHBvcnQgPSBzdXBwb3J0O1xuICAgICAgICB0aGlzLmV4dGVuc2lvbiA9IFtsYW5ndWFnZSwgc3VwcG9ydF07XG4gICAgfVxufVxuLyoqXG5MYW5ndWFnZSBkZXNjcmlwdGlvbnMgYXJlIHVzZWQgdG8gc3RvcmUgbWV0YWRhdGEgYWJvdXQgbGFuZ3VhZ2VzXG5hbmQgdG8gZHluYW1pY2FsbHkgbG9hZCB0aGVtLiBUaGVpciBtYWluIHJvbGUgaXMgZmluZGluZyB0aGVcbmFwcHJvcHJpYXRlIGxhbmd1YWdlIGZvciBhIGZpbGVuYW1lIG9yIGR5bmFtaWNhbGx5IGxvYWRpbmcgbmVzdGVkXG5wYXJzZXJzLlxuKi9cbmNsYXNzIExhbmd1YWdlRGVzY3JpcHRpb24ge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBuYW1lIG9mIHRoaXMgbGFuZ3VhZ2UuXG4gICAgKi9cbiAgICBuYW1lLCBcbiAgICAvKipcbiAgICBBbHRlcm5hdGl2ZSBuYW1lcyBmb3IgdGhlIG1vZGUgKGxvd2VyY2FzZWQsIGluY2x1ZGVzIGB0aGlzLm5hbWVgKS5cbiAgICAqL1xuICAgIGFsaWFzLCBcbiAgICAvKipcbiAgICBGaWxlIGV4dGVuc2lvbnMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbGFuZ3VhZ2UuXG4gICAgKi9cbiAgICBleHRlbnNpb25zLCBcbiAgICAvKipcbiAgICBPcHRpb25hbCBmaWxlbmFtZSBwYXR0ZXJuIHRoYXQgc2hvdWxkIGJlIGFzc29jaWF0ZWQgd2l0aCB0aGlzXG4gICAgbGFuZ3VhZ2UuXG4gICAgKi9cbiAgICBmaWxlbmFtZSwgbG9hZEZ1bmMpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5hbGlhcyA9IGFsaWFzO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xuICAgICAgICB0aGlzLmZpbGVuYW1lID0gZmlsZW5hbWU7XG4gICAgICAgIHRoaXMubG9hZEZ1bmMgPSBsb2FkRnVuYztcbiAgICAgICAgLyoqXG4gICAgICAgIElmIHRoZSBsYW5ndWFnZSBoYXMgYmVlbiBsb2FkZWQsIHRoaXMgd2lsbCBob2xkIGl0cyB2YWx1ZS5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdXBwb3J0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmxvYWRpbmcgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBTdGFydCBsb2FkaW5nIHRoZSB0aGUgbGFuZ3VhZ2UuIFdpbGwgcmV0dXJuIGEgcHJvbWlzZSB0aGF0XG4gICAgcmVzb2x2ZXMgdG8gYSBbYExhbmd1YWdlU3VwcG9ydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTGFuZ3VhZ2VTdXBwb3J0KVxuICAgIG9iamVjdCB3aGVuIHRoZSBsYW5ndWFnZSBzdWNjZXNzZnVsbHkgbG9hZHMuXG4gICAgKi9cbiAgICBsb2FkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2FkaW5nIHx8ICh0aGlzLmxvYWRpbmcgPSB0aGlzLmxvYWRGdW5jKCkudGhlbihzdXBwb3J0ID0+IHRoaXMuc3VwcG9ydCA9IHN1cHBvcnQsIGVyciA9PiB7IHRoaXMubG9hZGluZyA9IG51bGw7IHRocm93IGVycjsgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBsYW5ndWFnZSBkZXNjcmlwdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBvZihzcGVjKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGFuZ3VhZ2VEZXNjcmlwdGlvbihzcGVjLm5hbWUsIChzcGVjLmFsaWFzIHx8IFtdKS5jb25jYXQoc3BlYy5uYW1lKS5tYXAocyA9PiBzLnRvTG93ZXJDYXNlKCkpLCBzcGVjLmV4dGVuc2lvbnMgfHwgW10sIHNwZWMuZmlsZW5hbWUsIHNwZWMubG9hZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIExvb2sgZm9yIGEgbGFuZ3VhZ2UgaW4gdGhlIGdpdmVuIGFycmF5IG9mIGRlc2NyaXB0aW9ucyB0aGF0XG4gICAgbWF0Y2hlcyB0aGUgZmlsZW5hbWUuIFdpbGwgZmlyc3QgbWF0Y2hcbiAgICBbYGZpbGVuYW1lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZURlc2NyaXB0aW9uLmZpbGVuYW1lKSBwYXR0ZXJucyxcbiAgICBhbmQgdGhlbiBbZXh0ZW5zaW9uc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZURlc2NyaXB0aW9uLmV4dGVuc2lvbnMpLFxuICAgIGFuZCByZXR1cm4gdGhlIGZpcnN0IGxhbmd1YWdlIHRoYXQgbWF0Y2hlcy5cbiAgICAqL1xuICAgIHN0YXRpYyBtYXRjaEZpbGVuYW1lKGRlc2NzLCBmaWxlbmFtZSkge1xuICAgICAgICBmb3IgKGxldCBkIG9mIGRlc2NzKVxuICAgICAgICAgICAgaWYgKGQuZmlsZW5hbWUgJiYgZC5maWxlbmFtZS50ZXN0KGZpbGVuYW1lKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgbGV0IGV4dCA9IC9cXC4oW14uXSspJC8uZXhlYyhmaWxlbmFtZSk7XG4gICAgICAgIGlmIChleHQpXG4gICAgICAgICAgICBmb3IgKGxldCBkIG9mIGRlc2NzKVxuICAgICAgICAgICAgICAgIGlmIChkLmV4dGVuc2lvbnMuaW5kZXhPZihleHRbMV0pID4gLTEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgTG9vayBmb3IgYSBsYW5ndWFnZSB3aG9zZSBuYW1lIG9yIGFsaWFzIG1hdGNoZXMgdGhlIHRoZSBnaXZlblxuICAgIG5hbWUgKGNhc2UtaW5zZW5zaXRpdmVseSkuIElmIGBmdXp6eWAgaXMgdHJ1ZSwgYW5kIG5vIGRpcmVjdFxuICAgIG1hdGNocyBpcyBmb3VuZCwgdGhpcydsbCBhbHNvIHNlYXJjaCBmb3IgYSBsYW5ndWFnZSB3aG9zZSBuYW1lXG4gICAgb3IgYWxpYXMgb2NjdXJzIGluIHRoZSBzdHJpbmcgKGZvciBuYW1lcyBzaG9ydGVyIHRoYW4gdGhyZWVcbiAgICBjaGFyYWN0ZXJzLCBvbmx5IHdoZW4gc3Vycm91bmRlZCBieSBub24td29yZCBjaGFyYWN0ZXJzKS5cbiAgICAqL1xuICAgIHN0YXRpYyBtYXRjaExhbmd1YWdlTmFtZShkZXNjcywgbmFtZSwgZnV6enkgPSB0cnVlKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGZvciAobGV0IGQgb2YgZGVzY3MpXG4gICAgICAgICAgICBpZiAoZC5hbGlhcy5zb21lKGEgPT4gYSA9PSBuYW1lKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgaWYgKGZ1enp5KVxuICAgICAgICAgICAgZm9yIChsZXQgZCBvZiBkZXNjcylcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBhIG9mIGQuYWxpYXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gbmFtZS5pbmRleE9mKGEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmQgPiAtMSAmJiAoYS5sZW5ndGggPiAyIHx8ICEvXFx3Ly50ZXN0KG5hbWVbZm91bmQgLSAxXSkgJiYgIS9cXHcvLnRlc3QobmFtZVtmb3VuZCArIGEubGVuZ3RoXSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbi8qKlxuRmFjZXQgdGhhdCBkZWZpbmVzIGEgd2F5IHRvIHByb3ZpZGUgYSBmdW5jdGlvbiB0aGF0IGNvbXB1dGVzIHRoZVxuYXBwcm9wcmlhdGUgaW5kZW50YXRpb24gZGVwdGggYXQgdGhlIHN0YXJ0IG9mIGEgZ2l2ZW4gbGluZSwgb3JcbmBudWxsYCB0byBpbmRpY2F0ZSBubyBhcHByb3ByaWF0ZSBpbmRlbnRhdGlvbiBjb3VsZCBiZSBkZXRlcm1pbmVkLlxuKi9cbmNvbnN0IGluZGVudFNlcnZpY2UgPSBzdGF0ZS5GYWNldC5kZWZpbmUoKTtcbi8qKlxuRmFjZXQgZm9yIG92ZXJyaWRpbmcgdGhlIHVuaXQgYnkgd2hpY2ggaW5kZW50YXRpb24gaGFwcGVucy5cblNob3VsZCBiZSBhIHN0cmluZyBjb25zaXN0aW5nIGVpdGhlciBlbnRpcmVseSBvZiBzcGFjZXMgb3JcbmVudGlyZWx5IG9mIHRhYnMuIFdoZW4gbm90IHNldCwgdGhpcyBkZWZhdWx0cyB0byAyIHNwYWNlcy5cbiovXG5jb25zdCBpbmRlbnRVbml0ID0gc3RhdGUuRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4ge1xuICAgICAgICBpZiAoIXZhbHVlcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gXCIgIFwiO1xuICAgICAgICBpZiAoIS9eKD86ICt8XFx0KykkLy50ZXN0KHZhbHVlc1swXSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGluZGVudCB1bml0OiBcIiArIEpTT04uc3RyaW5naWZ5KHZhbHVlc1swXSkpO1xuICAgICAgICByZXR1cm4gdmFsdWVzWzBdO1xuICAgIH1cbn0pO1xuLyoqXG5SZXR1cm4gdGhlIF9jb2x1bW4gd2lkdGhfIG9mIGFuIGluZGVudCB1bml0IGluIHRoZSBzdGF0ZS5cbkRldGVybWluZWQgYnkgdGhlIFtgaW5kZW50VW5pdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50VW5pdClcbmZhY2V0LCBhbmQgW2B0YWJTaXplYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV50YWJTaXplKSB3aGVuIHRoYXRcbmNvbnRhaW5zIHRhYnMuXG4qL1xuZnVuY3Rpb24gZ2V0SW5kZW50VW5pdChzdGF0ZSkge1xuICAgIGxldCB1bml0ID0gc3RhdGUuZmFjZXQoaW5kZW50VW5pdCk7XG4gICAgcmV0dXJuIHVuaXQuY2hhckNvZGVBdCgwKSA9PSA5ID8gc3RhdGUudGFiU2l6ZSAqIHVuaXQubGVuZ3RoIDogdW5pdC5sZW5ndGg7XG59XG4vKipcbkNyZWF0ZSBhbiBpbmRlbnRhdGlvbiBzdHJpbmcgdGhhdCBjb3ZlcnMgY29sdW1ucyAwIHRvIGBjb2xzYC5cbldpbGwgdXNlIHRhYnMgZm9yIGFzIG11Y2ggb2YgdGhlIGNvbHVtbnMgYXMgcG9zc2libGUgd2hlbiB0aGVcbltgaW5kZW50VW5pdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50VW5pdCkgZmFjZXQgY29udGFpbnNcbnRhYnMuXG4qL1xuZnVuY3Rpb24gaW5kZW50U3RyaW5nKHN0YXRlLCBjb2xzKSB7XG4gICAgbGV0IHJlc3VsdCA9IFwiXCIsIHRzID0gc3RhdGUudGFiU2l6ZTtcbiAgICBpZiAoc3RhdGUuZmFjZXQoaW5kZW50VW5pdCkuY2hhckNvZGVBdCgwKSA9PSA5KVxuICAgICAgICB3aGlsZSAoY29scyA+PSB0cykge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiXFx0XCI7XG4gICAgICAgICAgICBjb2xzIC09IHRzO1xuICAgICAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xzOyBpKyspXG4gICAgICAgIHJlc3VsdCArPSBcIiBcIjtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG5HZXQgdGhlIGluZGVudGF0aW9uIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi4gV2lsbCBmaXJzdCBjb25zdWx0IGFueVxuW2luZGVudCBzZXJ2aWNlc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRTZXJ2aWNlKSB0aGF0IGFyZSByZWdpc3RlcmVkLFxuYW5kIGlmIG5vbmUgb2YgdGhvc2UgcmV0dXJuIGFuIGluZGVudGF0aW9uLCB0aGlzIHdpbGwgY2hlY2sgdGhlXG5zeW50YXggdHJlZSBmb3IgdGhlIFtpbmRlbnQgbm9kZSBwcm9wXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudE5vZGVQcm9wKVxuYW5kIHVzZSB0aGF0IGlmIGZvdW5kLiBSZXR1cm5zIGEgbnVtYmVyIHdoZW4gYW4gaW5kZW50YXRpb24gY291bGRcbmJlIGRldGVybWluZWQsIGFuZCBudWxsIG90aGVyd2lzZS5cbiovXG5mdW5jdGlvbiBnZXRJbmRlbnRhdGlvbihjb250ZXh0LCBwb3MpIHtcbiAgICBpZiAoY29udGV4dCBpbnN0YW5jZW9mIHN0YXRlLkVkaXRvclN0YXRlKVxuICAgICAgICBjb250ZXh0ID0gbmV3IEluZGVudENvbnRleHQoY29udGV4dCk7XG4gICAgZm9yIChsZXQgc2VydmljZSBvZiBjb250ZXh0LnN0YXRlLmZhY2V0KGluZGVudFNlcnZpY2UpKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBzZXJ2aWNlKGNvbnRleHQsIHBvcyk7XG4gICAgICAgIGlmIChyZXN1bHQgIT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGxldCB0cmVlID0gc3ludGF4VHJlZShjb250ZXh0LnN0YXRlKTtcbiAgICByZXR1cm4gdHJlZSA/IHN5bnRheEluZGVudGF0aW9uKGNvbnRleHQsIHRyZWUsIHBvcykgOiBudWxsO1xufVxuLyoqXG5JbmRlbnRhdGlvbiBjb250ZXh0cyBhcmUgdXNlZCB3aGVuIGNhbGxpbmcgW2luZGVudGF0aW9uXG5zZXJ2aWNlc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRTZXJ2aWNlKS4gVGhleSBwcm92aWRlIGhlbHBlciB1dGlsaXRpZXNcbnVzZWZ1bCBpbiBpbmRlbnRhdGlvbiBsb2dpYywgYW5kIGNhbiBzZWxlY3RpdmVseSBvdmVycmlkZSB0aGVcbmluZGVudGF0aW9uIHJlcG9ydGVkIGZvciBzb21lIGxpbmVzLlxuKi9cbmNsYXNzIEluZGVudENvbnRleHQge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBpbmRlbnQgY29udGV4dC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBlZGl0b3Igc3RhdGUuXG4gICAgKi9cbiAgICBzdGF0ZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnVuaXQgPSBnZXRJbmRlbnRVbml0KHN0YXRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSB0ZXh0IGRpcmVjdGx5IGFmdGVyIGBwb3NgLCBlaXRoZXIgdGhlIGVudGlyZSBsaW5lXG4gICAgb3IgdGhlIG5leHQgMTAwIGNoYXJhY3RlcnMsIHdoaWNoZXZlciBpcyBzaG9ydGVyLlxuICAgICovXG4gICAgdGV4dEFmdGVyUG9zKHBvcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgc2ltID0gKF9hID0gdGhpcy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2ltdWxhdGVCcmVhaztcbiAgICAgICAgaWYgKHBvcyA9PSBzaW0gJiYgKChfYiA9IHRoaXMub3B0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNpbXVsYXRlRG91YmxlQnJlYWspKVxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnNsaWNlRG9jKHBvcywgTWF0aC5taW4ocG9zICsgMTAwLCBzaW0gIT0gbnVsbCAmJiBzaW0gPiBwb3MgPyBzaW0gOiAxZTksIHRoaXMuc3RhdGUuZG9jLmxpbmVBdChwb3MpLnRvKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGNvbHVtbiBmb3IgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgY29sdW1uKHBvcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBsaW5lID0gdGhpcy5zdGF0ZS5kb2MubGluZUF0KHBvcyksIHRleHQgPSBsaW5lLnRleHQuc2xpY2UoMCwgcG9zIC0gbGluZS5mcm9tKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuY291bnRDb2x1bW4odGV4dCwgcG9zIC0gbGluZS5mcm9tKTtcbiAgICAgICAgbGV0IG92ZXJyaWRlID0gKChfYSA9IHRoaXMub3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm92ZXJyaWRlSW5kZW50YXRpb24pID8gdGhpcy5vcHRpb25zLm92ZXJyaWRlSW5kZW50YXRpb24obGluZS5mcm9tKSA6IC0xO1xuICAgICAgICBpZiAob3ZlcnJpZGUgPiAtMSlcbiAgICAgICAgICAgIHJlc3VsdCArPSBvdmVycmlkZSAtIHRoaXMuY291bnRDb2x1bW4odGV4dCwgdGV4dC5zZWFyY2goL1xcUy8pKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgZmluZCB0aGUgY29sdW1uIHBvc2l0aW9uICh0YWtpbmcgdGFicyBpbnRvIGFjY291bnQpIG9mIHRoZSBnaXZlblxuICAgIHBvc2l0aW9uIGluIHRoZSBnaXZlbiBzdHJpbmcuXG4gICAgKi9cbiAgICBjb3VudENvbHVtbihsaW5lLCBwb3MpIHtcbiAgICAgICAgcmV0dXJuIHRleHQuY291bnRDb2x1bW4ocG9zIDwgMCA/IGxpbmUgOiBsaW5lLnNsaWNlKDAsIHBvcyksIDAsIHRoaXMuc3RhdGUudGFiU2l6ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGluZGVudGF0aW9uIGNvbHVtbiBvZiB0aGUgZ2l2ZW4gZG9jdW1lbnQgbGluZS5cbiAgICAqL1xuICAgIGxpbmVJbmRlbnQobGluZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBvdmVycmlkZSA9IChfYSA9IHRoaXMub3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm92ZXJyaWRlSW5kZW50YXRpb247XG4gICAgICAgIGlmIChvdmVycmlkZSkge1xuICAgICAgICAgICAgbGV0IG92ZXJyaWRlbiA9IG92ZXJyaWRlKGxpbmUuZnJvbSk7XG4gICAgICAgICAgICBpZiAob3ZlcnJpZGVuID4gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG92ZXJyaWRlbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb3VudENvbHVtbihsaW5lLnRleHQsIGxpbmUudGV4dC5zZWFyY2goL1xcUy8pKTtcbiAgICB9XG59XG4vKipcbkEgc3ludGF4IHRyZWUgbm9kZSBwcm9wIHVzZWQgdG8gYXNzb2NpYXRlIGluZGVudGF0aW9uIHN0cmF0ZWdpZXNcbndpdGggbm9kZSB0eXBlcy4gU3VjaCBhIHN0cmF0ZWd5IGlzIGEgZnVuY3Rpb24gZnJvbSBhbiBpbmRlbnRhdGlvblxuY29udGV4dCB0byBhIGNvbHVtbiBudW1iZXIgb3IgbnVsbCwgd2hlcmUgbnVsbCBpbmRpY2F0ZXMgdGhhdCBub1xuZGVmaW5pdGl2ZSBpbmRlbnRhdGlvbiBjYW4gYmUgZGV0ZXJtaW5lZC5cbiovXG5jb25zdCBpbmRlbnROb2RlUHJvcCA9IG5ldyBsZXplclRyZWUuTm9kZVByb3AoKTtcbi8vIENvbXB1dGUgdGhlIGluZGVudGF0aW9uIGZvciBhIGdpdmVuIHBvc2l0aW9uIGZyb20gdGhlIHN5bnRheCB0cmVlLlxuZnVuY3Rpb24gc3ludGF4SW5kZW50YXRpb24oY3gsIGFzdCwgcG9zKSB7XG4gICAgbGV0IHRyZWUgPSBhc3QucmVzb2x2ZShwb3MpO1xuICAgIC8vIEVudGVyIHByZXZpb3VzIG5vZGVzIHRoYXQgZW5kIGluIGVtcHR5IGVycm9yIHRlcm1zLCB3aGljaCBtZWFuc1xuICAgIC8vIHRoZXkgd2VyZSBicm9rZW4gb2ZmIGJ5IGVycm9yIHJlY292ZXJ5LCBzbyB0aGF0IGluZGVudGF0aW9uXG4gICAgLy8gd29ya3MgZXZlbiBpZiB0aGUgY29uc3RydWN0cyBoYXZlbid0IGJlZW4gZmluaXNoZWQuXG4gICAgZm9yIChsZXQgc2NhbiA9IHRyZWUsIHNjYW5Qb3MgPSBwb3M7Oykge1xuICAgICAgICBsZXQgbGFzdCA9IHNjYW4uY2hpbGRCZWZvcmUoc2NhblBvcyk7XG4gICAgICAgIGlmICghbGFzdClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAobGFzdC50eXBlLmlzRXJyb3IgJiYgbGFzdC5mcm9tID09IGxhc3QudG8pIHtcbiAgICAgICAgICAgIHRyZWUgPSBzY2FuO1xuICAgICAgICAgICAgc2NhblBvcyA9IGxhc3QuZnJvbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNjYW4gPSBsYXN0O1xuICAgICAgICAgICAgc2NhblBvcyA9IHNjYW4udG8gKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbmRlbnRGcm9tKHRyZWUsIHBvcywgY3gpO1xufVxuZnVuY3Rpb24gaWdub3JlQ2xvc2VkKGN4KSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gY3gucG9zID09ICgoX2EgPSBjeC5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2ltdWxhdGVCcmVhaykgJiYgKChfYiA9IGN4Lm9wdGlvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zaW11bGF0ZURvdWJsZUJyZWFrKTtcbn1cbmZ1bmN0aW9uIGluZGVudFN0cmF0ZWd5KHRyZWUpIHtcbiAgICBsZXQgc3RyYXRlZ3kgPSB0cmVlLnR5cGUucHJvcChpbmRlbnROb2RlUHJvcCk7XG4gICAgaWYgKHN0cmF0ZWd5KVxuICAgICAgICByZXR1cm4gc3RyYXRlZ3k7XG4gICAgbGV0IGZpcnN0ID0gdHJlZS5maXJzdENoaWxkLCBjbG9zZTtcbiAgICBpZiAoZmlyc3QgJiYgKGNsb3NlID0gZmlyc3QudHlwZS5wcm9wKGxlemVyVHJlZS5Ob2RlUHJvcC5jbG9zZWRCeSkpKSB7XG4gICAgICAgIGxldCBsYXN0ID0gdHJlZS5sYXN0Q2hpbGQsIGNsb3NlZCA9IGxhc3QgJiYgY2xvc2UuaW5kZXhPZihsYXN0Lm5hbWUpID4gLTE7XG4gICAgICAgIHJldHVybiBjeCA9PiBkZWxpbWl0ZWRTdHJhdGVneShjeCwgdHJ1ZSwgMSwgdW5kZWZpbmVkLCBjbG9zZWQgJiYgIWlnbm9yZUNsb3NlZChjeCkgPyBsYXN0LmZyb20gOiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICByZXR1cm4gdHJlZS5wYXJlbnQgPT0gbnVsbCA/IHRvcEluZGVudCA6IG51bGw7XG59XG5mdW5jdGlvbiBpbmRlbnRGcm9tKG5vZGUsIHBvcywgYmFzZSkge1xuICAgIGZvciAoOyBub2RlOyBub2RlID0gbm9kZS5wYXJlbnQpIHtcbiAgICAgICAgbGV0IHN0cmF0ZWd5ID0gaW5kZW50U3RyYXRlZ3kobm9kZSk7XG4gICAgICAgIGlmIChzdHJhdGVneSlcbiAgICAgICAgICAgIHJldHVybiBzdHJhdGVneShuZXcgVHJlZUluZGVudENvbnRleHQoYmFzZSwgcG9zLCBub2RlKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gdG9wSW5kZW50KCkgeyByZXR1cm4gMDsgfVxuLyoqXG5PYmplY3RzIG9mIHRoaXMgdHlwZSBwcm92aWRlIGNvbnRleHQgaW5mb3JtYXRpb24gYW5kIGhlbHBlclxubWV0aG9kcyB0byBpbmRlbnRhdGlvbiBmdW5jdGlvbnMuXG4qL1xuY2xhc3MgVHJlZUluZGVudENvbnRleHQgZXh0ZW5kcyBJbmRlbnRDb250ZXh0IHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGJhc2UsIFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBhdCB3aGljaCBpbmRlbnRhdGlvbiBpcyBiZWluZyBjb21wdXRlZC5cbiAgICAqL1xuICAgIHBvcywgXG4gICAgLyoqXG4gICAgVGhlIHN5bnRheCB0cmVlIG5vZGUgdG8gd2hpY2ggdGhlIGluZGVudGF0aW9uIHN0cmF0ZWd5XG4gICAgYXBwbGllcy5cbiAgICAqL1xuICAgIG5vZGUpIHtcbiAgICAgICAgc3VwZXIoYmFzZS5zdGF0ZSwgYmFzZS5vcHRpb25zKTtcbiAgICAgICAgdGhpcy5iYXNlID0gYmFzZTtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgdGV4dCBkaXJlY3RseSBhZnRlciBgdGhpcy5wb3NgLCBlaXRoZXIgdGhlIGVudGlyZSBsaW5lXG4gICAgb3IgdGhlIG5leHQgMTAwIGNoYXJhY3RlcnMsIHdoaWNoZXZlciBpcyBzaG9ydGVyLlxuICAgICovXG4gICAgZ2V0IHRleHRBZnRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dEFmdGVyUG9zKHRoaXMucG9zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBpbmRlbnRhdGlvbiBhdCB0aGUgcmVmZXJlbmNlIGxpbmUgZm9yIGB0aGlzLm5vZGVgLCB3aGljaFxuICAgIGlzIHRoZSBsaW5lIG9uIHdoaWNoIGl0IHN0YXJ0cywgdW5sZXNzIHRoZXJlIGlzIGEgbm9kZSB0aGF0IGlzXG4gICAgX25vdF8gYSBwYXJlbnQgb2YgdGhpcyBub2RlIGNvdmVyaW5nIHRoZSBzdGFydCBvZiB0aGF0IGxpbmUuIElmXG4gICAgc28sIHRoZSBsaW5lIGF0IHRoZSBzdGFydCBvZiB0aGF0IG5vZGUgaXMgdHJpZWQsIGFnYWluIHNraXBwaW5nXG4gICAgb24gaWYgaXQgaXMgY292ZXJlZCBieSBhbm90aGVyIHN1Y2ggbm9kZS5cbiAgICAqL1xuICAgIGdldCBiYXNlSW5kZW50KCkge1xuICAgICAgICBsZXQgbGluZSA9IHRoaXMuc3RhdGUuZG9jLmxpbmVBdCh0aGlzLm5vZGUuZnJvbSk7XG4gICAgICAgIC8vIFNraXAgbGluZSBzdGFydHMgdGhhdCBhcmUgY292ZXJlZCBieSBhIHNpYmxpbmcgKG9yIGNvdXNpbiwgZXRjKVxuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgYXRCcmVhayA9IHRoaXMubm9kZS5yZXNvbHZlKGxpbmUuZnJvbSk7XG4gICAgICAgICAgICB3aGlsZSAoYXRCcmVhay5wYXJlbnQgJiYgYXRCcmVhay5wYXJlbnQuZnJvbSA9PSBhdEJyZWFrLmZyb20pXG4gICAgICAgICAgICAgICAgYXRCcmVhayA9IGF0QnJlYWsucGFyZW50O1xuICAgICAgICAgICAgaWYgKGlzUGFyZW50KGF0QnJlYWssIHRoaXMubm9kZSkpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsaW5lID0gdGhpcy5zdGF0ZS5kb2MubGluZUF0KGF0QnJlYWsuZnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubGluZUluZGVudChsaW5lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29udGludWUgbG9va2luZyBmb3IgaW5kZW50YXRpb25zIGluIHRoZSBub2RlJ3MgcGFyZW50IG5vZGVzLFxuICAgIGFuZCByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGF0LlxuICAgICovXG4gICAgY29udGludWUoKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLm5vZGUucGFyZW50O1xuICAgICAgICByZXR1cm4gcGFyZW50ID8gaW5kZW50RnJvbShwYXJlbnQsIHRoaXMucG9zLCB0aGlzLmJhc2UpIDogMDtcbiAgICB9XG59XG5mdW5jdGlvbiBpc1BhcmVudChwYXJlbnQsIG9mKSB7XG4gICAgZm9yIChsZXQgY3VyID0gb2Y7IGN1cjsgY3VyID0gY3VyLnBhcmVudClcbiAgICAgICAgaWYgKHBhcmVudCA9PSBjdXIpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG4vLyBDaGVjayB3aGV0aGVyIGEgZGVsaW1pdGVkIG5vZGUgaXMgYWxpZ25lZCAobWVhbmluZyB0aGVyZSBhcmVcbi8vIG5vbi1za2lwcGVkIG5vZGVzIG9uIHRoZSBzYW1lIGxpbmUgYXMgdGhlIG9wZW5pbmcgZGVsaW1pdGVyKS4gQW5kXG4vLyBpZiBzbywgcmV0dXJuIHRoZSBvcGVuaW5nIHRva2VuLlxuZnVuY3Rpb24gYnJhY2tldGVkQWxpZ25lZChjb250ZXh0KSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCB0cmVlID0gY29udGV4dC5ub2RlO1xuICAgIGxldCBvcGVuVG9rZW4gPSB0cmVlLmNoaWxkQWZ0ZXIodHJlZS5mcm9tKSwgbGFzdCA9IHRyZWUubGFzdENoaWxkO1xuICAgIGlmICghb3BlblRva2VuKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgc2ltID0gKF9hID0gY29udGV4dC5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2ltdWxhdGVCcmVhaztcbiAgICBsZXQgb3BlbkxpbmUgPSBjb250ZXh0LnN0YXRlLmRvYy5saW5lQXQob3BlblRva2VuLmZyb20pO1xuICAgIGxldCBsaW5lRW5kID0gc2ltID09IG51bGwgfHwgc2ltIDw9IG9wZW5MaW5lLmZyb20gPyBvcGVuTGluZS50byA6IE1hdGgubWluKG9wZW5MaW5lLnRvLCBzaW0pO1xuICAgIGZvciAobGV0IHBvcyA9IG9wZW5Ub2tlbi50bzs7KSB7XG4gICAgICAgIGxldCBuZXh0ID0gdHJlZS5jaGlsZEFmdGVyKHBvcyk7XG4gICAgICAgIGlmICghbmV4dCB8fCBuZXh0ID09IGxhc3QpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKCFuZXh0LnR5cGUuaXNTa2lwcGVkKVxuICAgICAgICAgICAgcmV0dXJuIG5leHQuZnJvbSA8IGxpbmVFbmQgPyBvcGVuVG9rZW4gOiBudWxsO1xuICAgICAgICBwb3MgPSBuZXh0LnRvO1xuICAgIH1cbn1cbi8qKlxuQW4gaW5kZW50YXRpb24gc3RyYXRlZ3kgZm9yIGRlbGltaXRlZCAodXN1YWxseSBicmFja2V0ZWQpIG5vZGVzLlxuV2lsbCwgYnkgZGVmYXVsdCwgaW5kZW50IG9uZSB1bml0IG1vcmUgdGhhbiB0aGUgcGFyZW50J3MgYmFzZVxuaW5kZW50IHVubGVzcyB0aGUgbGluZSBzdGFydHMgd2l0aCBhIGNsb3NpbmcgdG9rZW4uIFdoZW4gYGFsaWduYFxuaXMgdHJ1ZSBhbmQgdGhlcmUgYXJlIG5vbi1za2lwcGVkIG5vZGVzIG9uIHRoZSBub2RlJ3Mgb3BlbmluZ1xubGluZSwgdGhlIGNvbnRlbnQgb2YgdGhlIG5vZGUgd2lsbCBiZSBhbGlnbmVkIHdpdGggdGhlIGVuZCBvZiB0aGVcbm9wZW5pbmcgbm9kZSwgbGlrZSB0aGlzOlxuXG4gICAgZm9vKGJhcixcbiAgICAgICAgYmF6KVxuKi9cbmZ1bmN0aW9uIGRlbGltaXRlZEluZGVudCh7IGNsb3NpbmcsIGFsaWduID0gdHJ1ZSwgdW5pdHMgPSAxIH0pIHtcbiAgICByZXR1cm4gKGNvbnRleHQpID0+IGRlbGltaXRlZFN0cmF0ZWd5KGNvbnRleHQsIGFsaWduLCB1bml0cywgY2xvc2luZyk7XG59XG5mdW5jdGlvbiBkZWxpbWl0ZWRTdHJhdGVneShjb250ZXh0LCBhbGlnbiwgdW5pdHMsIGNsb3NpbmcsIGNsb3NlZEF0KSB7XG4gICAgbGV0IGFmdGVyID0gY29udGV4dC50ZXh0QWZ0ZXIsIHNwYWNlID0gYWZ0ZXIubWF0Y2goL15cXHMqLylbMF0ubGVuZ3RoO1xuICAgIGxldCBjbG9zZWQgPSBjbG9zaW5nICYmIGFmdGVyLnNsaWNlKHNwYWNlLCBzcGFjZSArIGNsb3NpbmcubGVuZ3RoKSA9PSBjbG9zaW5nIHx8IGNsb3NlZEF0ID09IGNvbnRleHQucG9zICsgc3BhY2U7XG4gICAgbGV0IGFsaWduZWQgPSBhbGlnbiA/IGJyYWNrZXRlZEFsaWduZWQoY29udGV4dCkgOiBudWxsO1xuICAgIGlmIChhbGlnbmVkKVxuICAgICAgICByZXR1cm4gY2xvc2VkID8gY29udGV4dC5jb2x1bW4oYWxpZ25lZC5mcm9tKSA6IGNvbnRleHQuY29sdW1uKGFsaWduZWQudG8pO1xuICAgIHJldHVybiBjb250ZXh0LmJhc2VJbmRlbnQgKyAoY2xvc2VkID8gMCA6IGNvbnRleHQudW5pdCAqIHVuaXRzKTtcbn1cbi8qKlxuQW4gaW5kZW50YXRpb24gc3RyYXRlZ3kgdGhhdCBhbGlnbnMgYSBub2RlJ3MgY29udGVudCB0byBpdHMgYmFzZVxuaW5kZW50YXRpb24uXG4qL1xuY29uc3QgZmxhdEluZGVudCA9IChjb250ZXh0KSA9PiBjb250ZXh0LmJhc2VJbmRlbnQ7XG4vKipcbkNyZWF0ZXMgYW4gaW5kZW50YXRpb24gc3RyYXRlZ3kgdGhhdCwgYnkgZGVmYXVsdCwgaW5kZW50c1xuY29udGludWVkIGxpbmVzIG9uZSB1bml0IG1vcmUgdGhhbiB0aGUgbm9kZSdzIGJhc2UgaW5kZW50YXRpb24uXG5Zb3UgY2FuIHByb3ZpZGUgYGV4Y2VwdGAgdG8gcHJldmVudCBpbmRlbnRhdGlvbiBvZiBsaW5lcyB0aGF0XG5tYXRjaCBhIHBhdHRlcm4gKGZvciBleGFtcGxlIGAvXmVsc2VcXGIvYCBpbiBgaWZgL2BlbHNlYFxuY29uc3RydWN0cyksIGFuZCB5b3UgY2FuIGNoYW5nZSB0aGUgYW1vdW50IG9mIHVuaXRzIHVzZWQgd2l0aCB0aGVcbmB1bml0c2Agb3B0aW9uLlxuKi9cbmZ1bmN0aW9uIGNvbnRpbnVlZEluZGVudCh7IGV4Y2VwdCwgdW5pdHMgPSAxIH0gPSB7fSkge1xuICAgIHJldHVybiAoY29udGV4dCkgPT4ge1xuICAgICAgICBsZXQgbWF0Y2hFeGNlcHQgPSBleGNlcHQgJiYgZXhjZXB0LnRlc3QoY29udGV4dC50ZXh0QWZ0ZXIpO1xuICAgICAgICByZXR1cm4gY29udGV4dC5iYXNlSW5kZW50ICsgKG1hdGNoRXhjZXB0ID8gMCA6IHVuaXRzICogY29udGV4dC51bml0KTtcbiAgICB9O1xufVxuY29uc3QgRG9udEluZGVudEJleW9uZCA9IDIwMDtcbi8qKlxuRW5hYmxlcyByZWluZGVudGF0aW9uIG9uIGlucHV0LiBXaGVuIGEgbGFuZ3VhZ2UgZGVmaW5lcyBhblxuYGluZGVudE9uSW5wdXRgIGZpZWxkIGluIGl0cyBbbGFuZ3VhZ2VcbmRhdGFdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUubGFuZ3VhZ2VEYXRhQXQpLCB3aGljaCBtdXN0IGhvbGQgYSByZWd1bGFyXG5leHByZXNzaW9uLCB0aGUgbGluZSBhdCB0aGUgY3Vyc29yIHdpbGwgYmUgcmVpbmRlbnRlZCB3aGVuZXZlciBuZXdcbnRleHQgaXMgdHlwZWQgYW5kIHRoZSBpbnB1dCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgbGluZSB1cCB0byB0aGVcbmN1cnNvciBtYXRjaGVzIHRoYXQgcmVnZXhwLlxuXG5UbyBhdm9pZCB1bm5lY2Nlc2FyeSByZWluZGVudHMsIGl0IGlzIHJlY29tbWVuZGVkIHRvIHN0YXJ0IHRoZVxucmVnZXhwIHdpdGggYF5gICh1c3VhbGx5IGZvbGxvd2VkIGJ5IGBcXHMqYCksIGFuZCBlbmQgaXQgd2l0aCBgJGAuXG5Gb3IgZXhhbXBsZSwgYC9eXFxzKlxcfSQvYCB3aWxsIHJlaW5kZW50IHdoZW4gYSBjbG9zaW5nIGJyYWNlIGlzXG5hZGRlZCBhdCB0aGUgc3RhcnQgb2YgYSBsaW5lLlxuKi9cbmZ1bmN0aW9uIGluZGVudE9uSW5wdXQoKSB7XG4gICAgcmV0dXJuIHN0YXRlLkVkaXRvclN0YXRlLnRyYW5zYWN0aW9uRmlsdGVyLm9mKHRyID0+IHtcbiAgICAgICAgaWYgKCF0ci5kb2NDaGFuZ2VkIHx8IHRyLmFubm90YXRpb24oc3RhdGUuVHJhbnNhY3Rpb24udXNlckV2ZW50KSAhPSBcImlucHV0XCIpXG4gICAgICAgICAgICByZXR1cm4gdHI7XG4gICAgICAgIGxldCBydWxlcyA9IHRyLnN0YXJ0U3RhdGUubGFuZ3VhZ2VEYXRhQXQoXCJpbmRlbnRPbklucHV0XCIsIHRyLnN0YXJ0U3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZCk7XG4gICAgICAgIGlmICghcnVsZXMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRyO1xuICAgICAgICBsZXQgZG9jID0gdHIubmV3RG9jLCB7IGhlYWQgfSA9IHRyLm5ld1NlbGVjdGlvbi5tYWluLCBsaW5lID0gZG9jLmxpbmVBdChoZWFkKTtcbiAgICAgICAgaWYgKGhlYWQgPiBsaW5lLmZyb20gKyBEb250SW5kZW50QmV5b25kKVxuICAgICAgICAgICAgcmV0dXJuIHRyO1xuICAgICAgICBsZXQgbGluZVN0YXJ0ID0gZG9jLnNsaWNlU3RyaW5nKGxpbmUuZnJvbSwgaGVhZCk7XG4gICAgICAgIGlmICghcnVsZXMuc29tZShyID0+IHIudGVzdChsaW5lU3RhcnQpKSlcbiAgICAgICAgICAgIHJldHVybiB0cjtcbiAgICAgICAgbGV0IHsgc3RhdGU6IHN0YXRlJDEgfSA9IHRyLCBsYXN0ID0gLTEsIGNoYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgeyBoZWFkIH0gb2Ygc3RhdGUkMS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHN0YXRlJDEuZG9jLmxpbmVBdChoZWFkKTtcbiAgICAgICAgICAgIGlmIChsaW5lLmZyb20gPT0gbGFzdClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxhc3QgPSBsaW5lLmZyb207XG4gICAgICAgICAgICBsZXQgaW5kZW50ID0gZ2V0SW5kZW50YXRpb24oc3RhdGUkMSwgbGluZS5mcm9tKTtcbiAgICAgICAgICAgIGlmIChpbmRlbnQgPT0gbnVsbClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCBjdXIgPSAvXlxccyovLmV4ZWMobGluZS50ZXh0KVswXTtcbiAgICAgICAgICAgIGxldCBub3JtID0gaW5kZW50U3RyaW5nKHN0YXRlJDEsIGluZGVudCk7XG4gICAgICAgICAgICBpZiAoY3VyICE9IG5vcm0pXG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogbGluZS5mcm9tLCB0bzogbGluZS5mcm9tICsgY3VyLmxlbmd0aCwgaW5zZXJ0OiBub3JtIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFuZ2VzLmxlbmd0aCA/IFt0ciwgeyBjaGFuZ2VzIH1dIDogdHI7XG4gICAgfSk7XG59XG5cbi8qKlxuQSBmYWNldCB0aGF0IHJlZ2lzdGVycyBhIGNvZGUgZm9sZGluZyBzZXJ2aWNlLiBXaGVuIGNhbGxlZCB3aXRoXG50aGUgZXh0ZW50IG9mIGEgbGluZSwgc3VjaCBhIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBmb2xkYWJsZVxucmFuZ2UgdGhhdCBzdGFydHMgb24gdGhhdCBsaW5lIChidXQgY29udGludWVzIGJleW9uZCBpdCksIGlmIG9uZVxuY2FuIGJlIGZvdW5kLlxuKi9cbmNvbnN0IGZvbGRTZXJ2aWNlID0gc3RhdGUuRmFjZXQuZGVmaW5lKCk7XG4vKipcblRoaXMgbm9kZSBwcm9wIGlzIHVzZWQgdG8gYXNzb2NpYXRlIGZvbGRpbmcgaW5mb3JtYXRpb24gd2l0aFxuc3ludGF4IG5vZGUgdHlwZXMuIEdpdmVuIGEgc3ludGF4IG5vZGUsIGl0IHNob3VsZCBjaGVjayB3aGV0aGVyXG50aGF0IHRyZWUgaXMgZm9sZGFibGUgYW5kIHJldHVybiB0aGUgcmFuZ2UgdGhhdCBjYW4gYmUgY29sbGFwc2VkXG53aGVuIGl0IGlzLlxuKi9cbmNvbnN0IGZvbGROb2RlUHJvcCA9IG5ldyBsZXplclRyZWUuTm9kZVByb3AoKTtcbi8qKlxuW0ZvbGRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZm9sZE5vZGVQcm9wKSBmdW5jdGlvbiB0aGF0IGZvbGRzIGV2ZXJ5dGhpbmcgYnV0XG50aGUgZmlyc3QgYW5kIHRoZSBsYXN0IGNoaWxkIG9mIGEgc3ludGF4IG5vZGUuIFVzZWZ1bCBmb3Igbm9kZXNcbnRoYXQgc3RhcnQgYW5kIGVuZCB3aXRoIGRlbGltaXRlcnMuXG4qL1xuZnVuY3Rpb24gZm9sZEluc2lkZShub2RlKSB7XG4gICAgbGV0IGZpcnN0ID0gbm9kZS5maXJzdENoaWxkLCBsYXN0ID0gbm9kZS5sYXN0Q2hpbGQ7XG4gICAgcmV0dXJuIGZpcnN0ICYmIGZpcnN0LnRvIDwgbGFzdC5mcm9tID8geyBmcm9tOiBmaXJzdC50bywgdG86IGxhc3QudHlwZS5pc0Vycm9yID8gbm9kZS50byA6IGxhc3QuZnJvbSB9IDogbnVsbDtcbn1cbmZ1bmN0aW9uIHN5bnRheEZvbGRpbmcoc3RhdGUsIHN0YXJ0LCBlbmQpIHtcbiAgICBsZXQgdHJlZSA9IHN5bnRheFRyZWUoc3RhdGUpO1xuICAgIGlmICh0cmVlLmxlbmd0aCA9PSAwKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgaW5uZXIgPSB0cmVlLnJlc29sdmUoZW5kKTtcbiAgICBsZXQgZm91bmQgPSBudWxsO1xuICAgIGZvciAobGV0IGN1ciA9IGlubmVyOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnQpIHtcbiAgICAgICAgaWYgKGN1ci50byA8PSBlbmQgfHwgY3VyLmZyb20gPiBlbmQpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKGZvdW5kICYmIGN1ci5mcm9tIDwgc3RhcnQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbGV0IHByb3AgPSBjdXIudHlwZS5wcm9wKGZvbGROb2RlUHJvcCk7XG4gICAgICAgIGlmIChwcm9wKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBwcm9wKGN1ciwgc3RhdGUpO1xuICAgICAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLmZyb20gPD0gZW5kICYmIHZhbHVlLmZyb20gPj0gc3RhcnQgJiYgdmFsdWUudG8gPiBlbmQpXG4gICAgICAgICAgICAgICAgZm91bmQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm91bmQ7XG59XG4vKipcbkNoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIGxpbmUgaXMgZm9sZGFibGUuIEZpcnN0IGFza3MgYW55IGZvbGRcbnNlcnZpY2VzIHJlZ2lzdGVyZWQgdGhyb3VnaFxuW2Bmb2xkU2VydmljZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZm9sZFNlcnZpY2UpLCBhbmQgaWYgbm9uZSBvZiB0aGVtIHJldHVyblxuYSByZXN1bHQsIHRyaWVzIHRvIHF1ZXJ5IHRoZSBbZm9sZCBub2RlXG5wcm9wXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmZvbGROb2RlUHJvcCkgb2Ygc3ludGF4IG5vZGVzIHRoYXQgY292ZXIgdGhlIGVuZFxub2YgdGhlIGxpbmUuXG4qL1xuZnVuY3Rpb24gZm9sZGFibGUoc3RhdGUsIGxpbmVTdGFydCwgbGluZUVuZCkge1xuICAgIGZvciAobGV0IHNlcnZpY2Ugb2Ygc3RhdGUuZmFjZXQoZm9sZFNlcnZpY2UpKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBzZXJ2aWNlKHN0YXRlLCBsaW5lU3RhcnQsIGxpbmVFbmQpO1xuICAgICAgICBpZiAocmVzdWx0KVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHN5bnRheEZvbGRpbmcoc3RhdGUsIGxpbmVTdGFydCwgbGluZUVuZCk7XG59XG5cbmV4cG9ydHMuRWRpdG9yUGFyc2VDb250ZXh0ID0gRWRpdG9yUGFyc2VDb250ZXh0O1xuZXhwb3J0cy5JbmRlbnRDb250ZXh0ID0gSW5kZW50Q29udGV4dDtcbmV4cG9ydHMuTGFuZ3VhZ2UgPSBMYW5ndWFnZTtcbmV4cG9ydHMuTGFuZ3VhZ2VEZXNjcmlwdGlvbiA9IExhbmd1YWdlRGVzY3JpcHRpb247XG5leHBvcnRzLkxhbmd1YWdlU3VwcG9ydCA9IExhbmd1YWdlU3VwcG9ydDtcbmV4cG9ydHMuTGV6ZXJMYW5ndWFnZSA9IExlemVyTGFuZ3VhZ2U7XG5leHBvcnRzLlRyZWVJbmRlbnRDb250ZXh0ID0gVHJlZUluZGVudENvbnRleHQ7XG5leHBvcnRzLmNvbnRpbnVlZEluZGVudCA9IGNvbnRpbnVlZEluZGVudDtcbmV4cG9ydHMuZGVmaW5lTGFuZ3VhZ2VGYWNldCA9IGRlZmluZUxhbmd1YWdlRmFjZXQ7XG5leHBvcnRzLmRlbGltaXRlZEluZGVudCA9IGRlbGltaXRlZEluZGVudDtcbmV4cG9ydHMuZW5zdXJlU3ludGF4VHJlZSA9IGVuc3VyZVN5bnRheFRyZWU7XG5leHBvcnRzLmZsYXRJbmRlbnQgPSBmbGF0SW5kZW50O1xuZXhwb3J0cy5mb2xkSW5zaWRlID0gZm9sZEluc2lkZTtcbmV4cG9ydHMuZm9sZE5vZGVQcm9wID0gZm9sZE5vZGVQcm9wO1xuZXhwb3J0cy5mb2xkU2VydmljZSA9IGZvbGRTZXJ2aWNlO1xuZXhwb3J0cy5mb2xkYWJsZSA9IGZvbGRhYmxlO1xuZXhwb3J0cy5nZXRJbmRlbnRVbml0ID0gZ2V0SW5kZW50VW5pdDtcbmV4cG9ydHMuZ2V0SW5kZW50YXRpb24gPSBnZXRJbmRlbnRhdGlvbjtcbmV4cG9ydHMuaW5kZW50Tm9kZVByb3AgPSBpbmRlbnROb2RlUHJvcDtcbmV4cG9ydHMuaW5kZW50T25JbnB1dCA9IGluZGVudE9uSW5wdXQ7XG5leHBvcnRzLmluZGVudFNlcnZpY2UgPSBpbmRlbnRTZXJ2aWNlO1xuZXhwb3J0cy5pbmRlbnRTdHJpbmcgPSBpbmRlbnRTdHJpbmc7XG5leHBvcnRzLmluZGVudFVuaXQgPSBpbmRlbnRVbml0O1xuZXhwb3J0cy5sYW5ndWFnZSA9IGxhbmd1YWdlO1xuZXhwb3J0cy5sYW5ndWFnZURhdGFQcm9wID0gbGFuZ3VhZ2VEYXRhUHJvcDtcbmV4cG9ydHMuc3ludGF4VHJlZSA9IHN5bnRheFRyZWU7XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciB2aWV3ID0gcmVxdWlyZSgnQGNvZGVtaXJyb3IvdmlldycpO1xudmFyIHN0YXRlID0gcmVxdWlyZSgnQGNvZGVtaXJyb3Ivc3RhdGUnKTtcbnZhciB0b29sdGlwID0gcmVxdWlyZSgnQGNvZGVtaXJyb3IvdG9vbHRpcCcpO1xudmFyIHBhbmVsID0gcmVxdWlyZSgnQGNvZGVtaXJyb3IvcGFuZWwnKTtcbnZhciBlbHQgPSByZXF1aXJlKCdjcmVsdCcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHRMZWdhY3kgKGUpIHsgcmV0dXJuIGUgJiYgdHlwZW9mIGUgPT09ICdvYmplY3QnICYmICdkZWZhdWx0JyBpbiBlID8gZSA6IHsgJ2RlZmF1bHQnOiBlIH07IH1cblxudmFyIGVsdF9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRMZWdhY3koZWx0KTtcblxuY2xhc3MgU2VsZWN0ZWREaWFnbm9zdGljIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCB0bywgZGlhZ25vc3RpYykge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMuZGlhZ25vc3RpYyA9IGRpYWdub3N0aWM7XG4gICAgfVxufVxuY2xhc3MgTGludFN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcihkaWFnbm9zdGljcywgcGFuZWwsIHNlbGVjdGVkKSB7XG4gICAgICAgIHRoaXMuZGlhZ25vc3RpY3MgPSBkaWFnbm9zdGljcztcbiAgICAgICAgdGhpcy5wYW5lbCA9IHBhbmVsO1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgfVxufVxuZnVuY3Rpb24gZmluZERpYWdub3N0aWMoZGlhZ25vc3RpY3MsIGRpYWdub3N0aWMgPSBudWxsLCBhZnRlciA9IDApIHtcbiAgICBsZXQgZm91bmQgPSBudWxsO1xuICAgIGRpYWdub3N0aWNzLmJldHdlZW4oYWZ0ZXIsIDFlOSwgKGZyb20sIHRvLCB7IHNwZWMgfSkgPT4ge1xuICAgICAgICBpZiAoZGlhZ25vc3RpYyAmJiBzcGVjLmRpYWdub3N0aWMgIT0gZGlhZ25vc3RpYylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZm91bmQgPSBuZXcgU2VsZWN0ZWREaWFnbm9zdGljKGZyb20sIHRvLCBzcGVjLmRpYWdub3N0aWMpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZvdW5kO1xufVxuZnVuY3Rpb24gbWF5YmVFbmFibGVMaW50KHN0YXRlJDEsIGVmZmVjdHMpIHtcbiAgICByZXR1cm4gc3RhdGUkMS5maWVsZChsaW50U3RhdGUsIGZhbHNlKSA/IGVmZmVjdHMgOiBlZmZlY3RzLmNvbmNhdChzdGF0ZS5TdGF0ZUVmZmVjdC5hcHBlbmRDb25maWcub2YoW1xuICAgICAgICBsaW50U3RhdGUsXG4gICAgICAgIHZpZXcuRWRpdG9yVmlldy5kZWNvcmF0aW9ucy5jb21wdXRlKFtsaW50U3RhdGVdLCBzdGF0ZSA9PiB7XG4gICAgICAgICAgICBsZXQgeyBzZWxlY3RlZCwgcGFuZWwgfSA9IHN0YXRlLmZpZWxkKGxpbnRTdGF0ZSk7XG4gICAgICAgICAgICByZXR1cm4gIXNlbGVjdGVkIHx8ICFwYW5lbCB8fCBzZWxlY3RlZC5mcm9tID09IHNlbGVjdGVkLnRvID8gdmlldy5EZWNvcmF0aW9uLm5vbmUgOiB2aWV3LkRlY29yYXRpb24uc2V0KFtcbiAgICAgICAgICAgICAgICBhY3RpdmVNYXJrLnJhbmdlKHNlbGVjdGVkLmZyb20sIHNlbGVjdGVkLnRvKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH0pLFxuICAgICAgICB0b29sdGlwLmhvdmVyVG9vbHRpcChsaW50VG9vbHRpcCksXG4gICAgICAgIGJhc2VUaGVtZVxuICAgIF0pKTtcbn1cbi8qKlxuUmV0dXJucyBhIHRyYW5zYWN0aW9uIHNwZWMgd2hpY2ggdXBkYXRlcyB0aGUgY3VycmVudCBzZXQgb2ZcbmRpYWdub3N0aWNzLlxuKi9cbmZ1bmN0aW9uIHNldERpYWdub3N0aWNzKHN0YXRlLCBkaWFnbm9zdGljcykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGVmZmVjdHM6IG1heWJlRW5hYmxlTGludChzdGF0ZSwgW3NldERpYWdub3N0aWNzRWZmZWN0Lm9mKGRpYWdub3N0aWNzKV0pXG4gICAgfTtcbn1cbmNvbnN0IHNldERpYWdub3N0aWNzRWZmZWN0ID0gc3RhdGUuU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCB0b2dnbGVQYW5lbCA9IHN0YXRlLlN0YXRlRWZmZWN0LmRlZmluZSgpO1xuY29uc3QgbW92ZVBhbmVsU2VsZWN0aW9uID0gc3RhdGUuU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCBsaW50U3RhdGUgPSBzdGF0ZS5TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkge1xuICAgICAgICByZXR1cm4gbmV3IExpbnRTdGF0ZSh2aWV3LkRlY29yYXRpb24ubm9uZSwgbnVsbCwgbnVsbCk7XG4gICAgfSxcbiAgICB1cGRhdGUodmFsdWUsIHRyKSB7XG4gICAgICAgIGlmICh0ci5kb2NDaGFuZ2VkKSB7XG4gICAgICAgICAgICBsZXQgbWFwcGVkID0gdmFsdWUuZGlhZ25vc3RpY3MubWFwKHRyLmNoYW5nZXMpLCBzZWxlY3RlZCA9IG51bGw7XG4gICAgICAgICAgICBpZiAodmFsdWUuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgc2VsUG9zID0gdHIuY2hhbmdlcy5tYXBQb3ModmFsdWUuc2VsZWN0ZWQuZnJvbSwgMSk7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSBmaW5kRGlhZ25vc3RpYyhtYXBwZWQsIHZhbHVlLnNlbGVjdGVkLmRpYWdub3N0aWMsIHNlbFBvcykgfHwgZmluZERpYWdub3N0aWMobWFwcGVkLCBudWxsLCBzZWxQb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSBuZXcgTGludFN0YXRlKG1hcHBlZCwgdmFsdWUucGFuZWwsIHNlbGVjdGVkKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhzZXREaWFnbm9zdGljc0VmZmVjdCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmFuZ2VzID0gdmlldy5EZWNvcmF0aW9uLnNldChlZmZlY3QudmFsdWUubWFwKChkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkLmZyb20gPCBkLnRvXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHZpZXcuRGVjb3JhdGlvbi5tYXJrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7IGNsYXNzOiBcImNtLWxpbnRSYW5nZSBjbS1saW50UmFuZ2UtXCIgKyBkLnNldmVyaXR5IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlhZ25vc3RpYzogZFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkucmFuZ2UoZC5mcm9tLCBkLnRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB2aWV3LkRlY29yYXRpb24ud2lkZ2V0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWRnZXQ6IG5ldyBEaWFnbm9zdGljV2lkZ2V0KGQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpYWdub3N0aWM6IGRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLnJhbmdlKGQuZnJvbSk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IExpbnRTdGF0ZShyYW5nZXMsIHZhbHVlLnBhbmVsLCBmaW5kRGlhZ25vc3RpYyhyYW5nZXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVmZmVjdC5pcyh0b2dnbGVQYW5lbCkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBMaW50U3RhdGUodmFsdWUuZGlhZ25vc3RpY3MsIGVmZmVjdC52YWx1ZSA/IExpbnRQYW5lbC5vcGVuIDogbnVsbCwgdmFsdWUuc2VsZWN0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZWZmZWN0LmlzKG1vdmVQYW5lbFNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBMaW50U3RhdGUodmFsdWUuZGlhZ25vc3RpY3MsIHZhbHVlLnBhbmVsLCBlZmZlY3QudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHByb3ZpZGU6IGYgPT4gW3BhbmVsLnNob3dQYW5lbC5mcm9tKGYsIHZhbCA9PiB2YWwucGFuZWwpLFxuICAgICAgICB2aWV3LkVkaXRvclZpZXcuZGVjb3JhdGlvbnMuZnJvbShmLCBzID0+IHMuZGlhZ25vc3RpY3MpXVxufSk7XG5jb25zdCBhY3RpdmVNYXJrID0gdmlldy5EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1saW50UmFuZ2UgY20tbGludFJhbmdlLWFjdGl2ZVwiIH0pO1xuZnVuY3Rpb24gbGludFRvb2x0aXAodmlldywgcG9zLCBzaWRlKSB7XG4gICAgbGV0IHsgZGlhZ25vc3RpY3MgfSA9IHZpZXcuc3RhdGUuZmllbGQobGludFN0YXRlKTtcbiAgICBsZXQgZm91bmQgPSBbXSwgc3RhY2tTdGFydCA9IDJlOCwgc3RhY2tFbmQgPSAwO1xuICAgIGRpYWdub3N0aWNzLmJldHdlZW4ocG9zIC0gKHNpZGUgPCAwID8gMSA6IDApLCBwb3MgKyAoc2lkZSA+IDAgPyAxIDogMCksIChmcm9tLCB0bywgeyBzcGVjIH0pID0+IHtcbiAgICAgICAgaWYgKHBvcyA+PSBmcm9tICYmIHBvcyA8PSB0byAmJlxuICAgICAgICAgICAgKGZyb20gPT0gdG8gfHwgKChwb3MgPiBmcm9tIHx8IHNpZGUgPiAwKSAmJiAocG9zIDwgdG8gfHwgc2lkZSA8IDApKSkpIHtcbiAgICAgICAgICAgIGZvdW5kLnB1c2goc3BlYy5kaWFnbm9zdGljKTtcbiAgICAgICAgICAgIHN0YWNrU3RhcnQgPSBNYXRoLm1pbihmcm9tLCBzdGFja1N0YXJ0KTtcbiAgICAgICAgICAgIHN0YWNrRW5kID0gTWF0aC5tYXgodG8sIHN0YWNrRW5kKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghZm91bmQubGVuZ3RoKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICBwb3M6IHN0YWNrU3RhcnQsXG4gICAgICAgIGVuZDogc3RhY2tFbmQsXG4gICAgICAgIGFib3ZlOiB2aWV3LnN0YXRlLmRvYy5saW5lQXQoc3RhY2tTdGFydCkudG8gPCBzdGFja0VuZCxcbiAgICAgICAgY3JlYXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZG9tOiBlbHRfX2RlZmF1bHRbJ2RlZmF1bHQnXShcInVsXCIsIHsgY2xhc3M6IFwiY20tdG9vbHRpcC1saW50XCIgfSwgZm91bmQubWFwKGQgPT4gcmVuZGVyRGlhZ25vc3RpYyh2aWV3LCBkLCBmYWxzZSkpKSB9O1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8qKlxuQ29tbWFuZCB0byBvcGVuIGFuZCBmb2N1cyB0aGUgbGludCBwYW5lbC5cbiovXG5jb25zdCBvcGVuTGludFBhbmVsID0gKHZpZXcpID0+IHtcbiAgICBsZXQgZmllbGQgPSB2aWV3LnN0YXRlLmZpZWxkKGxpbnRTdGF0ZSwgZmFsc2UpO1xuICAgIGlmICghZmllbGQgfHwgIWZpZWxkLnBhbmVsKVxuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogbWF5YmVFbmFibGVMaW50KHZpZXcuc3RhdGUsIFt0b2dnbGVQYW5lbC5vZih0cnVlKV0pIH0pO1xuICAgIGxldCBwYW5lbCQxID0gcGFuZWwuZ2V0UGFuZWwodmlldywgTGludFBhbmVsLm9wZW4pO1xuICAgIGlmIChwYW5lbCQxKVxuICAgICAgICBwYW5lbCQxLmRvbS5xdWVyeVNlbGVjdG9yKFwiLmNtLXBhbmVsLWxpbnQgdWxcIikuZm9jdXMoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkNvbW1hbmQgdG8gY2xvc2UgdGhlIGxpbnQgcGFuZWwsIHdoZW4gb3Blbi5cbiovXG5jb25zdCBjbG9zZUxpbnRQYW5lbCA9ICh2aWV3KSA9PiB7XG4gICAgbGV0IGZpZWxkID0gdmlldy5zdGF0ZS5maWVsZChsaW50U3RhdGUsIGZhbHNlKTtcbiAgICBpZiAoIWZpZWxkIHx8ICFmaWVsZC5wYW5lbClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiB0b2dnbGVQYW5lbC5vZihmYWxzZSkgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIG5leHQgZGlhZ25vc3RpYy5cbiovXG5jb25zdCBuZXh0RGlhZ25vc3RpYyA9ICh2aWV3KSA9PiB7XG4gICAgbGV0IGZpZWxkID0gdmlldy5zdGF0ZS5maWVsZChsaW50U3RhdGUsIGZhbHNlKTtcbiAgICBpZiAoIWZpZWxkKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4sIG5leHQgPSBmaWVsZC5kaWFnbm9zdGljcy5pdGVyKHNlbC50byArIDEpO1xuICAgIGlmICghbmV4dC52YWx1ZSkge1xuICAgICAgICBuZXh0ID0gZmllbGQuZGlhZ25vc3RpY3MuaXRlcigwKTtcbiAgICAgICAgaWYgKCFuZXh0LnZhbHVlIHx8IG5leHQuZnJvbSA9PSBzZWwuZnJvbSAmJiBuZXh0LnRvID09IHNlbC50bylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmlldy5kaXNwYXRjaCh7IHNlbGVjdGlvbjogeyBhbmNob3I6IG5leHQuZnJvbSwgaGVhZDogbmV4dC50byB9LCBzY3JvbGxJbnRvVmlldzogdHJ1ZSB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkEgc2V0IG9mIGRlZmF1bHQga2V5IGJpbmRpbmdzIGZvciB0aGUgbGludCBmdW5jdGlvbmFsaXR5LlxuXG4tIEN0cmwtU2hpZnQtbSAoQ21kLVNoaWZ0LW0gb24gbWFjT1MpOiBbYG9wZW5MaW50UGFuZWxgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xpbnQub3BlbkxpbnRQYW5lbClcbi0gRjg6IFtgbmV4dERpYWdub3N0aWNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xpbnQubmV4dERpYWdub3N0aWMpXG4qL1xuY29uc3QgbGludEtleW1hcCA9IFtcbiAgICB7IGtleTogXCJNb2QtU2hpZnQtbVwiLCBydW46IG9wZW5MaW50UGFuZWwgfSxcbiAgICB7IGtleTogXCJGOFwiLCBydW46IG5leHREaWFnbm9zdGljIH1cbl07XG4vKipcbkdpdmVuIGEgZGlhZ25vc3RpYyBzb3VyY2UsIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhbiBleHRlbnNpb24gdGhhdFxuZW5hYmxlcyBsaW50aW5nIHdpdGggdGhhdCBzb3VyY2UuIEl0IHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIHRoZVxuZWRpdG9yIGlzIGlkbGUgKGFmdGVyIGl0cyBjb250ZW50IGNoYW5nZWQpLlxuKi9cbmZ1bmN0aW9uIGxpbnRlcihzb3VyY2UsIGNvbmZpZyA9IHt9KSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBkZWxheSA9IChfYSA9IGNvbmZpZy5kZWxheSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogNzUwO1xuICAgIHJldHVybiB2aWV3LlZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICAgICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgICAgIHRoaXMubGludFRpbWUgPSBEYXRlLm5vdygpICsgZGVsYXk7XG4gICAgICAgICAgICB0aGlzLnNldCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnJ1biA9IHRoaXMucnVuLmJpbmQodGhpcyk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHRoaXMucnVuLCBkZWxheSk7XG4gICAgICAgIH1cbiAgICAgICAgcnVuKCkge1xuICAgICAgICAgICAgbGV0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgICAgICBpZiAobm93IDwgdGhpcy5saW50VGltZSAtIDEwKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCh0aGlzLnJ1biwgdGhpcy5saW50VGltZSAtIG5vdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGxldCB7IHN0YXRlIH0gPSB0aGlzLnZpZXc7XG4gICAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHNvdXJjZSh0aGlzLnZpZXcpKS50aGVuKGFubm90YXRpb25zID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudmlldy5zdGF0ZS5kb2MgPT0gc3RhdGUuZG9jICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoYW5ub3RhdGlvbnMubGVuZ3RoIHx8ICgoX2IgPSAoX2EgPSB0aGlzLnZpZXcuc3RhdGUuZmllbGQobGludFN0YXRlLCBmYWxzZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaWFnbm9zdGljcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNpemUpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaChzZXREaWFnbm9zdGljcyh0aGlzLnZpZXcuc3RhdGUsIGFubm90YXRpb25zKSk7XG4gICAgICAgICAgICAgICAgfSwgZXJyb3IgPT4geyB2aWV3LmxvZ0V4Y2VwdGlvbih0aGlzLnZpZXcuc3RhdGUsIGVycm9yKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICAgICAgaWYgKHVwZGF0ZS5kb2NDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saW50VGltZSA9IERhdGUubm93KCkgKyBkZWxheTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCh0aGlzLnJ1biwgZGVsYXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gYXNzaWduS2V5cyhhY3Rpb25zKSB7XG4gICAgbGV0IGFzc2lnbmVkID0gW107XG4gICAgaWYgKGFjdGlvbnMpXG4gICAgICAgIGFjdGlvbnM6IGZvciAobGV0IHsgbmFtZSB9IG9mIGFjdGlvbnMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBjaCA9IG5hbWVbaV07XG4gICAgICAgICAgICAgICAgaWYgKC9bYS16QS1aXS8udGVzdChjaCkgJiYgIWFzc2lnbmVkLnNvbWUoYyA9PiBjLnRvTG93ZXJDYXNlKCkgPT0gY2gudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzaWduZWQucHVzaChjaCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIGFjdGlvbnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzaWduZWQucHVzaChcIlwiKTtcbiAgICAgICAgfVxuICAgIHJldHVybiBhc3NpZ25lZDtcbn1cbmZ1bmN0aW9uIHJlbmRlckRpYWdub3N0aWModmlldywgZGlhZ25vc3RpYywgaW5QYW5lbCkge1xuICAgIHZhciBfYTtcbiAgICBsZXQga2V5cyA9IGluUGFuZWwgPyBhc3NpZ25LZXlzKGRpYWdub3N0aWMuYWN0aW9ucykgOiBbXTtcbiAgICByZXR1cm4gZWx0X19kZWZhdWx0WydkZWZhdWx0J10oXCJsaVwiLCB7IGNsYXNzOiBcImNtLWRpYWdub3N0aWMgY20tZGlhZ25vc3RpYy1cIiArIGRpYWdub3N0aWMuc2V2ZXJpdHkgfSwgZWx0X19kZWZhdWx0WydkZWZhdWx0J10oXCJzcGFuXCIsIHsgY2xhc3M6IFwiY20tZGlhZ25vc3RpY1RleHRcIiB9LCBkaWFnbm9zdGljLm1lc3NhZ2UpLCAoX2EgPSBkaWFnbm9zdGljLmFjdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKGFjdGlvbiwgaSkgPT4ge1xuICAgICAgICBsZXQgY2xpY2sgPSAoZSkgPT4ge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gZmluZERpYWdub3N0aWModmlldy5zdGF0ZS5maWVsZChsaW50U3RhdGUpLmRpYWdub3N0aWNzLCBkaWFnbm9zdGljKTtcbiAgICAgICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICAgICAgICBhY3Rpb24uYXBwbHkodmlldywgZm91bmQuZnJvbSwgZm91bmQudG8pO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgeyBuYW1lIH0gPSBhY3Rpb24sIGtleUluZGV4ID0ga2V5c1tpXSA/IG5hbWUuaW5kZXhPZihrZXlzW2ldKSA6IC0xO1xuICAgICAgICBsZXQgbmFtZUVsdCA9IGtleUluZGV4IDwgMCA/IG5hbWUgOiBbbmFtZS5zbGljZSgwLCBrZXlJbmRleCksXG4gICAgICAgICAgICBlbHRfX2RlZmF1bHRbJ2RlZmF1bHQnXShcInVcIiwgbmFtZS5zbGljZShrZXlJbmRleCwga2V5SW5kZXggKyAxKSksXG4gICAgICAgICAgICBuYW1lLnNsaWNlKGtleUluZGV4ICsgMSldO1xuICAgICAgICByZXR1cm4gZWx0X19kZWZhdWx0WydkZWZhdWx0J10oXCJidXR0b25cIiwge1xuICAgICAgICAgICAgY2xhc3M6IFwiY20tZGlhZ25vc3RpY0FjdGlvblwiLFxuICAgICAgICAgICAgb25jbGljazogY2xpY2ssXG4gICAgICAgICAgICBvbm1vdXNlZG93bjogY2xpY2ssXG4gICAgICAgICAgICBcImFyaWEtbGFiZWxcIjogYCBBY3Rpb246ICR7bmFtZX0ke2tleUluZGV4IDwgMCA/IFwiXCIgOiBgIChhY2Nlc3Mga2V5IFwiJHtrZXlzW2ldfSlcImB9LmBcbiAgICAgICAgfSwgbmFtZUVsdCk7XG4gICAgfSksIGRpYWdub3N0aWMuc291cmNlICYmIGVsdF9fZGVmYXVsdFsnZGVmYXVsdCddKFwiZGl2XCIsIHsgY2xhc3M6IFwiY20tZGlhZ25vc3RpY1NvdXJjZVwiIH0sIGRpYWdub3N0aWMuc291cmNlKSk7XG59XG5jbGFzcyBEaWFnbm9zdGljV2lkZ2V0IGV4dGVuZHMgdmlldy5XaWRnZXRUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihkaWFnbm9zdGljKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZGlhZ25vc3RpYyA9IGRpYWdub3N0aWM7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7IHJldHVybiBvdGhlci5kaWFnbm9zdGljID09IHRoaXMuZGlhZ25vc3RpYzsgfVxuICAgIHRvRE9NKCkge1xuICAgICAgICByZXR1cm4gZWx0X19kZWZhdWx0WydkZWZhdWx0J10oXCJzcGFuXCIsIHsgY2xhc3M6IFwiY20tbGludFBvaW50IGNtLWxpbnRQb2ludC1cIiArIHRoaXMuZGlhZ25vc3RpYy5zZXZlcml0eSB9KTtcbiAgICB9XG59XG5jbGFzcyBQYW5lbEl0ZW0ge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIGRpYWdub3N0aWMpIHtcbiAgICAgICAgdGhpcy5kaWFnbm9zdGljID0gZGlhZ25vc3RpYztcbiAgICAgICAgdGhpcy5pZCA9IFwiaXRlbV9cIiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgdGhpcy5kb20gPSByZW5kZXJEaWFnbm9zdGljKHZpZXcsIGRpYWdub3N0aWMsIHRydWUpO1xuICAgICAgICB0aGlzLmRvbS5pZCA9IHRoaXMuaWQ7XG4gICAgICAgIHRoaXMuZG9tLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJvcHRpb25cIik7XG4gICAgfVxufVxuY2xhc3MgTGludFBhbmVsIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBbXTtcbiAgICAgICAgbGV0IG9ua2V5ZG93biA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gMjcpIHsgLy8gRXNjYXBlXG4gICAgICAgICAgICAgICAgY2xvc2VMaW50UGFuZWwodGhpcy52aWV3KTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT0gMzggfHwgZXZlbnQua2V5Q29kZSA9PSAzMykgeyAvLyBBcnJvd1VwLCBQYWdlVXBcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVTZWxlY3Rpb24oKHRoaXMuc2VsZWN0ZWRJbmRleCAtIDEgKyB0aGlzLml0ZW1zLmxlbmd0aCkgJSB0aGlzLml0ZW1zLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5rZXlDb2RlID09IDQwIHx8IGV2ZW50LmtleUNvZGUgPT0gMzQpIHsgLy8gQXJyb3dEb3duLCBQYWdlRG93blxuICAgICAgICAgICAgICAgIHRoaXMubW92ZVNlbGVjdGlvbigodGhpcy5zZWxlY3RlZEluZGV4ICsgMSkgJSB0aGlzLml0ZW1zLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5rZXlDb2RlID09IDM2KSB7IC8vIEhvbWVcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVTZWxlY3Rpb24oMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5rZXlDb2RlID09IDM1KSB7IC8vIEVuZFxuICAgICAgICAgICAgICAgIHRoaXMubW92ZVNlbGVjdGlvbih0aGlzLml0ZW1zLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PSAxMykgeyAvLyBFbnRlclxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA+PSA2NSAmJiBldmVudC5rZXlDb2RlIDw9IDkwICYmIHRoaXMuaXRlbXMubGVuZ3RoKSB7IC8vIEEtWlxuICAgICAgICAgICAgICAgIGxldCB7IGRpYWdub3N0aWMgfSA9IHRoaXMuaXRlbXNbdGhpcy5zZWxlY3RlZEluZGV4XSwga2V5cyA9IGFzc2lnbktleXMoZGlhZ25vc3RpYy5hY3Rpb25zKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXlzW2ldLnRvVXBwZXJDYXNlKCkuY2hhckNvZGVBdCgwKSA9PSBldmVudC5rZXlDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBmaW5kRGlhZ25vc3RpYyh0aGlzLnZpZXcuc3RhdGUuZmllbGQobGludFN0YXRlKS5kaWFnbm9zdGljcywgZGlhZ25vc3RpYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlhZ25vc3RpYy5hY3Rpb25zW2ldLmFwcGx5KHZpZXcsIGZvdW5kLmZyb20sIGZvdW5kLnRvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IG9uY2xpY2sgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5pdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLml0ZW1zW2ldLmRvbS5jb250YWlucyhldmVudC50YXJnZXQpKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmVTZWxlY3Rpb24oaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubGlzdCA9IGVsdF9fZGVmYXVsdFsnZGVmYXVsdCddKFwidWxcIiwge1xuICAgICAgICAgICAgdGFiSW5kZXg6IDAsXG4gICAgICAgICAgICByb2xlOiBcImxpc3Rib3hcIixcbiAgICAgICAgICAgIFwiYXJpYS1sYWJlbFwiOiB0aGlzLnZpZXcuc3RhdGUucGhyYXNlKFwiRGlhZ25vc3RpY3NcIiksXG4gICAgICAgICAgICBvbmtleWRvd24sXG4gICAgICAgICAgICBvbmNsaWNrXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRvbSA9IGVsdF9fZGVmYXVsdFsnZGVmYXVsdCddKFwiZGl2XCIsIHsgY2xhc3M6IFwiY20tcGFuZWwtbGludFwiIH0sIHRoaXMubGlzdCwgZWx0X19kZWZhdWx0WydkZWZhdWx0J10oXCJidXR0b25cIiwge1xuICAgICAgICAgICAgbmFtZTogXCJjbG9zZVwiLFxuICAgICAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHRoaXMudmlldy5zdGF0ZS5waHJhc2UoXCJjbG9zZVwiKSxcbiAgICAgICAgICAgIG9uY2xpY2s6ICgpID0+IGNsb3NlTGludFBhbmVsKHRoaXMudmlldylcbiAgICAgICAgfSwgXCLDl1wiKSk7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuICAgIGdldCBzZWxlY3RlZEluZGV4KCkge1xuICAgICAgICBsZXQgc2VsZWN0ZWQgPSB0aGlzLnZpZXcuc3RhdGUuZmllbGQobGludFN0YXRlKS5zZWxlY3RlZDtcbiAgICAgICAgaWYgKCFzZWxlY3RlZClcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLml0ZW1zLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHRoaXMuaXRlbXNbaV0uZGlhZ25vc3RpYyA9PSBzZWxlY3RlZC5kaWFnbm9zdGljKVxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgZGlhZ25vc3RpY3MsIHNlbGVjdGVkIH0gPSB0aGlzLnZpZXcuc3RhdGUuZmllbGQobGludFN0YXRlKTtcbiAgICAgICAgbGV0IGkgPSAwLCBuZWVkc1N5bmMgPSBmYWxzZSwgbmV3U2VsZWN0ZWRJdGVtID0gbnVsbDtcbiAgICAgICAgZGlhZ25vc3RpY3MuYmV0d2VlbigwLCB0aGlzLnZpZXcuc3RhdGUuZG9jLmxlbmd0aCwgKF9zdGFydCwgX2VuZCwgeyBzcGVjIH0pID0+IHtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IC0xLCBpdGVtO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGk7IGogPCB0aGlzLml0ZW1zLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLml0ZW1zW2pdLmRpYWdub3N0aWMgPT0gc3BlYy5kaWFnbm9zdGljKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gajtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvdW5kIDwgMCkge1xuICAgICAgICAgICAgICAgIGl0ZW0gPSBuZXcgUGFuZWxJdGVtKHRoaXMudmlldywgc3BlYy5kaWFnbm9zdGljKTtcbiAgICAgICAgICAgICAgICB0aGlzLml0ZW1zLnNwbGljZShpLCAwLCBpdGVtKTtcbiAgICAgICAgICAgICAgICBuZWVkc1N5bmMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IHRoaXMuaXRlbXNbZm91bmRdO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZCA+IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pdGVtcy5zcGxpY2UoaSwgZm91bmQgLSBpKTtcbiAgICAgICAgICAgICAgICAgICAgbmVlZHNTeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWQgJiYgaXRlbS5kaWFnbm9zdGljID09IHNlbGVjdGVkLmRpYWdub3N0aWMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW0uZG9tLmhhc0F0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5kb20uc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCBcInRydWVcIik7XG4gICAgICAgICAgICAgICAgICAgIG5ld1NlbGVjdGVkSXRlbSA9IGl0ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXRlbS5kb20uaGFzQXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiKSkge1xuICAgICAgICAgICAgICAgIGl0ZW0uZG9tLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH0pO1xuICAgICAgICB3aGlsZSAoaSA8IHRoaXMuaXRlbXMubGVuZ3RoICYmICEodGhpcy5pdGVtcy5sZW5ndGggPT0gMSAmJiB0aGlzLml0ZW1zWzBdLmRpYWdub3N0aWMuZnJvbSA8IDApKSB7XG4gICAgICAgICAgICBuZWVkc1N5bmMgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5pdGVtcy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pdGVtcy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5pdGVtcy5wdXNoKG5ldyBQYW5lbEl0ZW0odGhpcy52aWV3LCB7XG4gICAgICAgICAgICAgICAgZnJvbTogLTEsIHRvOiAtMSxcbiAgICAgICAgICAgICAgICBzZXZlcml0eTogXCJpbmZvXCIsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogdGhpcy52aWV3LnN0YXRlLnBocmFzZShcIk5vIGRpYWdub3N0aWNzXCIpXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBuZWVkc1N5bmMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdTZWxlY3RlZEl0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMubGlzdC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIiwgbmV3U2VsZWN0ZWRJdGVtLmlkKTtcbiAgICAgICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSh7XG4gICAgICAgICAgICAgICAga2V5OiB0aGlzLFxuICAgICAgICAgICAgICAgIHJlYWQ6ICgpID0+ICh7IHNlbDogbmV3U2VsZWN0ZWRJdGVtLmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgcGFuZWw6IHRoaXMubGlzdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSB9KSxcbiAgICAgICAgICAgICAgICB3cml0ZTogKHsgc2VsLCBwYW5lbCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWwudG9wIDwgcGFuZWwudG9wKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0LnNjcm9sbFRvcCAtPSBwYW5lbC50b3AgLSBzZWwudG9wO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzZWwuYm90dG9tID4gcGFuZWwuYm90dG9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0LnNjcm9sbFRvcCArPSBzZWwuYm90dG9tIC0gcGFuZWwuYm90dG9tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5saXN0LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmVlZHNTeW5jKVxuICAgICAgICAgICAgdGhpcy5zeW5jKCk7XG4gICAgfVxuICAgIHN5bmMoKSB7XG4gICAgICAgIGxldCBkb21Qb3MgPSB0aGlzLmxpc3QuZmlyc3RDaGlsZDtcbiAgICAgICAgZnVuY3Rpb24gcm0oKSB7XG4gICAgICAgICAgICBsZXQgcHJldiA9IGRvbVBvcztcbiAgICAgICAgICAgIGRvbVBvcyA9IHByZXYubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBwcmV2LnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGl0ZW0gb2YgdGhpcy5pdGVtcykge1xuICAgICAgICAgICAgaWYgKGl0ZW0uZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5saXN0KSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGRvbVBvcyAhPSBpdGVtLmRvbSlcbiAgICAgICAgICAgICAgICAgICAgcm0oKTtcbiAgICAgICAgICAgICAgICBkb21Qb3MgPSBpdGVtLmRvbS5uZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdC5pbnNlcnRCZWZvcmUoaXRlbS5kb20sIGRvbVBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGRvbVBvcylcbiAgICAgICAgICAgIHJtKCk7XG4gICAgfVxuICAgIG1vdmVTZWxlY3Rpb24oc2VsZWN0ZWRJbmRleCkge1xuICAgICAgICBpZiAodGhpcy5pdGVtcy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGZpZWxkID0gdGhpcy52aWV3LnN0YXRlLmZpZWxkKGxpbnRTdGF0ZSk7XG4gICAgICAgIGxldCBzZWxlY3Rpb24gPSBmaW5kRGlhZ25vc3RpYyhmaWVsZC5kaWFnbm9zdGljcywgdGhpcy5pdGVtc1tzZWxlY3RlZEluZGV4XS5kaWFnbm9zdGljKTtcbiAgICAgICAgaWYgKCFzZWxlY3Rpb24pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7XG4gICAgICAgICAgICBzZWxlY3Rpb246IHsgYW5jaG9yOiBzZWxlY3Rpb24uZnJvbSwgaGVhZDogc2VsZWN0aW9uLnRvIH0sXG4gICAgICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZSxcbiAgICAgICAgICAgIGVmZmVjdHM6IG1vdmVQYW5lbFNlbGVjdGlvbi5vZihzZWxlY3Rpb24pXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgb3Blbih2aWV3KSB7IHJldHVybiBuZXcgTGludFBhbmVsKHZpZXcpOyB9XG59XG5mdW5jdGlvbiB1bmRlcmxpbmUoY29sb3IpIHtcbiAgICBpZiAodHlwZW9mIGJ0b2EgIT0gXCJmdW5jdGlvblwiKVxuICAgICAgICByZXR1cm4gXCJub25lXCI7XG4gICAgbGV0IHN2ZyA9IGA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjZcIiBoZWlnaHQ9XCIzXCI+XG4gICAgPHBhdGggZD1cIm0wIDMgbDIgLTIgbDEgMCBsMiAyIGwxIDBcIiBzdHJva2U9XCIke2NvbG9yfVwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLXdpZHRoPVwiLjdcIi8+XG4gIDwvc3ZnPmA7XG4gICAgcmV0dXJuIGB1cmwoJ2RhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsJHtidG9hKHN2Zyl9JylgO1xufVxuY29uc3QgYmFzZVRoZW1lID0gdmlldy5FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCIuY20tZGlhZ25vc3RpY1wiOiB7XG4gICAgICAgIHBhZGRpbmc6IFwiM3B4IDZweCAzcHggOHB4XCIsXG4gICAgICAgIG1hcmdpbkxlZnQ6IFwiLTFweFwiLFxuICAgICAgICBkaXNwbGF5OiBcImJsb2NrXCIsXG4gICAgICAgIHdoaXRlU3BhY2U6IFwicHJlLXdyYXBcIlxuICAgIH0sXG4gICAgXCIuY20tZGlhZ25vc3RpYy1lcnJvclwiOiB7IGJvcmRlckxlZnQ6IFwiNXB4IHNvbGlkICNkMTFcIiB9LFxuICAgIFwiLmNtLWRpYWdub3N0aWMtd2FybmluZ1wiOiB7IGJvcmRlckxlZnQ6IFwiNXB4IHNvbGlkIG9yYW5nZVwiIH0sXG4gICAgXCIuY20tZGlhZ25vc3RpYy1pbmZvXCI6IHsgYm9yZGVyTGVmdDogXCI1cHggc29saWQgIzk5OVwiIH0sXG4gICAgXCIuY20tZGlhZ25vc3RpY0FjdGlvblwiOiB7XG4gICAgICAgIGZvbnQ6IFwiaW5oZXJpdFwiLFxuICAgICAgICBib3JkZXI6IFwibm9uZVwiLFxuICAgICAgICBwYWRkaW5nOiBcIjJweCA0cHhcIixcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiM0NDRcIixcbiAgICAgICAgY29sb3I6IFwid2hpdGVcIixcbiAgICAgICAgYm9yZGVyUmFkaXVzOiBcIjNweFwiLFxuICAgICAgICBtYXJnaW5MZWZ0OiBcIjhweFwiXG4gICAgfSxcbiAgICBcIi5jbS1kaWFnbm9zdGljU291cmNlXCI6IHtcbiAgICAgICAgZm9udFNpemU6IFwiNzAlXCIsXG4gICAgICAgIG9wYWNpdHk6IC43XG4gICAgfSxcbiAgICBcIi5jbS1saW50UmFuZ2VcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kUG9zaXRpb246IFwibGVmdCBib3R0b21cIixcbiAgICAgICAgYmFja2dyb3VuZFJlcGVhdDogXCJyZXBlYXQteFwiXG4gICAgfSxcbiAgICBcIi5jbS1saW50UmFuZ2UtZXJyb3JcIjogeyBiYWNrZ3JvdW5kSW1hZ2U6IHVuZGVybGluZShcIiNkMTFcIikgfSxcbiAgICBcIi5jbS1saW50UmFuZ2Utd2FybmluZ1wiOiB7IGJhY2tncm91bmRJbWFnZTogdW5kZXJsaW5lKFwib3JhbmdlXCIpIH0sXG4gICAgXCIuY20tbGludFJhbmdlLWluZm9cIjogeyBiYWNrZ3JvdW5kSW1hZ2U6IHVuZGVybGluZShcIiM5OTlcIikgfSxcbiAgICBcIi5jbS1saW50UmFuZ2UtYWN0aXZlXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiNmZmRkOTk4MFwiIH0sXG4gICAgXCIuY20tbGludFBvaW50XCI6IHtcbiAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcbiAgICAgICAgXCImOmFmdGVyXCI6IHtcbiAgICAgICAgICAgIGNvbnRlbnQ6ICdcIlwiJyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgICBib3R0b206IDAsXG4gICAgICAgICAgICBsZWZ0OiBcIi0ycHhcIixcbiAgICAgICAgICAgIGJvcmRlckxlZnQ6IFwiM3B4IHNvbGlkIHRyYW5zcGFyZW50XCIsXG4gICAgICAgICAgICBib3JkZXJSaWdodDogXCIzcHggc29saWQgdHJhbnNwYXJlbnRcIixcbiAgICAgICAgICAgIGJvcmRlckJvdHRvbTogXCI0cHggc29saWQgI2QxMVwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwiLmNtLWxpbnRQb2ludC13YXJuaW5nXCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgYm9yZGVyQm90dG9tQ29sb3I6IFwib3JhbmdlXCIgfVxuICAgIH0sXG4gICAgXCIuY20tbGludFBvaW50LWluZm9cIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBib3JkZXJCb3R0b21Db2xvcjogXCIjOTk5XCIgfVxuICAgIH0sXG4gICAgXCIuY20tcGFuZWwuY20tcGFuZWwtbGludFwiOiB7XG4gICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICAgIFwiJiB1bFwiOiB7XG4gICAgICAgICAgICBtYXhIZWlnaHQ6IFwiMTAwcHhcIixcbiAgICAgICAgICAgIG92ZXJmbG93WTogXCJhdXRvXCIsXG4gICAgICAgICAgICBcIiYgW2FyaWEtc2VsZWN0ZWRdXCI6IHtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2RkZFwiLFxuICAgICAgICAgICAgICAgIFwiJiB1XCI6IHsgdGV4dERlY29yYXRpb246IFwidW5kZXJsaW5lXCIgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiJjpmb2N1cyBbYXJpYS1zZWxlY3RlZF1cIjoge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmRfZmFsbGJhY2s6IFwiI2JkZlwiLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJIaWdobGlnaHRcIixcbiAgICAgICAgICAgICAgICBjb2xvcl9mYWxsYmFjazogXCJ3aGl0ZVwiLFxuICAgICAgICAgICAgICAgIGNvbG9yOiBcIkhpZ2hsaWdodFRleHRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiJiB1XCI6IHsgdGV4dERlY29yYXRpb246IFwibm9uZVwiIH0sXG4gICAgICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICAgICAgbWFyZ2luOiAwXG4gICAgICAgIH0sXG4gICAgICAgIFwiJiBbbmFtZT1jbG9zZV1cIjoge1xuICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgIHRvcDogXCIwXCIsXG4gICAgICAgICAgICByaWdodDogXCIycHhcIixcbiAgICAgICAgICAgIGJhY2tncm91bmQ6IFwiaW5oZXJpdFwiLFxuICAgICAgICAgICAgYm9yZGVyOiBcIm5vbmVcIixcbiAgICAgICAgICAgIGZvbnQ6IFwiaW5oZXJpdFwiLFxuICAgICAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgICAgIG1hcmdpbjogMFxuICAgICAgICB9XG4gICAgfSxcbiAgICBcIi5jbS10b29sdGlwLmNtLXRvb2x0aXAtbGludFwiOiB7XG4gICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgIG1hcmdpbjogMFxuICAgIH1cbn0pO1xuXG5leHBvcnRzLmNsb3NlTGludFBhbmVsID0gY2xvc2VMaW50UGFuZWw7XG5leHBvcnRzLmxpbnRLZXltYXAgPSBsaW50S2V5bWFwO1xuZXhwb3J0cy5saW50ZXIgPSBsaW50ZXI7XG5leHBvcnRzLm5leHREaWFnbm9zdGljID0gbmV4dERpYWdub3N0aWM7XG5leHBvcnRzLm9wZW5MaW50UGFuZWwgPSBvcGVuTGludFBhbmVsO1xuZXhwb3J0cy5zZXREaWFnbm9zdGljcyA9IHNldERpYWdub3N0aWNzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgc3RhdGUgPSByZXF1aXJlKCdAY29kZW1pcnJvci9zdGF0ZScpO1xudmFyIGxhbmd1YWdlID0gcmVxdWlyZSgnQGNvZGVtaXJyb3IvbGFuZ3VhZ2UnKTtcbnZhciB2aWV3ID0gcmVxdWlyZSgnQGNvZGVtaXJyb3IvdmlldycpO1xudmFyIGxlemVyVHJlZSA9IHJlcXVpcmUoJ2xlemVyLXRyZWUnKTtcblxuY29uc3QgYmFzZVRoZW1lID0gdmlldy5FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCIuY20tbWF0Y2hpbmdCcmFja2V0XCI6IHsgY29sb3I6IFwiIzBiMFwiIH0sXG4gICAgXCIuY20tbm9ubWF0Y2hpbmdCcmFja2V0XCI6IHsgY29sb3I6IFwiI2EyMlwiIH1cbn0pO1xuY29uc3QgRGVmYXVsdFNjYW5EaXN0ID0gMTAwMDAsIERlZmF1bHRCcmFja2V0cyA9IFwiKClbXXt9XCI7XG5jb25zdCBicmFja2V0TWF0Y2hpbmdDb25maWcgPSBzdGF0ZS5GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUoY29uZmlncykge1xuICAgICAgICByZXR1cm4gc3RhdGUuY29tYmluZUNvbmZpZyhjb25maWdzLCB7XG4gICAgICAgICAgICBhZnRlckN1cnNvcjogdHJ1ZSxcbiAgICAgICAgICAgIGJyYWNrZXRzOiBEZWZhdWx0QnJhY2tldHMsXG4gICAgICAgICAgICBtYXhTY2FuRGlzdGFuY2U6IERlZmF1bHRTY2FuRGlzdFxuICAgICAgICB9KTtcbiAgICB9XG59KTtcbmNvbnN0IG1hdGNoaW5nTWFyayA9IHZpZXcuRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tbWF0Y2hpbmdCcmFja2V0XCIgfSksIG5vbm1hdGNoaW5nTWFyayA9IHZpZXcuRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tbm9ubWF0Y2hpbmdCcmFja2V0XCIgfSk7XG5jb25zdCBicmFja2V0TWF0Y2hpbmdTdGF0ZSA9IHN0YXRlLlN0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7IHJldHVybiB2aWV3LkRlY29yYXRpb24ubm9uZTsgfSxcbiAgICB1cGRhdGUoZGVjbywgdHIpIHtcbiAgICAgICAgaWYgKCF0ci5kb2NDaGFuZ2VkICYmICF0ci5zZWxlY3Rpb24pXG4gICAgICAgICAgICByZXR1cm4gZGVjbztcbiAgICAgICAgbGV0IGRlY29yYXRpb25zID0gW107XG4gICAgICAgIGxldCBjb25maWcgPSB0ci5zdGF0ZS5mYWNldChicmFja2V0TWF0Y2hpbmdDb25maWcpO1xuICAgICAgICBmb3IgKGxldCByYW5nZSBvZiB0ci5zdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgICAgICAgICBpZiAoIXJhbmdlLmVtcHR5KVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IG1hdGNoID0gbWF0Y2hCcmFja2V0cyh0ci5zdGF0ZSwgcmFuZ2UuaGVhZCwgLTEsIGNvbmZpZylcbiAgICAgICAgICAgICAgICB8fCAocmFuZ2UuaGVhZCA+IDAgJiYgbWF0Y2hCcmFja2V0cyh0ci5zdGF0ZSwgcmFuZ2UuaGVhZCAtIDEsIDEsIGNvbmZpZykpXG4gICAgICAgICAgICAgICAgfHwgKGNvbmZpZy5hZnRlckN1cnNvciAmJlxuICAgICAgICAgICAgICAgICAgICAobWF0Y2hCcmFja2V0cyh0ci5zdGF0ZSwgcmFuZ2UuaGVhZCwgMSwgY29uZmlnKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKHJhbmdlLmhlYWQgPCB0ci5zdGF0ZS5kb2MubGVuZ3RoICYmIG1hdGNoQnJhY2tldHModHIuc3RhdGUsIHJhbmdlLmhlYWQgKyAxLCAtMSwgY29uZmlnKSkpKTtcbiAgICAgICAgICAgIGlmICghbWF0Y2gpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgbWFyayA9IG1hdGNoLm1hdGNoZWQgPyBtYXRjaGluZ01hcmsgOiBub25tYXRjaGluZ01hcms7XG4gICAgICAgICAgICBkZWNvcmF0aW9ucy5wdXNoKG1hcmsucmFuZ2UobWF0Y2guc3RhcnQuZnJvbSwgbWF0Y2guc3RhcnQudG8pKTtcbiAgICAgICAgICAgIGlmIChtYXRjaC5lbmQpXG4gICAgICAgICAgICAgICAgZGVjb3JhdGlvbnMucHVzaChtYXJrLnJhbmdlKG1hdGNoLmVuZC5mcm9tLCBtYXRjaC5lbmQudG8pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmlldy5EZWNvcmF0aW9uLnNldChkZWNvcmF0aW9ucywgdHJ1ZSk7XG4gICAgfSxcbiAgICBwcm92aWRlOiBmID0+IHZpZXcuRWRpdG9yVmlldy5kZWNvcmF0aW9ucy5mcm9tKGYpXG59KTtcbmNvbnN0IGJyYWNrZXRNYXRjaGluZ1VuaXF1ZSA9IFtcbiAgICBicmFja2V0TWF0Y2hpbmdTdGF0ZSxcbiAgICBiYXNlVGhlbWVcbl07XG4vLy8gQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IGVuYWJsZXMgYnJhY2tldCBtYXRjaGluZy4gV2hlbmV2ZXIgdGhlXG4vLy8gY3Vyc29yIGlzIG5leHQgdG8gYSBicmFja2V0LCB0aGF0IGJyYWNrZXQgYW5kIHRoZSBvbmUgaXQgbWF0Y2hlc1xuLy8vIGFyZSBoaWdobGlnaHRlZC4gT3IsIHdoZW4gbm8gbWF0Y2hpbmcgYnJhY2tldCBpcyBmb3VuZCwgYW5vdGhlclxuLy8vIGhpZ2hsaWdodGluZyBzdHlsZSBpcyB1c2VkIHRvIGluZGljYXRlIHRoaXMuXG5mdW5jdGlvbiBicmFja2V0TWF0Y2hpbmcoY29uZmlnID0ge30pIHtcbiAgICByZXR1cm4gW2JyYWNrZXRNYXRjaGluZ0NvbmZpZy5vZihjb25maWcpLCBicmFja2V0TWF0Y2hpbmdVbmlxdWVdO1xufVxuZnVuY3Rpb24gbWF0Y2hpbmdOb2Rlcyhub2RlLCBkaXIsIGJyYWNrZXRzKSB7XG4gICAgbGV0IGJ5UHJvcCA9IG5vZGUucHJvcChkaXIgPCAwID8gbGV6ZXJUcmVlLk5vZGVQcm9wLm9wZW5lZEJ5IDogbGV6ZXJUcmVlLk5vZGVQcm9wLmNsb3NlZEJ5KTtcbiAgICBpZiAoYnlQcm9wKVxuICAgICAgICByZXR1cm4gYnlQcm9wO1xuICAgIGlmIChub2RlLm5hbWUubGVuZ3RoID09IDEpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gYnJhY2tldHMuaW5kZXhPZihub2RlLm5hbWUpO1xuICAgICAgICBpZiAoaW5kZXggPiAtMSAmJiBpbmRleCAlIDIgPT0gKGRpciA8IDAgPyAxIDogMCkpXG4gICAgICAgICAgICByZXR1cm4gW2JyYWNrZXRzW2luZGV4ICsgZGlyXV07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLy8vIEZpbmQgdGhlIG1hdGNoaW5nIGJyYWNrZXQgZm9yIHRoZSB0b2tlbiBhdCBgcG9zYCwgc2Nhbm5pbmdcbi8vLyBkaXJlY3Rpb24gYGRpcmAuIE9ubHkgdGhlIGBicmFja2V0c2AgYW5kIGBtYXhTY2FuRGlzdGFuY2VgXG4vLy8gcHJvcGVydGllcyBhcmUgdXNlZCBmcm9tIGBjb25maWdgLCBpZiBnaXZlbi4gUmV0dXJucyBudWxsIGlmIG5vXG4vLy8gYnJhY2tldCB3YXMgZm91bmQgYXQgYHBvc2AsIG9yIGEgbWF0Y2ggcmVzdWx0IG90aGVyd2lzZS5cbmZ1bmN0aW9uIG1hdGNoQnJhY2tldHMoc3RhdGUsIHBvcywgZGlyLCBjb25maWcgPSB7fSkge1xuICAgIGxldCBtYXhTY2FuRGlzdGFuY2UgPSBjb25maWcubWF4U2NhbkRpc3RhbmNlIHx8IERlZmF1bHRTY2FuRGlzdCwgYnJhY2tldHMgPSBjb25maWcuYnJhY2tldHMgfHwgRGVmYXVsdEJyYWNrZXRzO1xuICAgIGxldCB0cmVlID0gbGFuZ3VhZ2Uuc3ludGF4VHJlZShzdGF0ZSksIHN1YiA9IHRyZWUucmVzb2x2ZShwb3MsIGRpciksIG1hdGNoZXM7XG4gICAgaWYgKG1hdGNoZXMgPSBtYXRjaGluZ05vZGVzKHN1Yi50eXBlLCBkaXIsIGJyYWNrZXRzKSlcbiAgICAgICAgcmV0dXJuIG1hdGNoTWFya2VkQnJhY2tldHMoc3RhdGUsIHBvcywgZGlyLCBzdWIsIG1hdGNoZXMsIGJyYWNrZXRzKTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiBtYXRjaFBsYWluQnJhY2tldHMoc3RhdGUsIHBvcywgZGlyLCB0cmVlLCBzdWIudHlwZSwgbWF4U2NhbkRpc3RhbmNlLCBicmFja2V0cyk7XG59XG5mdW5jdGlvbiBtYXRjaE1hcmtlZEJyYWNrZXRzKF9zdGF0ZSwgX3BvcywgZGlyLCB0b2tlbiwgbWF0Y2hpbmcsIGJyYWNrZXRzKSB7XG4gICAgbGV0IHBhcmVudCA9IHRva2VuLnBhcmVudCwgZmlyc3RUb2tlbiA9IHsgZnJvbTogdG9rZW4uZnJvbSwgdG86IHRva2VuLnRvIH07XG4gICAgbGV0IGRlcHRoID0gMCwgY3Vyc29yID0gcGFyZW50ID09PSBudWxsIHx8IHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50LmN1cnNvcjtcbiAgICBpZiAoY3Vyc29yICYmIChkaXIgPCAwID8gY3Vyc29yLmNoaWxkQmVmb3JlKHRva2VuLmZyb20pIDogY3Vyc29yLmNoaWxkQWZ0ZXIodG9rZW4udG8pKSlcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKGRpciA8IDAgPyBjdXJzb3IudG8gPD0gdG9rZW4uZnJvbSA6IGN1cnNvci5mcm9tID49IHRva2VuLnRvKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlcHRoID09IDAgJiYgbWF0Y2hpbmcuaW5kZXhPZihjdXJzb3IudHlwZS5uYW1lKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0OiBmaXJzdFRva2VuLCBlbmQ6IHsgZnJvbTogY3Vyc29yLmZyb20sIHRvOiBjdXJzb3IudG8gfSwgbWF0Y2hlZDogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtYXRjaGluZ05vZGVzKGN1cnNvci50eXBlLCBkaXIsIGJyYWNrZXRzKSkge1xuICAgICAgICAgICAgICAgICAgICBkZXB0aCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtYXRjaGluZ05vZGVzKGN1cnNvci50eXBlLCAtZGlyLCBicmFja2V0cykpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlcHRoID09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBzdGFydDogZmlyc3RUb2tlbiwgZW5kOiB7IGZyb206IGN1cnNvci5mcm9tLCB0bzogY3Vyc29yLnRvIH0sIG1hdGNoZWQ6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChkaXIgPCAwID8gY3Vyc29yLnByZXZTaWJsaW5nKCkgOiBjdXJzb3IubmV4dFNpYmxpbmcoKSk7XG4gICAgcmV0dXJuIHsgc3RhcnQ6IGZpcnN0VG9rZW4sIG1hdGNoZWQ6IGZhbHNlIH07XG59XG5mdW5jdGlvbiBtYXRjaFBsYWluQnJhY2tldHMoc3RhdGUsIHBvcywgZGlyLCB0cmVlLCB0b2tlblR5cGUsIG1heFNjYW5EaXN0YW5jZSwgYnJhY2tldHMpIHtcbiAgICBsZXQgc3RhcnRDaCA9IGRpciA8IDAgPyBzdGF0ZS5zbGljZURvYyhwb3MgLSAxLCBwb3MpIDogc3RhdGUuc2xpY2VEb2MocG9zLCBwb3MgKyAxKTtcbiAgICBsZXQgYnJhY2tldCA9IGJyYWNrZXRzLmluZGV4T2Yoc3RhcnRDaCk7XG4gICAgaWYgKGJyYWNrZXQgPCAwIHx8IChicmFja2V0ICUgMiA9PSAwKSAhPSAoZGlyID4gMCkpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBzdGFydFRva2VuID0geyBmcm9tOiBkaXIgPCAwID8gcG9zIC0gMSA6IHBvcywgdG86IGRpciA+IDAgPyBwb3MgKyAxIDogcG9zIH07XG4gICAgbGV0IGl0ZXIgPSBzdGF0ZS5kb2MuaXRlclJhbmdlKHBvcywgZGlyID4gMCA/IHN0YXRlLmRvYy5sZW5ndGggOiAwKSwgZGVwdGggPSAwO1xuICAgIGZvciAobGV0IGRpc3RhbmNlID0gMDsgIShpdGVyLm5leHQoKSkuZG9uZSAmJiBkaXN0YW5jZSA8PSBtYXhTY2FuRGlzdGFuY2U7KSB7XG4gICAgICAgIGxldCB0ZXh0ID0gaXRlci52YWx1ZTtcbiAgICAgICAgaWYgKGRpciA8IDApXG4gICAgICAgICAgICBkaXN0YW5jZSArPSB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgbGV0IGJhc2VQb3MgPSBwb3MgKyBkaXN0YW5jZSAqIGRpcjtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gZGlyID4gMCA/IDAgOiB0ZXh0Lmxlbmd0aCAtIDEsIGVuZCA9IGRpciA+IDAgPyB0ZXh0Lmxlbmd0aCA6IC0xOyBwb3MgIT0gZW5kOyBwb3MgKz0gZGlyKSB7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBicmFja2V0cy5pbmRleE9mKHRleHRbcG9zXSk7XG4gICAgICAgICAgICBpZiAoZm91bmQgPCAwIHx8IHRyZWUucmVzb2x2ZShiYXNlUG9zICsgcG9zLCAxKS50eXBlICE9IHRva2VuVHlwZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICgoZm91bmQgJSAyID09IDApID09IChkaXIgPiAwKSkge1xuICAgICAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkZXB0aCA9PSAxKSB7IC8vIENsb3NpbmdcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdGFydDogc3RhcnRUb2tlbiwgZW5kOiB7IGZyb206IGJhc2VQb3MgKyBwb3MsIHRvOiBiYXNlUG9zICsgcG9zICsgMSB9LCBtYXRjaGVkOiAoZm91bmQgPj4gMSkgPT0gKGJyYWNrZXQgPj4gMSkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpciA+IDApXG4gICAgICAgICAgICBkaXN0YW5jZSArPSB0ZXh0Lmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZXIuZG9uZSA/IHsgc3RhcnQ6IHN0YXJ0VG9rZW4sIG1hdGNoZWQ6IGZhbHNlIH0gOiBudWxsO1xufVxuXG5leHBvcnRzLmJyYWNrZXRNYXRjaGluZyA9IGJyYWNrZXRNYXRjaGluZztcbmV4cG9ydHMubWF0Y2hCcmFja2V0cyA9IG1hdGNoQnJhY2tldHM7XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciB2aWV3ID0gcmVxdWlyZSgnQGNvZGVtaXJyb3IvdmlldycpO1xudmFyIHN0YXRlID0gcmVxdWlyZSgnQGNvZGVtaXJyb3Ivc3RhdGUnKTtcblxuY29uc3QgcGFuZWxDb25maWcgPSBzdGF0ZS5GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUoY29uZmlncykge1xuICAgICAgICBsZXQgdG9wQ29udGFpbmVyLCBib3R0b21Db250YWluZXI7XG4gICAgICAgIGZvciAobGV0IGMgb2YgY29uZmlncykge1xuICAgICAgICAgICAgdG9wQ29udGFpbmVyID0gdG9wQ29udGFpbmVyIHx8IGMudG9wQ29udGFpbmVyO1xuICAgICAgICAgICAgYm90dG9tQ29udGFpbmVyID0gYm90dG9tQ29udGFpbmVyIHx8IGMuYm90dG9tQ29udGFpbmVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHRvcENvbnRhaW5lciwgYm90dG9tQ29udGFpbmVyIH07XG4gICAgfVxufSk7XG4vKipcbkNvbmZpZ3VyZXMgdGhlIHBhbmVsLW1hbmFnaW5nIGV4dGVuc2lvbi5cbiovXG5mdW5jdGlvbiBwYW5lbHMoY29uZmlnKSB7XG4gICAgcmV0dXJuIGNvbmZpZyA/IFtwYW5lbENvbmZpZy5vZihjb25maWcpXSA6IFtdO1xufVxuLyoqXG5HZXQgdGhlIGFjdGl2ZSBwYW5lbCBjcmVhdGVkIGJ5IHRoZSBnaXZlbiBjb25zdHJ1Y3RvciwgaWYgYW55LlxuVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW4geW91IG5lZWQgYWNjZXNzIHRvIHlvdXIgcGFuZWxzJyBET01cbnN0cnVjdHVyZS5cbiovXG5mdW5jdGlvbiBnZXRQYW5lbCh2aWV3LCBwYW5lbCkge1xuICAgIGxldCBwbHVnaW4gPSB2aWV3LnBsdWdpbihwYW5lbFBsdWdpbik7XG4gICAgbGV0IGluZGV4ID0gcGx1Z2luID8gcGx1Z2luLnNwZWNzLmluZGV4T2YocGFuZWwpIDogLTE7XG4gICAgcmV0dXJuIGluZGV4ID4gLTEgPyBwbHVnaW4ucGFuZWxzW2luZGV4XSA6IG51bGw7XG59XG5jb25zdCBwYW5lbFBsdWdpbiA9IHZpZXcuVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy5pbnB1dCA9IHZpZXcuc3RhdGUuZmFjZXQoc2hvd1BhbmVsKTtcbiAgICAgICAgdGhpcy5zcGVjcyA9IHRoaXMuaW5wdXQuZmlsdGVyKHMgPT4gcyk7XG4gICAgICAgIHRoaXMucGFuZWxzID0gdGhpcy5zcGVjcy5tYXAoc3BlYyA9PiBzcGVjKHZpZXcpKTtcbiAgICAgICAgbGV0IGNvbmYgPSB2aWV3LnN0YXRlLmZhY2V0KHBhbmVsQ29uZmlnKTtcbiAgICAgICAgdGhpcy50b3AgPSBuZXcgUGFuZWxHcm91cCh2aWV3LCB0cnVlLCBjb25mLnRvcENvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuYm90dG9tID0gbmV3IFBhbmVsR3JvdXAodmlldywgZmFsc2UsIGNvbmYuYm90dG9tQ29udGFpbmVyKTtcbiAgICAgICAgdGhpcy50b3Auc3luYyh0aGlzLnBhbmVscy5maWx0ZXIocCA9PiBwLnRvcCkpO1xuICAgICAgICB0aGlzLmJvdHRvbS5zeW5jKHRoaXMucGFuZWxzLmZpbHRlcihwID0+ICFwLnRvcCkpO1xuICAgICAgICBmb3IgKGxldCBwIG9mIHRoaXMucGFuZWxzKSB7XG4gICAgICAgICAgICBwLmRvbS5jbGFzc0xpc3QuYWRkKFwiY20tcGFuZWxcIik7XG4gICAgICAgICAgICAvLyBGSVhNRSBkcm9wIG9uIG5leHQgYnJlYWtpbmcgcmVsZWFzZVxuICAgICAgICAgICAgaWYgKHAuY2xhc3MpXG4gICAgICAgICAgICAgICAgcC5kb20uY2xhc3NMaXN0LmFkZChwLmNsYXNzKTtcbiAgICAgICAgICAgIGlmIChwLm1vdW50KVxuICAgICAgICAgICAgICAgIHAubW91bnQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGxldCBjb25mID0gdXBkYXRlLnN0YXRlLmZhY2V0KHBhbmVsQ29uZmlnKTtcbiAgICAgICAgaWYgKHRoaXMudG9wLmNvbnRhaW5lciAhPSBjb25mLnRvcENvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy50b3Auc3luYyhbXSk7XG4gICAgICAgICAgICB0aGlzLnRvcCA9IG5ldyBQYW5lbEdyb3VwKHVwZGF0ZS52aWV3LCB0cnVlLCBjb25mLnRvcENvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYm90dG9tLmNvbnRhaW5lciAhPSBjb25mLmJvdHRvbUNvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy5ib3R0b20uc3luYyhbXSk7XG4gICAgICAgICAgICB0aGlzLmJvdHRvbSA9IG5ldyBQYW5lbEdyb3VwKHVwZGF0ZS52aWV3LCBmYWxzZSwgY29uZi5ib3R0b21Db250YWluZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG9wLnN5bmNDbGFzc2VzKCk7XG4gICAgICAgIHRoaXMuYm90dG9tLnN5bmNDbGFzc2VzKCk7XG4gICAgICAgIGxldCBpbnB1dCA9IHVwZGF0ZS5zdGF0ZS5mYWNldChzaG93UGFuZWwpO1xuICAgICAgICBpZiAoaW5wdXQgIT0gdGhpcy5pbnB1dCkge1xuICAgICAgICAgICAgbGV0IHNwZWNzID0gaW5wdXQuZmlsdGVyKHggPT4geCk7XG4gICAgICAgICAgICBsZXQgcGFuZWxzID0gW10sIHRvcCA9IFtdLCBib3R0b20gPSBbXSwgbW91bnQgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IHNwZWMgb2Ygc3BlY3MpIHtcbiAgICAgICAgICAgICAgICBsZXQga25vd24gPSB0aGlzLnNwZWNzLmluZGV4T2Yoc3BlYyksIHBhbmVsO1xuICAgICAgICAgICAgICAgIGlmIChrbm93biA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcGFuZWwgPSBzcGVjKHVwZGF0ZS52aWV3KTtcbiAgICAgICAgICAgICAgICAgICAgbW91bnQucHVzaChwYW5lbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYW5lbCA9IHRoaXMucGFuZWxzW2tub3duXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhbmVsLnVwZGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhbmVsLnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYW5lbHMucHVzaChwYW5lbCk7XG4gICAgICAgICAgICAgICAgKHBhbmVsLnRvcCA/IHRvcCA6IGJvdHRvbSkucHVzaChwYW5lbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNwZWNzID0gc3BlY3M7XG4gICAgICAgICAgICB0aGlzLnBhbmVscyA9IHBhbmVscztcbiAgICAgICAgICAgIHRoaXMudG9wLnN5bmModG9wKTtcbiAgICAgICAgICAgIHRoaXMuYm90dG9tLnN5bmMoYm90dG9tKTtcbiAgICAgICAgICAgIGZvciAobGV0IHAgb2YgbW91bnQpIHtcbiAgICAgICAgICAgICAgICBwLmRvbS5jbGFzc0xpc3QuYWRkKFwiY20tcGFuZWxcIik7XG4gICAgICAgICAgICAgICAgLy8gRklYTUUgZHJvcCBvbiBuZXh0IGJyZWFraW5nIHJlbGVhc2VcbiAgICAgICAgICAgICAgICBpZiAocC5jbGFzcylcbiAgICAgICAgICAgICAgICAgICAgcC5kb20uY2xhc3NMaXN0LmFkZChwLmNsYXNzKTtcbiAgICAgICAgICAgICAgICBpZiAocC5tb3VudClcbiAgICAgICAgICAgICAgICAgICAgcC5tb3VudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgcCBvZiB0aGlzLnBhbmVscylcbiAgICAgICAgICAgICAgICBpZiAocC51cGRhdGUpXG4gICAgICAgICAgICAgICAgICAgIHAudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy50b3Auc3luYyhbXSk7XG4gICAgICAgIHRoaXMuYm90dG9tLnN5bmMoW10pO1xuICAgIH1cbn0sIHtcbiAgICBwcm92aWRlOiB2aWV3LlBsdWdpbkZpZWxkLnNjcm9sbE1hcmdpbnMuZnJvbSh2YWx1ZSA9PiAoeyB0b3A6IHZhbHVlLnRvcC5zY3JvbGxNYXJnaW4oKSwgYm90dG9tOiB2YWx1ZS5ib3R0b20uc2Nyb2xsTWFyZ2luKCkgfSkpXG59KTtcbmNsYXNzIFBhbmVsR3JvdXAge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIHRvcCwgY29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMudG9wID0gdG9wO1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5kb20gPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY2xhc3NlcyA9IFwiXCI7XG4gICAgICAgIHRoaXMucGFuZWxzID0gW107XG4gICAgICAgIHRoaXMuc3luY0NsYXNzZXMoKTtcbiAgICB9XG4gICAgc3luYyhwYW5lbHMpIHtcbiAgICAgICAgdGhpcy5wYW5lbHMgPSBwYW5lbHM7XG4gICAgICAgIHRoaXMuc3luY0RPTSgpO1xuICAgIH1cbiAgICBzeW5jRE9NKCkge1xuICAgICAgICBpZiAodGhpcy5wYW5lbHMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5kb20pIHtcbiAgICAgICAgICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9IHRoaXMudG9wID8gXCJjbS1wYW5lbHMgY20tcGFuZWxzLXRvcFwiIDogXCJjbS1wYW5lbHMgY20tcGFuZWxzLWJvdHRvbVwiO1xuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGVbdGhpcy50b3AgPyBcInRvcFwiIDogXCJib3R0b21cIl0gPSBcIjBcIjtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLmNvbnRhaW5lciB8fCB0aGlzLnZpZXcuZG9tO1xuICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLmRvbSwgdGhpcy50b3AgPyBwYXJlbnQuZmlyc3RDaGlsZCA6IG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJET00gPSB0aGlzLmRvbS5maXJzdENoaWxkO1xuICAgICAgICBmb3IgKGxldCBwYW5lbCBvZiB0aGlzLnBhbmVscykge1xuICAgICAgICAgICAgaWYgKHBhbmVsLmRvbS5wYXJlbnROb2RlID09IHRoaXMuZG9tKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGN1ckRPTSAhPSBwYW5lbC5kb20pXG4gICAgICAgICAgICAgICAgICAgIGN1ckRPTSA9IHJtKGN1ckRPTSk7XG4gICAgICAgICAgICAgICAgY3VyRE9NID0gY3VyRE9NLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb20uaW5zZXJ0QmVmb3JlKHBhbmVsLmRvbSwgY3VyRE9NKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoY3VyRE9NKVxuICAgICAgICAgICAgY3VyRE9NID0gcm0oY3VyRE9NKTtcbiAgICB9XG4gICAgc2Nyb2xsTWFyZ2luKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuZG9tIHx8IHRoaXMuY29udGFpbmVyID8gMFxuICAgICAgICAgICAgOiBNYXRoLm1heCgwLCB0aGlzLnRvcCA/IHRoaXMuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbSAtIHRoaXMudmlldy5zY3JvbGxET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wXG4gICAgICAgICAgICAgICAgOiB0aGlzLnZpZXcuc2Nyb2xsRE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbSAtIHRoaXMuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCk7XG4gICAgfVxuICAgIHN5bmNDbGFzc2VzKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29udGFpbmVyIHx8IHRoaXMuY2xhc3NlcyA9PSB0aGlzLnZpZXcudGhlbWVDbGFzc2VzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKGxldCBjbHMgb2YgdGhpcy5jbGFzc2VzLnNwbGl0KFwiIFwiKSlcbiAgICAgICAgICAgIGlmIChjbHMpXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xuICAgICAgICBmb3IgKGxldCBjbHMgb2YgKHRoaXMuY2xhc3NlcyA9IHRoaXMudmlldy50aGVtZUNsYXNzZXMpLnNwbGl0KFwiIFwiKSlcbiAgICAgICAgICAgIGlmIChjbHMpXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChjbHMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJtKG5vZGUpIHtcbiAgICBsZXQgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgbm9kZS5yZW1vdmUoKTtcbiAgICByZXR1cm4gbmV4dDtcbn1cbmNvbnN0IGJhc2VUaGVtZSA9IHZpZXcuRWRpdG9yVmlldy5iYXNlVGhlbWUoe1xuICAgIFwiLmNtLXBhbmVsc1wiOiB7XG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgICAgIHBvc2l0aW9uOiBcInN0aWNreVwiLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICByaWdodDogMFxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXBhbmVsc1wiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjZjVmNWY1XCIsXG4gICAgICAgIGNvbG9yOiBcImJsYWNrXCJcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1wYW5lbHMtdG9wXCI6IHtcbiAgICAgICAgYm9yZGVyQm90dG9tOiBcIjFweCBzb2xpZCAjZGRkXCJcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1wYW5lbHMtYm90dG9tXCI6IHtcbiAgICAgICAgYm9yZGVyVG9wOiBcIjFweCBzb2xpZCAjZGRkXCJcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLXBhbmVsc1wiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjMzMzMzM4XCIsXG4gICAgICAgIGNvbG9yOiBcIndoaXRlXCJcbiAgICB9XG59KTtcbi8qKlxuT3BlbmluZyBhIHBhbmVsIGlzIGRvbmUgYnkgcHJvdmlkaW5nIGEgY29uc3RydWN0b3IgZnVuY3Rpb24gZm9yXG50aGUgcGFuZWwgdGhyb3VnaCB0aGlzIGZhY2V0LiAoVGhlIHBhbmVsIGlzIGNsb3NlZCBhZ2FpbiB3aGVuIGl0c1xuY29uc3RydWN0b3IgaXMgbm8gbG9uZ2VyIHByb3ZpZGVkLikgVmFsdWVzIG9mIGBudWxsYCBhcmUgaWdub3JlZC5cbiovXG5jb25zdCBzaG93UGFuZWwgPSBzdGF0ZS5GYWNldC5kZWZpbmUoe1xuICAgIGVuYWJsZXM6IFtwYW5lbFBsdWdpbiwgYmFzZVRoZW1lXVxufSk7XG5cbmV4cG9ydHMuZ2V0UGFuZWwgPSBnZXRQYW5lbDtcbmV4cG9ydHMucGFuZWxzID0gcGFuZWxzO1xuZXhwb3J0cy5zaG93UGFuZWwgPSBzaG93UGFuZWw7XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBzdGF0ZSA9IHJlcXVpcmUoJ0Bjb2RlbWlycm9yL3N0YXRlJyk7XG5cbi8vLyBFYWNoIHJhbmdlIGlzIGFzc29jaWF0ZWQgd2l0aCBhIHZhbHVlLCB3aGljaCBtdXN0IGluaGVyaXQgZnJvbVxuLy8vIHRoaXMgY2xhc3MuXG5jbGFzcyBSYW5nZVZhbHVlIHtcbiAgICAvLy8gQ29tcGFyZSB0aGlzIHZhbHVlIHdpdGggYW5vdGhlciB2YWx1ZS4gVGhlIGRlZmF1bHRcbiAgICAvLy8gaW1wbGVtZW50YXRpb24gY29tcGFyZXMgYnkgaWRlbnRpdHkuXG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIHRoaXMgPT0gb3RoZXI7IH1cbiAgICAvLy8gQ3JlYXRlIGEgW3JhbmdlXSgjcmFuZ2VzZXQuUmFuZ2UpIHdpdGggdGhpcyB2YWx1ZS5cbiAgICByYW5nZShmcm9tLCB0byA9IGZyb20pIHsgcmV0dXJuIG5ldyBSYW5nZShmcm9tLCB0bywgdGhpcyk7IH1cbn1cblJhbmdlVmFsdWUucHJvdG90eXBlLnN0YXJ0U2lkZSA9IFJhbmdlVmFsdWUucHJvdG90eXBlLmVuZFNpZGUgPSAwO1xuUmFuZ2VWYWx1ZS5wcm90b3R5cGUucG9pbnQgPSBmYWxzZTtcblJhbmdlVmFsdWUucHJvdG90eXBlLm1hcE1vZGUgPSBzdGF0ZS5NYXBNb2RlLlRyYWNrRGVsO1xuLy8vIEEgcmFuZ2UgYXNzb2NpYXRlcyBhIHZhbHVlIHdpdGggYSByYW5nZSBvZiBwb3NpdGlvbnMuXG5jbGFzcyBSYW5nZSB7XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBUaGUgcmFuZ2UncyBzdGFydCBwb3NpdGlvbi5cbiAgICBmcm9tLCBcbiAgICAvLy8gSXRzIGVuZCBwb3NpdGlvbi5cbiAgICB0bywgXG4gICAgLy8vIFRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhpcyByYW5nZS5cbiAgICB2YWx1ZSkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbXBSYW5nZShhLCBiKSB7XG4gICAgcmV0dXJuIGEuZnJvbSAtIGIuZnJvbSB8fCBhLnZhbHVlLnN0YXJ0U2lkZSAtIGIudmFsdWUuc3RhcnRTaWRlO1xufVxuY2xhc3MgQ2h1bmsge1xuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvLCB2YWx1ZSwgXG4gICAgLy8gQ2h1bmtzIGFyZSBtYXJrZWQgd2l0aCB0aGUgbGFyZ2VzdCBwb2ludCB0aGF0IG9jY3Vyc1xuICAgIC8vIGluIHRoZW0gKG9yIC0xIGZvciBubyBwb2ludHMpLCBzbyB0aGF0IHNjYW5zIHRoYXQgYXJlXG4gICAgLy8gb25seSBpbnRlcmVzdGVkIGluIHBvaW50cyAoc3VjaCBhcyB0aGVcbiAgICAvLyBoZWlnaHRtYXAtcmVsYXRlZCBsb2dpYykgY2FuIHNraXAgcmFuZ2Utb25seSBjaHVua3MuXG4gICAgbWF4UG9pbnQpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMubWF4UG9pbnQgPSBtYXhQb2ludDtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMudG9bdGhpcy50by5sZW5ndGggLSAxXTsgfVxuICAgIC8vIFdpdGggc2lkZSA9PSAtMSwgcmV0dXJuIHRoZSBmaXJzdCBpbmRleCB3aGVyZSB0byA+PSBwb3MuIFdoZW5cbiAgICAvLyBzaWRlID09IDEsIHRoZSBmaXJzdCBpbmRleCB3aGVyZSBmcm9tID4gcG9zLlxuICAgIGZpbmRJbmRleChwb3MsIGVuZCwgc2lkZSA9IGVuZCAqIDEwMDAwMDAwMDAgLyogRmFyICovLCBzdGFydEF0ID0gMCkge1xuICAgICAgICBpZiAocG9zIDw9IDApXG4gICAgICAgICAgICByZXR1cm4gc3RhcnRBdDtcbiAgICAgICAgbGV0IGFyciA9IGVuZCA8IDAgPyB0aGlzLnRvIDogdGhpcy5mcm9tO1xuICAgICAgICBmb3IgKGxldCBsbyA9IHN0YXJ0QXQsIGhpID0gYXJyLmxlbmd0aDs7KSB7XG4gICAgICAgICAgICBpZiAobG8gPT0gaGkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvO1xuICAgICAgICAgICAgbGV0IG1pZCA9IChsbyArIGhpKSA+PiAxO1xuICAgICAgICAgICAgbGV0IGRpZmYgPSBhcnJbbWlkXSAtIHBvcyB8fCAoZW5kIDwgMCA/IHRoaXMudmFsdWVbbWlkXS5zdGFydFNpZGUgOiB0aGlzLnZhbHVlW21pZF0uZW5kU2lkZSkgLSBzaWRlO1xuICAgICAgICAgICAgaWYgKG1pZCA9PSBsbylcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlmZiA+PSAwID8gbG8gOiBoaTtcbiAgICAgICAgICAgIGlmIChkaWZmID49IDApXG4gICAgICAgICAgICAgICAgaGkgPSBtaWQ7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbG8gPSBtaWQgKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJldHdlZW4ob2Zmc2V0LCBmcm9tLCB0bywgZikge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5maW5kSW5kZXgoZnJvbSwgLTEpLCBlID0gdGhpcy5maW5kSW5kZXgodG8sIDEsIHVuZGVmaW5lZCwgaSk7IGkgPCBlOyBpKyspXG4gICAgICAgICAgICBpZiAoZih0aGlzLmZyb21baV0gKyBvZmZzZXQsIHRoaXMudG9baV0gKyBvZmZzZXQsIHRoaXMudmFsdWVbaV0pID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG1hcChvZmZzZXQsIGNoYW5nZXMpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gW10sIGZyb20gPSBbXSwgdG8gPSBbXSwgbmV3UG9zID0gLTEsIG1heFBvaW50ID0gLTE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHZhbCA9IHRoaXMudmFsdWVbaV0sIGN1ckZyb20gPSB0aGlzLmZyb21baV0gKyBvZmZzZXQsIGN1clRvID0gdGhpcy50b1tpXSArIG9mZnNldCwgbmV3RnJvbSwgbmV3VG87XG4gICAgICAgICAgICBpZiAoY3VyRnJvbSA9PSBjdXJUbykge1xuICAgICAgICAgICAgICAgIGxldCBtYXBwZWQgPSBjaGFuZ2VzLm1hcFBvcyhjdXJGcm9tLCB2YWwuc3RhcnRTaWRlLCB2YWwubWFwTW9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hcHBlZCA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBuZXdGcm9tID0gbmV3VG8gPSBtYXBwZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdGcm9tID0gY2hhbmdlcy5tYXBQb3MoY3VyRnJvbSwgdmFsLnN0YXJ0U2lkZSk7XG4gICAgICAgICAgICAgICAgbmV3VG8gPSBjaGFuZ2VzLm1hcFBvcyhjdXJUbywgdmFsLmVuZFNpZGUpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdGcm9tID4gbmV3VG8gfHwgbmV3RnJvbSA9PSBuZXdUbyAmJiB2YWwuc3RhcnRTaWRlID4gMCAmJiB2YWwuZW5kU2lkZSA8PSAwKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgobmV3VG8gLSBuZXdGcm9tIHx8IHZhbC5lbmRTaWRlIC0gdmFsLnN0YXJ0U2lkZSkgPCAwKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKG5ld1BvcyA8IDApXG4gICAgICAgICAgICAgICAgbmV3UG9zID0gbmV3RnJvbTtcbiAgICAgICAgICAgIGlmICh2YWwucG9pbnQpXG4gICAgICAgICAgICAgICAgbWF4UG9pbnQgPSBNYXRoLm1heChtYXhQb2ludCwgbmV3VG8gLSBuZXdGcm9tKTtcbiAgICAgICAgICAgIHZhbHVlLnB1c2godmFsKTtcbiAgICAgICAgICAgIGZyb20ucHVzaChuZXdGcm9tIC0gbmV3UG9zKTtcbiAgICAgICAgICAgIHRvLnB1c2gobmV3VG8gLSBuZXdQb3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG1hcHBlZDogdmFsdWUubGVuZ3RoID8gbmV3IENodW5rKGZyb20sIHRvLCB2YWx1ZSwgbWF4UG9pbnQpIDogbnVsbCwgcG9zOiBuZXdQb3MgfTtcbiAgICB9XG59XG4vLy8gQSByYW5nZSBzZXQgc3RvcmVzIGEgY29sbGVjdGlvbiBvZiBbcmFuZ2VzXSgjcmFuZ2VzZXQuUmFuZ2UpIGluIGFcbi8vLyB3YXkgdGhhdCBtYWtlcyB0aGVtIGVmZmljaWVudCB0byBbbWFwXSgjcmFuZ2VzZXQuUmFuZ2VTZXQubWFwKSBhbmRcbi8vLyBbdXBkYXRlXSgjcmFuZ2VzZXQuUmFuZ2VTZXQudXBkYXRlKS4gVGhpcyBpcyBhbiBpbW11dGFibGUgZGF0YVxuLy8vIHN0cnVjdHVyZS5cbmNsYXNzIFJhbmdlU2V0IHtcbiAgICAvLy8gQGludGVybmFsXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGNodW5rUG9zLCBcbiAgICAvLy8gQGludGVybmFsXG4gICAgY2h1bmssIFxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBuZXh0TGF5ZXIgPSBSYW5nZVNldC5lbXB0eSwgXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIG1heFBvaW50KSB7XG4gICAgICAgIHRoaXMuY2h1bmtQb3MgPSBjaHVua1BvcztcbiAgICAgICAgdGhpcy5jaHVuayA9IGNodW5rO1xuICAgICAgICB0aGlzLm5leHRMYXllciA9IG5leHRMYXllcjtcbiAgICAgICAgdGhpcy5tYXhQb2ludCA9IG1heFBvaW50O1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmNodW5rLmxlbmd0aCAtIDE7XG4gICAgICAgIHJldHVybiBsYXN0IDwgMCA/IDAgOiBNYXRoLm1heCh0aGlzLmNodW5rRW5kKGxhc3QpLCB0aGlzLm5leHRMYXllci5sZW5ndGgpO1xuICAgIH1cbiAgICAvLy8gVGhlIG51bWJlciBvZiByYW5nZXMgaW4gdGhlIHNldC5cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMgPT0gUmFuZ2VTZXQuZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgbGV0IHNpemUgPSB0aGlzLm5leHRMYXllci5zaXplO1xuICAgICAgICBmb3IgKGxldCBjaHVuayBvZiB0aGlzLmNodW5rKVxuICAgICAgICAgICAgc2l6ZSArPSBjaHVuay52YWx1ZS5sZW5ndGg7XG4gICAgICAgIHJldHVybiBzaXplO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgY2h1bmtFbmQoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2h1bmtQb3NbaW5kZXhdICsgdGhpcy5jaHVua1tpbmRleF0ubGVuZ3RoO1xuICAgIH1cbiAgICAvLy8gVXBkYXRlIHRoZSByYW5nZSBzZXQsIG9wdGlvbmFsbHkgYWRkaW5nIG5ldyByYW5nZXMgb3IgZmlsdGVyaW5nXG4gICAgLy8vIG91dCBleGlzdGluZyBvbmVzLlxuICAgIC8vL1xuICAgIC8vLyAoVGhlIGV4dHJhIHR5cGUgcGFyYW1ldGVyIGlzIGp1c3QgdGhlcmUgYXMgYSBrbHVkZ2UgdG8gd29ya1xuICAgIC8vLyBhcm91bmQgVHlwZVNjcmlwdCB2YXJpYW5jZSBpc3N1ZXMgdGhhdCBwcmV2ZW50ZWQgYFJhbmdlU2V0PFg+YFxuICAgIC8vLyBmcm9tIGJlaW5nIGEgc3VidHlwZSBvZiBgUmFuZ2VTZXQ8WT5gIHdoZW4gYFhgIGlzIGEgc3VidHlwZSBvZlxuICAgIC8vLyBgWWAuKVxuICAgIHVwZGF0ZSh1cGRhdGVTcGVjKSB7XG4gICAgICAgIGxldCB7IGFkZCA9IFtdLCBzb3J0ID0gZmFsc2UsIGZpbHRlckZyb20gPSAwLCBmaWx0ZXJUbyA9IHRoaXMubGVuZ3RoIH0gPSB1cGRhdGVTcGVjO1xuICAgICAgICBsZXQgZmlsdGVyID0gdXBkYXRlU3BlYy5maWx0ZXI7XG4gICAgICAgIGlmIChhZGQubGVuZ3RoID09IDAgJiYgIWZpbHRlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAoc29ydClcbiAgICAgICAgICAgIGFkZC5zbGljZSgpLnNvcnQoY21wUmFuZ2UpO1xuICAgICAgICBpZiAodGhpcyA9PSBSYW5nZVNldC5lbXB0eSlcbiAgICAgICAgICAgIHJldHVybiBhZGQubGVuZ3RoID8gUmFuZ2VTZXQub2YoYWRkKSA6IHRoaXM7XG4gICAgICAgIGxldCBjdXIgPSBuZXcgTGF5ZXJDdXJzb3IodGhpcywgbnVsbCwgLTEpLmdvdG8oMCksIGkgPSAwLCBzcGlsbCA9IFtdO1xuICAgICAgICBsZXQgYnVpbGRlciA9IG5ldyBSYW5nZVNldEJ1aWxkZXIoKTtcbiAgICAgICAgd2hpbGUgKGN1ci52YWx1ZSB8fCBpIDwgYWRkLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGkgPCBhZGQubGVuZ3RoICYmIChjdXIuZnJvbSAtIGFkZFtpXS5mcm9tIHx8IGN1ci5zdGFydFNpZGUgLSBhZGRbaV0udmFsdWUuc3RhcnRTaWRlKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJhbmdlID0gYWRkW2krK107XG4gICAgICAgICAgICAgICAgaWYgKCFidWlsZGVyLmFkZElubmVyKHJhbmdlLmZyb20sIHJhbmdlLnRvLCByYW5nZS52YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgIHNwaWxsLnB1c2gocmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3VyLnJhbmdlSW5kZXggPT0gMSAmJiBjdXIuY2h1bmtJbmRleCA8IHRoaXMuY2h1bmsubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgKGkgPT0gYWRkLmxlbmd0aCB8fCB0aGlzLmNodW5rRW5kKGN1ci5jaHVua0luZGV4KSA8IGFkZFtpXS5mcm9tKSAmJlxuICAgICAgICAgICAgICAgICghZmlsdGVyIHx8IGZpbHRlckZyb20gPiB0aGlzLmNodW5rRW5kKGN1ci5jaHVua0luZGV4KSB8fCBmaWx0ZXJUbyA8IHRoaXMuY2h1bmtQb3NbY3VyLmNodW5rSW5kZXhdKSAmJlxuICAgICAgICAgICAgICAgIGJ1aWxkZXIuYWRkQ2h1bmsodGhpcy5jaHVua1Bvc1tjdXIuY2h1bmtJbmRleF0sIHRoaXMuY2h1bmtbY3VyLmNodW5rSW5kZXhdKSkge1xuICAgICAgICAgICAgICAgIGN1ci5uZXh0Q2h1bmsoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlckZyb20gPiBjdXIudG8gfHwgZmlsdGVyVG8gPCBjdXIuZnJvbSB8fCBmaWx0ZXIoY3VyLmZyb20sIGN1ci50bywgY3VyLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWJ1aWxkZXIuYWRkSW5uZXIoY3VyLmZyb20sIGN1ci50bywgY3VyLnZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwaWxsLnB1c2gobmV3IFJhbmdlKGN1ci5mcm9tLCBjdXIudG8sIGN1ci52YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXIubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWlsZGVyLmZpbmlzaElubmVyKHRoaXMubmV4dExheWVyID09IFJhbmdlU2V0LmVtcHR5ICYmICFzcGlsbC5sZW5ndGggPyBSYW5nZVNldC5lbXB0eVxuICAgICAgICAgICAgOiB0aGlzLm5leHRMYXllci51cGRhdGUoeyBhZGQ6IHNwaWxsLCBmaWx0ZXIsIGZpbHRlckZyb20sIGZpbHRlclRvIH0pKTtcbiAgICB9XG4gICAgLy8vIE1hcCB0aGlzIHJhbmdlIHNldCB0aHJvdWdoIGEgc2V0IG9mIGNoYW5nZXMsIHJldHVybiB0aGUgbmV3IHNldC5cbiAgICBtYXAoY2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlcy5sZW5ndGggPT0gMCB8fCB0aGlzID09IFJhbmdlU2V0LmVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGxldCBjaHVua3MgPSBbXSwgY2h1bmtQb3MgPSBbXSwgbWF4UG9pbnQgPSAtMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNodW5rLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLmNodW5rUG9zW2ldLCBjaHVuayA9IHRoaXMuY2h1bmtbaV07XG4gICAgICAgICAgICBsZXQgdG91Y2ggPSBjaGFuZ2VzLnRvdWNoZXNSYW5nZShzdGFydCwgc3RhcnQgKyBjaHVuay5sZW5ndGgpO1xuICAgICAgICAgICAgaWYgKHRvdWNoID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIG1heFBvaW50ID0gTWF0aC5tYXgobWF4UG9pbnQsIGNodW5rLm1heFBvaW50KTtcbiAgICAgICAgICAgICAgICBjaHVua3MucHVzaChjaHVuayk7XG4gICAgICAgICAgICAgICAgY2h1bmtQb3MucHVzaChjaGFuZ2VzLm1hcFBvcyhzdGFydCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodG91Y2ggPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBtYXBwZWQsIHBvcyB9ID0gY2h1bmsubWFwKHN0YXJ0LCBjaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICBpZiAobWFwcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heFBvaW50ID0gTWF0aC5tYXgobWF4UG9pbnQsIG1hcHBlZC5tYXhQb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rcy5wdXNoKG1hcHBlZCk7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rUG9zLnB1c2gocG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5leHQgPSB0aGlzLm5leHRMYXllci5tYXAoY2hhbmdlcyk7XG4gICAgICAgIHJldHVybiBjaHVua3MubGVuZ3RoID09IDAgPyBuZXh0IDogbmV3IFJhbmdlU2V0KGNodW5rUG9zLCBjaHVua3MsIG5leHQsIG1heFBvaW50KTtcbiAgICB9XG4gICAgLy8vIEl0ZXJhdGUgb3ZlciB0aGUgcmFuZ2VzIHRoYXQgdG91Y2ggdGhlIHJlZ2lvbiBgZnJvbWAgdG8gYHRvYCxcbiAgICAvLy8gY2FsbGluZyBgZmAgZm9yIGVhY2guIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSByYW5nZXMgd2lsbFxuICAgIC8vLyBiZSByZXBvcnRlZCBpbiBhbnkgc3BlY2lmaWMgb3JkZXIuIFdoZW4gdGhlIGNhbGxiYWNrIHJldHVybnNcbiAgICAvLy8gYGZhbHNlYCwgaXRlcmF0aW9uIHN0b3BzLlxuICAgIGJldHdlZW4oZnJvbSwgdG8sIGYpIHtcbiAgICAgICAgaWYgKHRoaXMgPT0gUmFuZ2VTZXQuZW1wdHkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaHVuay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5jaHVua1Bvc1tpXSwgY2h1bmsgPSB0aGlzLmNodW5rW2ldO1xuICAgICAgICAgICAgaWYgKHRvID49IHN0YXJ0ICYmIGZyb20gPD0gc3RhcnQgKyBjaHVuay5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICBjaHVuay5iZXR3ZWVuKHN0YXJ0LCBmcm9tIC0gc3RhcnQsIHRvIC0gc3RhcnQsIGYpID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uZXh0TGF5ZXIuYmV0d2Vlbihmcm9tLCB0bywgZik7XG4gICAgfVxuICAgIC8vLyBJdGVyYXRlIG92ZXIgdGhlIHJhbmdlcyBpbiB0aGlzIHNldCwgaW4gb3JkZXIsIGluY2x1ZGluZyBhbGxcbiAgICAvLy8gcmFuZ2VzIHRoYXQgZW5kIGF0IG9yIGFmdGVyIGBmcm9tYC5cbiAgICBpdGVyKGZyb20gPSAwKSB7XG4gICAgICAgIHJldHVybiBIZWFwQ3Vyc29yLmZyb20oW3RoaXNdKS5nb3RvKGZyb20pO1xuICAgIH1cbiAgICAvLy8gSXRlcmF0ZSBvdmVyIHRoZSByYW5nZXMgaW4gYSBjb2xsZWN0aW9uIG9mIHNldHMsIGluIG9yZGVyLFxuICAgIC8vLyBzdGFydGluZyBmcm9tIGBmcm9tYC5cbiAgICBzdGF0aWMgaXRlcihzZXRzLCBmcm9tID0gMCkge1xuICAgICAgICByZXR1cm4gSGVhcEN1cnNvci5mcm9tKHNldHMpLmdvdG8oZnJvbSk7XG4gICAgfVxuICAgIC8vLyBJdGVyYXRlIG92ZXIgdHdvIGdyb3VwcyBvZiBzZXRzLCBjYWxsaW5nIG1ldGhvZHMgb24gYGNvbXBhcmF0b3JgXG4gICAgLy8vIHRvIG5vdGlmeSBpdCBvZiBwb3NzaWJsZSBkaWZmZXJlbmNlcy5cbiAgICBzdGF0aWMgY29tcGFyZShvbGRTZXRzLCBuZXdTZXRzLCBcbiAgICAvLy8gVGhpcyBpbmRpY2F0ZXMgaG93IHRoZSB1bmRlcmx5aW5nIGRhdGEgY2hhbmdlZCBiZXR3ZWVuIHRoZXNlXG4gICAgLy8vIHJhbmdlcywgYW5kIGlzIG5lZWRlZCB0byBzeW5jaHJvbml6ZSB0aGUgaXRlcmF0aW9uLiBgZnJvbWAgYW5kXG4gICAgLy8vIGB0b2AgYXJlIGNvb3JkaW5hdGVzIGluIHRoZSBfbmV3XyBzcGFjZSwgYWZ0ZXIgdGhlc2UgY2hhbmdlcy5cbiAgICB0ZXh0RGlmZiwgY29tcGFyYXRvciwgXG4gICAgLy8vIENhbiBiZSB1c2VkIHRvIGlnbm9yZSBhbGwgbm9uLXBvaW50IHJhbmdlcywgYW5kIHBvaW50cyBiZWxvd1xuICAgIC8vLyB0aGUgZ2l2ZW4gc2l6ZS4gV2hlbiAtMSwgYWxsIHJhbmdlcyBhcmUgY29tcGFyZWQuXG4gICAgbWluUG9pbnRTaXplID0gLTEpIHtcbiAgICAgICAgbGV0IGEgPSBvbGRTZXRzLmZpbHRlcihzZXQgPT4gc2V0Lm1heFBvaW50ID49IDUwMCAvKiBCaWdQb2ludFNpemUgKi8gfHxcbiAgICAgICAgICAgIHNldCAhPSBSYW5nZVNldC5lbXB0eSAmJiBuZXdTZXRzLmluZGV4T2Yoc2V0KSA8IDAgJiYgc2V0Lm1heFBvaW50ID49IG1pblBvaW50U2l6ZSk7XG4gICAgICAgIGxldCBiID0gbmV3U2V0cy5maWx0ZXIoc2V0ID0+IHNldC5tYXhQb2ludCA+PSA1MDAgLyogQmlnUG9pbnRTaXplICovIHx8XG4gICAgICAgICAgICBzZXQgIT0gUmFuZ2VTZXQuZW1wdHkgJiYgb2xkU2V0cy5pbmRleE9mKHNldCkgPCAwICYmIHNldC5tYXhQb2ludCA+PSBtaW5Qb2ludFNpemUpO1xuICAgICAgICBsZXQgc2hhcmVkQ2h1bmtzID0gZmluZFNoYXJlZENodW5rcyhhLCBiKTtcbiAgICAgICAgbGV0IHNpZGVBID0gbmV3IFNwYW5DdXJzb3IoYSwgc2hhcmVkQ2h1bmtzLCBtaW5Qb2ludFNpemUpO1xuICAgICAgICBsZXQgc2lkZUIgPSBuZXcgU3BhbkN1cnNvcihiLCBzaGFyZWRDaHVua3MsIG1pblBvaW50U2l6ZSk7XG4gICAgICAgIHRleHREaWZmLml0ZXJHYXBzKChmcm9tQSwgZnJvbUIsIGxlbmd0aCkgPT4gY29tcGFyZShzaWRlQSwgZnJvbUEsIHNpZGVCLCBmcm9tQiwgbGVuZ3RoLCBjb21wYXJhdG9yKSk7XG4gICAgICAgIGlmICh0ZXh0RGlmZi5lbXB0eSAmJiB0ZXh0RGlmZi5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIGNvbXBhcmUoc2lkZUEsIDAsIHNpZGVCLCAwLCAwLCBjb21wYXJhdG9yKTtcbiAgICB9XG4gICAgLy8vIEl0ZXJhdGUgb3ZlciBhIGdyb3VwIG9mIHJhbmdlIHNldHMgYXQgdGhlIHNhbWUgdGltZSwgbm90aWZ5aW5nXG4gICAgLy8vIHRoZSBpdGVyYXRvciBhYm91dCB0aGUgcmFuZ2VzIGNvdmVyaW5nIGV2ZXJ5IGdpdmVuIHBpZWNlIG9mXG4gICAgLy8vIGNvbnRlbnQuIFJldHVybnMgdGhlIG9wZW4gY291bnQgKHNlZVxuICAgIC8vLyBbYFNwYW5JdGVyYXRvci5zcGFuYF0oI3Jhbmdlc2V0LlNwYW5JdGVyYXRvci5zcGFuKSkgYXQgdGhlIGVuZFxuICAgIC8vLyBvZiB0aGUgaXRlcmF0aW9uLlxuICAgIHN0YXRpYyBzcGFucyhzZXRzLCBmcm9tLCB0bywgaXRlcmF0b3IsIFxuICAgIC8vLyBXaGVuIGdpdmVuIGFuZCBncmVhdGVyIHRoYW4gLTEsIG9ubHkgcG9pbnRzIG9mIGF0IGxlYXN0IHRoaXNcbiAgICAvLy8gc2l6ZSBhcmUgdGFrZW4gaW50byBhY2NvdW50LlxuICAgIG1pblBvaW50U2l6ZSA9IC0xKSB7XG4gICAgICAgIGxldCBjdXJzb3IgPSBuZXcgU3BhbkN1cnNvcihzZXRzLCBudWxsLCBtaW5Qb2ludFNpemUpLmdvdG8oZnJvbSksIHBvcyA9IGZyb207XG4gICAgICAgIGxldCBvcGVuID0gY3Vyc29yLm9wZW5TdGFydDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGN1clRvID0gTWF0aC5taW4oY3Vyc29yLnRvLCB0byk7XG4gICAgICAgICAgICBpZiAoY3Vyc29yLnBvaW50KSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IucG9pbnQocG9zLCBjdXJUbywgY3Vyc29yLnBvaW50LCBjdXJzb3IuYWN0aXZlRm9yUG9pbnQoY3Vyc29yLnRvKSwgb3Blbik7XG4gICAgICAgICAgICAgICAgb3BlbiA9IGN1cnNvci5vcGVuRW5kKGN1clRvKSArIChjdXJzb3IudG8gPiBjdXJUbyA/IDEgOiAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1clRvID4gcG9zKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3Iuc3Bhbihwb3MsIGN1clRvLCBjdXJzb3IuYWN0aXZlLCBvcGVuKTtcbiAgICAgICAgICAgICAgICBvcGVuID0gY3Vyc29yLm9wZW5FbmQoY3VyVG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnNvci50byA+IHRvKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcG9zID0gY3Vyc29yLnRvO1xuICAgICAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3BlbjtcbiAgICB9XG4gICAgLy8vIENyZWF0ZSBhIHJhbmdlIHNldCBmb3IgdGhlIGdpdmVuIHJhbmdlIG9yIGFycmF5IG9mIHJhbmdlcy4gQnlcbiAgICAvLy8gZGVmYXVsdCwgdGhpcyBleHBlY3RzIHRoZSByYW5nZXMgdG8gYmUgX3NvcnRlZF8gKGJ5IHN0YXJ0XG4gICAgLy8vIHBvc2l0aW9uIGFuZCwgaWYgdHdvIHN0YXJ0IGF0IHRoZSBzYW1lIHBvc2l0aW9uLFxuICAgIC8vLyBgdmFsdWUuc3RhcnRTaWRlYCkuIFlvdSBjYW4gcGFzcyBgdHJ1ZWAgYXMgc2Vjb25kIGFyZ3VtZW50IHRvXG4gICAgLy8vIGNhdXNlIHRoZSBtZXRob2QgdG8gc29ydCB0aGVtLlxuICAgIHN0YXRpYyBvZihyYW5nZXMsIHNvcnQgPSBmYWxzZSkge1xuICAgICAgICBsZXQgYnVpbGQgPSBuZXcgUmFuZ2VTZXRCdWlsZGVyKCk7XG4gICAgICAgIGZvciAobGV0IHJhbmdlIG9mIHJhbmdlcyBpbnN0YW5jZW9mIFJhbmdlID8gW3Jhbmdlc10gOiBzb3J0ID8gcmFuZ2VzLnNsaWNlKCkuc29ydChjbXBSYW5nZSkgOiByYW5nZXMpXG4gICAgICAgICAgICBidWlsZC5hZGQocmFuZ2UuZnJvbSwgcmFuZ2UudG8sIHJhbmdlLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkLmZpbmlzaCgpO1xuICAgIH1cbn1cbi8vLyBUaGUgZW1wdHkgc2V0IG9mIHJhbmdlcy5cblJhbmdlU2V0LmVtcHR5ID0gbmV3IFJhbmdlU2V0KFtdLCBbXSwgbnVsbCwgLTEpO1xuUmFuZ2VTZXQuZW1wdHkubmV4dExheWVyID0gUmFuZ2VTZXQuZW1wdHk7XG4vLy8gQSByYW5nZSBzZXQgYnVpbGRlciBpcyBhIGRhdGEgc3RydWN0dXJlIHRoYXQgaGVscHMgYnVpbGQgdXAgYVxuLy8vIFtyYW5nZSBzZXRdKCNyYW5nZXNldC5SYW5nZVNldCkgZGlyZWN0bHksIHdpdGhvdXQgZmlyc3QgYWxsb2NhdGluZ1xuLy8vIGFuIGFycmF5IG9mIFtgUmFuZ2VgXSgjcmFuZ2VzZXQuUmFuZ2UpIG9iamVjdHMuXG5jbGFzcyBSYW5nZVNldEJ1aWxkZXIge1xuICAgIC8vLyBDcmVhdGUgYW4gZW1wdHkgYnVpbGRlci5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jaHVua3MgPSBbXTtcbiAgICAgICAgdGhpcy5jaHVua1BvcyA9IFtdO1xuICAgICAgICB0aGlzLmNodW5rU3RhcnQgPSAtMTtcbiAgICAgICAgdGhpcy5sYXN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0RnJvbSA9IC0xMDAwMDAwMDAwIC8qIEZhciAqLztcbiAgICAgICAgdGhpcy5sYXN0VG8gPSAtMTAwMDAwMDAwMCAvKiBGYXIgKi87XG4gICAgICAgIHRoaXMuZnJvbSA9IFtdO1xuICAgICAgICB0aGlzLnRvID0gW107XG4gICAgICAgIHRoaXMudmFsdWUgPSBbXTtcbiAgICAgICAgdGhpcy5tYXhQb2ludCA9IC0xO1xuICAgICAgICB0aGlzLnNldE1heFBvaW50ID0gLTE7XG4gICAgICAgIHRoaXMubmV4dExheWVyID0gbnVsbDtcbiAgICB9XG4gICAgZmluaXNoQ2h1bmsobmV3QXJyYXlzKSB7XG4gICAgICAgIHRoaXMuY2h1bmtzLnB1c2gobmV3IENodW5rKHRoaXMuZnJvbSwgdGhpcy50bywgdGhpcy52YWx1ZSwgdGhpcy5tYXhQb2ludCkpO1xuICAgICAgICB0aGlzLmNodW5rUG9zLnB1c2godGhpcy5jaHVua1N0YXJ0KTtcbiAgICAgICAgdGhpcy5jaHVua1N0YXJ0ID0gLTE7XG4gICAgICAgIHRoaXMuc2V0TWF4UG9pbnQgPSBNYXRoLm1heCh0aGlzLnNldE1heFBvaW50LCB0aGlzLm1heFBvaW50KTtcbiAgICAgICAgdGhpcy5tYXhQb2ludCA9IC0xO1xuICAgICAgICBpZiAobmV3QXJyYXlzKSB7XG4gICAgICAgICAgICB0aGlzLmZyb20gPSBbXTtcbiAgICAgICAgICAgIHRoaXMudG8gPSBbXTtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gQWRkIGEgcmFuZ2UuIFJhbmdlcyBzaG91bGQgYmUgYWRkZWQgaW4gc29ydGVkIChieSBgZnJvbWAgYW5kXG4gICAgLy8vIGB2YWx1ZS5zdGFydFNpZGVgKSBvcmRlci5cbiAgICBhZGQoZnJvbSwgdG8sIHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5hZGRJbm5lcihmcm9tLCB0bywgdmFsdWUpKVxuICAgICAgICAgICAgKHRoaXMubmV4dExheWVyIHx8ICh0aGlzLm5leHRMYXllciA9IG5ldyBSYW5nZVNldEJ1aWxkZXIpKS5hZGQoZnJvbSwgdG8sIHZhbHVlKTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGFkZElubmVyKGZyb20sIHRvLCB2YWx1ZSkge1xuICAgICAgICBsZXQgZGlmZiA9IGZyb20gLSB0aGlzLmxhc3RUbyB8fCB2YWx1ZS5zdGFydFNpZGUgLSB0aGlzLmxhc3QuZW5kU2lkZTtcbiAgICAgICAgaWYgKGRpZmYgPD0gMCAmJiAoZnJvbSAtIHRoaXMubGFzdEZyb20gfHwgdmFsdWUuc3RhcnRTaWRlIC0gdGhpcy5sYXN0LnN0YXJ0U2lkZSkgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmFuZ2VzIG11c3QgYmUgYWRkZWQgc29ydGVkIGJ5IGBmcm9tYCBwb3NpdGlvbiBhbmQgYHN0YXJ0U2lkZWBcIik7XG4gICAgICAgIGlmIChkaWZmIDwgMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuZnJvbS5sZW5ndGggPT0gMjUwIC8qIENodW5rU2l6ZSAqLylcbiAgICAgICAgICAgIHRoaXMuZmluaXNoQ2h1bmsodHJ1ZSk7XG4gICAgICAgIGlmICh0aGlzLmNodW5rU3RhcnQgPCAwKVxuICAgICAgICAgICAgdGhpcy5jaHVua1N0YXJ0ID0gZnJvbTtcbiAgICAgICAgdGhpcy5mcm9tLnB1c2goZnJvbSAtIHRoaXMuY2h1bmtTdGFydCk7XG4gICAgICAgIHRoaXMudG8ucHVzaCh0byAtIHRoaXMuY2h1bmtTdGFydCk7XG4gICAgICAgIHRoaXMubGFzdCA9IHZhbHVlO1xuICAgICAgICB0aGlzLmxhc3RGcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy5sYXN0VG8gPSB0bztcbiAgICAgICAgdGhpcy52YWx1ZS5wdXNoKHZhbHVlKTtcbiAgICAgICAgaWYgKHZhbHVlLnBvaW50KVxuICAgICAgICAgICAgdGhpcy5tYXhQb2ludCA9IE1hdGgubWF4KHRoaXMubWF4UG9pbnQsIHRvIC0gZnJvbSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgYWRkQ2h1bmsoZnJvbSwgY2h1bmspIHtcbiAgICAgICAgaWYgKChmcm9tIC0gdGhpcy5sYXN0VG8gfHwgY2h1bmsudmFsdWVbMF0uc3RhcnRTaWRlIC0gdGhpcy5sYXN0LmVuZFNpZGUpIDwgMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuZnJvbS5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLmZpbmlzaENodW5rKHRydWUpO1xuICAgICAgICB0aGlzLnNldE1heFBvaW50ID0gTWF0aC5tYXgodGhpcy5zZXRNYXhQb2ludCwgY2h1bmsubWF4UG9pbnQpO1xuICAgICAgICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbiAgICAgICAgdGhpcy5jaHVua1Bvcy5wdXNoKGZyb20pO1xuICAgICAgICBsZXQgbGFzdCA9IGNodW5rLnZhbHVlLmxlbmd0aCAtIDE7XG4gICAgICAgIHRoaXMubGFzdCA9IGNodW5rLnZhbHVlW2xhc3RdO1xuICAgICAgICB0aGlzLmxhc3RGcm9tID0gY2h1bmsuZnJvbVtsYXN0XSArIGZyb207XG4gICAgICAgIHRoaXMubGFzdFRvID0gY2h1bmsudG9bbGFzdF0gKyBmcm9tO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8vIEZpbmlzaCB0aGUgcmFuZ2Ugc2V0LiBSZXR1cm5zIHRoZSBuZXcgc2V0LiBUaGUgYnVpbGRlciBjYW4ndCBiZVxuICAgIC8vLyB1c2VkIGFueW1vcmUgYWZ0ZXIgdGhpcyBoYXMgYmVlbiBjYWxsZWQuXG4gICAgZmluaXNoKCkgeyByZXR1cm4gdGhpcy5maW5pc2hJbm5lcihSYW5nZVNldC5lbXB0eSk7IH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgZmluaXNoSW5uZXIobmV4dCkge1xuICAgICAgICBpZiAodGhpcy5mcm9tLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMuZmluaXNoQ2h1bmsoZmFsc2UpO1xuICAgICAgICBpZiAodGhpcy5jaHVua3MubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG5ldyBSYW5nZVNldCh0aGlzLmNodW5rUG9zLCB0aGlzLmNodW5rcywgdGhpcy5uZXh0TGF5ZXIgPyB0aGlzLm5leHRMYXllci5maW5pc2hJbm5lcihuZXh0KSA6IG5leHQsIHRoaXMuc2V0TWF4UG9pbnQpO1xuICAgICAgICB0aGlzLmZyb20gPSBudWxsOyAvLyBNYWtlIHN1cmUgZnVydGhlciBgYWRkYCBjYWxscyBwcm9kdWNlIGVycm9yc1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmRTaGFyZWRDaHVua3MoYSwgYikge1xuICAgIGxldCBpbkEgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChsZXQgc2V0IG9mIGEpXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0LmNodW5rLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHNldC5jaHVua1tpXS5tYXhQb2ludCA8IDUwMCAvKiBCaWdQb2ludFNpemUgKi8pXG4gICAgICAgICAgICAgICAgaW5BLnNldChzZXQuY2h1bmtbaV0sIHNldC5jaHVua1Bvc1tpXSk7XG4gICAgbGV0IHNoYXJlZCA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGxldCBzZXQgb2YgYilcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQuY2h1bmsubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoaW5BLmdldChzZXQuY2h1bmtbaV0pID09IHNldC5jaHVua1Bvc1tpXSlcbiAgICAgICAgICAgICAgICBzaGFyZWQuYWRkKHNldC5jaHVua1tpXSk7XG4gICAgcmV0dXJuIHNoYXJlZDtcbn1cbmNsYXNzIExheWVyQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihsYXllciwgc2tpcCwgbWluUG9pbnQsIHJhbmsgPSAwKSB7XG4gICAgICAgIHRoaXMubGF5ZXIgPSBsYXllcjtcbiAgICAgICAgdGhpcy5za2lwID0gc2tpcDtcbiAgICAgICAgdGhpcy5taW5Qb2ludCA9IG1pblBvaW50O1xuICAgICAgICB0aGlzLnJhbmsgPSByYW5rO1xuICAgIH1cbiAgICBnZXQgc3RhcnRTaWRlKCkgeyByZXR1cm4gdGhpcy52YWx1ZSA/IHRoaXMudmFsdWUuc3RhcnRTaWRlIDogMDsgfVxuICAgIGdldCBlbmRTaWRlKCkgeyByZXR1cm4gdGhpcy52YWx1ZSA/IHRoaXMudmFsdWUuZW5kU2lkZSA6IDA7IH1cbiAgICBnb3RvKHBvcywgc2lkZSA9IC0xMDAwMDAwMDAwIC8qIEZhciAqLykge1xuICAgICAgICB0aGlzLmNodW5rSW5kZXggPSB0aGlzLnJhbmdlSW5kZXggPSAwO1xuICAgICAgICB0aGlzLmdvdG9Jbm5lcihwb3MsIHNpZGUsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdvdG9Jbm5lcihwb3MsIHNpZGUsIGZvcndhcmQpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuY2h1bmtJbmRleCA8IHRoaXMubGF5ZXIuY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMubGF5ZXIuY2h1bmtbdGhpcy5jaHVua0luZGV4XTtcbiAgICAgICAgICAgIGlmICghKHRoaXMuc2tpcCAmJiB0aGlzLnNraXAuaGFzKG5leHQpIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5sYXllci5jaHVua0VuZCh0aGlzLmNodW5rSW5kZXgpIDwgcG9zIHx8XG4gICAgICAgICAgICAgICAgbmV4dC5tYXhQb2ludCA8IHRoaXMubWluUG9pbnQpKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgdGhpcy5jaHVua0luZGV4Kys7XG4gICAgICAgICAgICBmb3J3YXJkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJhbmdlSW5kZXggPSB0aGlzLmNodW5rSW5kZXggPT0gdGhpcy5sYXllci5jaHVuay5sZW5ndGggPyAwXG4gICAgICAgICAgICA6IHRoaXMubGF5ZXIuY2h1bmtbdGhpcy5jaHVua0luZGV4XS5maW5kSW5kZXgocG9zIC0gdGhpcy5sYXllci5jaHVua1Bvc1t0aGlzLmNodW5rSW5kZXhdLCAtMSwgc2lkZSk7XG4gICAgICAgIGlmICghZm9yd2FyZCB8fCB0aGlzLnJhbmdlSW5kZXggPCByYW5nZUluZGV4KVxuICAgICAgICAgICAgdGhpcy5yYW5nZUluZGV4ID0gcmFuZ2VJbmRleDtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfVxuICAgIGZvcndhcmQocG9zLCBzaWRlKSB7XG4gICAgICAgIGlmICgodGhpcy50byAtIHBvcyB8fCB0aGlzLmVuZFNpZGUgLSBzaWRlKSA8IDApXG4gICAgICAgICAgICB0aGlzLmdvdG9Jbm5lcihwb3MsIHNpZGUsIHRydWUpO1xuICAgIH1cbiAgICBuZXh0KCkge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaHVua0luZGV4ID09IHRoaXMubGF5ZXIuY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcm9tID0gdGhpcy50byA9IDEwMDAwMDAwMDAgLyogRmFyICovO1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGNodW5rUG9zID0gdGhpcy5sYXllci5jaHVua1Bvc1t0aGlzLmNodW5rSW5kZXhdLCBjaHVuayA9IHRoaXMubGF5ZXIuY2h1bmtbdGhpcy5jaHVua0luZGV4XTtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IGNodW5rUG9zICsgY2h1bmsuZnJvbVt0aGlzLnJhbmdlSW5kZXhdO1xuICAgICAgICAgICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgICAgICAgICAgdGhpcy50byA9IGNodW5rUG9zICsgY2h1bmsudG9bdGhpcy5yYW5nZUluZGV4XTtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gY2h1bmsudmFsdWVbdGhpcy5yYW5nZUluZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoKyt0aGlzLnJhbmdlSW5kZXggPT0gY2h1bmsudmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2h1bmtJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5za2lwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5jaHVua0luZGV4IDwgdGhpcy5sYXllci5jaHVuay5sZW5ndGggJiYgdGhpcy5za2lwLmhhcyh0aGlzLmxheWVyLmNodW5rW3RoaXMuY2h1bmtJbmRleF0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2h1bmtJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmFuZ2VJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1pblBvaW50IDwgMCB8fCB0aGlzLnZhbHVlLnBvaW50ICYmIHRoaXMudG8gLSB0aGlzLmZyb20gPj0gdGhpcy5taW5Qb2ludClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmV4dENodW5rKCkge1xuICAgICAgICB0aGlzLmNodW5rSW5kZXgrKztcbiAgICAgICAgdGhpcy5yYW5nZUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfVxuICAgIGNvbXBhcmUob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbSAtIG90aGVyLmZyb20gfHwgdGhpcy5zdGFydFNpZGUgLSBvdGhlci5zdGFydFNpZGUgfHwgdGhpcy50byAtIG90aGVyLnRvIHx8IHRoaXMuZW5kU2lkZSAtIG90aGVyLmVuZFNpZGU7XG4gICAgfVxufVxuY2xhc3MgSGVhcEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoaGVhcCkge1xuICAgICAgICB0aGlzLmhlYXAgPSBoZWFwO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbShzZXRzLCBza2lwID0gbnVsbCwgbWluUG9pbnQgPSAtMSkge1xuICAgICAgICBsZXQgaGVhcCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGN1ciA9IHNldHNbaV07IGN1ciAhPSBSYW5nZVNldC5lbXB0eTsgY3VyID0gY3VyLm5leHRMYXllcikge1xuICAgICAgICAgICAgICAgIGlmIChjdXIubWF4UG9pbnQgPj0gbWluUG9pbnQpXG4gICAgICAgICAgICAgICAgICAgIGhlYXAucHVzaChuZXcgTGF5ZXJDdXJzb3IoY3VyLCBza2lwLCBtaW5Qb2ludCwgaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWFwLmxlbmd0aCA9PSAxID8gaGVhcFswXSA6IG5ldyBIZWFwQ3Vyc29yKGhlYXApO1xuICAgIH1cbiAgICBnZXQgc3RhcnRTaWRlKCkgeyByZXR1cm4gdGhpcy52YWx1ZSA/IHRoaXMudmFsdWUuc3RhcnRTaWRlIDogMDsgfVxuICAgIGdvdG8ocG9zLCBzaWRlID0gLTEwMDAwMDAwMDAgLyogRmFyICovKSB7XG4gICAgICAgIGZvciAobGV0IGN1ciBvZiB0aGlzLmhlYXApXG4gICAgICAgICAgICBjdXIuZ290byhwb3MsIHNpZGUpO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5oZWFwLmxlbmd0aCA+PiAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgIGhlYXBCdWJibGUodGhpcy5oZWFwLCBpKTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmb3J3YXJkKHBvcywgc2lkZSkge1xuICAgICAgICBmb3IgKGxldCBjdXIgb2YgdGhpcy5oZWFwKVxuICAgICAgICAgICAgY3VyLmZvcndhcmQocG9zLCBzaWRlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuaGVhcC5sZW5ndGggPj4gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgICBoZWFwQnViYmxlKHRoaXMuaGVhcCwgaSk7XG4gICAgICAgIGlmICgodGhpcy50byAtIHBvcyB8fCB0aGlzLnZhbHVlLmVuZFNpZGUgLSBzaWRlKSA8IDApXG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaGVhcC5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5mcm9tID0gdGhpcy50byA9IDEwMDAwMDAwMDAgLyogRmFyICovO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnJhbmsgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCB0b3AgPSB0aGlzLmhlYXBbMF07XG4gICAgICAgICAgICB0aGlzLmZyb20gPSB0b3AuZnJvbTtcbiAgICAgICAgICAgIHRoaXMudG8gPSB0b3AudG87XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdG9wLnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5yYW5rID0gdG9wLnJhbms7XG4gICAgICAgICAgICBpZiAodG9wLnZhbHVlKVxuICAgICAgICAgICAgICAgIHRvcC5uZXh0KCk7XG4gICAgICAgICAgICBoZWFwQnViYmxlKHRoaXMuaGVhcCwgMCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBoZWFwQnViYmxlKGhlYXAsIGluZGV4KSB7XG4gICAgZm9yIChsZXQgY3VyID0gaGVhcFtpbmRleF07Oykge1xuICAgICAgICBsZXQgY2hpbGRJbmRleCA9IChpbmRleCA8PCAxKSArIDE7XG4gICAgICAgIGlmIChjaGlsZEluZGV4ID49IGhlYXAubGVuZ3RoKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGxldCBjaGlsZCA9IGhlYXBbY2hpbGRJbmRleF07XG4gICAgICAgIGlmIChjaGlsZEluZGV4ICsgMSA8IGhlYXAubGVuZ3RoICYmIGNoaWxkLmNvbXBhcmUoaGVhcFtjaGlsZEluZGV4ICsgMV0pID49IDApIHtcbiAgICAgICAgICAgIGNoaWxkID0gaGVhcFtjaGlsZEluZGV4ICsgMV07XG4gICAgICAgICAgICBjaGlsZEluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1ci5jb21wYXJlKGNoaWxkKSA8IDApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaGVhcFtjaGlsZEluZGV4XSA9IGN1cjtcbiAgICAgICAgaGVhcFtpbmRleF0gPSBjaGlsZDtcbiAgICAgICAgaW5kZXggPSBjaGlsZEluZGV4O1xuICAgIH1cbn1cbmNsYXNzIFNwYW5DdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKHNldHMsIHNraXAsIG1pblBvaW50KSB7XG4gICAgICAgIHRoaXMubWluUG9pbnQgPSBtaW5Qb2ludDtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBbXTtcbiAgICAgICAgdGhpcy5hY3RpdmVUbyA9IFtdO1xuICAgICAgICB0aGlzLmFjdGl2ZVJhbmsgPSBbXTtcbiAgICAgICAgdGhpcy5taW5BY3RpdmUgPSAtMTtcbiAgICAgICAgLy8gQSBjdXJyZW50bHkgYWN0aXZlIHBvaW50IHJhbmdlLCBpZiBhbnlcbiAgICAgICAgdGhpcy5wb2ludCA9IG51bGw7XG4gICAgICAgIHRoaXMucG9pbnRGcm9tID0gMDtcbiAgICAgICAgdGhpcy5wb2ludFJhbmsgPSAwO1xuICAgICAgICB0aGlzLnRvID0gLTEwMDAwMDAwMDAgLyogRmFyICovO1xuICAgICAgICB0aGlzLmVuZFNpZGUgPSAwO1xuICAgICAgICB0aGlzLm9wZW5TdGFydCA9IC0xO1xuICAgICAgICB0aGlzLmN1cnNvciA9IEhlYXBDdXJzb3IuZnJvbShzZXRzLCBza2lwLCBtaW5Qb2ludCk7XG4gICAgfVxuICAgIGdvdG8ocG9zLCBzaWRlID0gLTEwMDAwMDAwMDAgLyogRmFyICovKSB7XG4gICAgICAgIHRoaXMuY3Vyc29yLmdvdG8ocG9zLCBzaWRlKTtcbiAgICAgICAgdGhpcy5hY3RpdmUubGVuZ3RoID0gdGhpcy5hY3RpdmVUby5sZW5ndGggPSB0aGlzLmFjdGl2ZVJhbmsubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5taW5BY3RpdmUgPSAtMTtcbiAgICAgICAgdGhpcy50byA9IHBvcztcbiAgICAgICAgdGhpcy5lbmRTaWRlID0gc2lkZTtcbiAgICAgICAgdGhpcy5vcGVuU3RhcnQgPSAtMTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmb3J3YXJkKHBvcywgc2lkZSkge1xuICAgICAgICB3aGlsZSAodGhpcy5taW5BY3RpdmUgPiAtMSAmJiAodGhpcy5hY3RpdmVUb1t0aGlzLm1pbkFjdGl2ZV0gLSBwb3MgfHwgdGhpcy5hY3RpdmVbdGhpcy5taW5BY3RpdmVdLmVuZFNpZGUgLSBzaWRlKSA8IDApXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUFjdGl2ZSh0aGlzLm1pbkFjdGl2ZSk7XG4gICAgICAgIHRoaXMuY3Vyc29yLmZvcndhcmQocG9zLCBzaWRlKTtcbiAgICB9XG4gICAgcmVtb3ZlQWN0aXZlKGluZGV4KSB7XG4gICAgICAgIHJlbW92ZSh0aGlzLmFjdGl2ZSwgaW5kZXgpO1xuICAgICAgICByZW1vdmUodGhpcy5hY3RpdmVUbywgaW5kZXgpO1xuICAgICAgICByZW1vdmUodGhpcy5hY3RpdmVSYW5rLCBpbmRleCk7XG4gICAgICAgIHRoaXMubWluQWN0aXZlID0gZmluZE1pbkluZGV4KHRoaXMuYWN0aXZlLCB0aGlzLmFjdGl2ZVRvKTtcbiAgICB9XG4gICAgYWRkQWN0aXZlKHRyYWNrT3Blbikge1xuICAgICAgICBsZXQgaSA9IDAsIHsgdmFsdWUsIHRvLCByYW5rIH0gPSB0aGlzLmN1cnNvcjtcbiAgICAgICAgd2hpbGUgKGkgPCB0aGlzLmFjdGl2ZVJhbmsubGVuZ3RoICYmIHRoaXMuYWN0aXZlUmFua1tpXSA8PSByYW5rKVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICBpbnNlcnQodGhpcy5hY3RpdmUsIGksIHZhbHVlKTtcbiAgICAgICAgaW5zZXJ0KHRoaXMuYWN0aXZlVG8sIGksIHRvKTtcbiAgICAgICAgaW5zZXJ0KHRoaXMuYWN0aXZlUmFuaywgaSwgcmFuayk7XG4gICAgICAgIGlmICh0cmFja09wZW4pXG4gICAgICAgICAgICBpbnNlcnQodHJhY2tPcGVuLCBpLCB0aGlzLmN1cnNvci5mcm9tKTtcbiAgICAgICAgdGhpcy5taW5BY3RpdmUgPSBmaW5kTWluSW5kZXgodGhpcy5hY3RpdmUsIHRoaXMuYWN0aXZlVG8pO1xuICAgIH1cbiAgICAvLyBBZnRlciBjYWxsaW5nIHRoaXMsIGlmIGB0aGlzLnBvaW50YCAhPSBudWxsLCB0aGUgbmV4dCByYW5nZSBpcyBhXG4gICAgLy8gcG9pbnQuIE90aGVyd2lzZSwgaXQncyBhIHJlZ3VsYXIgcmFuZ2UsIGNvdmVyZWQgYnkgYHRoaXMuYWN0aXZlYC5cbiAgICBuZXh0KCkge1xuICAgICAgICBsZXQgZnJvbSA9IHRoaXMudG87XG4gICAgICAgIHRoaXMucG9pbnQgPSBudWxsO1xuICAgICAgICBsZXQgdHJhY2tPcGVuID0gdGhpcy5vcGVuU3RhcnQgPCAwID8gW10gOiBudWxsLCB0cmFja0V4dHJhID0gMDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGEgPSB0aGlzLm1pbkFjdGl2ZTtcbiAgICAgICAgICAgIGlmIChhID4gLTEgJiYgKHRoaXMuYWN0aXZlVG9bYV0gLSB0aGlzLmN1cnNvci5mcm9tIHx8IHRoaXMuYWN0aXZlW2FdLmVuZFNpZGUgLSB0aGlzLmN1cnNvci5zdGFydFNpZGUpIDwgMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZVRvW2FdID4gZnJvbSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvID0gdGhpcy5hY3RpdmVUb1thXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmRTaWRlID0gdGhpcy5hY3RpdmVbYV0uZW5kU2lkZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQWN0aXZlKGEpO1xuICAgICAgICAgICAgICAgIGlmICh0cmFja09wZW4pXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZSh0cmFja09wZW4sIGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuY3Vyc29yLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50byA9IHRoaXMuZW5kU2lkZSA9IDEwMDAwMDAwMDAgLyogRmFyICovO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jdXJzb3IuZnJvbSA+IGZyb20pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvID0gdGhpcy5jdXJzb3IuZnJvbTtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZFNpZGUgPSB0aGlzLmN1cnNvci5zdGFydFNpZGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dFZhbCA9IHRoaXMuY3Vyc29yLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICghbmV4dFZhbC5wb2ludCkgeyAvLyBPcGVuaW5nIGEgcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRBY3RpdmUodHJhY2tPcGVuKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHsgLy8gTmV3IHBvaW50XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9pbnQgPSBuZXh0VmFsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvaW50RnJvbSA9IHRoaXMuY3Vyc29yLmZyb207XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9pbnRSYW5rID0gdGhpcy5jdXJzb3IucmFuaztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50byA9IHRoaXMuY3Vyc29yLnRvO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZFNpZGUgPSBuZXh0VmFsLmVuZFNpZGU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnNvci5mcm9tIDwgZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrRXh0cmEgPSAxO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRvID4gZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZm9yd2FyZCh0aGlzLnRvLCB0aGlzLmVuZFNpZGUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYWNrT3Blbikge1xuICAgICAgICAgICAgbGV0IG9wZW5TdGFydCA9IDA7XG4gICAgICAgICAgICB3aGlsZSAob3BlblN0YXJ0IDwgdHJhY2tPcGVuLmxlbmd0aCAmJiB0cmFja09wZW5bb3BlblN0YXJ0XSA8IGZyb20pXG4gICAgICAgICAgICAgICAgb3BlblN0YXJ0Kys7XG4gICAgICAgICAgICB0aGlzLm9wZW5TdGFydCA9IG9wZW5TdGFydCArIHRyYWNrRXh0cmE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWN0aXZlRm9yUG9pbnQodG8pIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmU7XG4gICAgICAgIGxldCBhY3RpdmUgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmFjdGl2ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlUmFua1tpXSA+IHRoaXMucG9pbnRSYW5rKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlVG9baV0gPiB0byB8fCB0aGlzLmFjdGl2ZVRvW2ldID09IHRvICYmIHRoaXMuYWN0aXZlW2ldLmVuZFNpZGUgPiB0aGlzLnBvaW50LmVuZFNpZGUpXG4gICAgICAgICAgICAgICAgYWN0aXZlLnB1c2godGhpcy5hY3RpdmVbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY3RpdmU7XG4gICAgfVxuICAgIG9wZW5FbmQodG8pIHtcbiAgICAgICAgbGV0IG9wZW4gPSAwO1xuICAgICAgICB3aGlsZSAob3BlbiA8IHRoaXMuYWN0aXZlVG8ubGVuZ3RoICYmIHRoaXMuYWN0aXZlVG9bb3Blbl0gPiB0bylcbiAgICAgICAgICAgIG9wZW4rKztcbiAgICAgICAgcmV0dXJuIG9wZW47XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcGFyZShhLCBzdGFydEEsIGIsIHN0YXJ0QiwgbGVuZ3RoLCBjb21wYXJhdG9yKSB7XG4gICAgYS5nb3RvKHN0YXJ0QSk7XG4gICAgYi5nb3RvKHN0YXJ0Qik7XG4gICAgbGV0IGVuZEIgPSBzdGFydEIgKyBsZW5ndGg7XG4gICAgbGV0IHBvcyA9IHN0YXJ0QiwgZFBvcyA9IHN0YXJ0QiAtIHN0YXJ0QTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGxldCBkaWZmID0gKGEudG8gKyBkUG9zKSAtIGIudG8gfHwgYS5lbmRTaWRlIC0gYi5lbmRTaWRlO1xuICAgICAgICBsZXQgZW5kID0gZGlmZiA8IDAgPyBhLnRvICsgZFBvcyA6IGIudG8sIGNsaXBFbmQgPSBNYXRoLm1pbihlbmQsIGVuZEIpO1xuICAgICAgICBpZiAoYS5wb2ludCB8fCBiLnBvaW50KSB7XG4gICAgICAgICAgICBpZiAoIShhLnBvaW50ICYmIGIucG9pbnQgJiYgKGEucG9pbnQgPT0gYi5wb2ludCB8fCBhLnBvaW50LmVxKGIucG9pbnQpKSkpXG4gICAgICAgICAgICAgICAgY29tcGFyYXRvci5jb21wYXJlUG9pbnQocG9zLCBjbGlwRW5kLCBhLnBvaW50LCBiLnBvaW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjbGlwRW5kID4gcG9zICYmICFzYW1lVmFsdWVzKGEuYWN0aXZlLCBiLmFjdGl2ZSkpXG4gICAgICAgICAgICAgICAgY29tcGFyYXRvci5jb21wYXJlUmFuZ2UocG9zLCBjbGlwRW5kLCBhLmFjdGl2ZSwgYi5hY3RpdmUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQgPiBlbmRCKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIHBvcyA9IGVuZDtcbiAgICAgICAgaWYgKGRpZmYgPD0gMClcbiAgICAgICAgICAgIGEubmV4dCgpO1xuICAgICAgICBpZiAoZGlmZiA+PSAwKVxuICAgICAgICAgICAgYi5uZXh0KCk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2FtZVZhbHVlcyhhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoYVtpXSAhPSBiW2ldICYmICFhW2ldLmVxKGJbaV0pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gcmVtb3ZlKGFycmF5LCBpbmRleCkge1xuICAgIGZvciAobGV0IGkgPSBpbmRleCwgZSA9IGFycmF5Lmxlbmd0aCAtIDE7IGkgPCBlOyBpKyspXG4gICAgICAgIGFycmF5W2ldID0gYXJyYXlbaSArIDFdO1xuICAgIGFycmF5LnBvcCgpO1xufVxuZnVuY3Rpb24gaW5zZXJ0KGFycmF5LCBpbmRleCwgdmFsdWUpIHtcbiAgICBmb3IgKGxldCBpID0gYXJyYXkubGVuZ3RoIC0gMTsgaSA+PSBpbmRleDsgaS0tKVxuICAgICAgICBhcnJheVtpICsgMV0gPSBhcnJheVtpXTtcbiAgICBhcnJheVtpbmRleF0gPSB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGZpbmRNaW5JbmRleCh2YWx1ZSwgYXJyYXkpIHtcbiAgICBsZXQgZm91bmQgPSAtMSwgZm91bmRQb3MgPSAxMDAwMDAwMDAwIC8qIEZhciAqLztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoKGFycmF5W2ldIC0gZm91bmRQb3MgfHwgdmFsdWVbaV0uZW5kU2lkZSAtIHZhbHVlW2ZvdW5kXS5lbmRTaWRlKSA8IDApIHtcbiAgICAgICAgICAgIGZvdW5kID0gaTtcbiAgICAgICAgICAgIGZvdW5kUG9zID0gYXJyYXlbaV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gZm91bmQ7XG59XG5cbmV4cG9ydHMuUmFuZ2UgPSBSYW5nZTtcbmV4cG9ydHMuUmFuZ2VTZXQgPSBSYW5nZVNldDtcbmV4cG9ydHMuUmFuZ2VTZXRCdWlsZGVyID0gUmFuZ2VTZXRCdWlsZGVyO1xuZXhwb3J0cy5SYW5nZVZhbHVlID0gUmFuZ2VWYWx1ZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIHN0YXRlID0gcmVxdWlyZSgnQGNvZGVtaXJyb3Ivc3RhdGUnKTtcbnZhciB2aWV3ID0gcmVxdWlyZSgnQGNvZGVtaXJyb3IvdmlldycpO1xudmFyIHRleHQgPSByZXF1aXJlKCdAY29kZW1pcnJvci90ZXh0Jyk7XG5cbi8vIERvbid0IGNvbXB1dGUgcHJlY2lzZSBjb2x1bW4gcG9zaXRpb25zIGZvciBsaW5lIG9mZnNldHMgYWJvdmUgdGhpc1xuLy8gKHNpbmNlIGl0IGNvdWxkIGdldCBleHBlbnNpdmUpLiBBc3N1bWUgb2Zmc2V0PT1jb2x1bW4gZm9yIHRoZW0uXG5jb25zdCBNYXhPZmYgPSAyMDAwO1xuZnVuY3Rpb24gcmVjdGFuZ2xlRm9yKHN0YXRlJDEsIGEsIGIpIHtcbiAgICBsZXQgc3RhcnRMaW5lID0gTWF0aC5taW4oYS5saW5lLCBiLmxpbmUpLCBlbmRMaW5lID0gTWF0aC5tYXgoYS5saW5lLCBiLmxpbmUpO1xuICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICBpZiAoYS5vZmYgPiBNYXhPZmYgfHwgYi5vZmYgPiBNYXhPZmYgfHwgYS5jb2wgPCAwIHx8IGIuY29sIDwgMCkge1xuICAgICAgICBsZXQgc3RhcnRPZmYgPSBNYXRoLm1pbihhLm9mZiwgYi5vZmYpLCBlbmRPZmYgPSBNYXRoLm1heChhLm9mZiwgYi5vZmYpO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRMaW5lOyBpIDw9IGVuZExpbmU7IGkrKykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBzdGF0ZSQxLmRvYy5saW5lKGkpO1xuICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoIDw9IGVuZE9mZilcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaChzdGF0ZS5FZGl0b3JTZWxlY3Rpb24ucmFuZ2UobGluZS5mcm9tICsgc3RhcnRPZmYsIGxpbmUudG8gKyBlbmRPZmYpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IHN0YXJ0Q29sID0gTWF0aC5taW4oYS5jb2wsIGIuY29sKSwgZW5kQ29sID0gTWF0aC5tYXgoYS5jb2wsIGIuY29sKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0TGluZTsgaSA8PSBlbmRMaW5lOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gc3RhdGUkMS5kb2MubGluZShpKSwgc3RyID0gbGluZS5sZW5ndGggPiBNYXhPZmYgPyBsaW5lLnRleHQuc2xpY2UoMCwgMiAqIGVuZENvbCkgOiBsaW5lLnRleHQ7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0ZXh0LmZpbmRDb2x1bW4oc3RyLCAwLCBzdGFydENvbCwgc3RhdGUkMS50YWJTaXplKSwgZW5kID0gdGV4dC5maW5kQ29sdW1uKHN0ciwgMCwgZW5kQ29sLCBzdGF0ZSQxLnRhYlNpemUpO1xuICAgICAgICAgICAgaWYgKCFzdGFydC5sZWZ0T3ZlcilcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaChzdGF0ZS5FZGl0b3JTZWxlY3Rpb24ucmFuZ2UobGluZS5mcm9tICsgc3RhcnQub2Zmc2V0LCBsaW5lLmZyb20gKyBlbmQub2Zmc2V0KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlcztcbn1cbmZ1bmN0aW9uIGFic29sdXRlQ29sdW1uKHZpZXcsIHgpIHtcbiAgICBsZXQgcmVmID0gdmlldy5jb29yZHNBdFBvcyh2aWV3LnZpZXdwb3J0LmZyb20pO1xuICAgIHJldHVybiByZWYgPyBNYXRoLnJvdW5kKE1hdGguYWJzKChyZWYubGVmdCAtIHgpIC8gdmlldy5kZWZhdWx0Q2hhcmFjdGVyV2lkdGgpKSA6IC0xO1xufVxuZnVuY3Rpb24gZ2V0UG9zKHZpZXcsIGV2ZW50KSB7XG4gICAgbGV0IG9mZnNldCA9IHZpZXcucG9zQXRDb29yZHMoeyB4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZIH0pO1xuICAgIGlmIChvZmZzZXQgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGxpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQob2Zmc2V0KSwgb2ZmID0gb2Zmc2V0IC0gbGluZS5mcm9tO1xuICAgIGxldCBjb2wgPSBvZmYgPiBNYXhPZmYgPyAtMVxuICAgICAgICA6IG9mZiA9PSBsaW5lLmxlbmd0aCA/IGFic29sdXRlQ29sdW1uKHZpZXcsIGV2ZW50LmNsaWVudFgpXG4gICAgICAgICAgICA6IHRleHQuY291bnRDb2x1bW4obGluZS50ZXh0LnNsaWNlKDAsIG9mZnNldCAtIGxpbmUuZnJvbSksIDAsIHZpZXcuc3RhdGUudGFiU2l6ZSk7XG4gICAgcmV0dXJuIHsgbGluZTogbGluZS5udW1iZXIsIGNvbCwgb2ZmIH07XG59XG5mdW5jdGlvbiByZWN0YW5nbGVTZWxlY3Rpb25TdHlsZSh2aWV3LCBldmVudCkge1xuICAgIGxldCBzdGFydCA9IGdldFBvcyh2aWV3LCBldmVudCksIHN0YXJ0U2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCFzdGFydClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICAgICAgaWYgKHVwZGF0ZS5kb2NDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5ld1N0YXJ0ID0gdXBkYXRlLmNoYW5nZXMubWFwUG9zKHVwZGF0ZS5zdGFydFN0YXRlLmRvYy5saW5lKHN0YXJ0LmxpbmUpLmZyb20pO1xuICAgICAgICAgICAgICAgIGxldCBuZXdMaW5lID0gdXBkYXRlLnN0YXRlLmRvYy5saW5lQXQobmV3U3RhcnQpO1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0geyBsaW5lOiBuZXdMaW5lLm51bWJlciwgY29sOiBzdGFydC5jb2wsIG9mZjogTWF0aC5taW4oc3RhcnQub2ZmLCBuZXdMaW5lLmxlbmd0aCkgfTtcbiAgICAgICAgICAgICAgICBzdGFydFNlbCA9IHN0YXJ0U2VsLm1hcCh1cGRhdGUuY2hhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldChldmVudCwgX2V4dGVuZCwgbXVsdGlwbGUpIHtcbiAgICAgICAgICAgIGxldCBjdXIgPSBnZXRQb3ModmlldywgZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCFjdXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0U2VsO1xuICAgICAgICAgICAgbGV0IHJhbmdlcyA9IHJlY3RhbmdsZUZvcih2aWV3LnN0YXRlLCBzdGFydCwgY3VyKTtcbiAgICAgICAgICAgIGlmICghcmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRTZWw7XG4gICAgICAgICAgICBpZiAobXVsdGlwbGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlLkVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzLmNvbmNhdChzdGFydFNlbC5yYW5nZXMpKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUuRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8vLyBDcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgZW5hYmxlcyByZWN0YW5ndWxhciBzZWxlY3Rpb25zLiBCeVxuLy8vIGRlZmF1bHQsIGl0IHdpbGwgcmVhY3QgdG8gbGVmdCBtb3VzZSBkcmFnIHdpdGggdGhlIEFsdCBrZXkgaGVsZFxuLy8vIGRvd24uIFdoZW4gc3VjaCBhIHNlbGVjdGlvbiBvY2N1cnMsIHRoZSB0ZXh0IHdpdGhpbiB0aGUgcmVjdGFuZ2xlXG4vLy8gdGhhdCB3YXMgZHJhZ2dlZCBvdmVyIHdpbGwgYmUgc2VsZWN0ZWQsIGFzIG9uZSBzZWxlY3Rpb25cbi8vLyBbcmFuZ2VdKCNzdGF0ZS5TZWxlY3Rpb25SYW5nZSkgcGVyIGxpbmUuXG5mdW5jdGlvbiByZWN0YW5ndWxhclNlbGVjdGlvbihvcHRpb25zKSB7XG4gICAgbGV0IGZpbHRlciA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZXZlbnRGaWx0ZXIpIHx8IChlID0+IGUuYWx0S2V5ICYmIGUuYnV0dG9uID09IDApO1xuICAgIHJldHVybiB2aWV3LkVkaXRvclZpZXcubW91c2VTZWxlY3Rpb25TdHlsZS5vZigodmlldywgZXZlbnQpID0+IGZpbHRlcihldmVudCkgPyByZWN0YW5nbGVTZWxlY3Rpb25TdHlsZSh2aWV3LCBldmVudCkgOiBudWxsKTtcbn1cblxuZXhwb3J0cy5yZWN0YW5ndWxhclNlbGVjdGlvbiA9IHJlY3Rhbmd1bGFyU2VsZWN0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgdmlldyA9IHJlcXVpcmUoJ0Bjb2RlbWlycm9yL3ZpZXcnKTtcbnZhciBzdGF0ZSA9IHJlcXVpcmUoJ0Bjb2RlbWlycm9yL3N0YXRlJyk7XG52YXIgcGFuZWwgPSByZXF1aXJlKCdAY29kZW1pcnJvci9wYW5lbCcpO1xudmFyIHJhbmdlc2V0ID0gcmVxdWlyZSgnQGNvZGVtaXJyb3IvcmFuZ2VzZXQnKTtcbnZhciBlbHQgPSByZXF1aXJlKCdjcmVsdCcpO1xudmFyIHRleHQgPSByZXF1aXJlKCdAY29kZW1pcnJvci90ZXh0Jyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdExlZ2FjeSAoZSkgeyByZXR1cm4gZSAmJiB0eXBlb2YgZSA9PT0gJ29iamVjdCcgJiYgJ2RlZmF1bHQnIGluIGUgPyBlIDogeyAnZGVmYXVsdCc6IGUgfTsgfVxuXG52YXIgZWx0X19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShlbHQpO1xuXG5jb25zdCBiYXNpY05vcm1hbGl6ZSA9IHR5cGVvZiBTdHJpbmcucHJvdG90eXBlLm5vcm1hbGl6ZSA9PSBcImZ1bmN0aW9uXCJcbiAgICA/IHggPT4geC5ub3JtYWxpemUoXCJORktEXCIpIDogeCA9PiB4O1xuLyoqXG5BIHNlYXJjaCBjdXJzb3IgcHJvdmlkZXMgYW4gaXRlcmF0b3Igb3ZlciB0ZXh0IG1hdGNoZXMgaW4gYVxuZG9jdW1lbnQuXG4qL1xuY2xhc3MgU2VhcmNoQ3Vyc29yIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSB0ZXh0IGN1cnNvci4gVGhlIHF1ZXJ5IGlzIHRoZSBzZWFyY2ggc3RyaW5nLCBgZnJvbWAgdG9cbiAgICBgdG9gIHByb3ZpZGVzIHRoZSByZWdpb24gdG8gc2VhcmNoLlxuICAgIFxuICAgIFdoZW4gYG5vcm1hbGl6ZWAgaXMgZ2l2ZW4sIGl0IHdpbGwgYmUgY2FsbGVkLCBvbiBib3RoIHRoZSBxdWVyeVxuICAgIHN0cmluZyBhbmQgdGhlIGNvbnRlbnQgaXQgaXMgbWF0Y2hlZCBhZ2FpbnN0LCBiZWZvcmUgY29tcGFyaW5nLlxuICAgIFlvdSBjYW4sIGZvciBleGFtcGxlLCBjcmVhdGUgYSBjYXNlLWluc2Vuc2l0aXZlIHNlYXJjaCBieVxuICAgIHBhc3NpbmcgYHMgPT4gcy50b0xvd2VyQ2FzZSgpYC5cbiAgICBcbiAgICBUZXh0IGlzIGFsd2F5cyBub3JtYWxpemVkIHdpdGhcbiAgICBbYC5ub3JtYWxpemUoXCJORktEXCIpYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL25vcm1hbGl6ZSlcbiAgICAod2hlbiBzdXBwb3J0ZWQpLlxuICAgICovXG4gICAgY29uc3RydWN0b3IodGV4dCwgcXVlcnksIGZyb20gPSAwLCB0byA9IHRleHQubGVuZ3RoLCBub3JtYWxpemUpIHtcbiAgICAgICAgLyoqXG4gICAgICAgIFRoZSBjdXJyZW50IG1hdGNoIChvbmx5IGhvbGRzIGEgbWVhbmluZ2Z1bCB2YWx1ZSBhZnRlclxuICAgICAgICBbYG5leHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5TZWFyY2hDdXJzb3IubmV4dCkgaGFzIGJlZW4gY2FsbGVkIGFuZCB3aGVuXG4gICAgICAgIGBkb25lYCBpcyBmYWxzZSkuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMudmFsdWUgPSB7IGZyb206IDAsIHRvOiAwIH07XG4gICAgICAgIC8qKlxuICAgICAgICBXaGV0aGVyIHRoZSBlbmQgb2YgdGhlIGl0ZXJhdGVkIHJlZ2lvbiBoYXMgYmVlbiByZWFjaGVkLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tYXRjaGVzID0gW107XG4gICAgICAgIHRoaXMuYnVmZmVyID0gXCJcIjtcbiAgICAgICAgdGhpcy5idWZmZXJQb3MgPSAwO1xuICAgICAgICB0aGlzLml0ZXIgPSB0ZXh0Lml0ZXJSYW5nZShmcm9tLCB0byk7XG4gICAgICAgIHRoaXMuYnVmZmVyU3RhcnQgPSBmcm9tO1xuICAgICAgICB0aGlzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZSA/IHggPT4gbm9ybWFsaXplKGJhc2ljTm9ybWFsaXplKHgpKSA6IGJhc2ljTm9ybWFsaXplO1xuICAgICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5ub3JtYWxpemUocXVlcnkpO1xuICAgIH1cbiAgICBwZWVrKCkge1xuICAgICAgICBpZiAodGhpcy5idWZmZXJQb3MgPT0gdGhpcy5idWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlclN0YXJ0ICs9IHRoaXMuYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuaXRlci5uZXh0KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5pdGVyLmRvbmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJQb3MgPSAwO1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSB0aGlzLml0ZXIudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQuY29kZVBvaW50QXQodGhpcy5idWZmZXIsIHRoaXMuYnVmZmVyUG9zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTG9vayBmb3IgdGhlIG5leHQgbWF0Y2guIFVwZGF0ZXMgdGhlIGl0ZXJhdG9yJ3NcbiAgICBbYHZhbHVlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2guU2VhcmNoQ3Vyc29yLnZhbHVlKSBhbmRcbiAgICBbYGRvbmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5TZWFyY2hDdXJzb3IuZG9uZSkgcHJvcGVydGllcy4gU2hvdWxkIGJlIGNhbGxlZFxuICAgIGF0IGxlYXN0IG9uY2UgYmVmb3JlIHVzaW5nIHRoZSBjdXJzb3IuXG4gICAgKi9cbiAgICBuZXh0KCkge1xuICAgICAgICB3aGlsZSAodGhpcy5tYXRjaGVzLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMubWF0Y2hlcy5wb3AoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dE92ZXJsYXBwaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBgbmV4dGAgbWV0aG9kIHdpbGwgaWdub3JlIG1hdGNoZXMgdGhhdCBwYXJ0aWFsbHkgb3ZlcmxhcCBhXG4gICAgcHJldmlvdXMgbWF0Y2guIFRoaXMgbWV0aG9kIGJlaGF2ZXMgbGlrZSBgbmV4dGAsIGJ1dCBpbmNsdWRlc1xuICAgIHN1Y2ggbWF0Y2hlcy5cbiAgICAqL1xuICAgIG5leHRPdmVybGFwcGluZygpIHtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgICAgIGlmIChuZXh0IDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc3RyID0gdGV4dC5mcm9tQ29kZVBvaW50KG5leHQpLCBzdGFydCA9IHRoaXMuYnVmZmVyU3RhcnQgKyB0aGlzLmJ1ZmZlclBvcztcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyUG9zICs9IHRleHQuY29kZVBvaW50U2l6ZShuZXh0KTtcbiAgICAgICAgICAgIGxldCBub3JtID0gdGhpcy5ub3JtYWxpemUoc3RyKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSBzdGFydDs7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBjb2RlID0gbm9ybS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IHRoaXMubWF0Y2goY29kZSwgcG9zKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG1hdGNoO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gbm9ybS5sZW5ndGggLSAxKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAocG9zID09IHN0YXJ0ICYmIGkgPCBzdHIubGVuZ3RoICYmIHN0ci5jaGFyQ29kZUF0KGkpID09IGNvZGUpXG4gICAgICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG1hdGNoKGNvZGUsIHBvcykge1xuICAgICAgICBsZXQgbWF0Y2ggPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWF0Y2hlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5tYXRjaGVzW2ldLCBrZWVwID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5xdWVyeS5jaGFyQ29kZUF0KGluZGV4KSA9PSBjb2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09IHRoaXMucXVlcnkubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IHsgZnJvbTogdGhpcy5tYXRjaGVzW2kgKyAxXSwgdG86IHBvcyArIDEgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hlc1tpXSsrO1xuICAgICAgICAgICAgICAgICAgICBrZWVwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWtlZXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoZXMuc3BsaWNlKGksIDIpO1xuICAgICAgICAgICAgICAgIGkgLT0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5xdWVyeS5jaGFyQ29kZUF0KDApID09IGNvZGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnF1ZXJ5Lmxlbmd0aCA9PSAxKVxuICAgICAgICAgICAgICAgIG1hdGNoID0geyBmcm9tOiBwb3MsIHRvOiBwb3MgKyAxIH07XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaGVzLnB1c2goMSwgcG9zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfVxufVxuXG5jb25zdCBlbXB0eSA9IHsgZnJvbTogLTEsIHRvOiAtMSwgbWF0Y2g6IC8uKi8uZXhlYyhcIlwiKSB9O1xuY29uc3QgYmFzZUZsYWdzID0gXCJnbVwiICsgKC94Ly51bmljb2RlID09IG51bGwgPyBcIlwiIDogXCJ1XCIpO1xuY2xhc3MgUmVnRXhwQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBxdWVyeSwgb3B0aW9ucywgZnJvbSA9IDAsIHRvID0gdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLmN1ckxpbmUgPSBcIlwiO1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IGVtcHR5O1xuICAgICAgICBpZiAoL1xcXFxbc1dEbnJdfFxcbnxcXHJ8XFxbXFxeLy50ZXN0KHF1ZXJ5KSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgTXVsdGlsaW5lUmVnRXhwQ3Vyc29yKHRleHQsIHF1ZXJ5LCBvcHRpb25zLCBmcm9tLCB0byk7XG4gICAgICAgIHRoaXMucmUgPSBuZXcgUmVnRXhwKHF1ZXJ5LCBiYXNlRmxhZ3MgKyAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5pZ25vcmVDYXNlKSA/IFwiaVwiIDogXCJcIikpO1xuICAgICAgICB0aGlzLml0ZXIgPSB0ZXh0Lml0ZXIoKTtcbiAgICAgICAgbGV0IHN0YXJ0TGluZSA9IHRleHQubGluZUF0KGZyb20pO1xuICAgICAgICB0aGlzLmN1ckxpbmVTdGFydCA9IHN0YXJ0TGluZS5mcm9tO1xuICAgICAgICB0aGlzLm1hdGNoUG9zID0gZnJvbTtcbiAgICAgICAgdGhpcy5nZXRMaW5lKHRoaXMuY3VyTGluZVN0YXJ0KTtcbiAgICB9XG4gICAgZ2V0TGluZShza2lwKSB7XG4gICAgICAgIHRoaXMuaXRlci5uZXh0KHNraXApO1xuICAgICAgICBpZiAodGhpcy5pdGVyLmxpbmVCcmVhaykge1xuICAgICAgICAgICAgdGhpcy5jdXJMaW5lID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3VyTGluZSA9IHRoaXMuaXRlci52YWx1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1ckxpbmVTdGFydCArIHRoaXMuY3VyTGluZS5sZW5ndGggPiB0aGlzLnRvKVxuICAgICAgICAgICAgICAgIHRoaXMuY3VyTGluZSA9IHRoaXMuY3VyTGluZS5zbGljZSgwLCB0aGlzLnRvIC0gdGhpcy5jdXJMaW5lU3RhcnQpO1xuICAgICAgICAgICAgdGhpcy5pdGVyLm5leHQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZXh0TGluZSgpIHtcbiAgICAgICAgdGhpcy5jdXJMaW5lU3RhcnQgPSB0aGlzLmN1ckxpbmVTdGFydCArIHRoaXMuY3VyTGluZS5sZW5ndGggKyAxO1xuICAgICAgICBpZiAodGhpcy5jdXJMaW5lU3RhcnQgPiB0aGlzLnRvKVxuICAgICAgICAgICAgdGhpcy5jdXJMaW5lID0gXCJcIjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5nZXRMaW5lKDApO1xuICAgIH1cbiAgICBuZXh0KCkge1xuICAgICAgICBmb3IgKGxldCBvZmYgPSB0aGlzLm1hdGNoUG9zIC0gdGhpcy5jdXJMaW5lU3RhcnQ7Oykge1xuICAgICAgICAgICAgdGhpcy5yZS5sYXN0SW5kZXggPSBvZmY7XG4gICAgICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLm1hdGNoUG9zIDw9IHRoaXMudG8gJiYgdGhpcy5yZS5leGVjKHRoaXMuY3VyTGluZSk7XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IHRoaXMuY3VyTGluZVN0YXJ0ICsgbWF0Y2guaW5kZXgsIHRvID0gZnJvbSArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoUG9zID0gdG8gKyAoZnJvbSA9PSB0byA/IDEgOiAwKTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA9PSB0aGlzLmN1ckxpbmUubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRMaW5lKCk7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPCB0byB8fCBmcm9tID4gdGhpcy52YWx1ZS50bykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0geyBmcm9tLCB0bywgbWF0Y2ggfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZiA9IHRoaXMubWF0Y2hQb3MgLSB0aGlzLmN1ckxpbmVTdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY3VyTGluZVN0YXJ0ICsgdGhpcy5jdXJMaW5lLmxlbmd0aCA8IHRoaXMudG8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRMaW5lKCk7XG4gICAgICAgICAgICAgICAgb2ZmID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5jb25zdCBmbGF0dGVuZWQgPSBuZXcgV2Vha01hcCgpO1xuLy8gUmV1c2FibGUgKHBhcnRpYWxseSkgZmxhdHRlbmVkIGRvY3VtZW50IHN0cmluZ3NcbmNsYXNzIEZsYXR0ZW5lZERvYyB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdGV4dCkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIH1cbiAgICBnZXQgdG8oKSB7IHJldHVybiB0aGlzLmZyb20gKyB0aGlzLnRleHQubGVuZ3RoOyB9XG4gICAgc3RhdGljIGdldChkb2MsIGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBjYWNoZWQgPSBmbGF0dGVuZWQuZ2V0KGRvYyk7XG4gICAgICAgIGlmICghY2FjaGVkIHx8IGNhY2hlZC5mcm9tID49IHRvIHx8IGNhY2hlZC50byA8PSBmcm9tKSB7XG4gICAgICAgICAgICBsZXQgZmxhdCA9IG5ldyBGbGF0dGVuZWREb2MoZnJvbSwgZG9jLnNsaWNlU3RyaW5nKGZyb20sIHRvKSk7XG4gICAgICAgICAgICBmbGF0dGVuZWQuc2V0KGRvYywgZmxhdCk7XG4gICAgICAgICAgICByZXR1cm4gZmxhdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FjaGVkLmZyb20gPT0gZnJvbSAmJiBjYWNoZWQudG8gPT0gdG8pXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgICAgICBsZXQgeyB0ZXh0LCBmcm9tOiBjYWNoZWRGcm9tIH0gPSBjYWNoZWQ7XG4gICAgICAgIGlmIChjYWNoZWRGcm9tID4gZnJvbSkge1xuICAgICAgICAgICAgdGV4dCA9IGRvYy5zbGljZVN0cmluZyhmcm9tLCBjYWNoZWRGcm9tKSArIHRleHQ7XG4gICAgICAgICAgICBjYWNoZWRGcm9tID0gZnJvbTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FjaGVkLnRvIDwgdG8pXG4gICAgICAgICAgICB0ZXh0ICs9IGRvYy5zbGljZVN0cmluZyhjYWNoZWQudG8sIHRvKTtcbiAgICAgICAgZmxhdHRlbmVkLnNldChkb2MsIG5ldyBGbGF0dGVuZWREb2MoY2FjaGVkRnJvbSwgdGV4dCkpO1xuICAgICAgICByZXR1cm4gbmV3IEZsYXR0ZW5lZERvYyhmcm9tLCB0ZXh0LnNsaWNlKGZyb20gLSBjYWNoZWRGcm9tLCB0byAtIGNhY2hlZEZyb20pKTtcbiAgICB9XG59XG5jbGFzcyBNdWx0aWxpbmVSZWdFeHBDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKHRleHQsIHF1ZXJ5LCBvcHRpb25zLCBmcm9tLCB0bykge1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnZhbHVlID0gZW1wdHk7XG4gICAgICAgIHRoaXMubWF0Y2hQb3MgPSBmcm9tO1xuICAgICAgICB0aGlzLnJlID0gbmV3IFJlZ0V4cChxdWVyeSwgYmFzZUZsYWdzICsgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaWdub3JlQ2FzZSkgPyBcImlcIiA6IFwiXCIpKTtcbiAgICAgICAgdGhpcy5mbGF0ID0gRmxhdHRlbmVkRG9jLmdldCh0ZXh0LCBmcm9tLCB0aGlzLmNodW5rRW5kKGZyb20gKyA1MDAwIC8qIEJhc2UgKi8pKTtcbiAgICB9XG4gICAgY2h1bmtFbmQocG9zKSB7XG4gICAgICAgIHJldHVybiBwb3MgPj0gdGhpcy50byA/IHRoaXMudG8gOiB0aGlzLnRleHQubGluZUF0KHBvcykudG87XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBvZmYgPSB0aGlzLnJlLmxhc3RJbmRleCA9IHRoaXMubWF0Y2hQb3MgLSB0aGlzLmZsYXQuZnJvbTtcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IHRoaXMucmUuZXhlYyh0aGlzLmZsYXQudGV4dCk7XG4gICAgICAgICAgICAvLyBTa2lwIGVtcHR5IG1hdGNoZXMgZGlyZWN0bHkgYWZ0ZXIgdGhlIGxhc3QgbWF0Y2hcbiAgICAgICAgICAgIGlmIChtYXRjaCAmJiAhbWF0Y2hbMF0gJiYgbWF0Y2guaW5kZXggPT0gb2ZmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZS5sYXN0SW5kZXggPSBvZmYgKyAxO1xuICAgICAgICAgICAgICAgIG1hdGNoID0gdGhpcy5yZS5leGVjKHRoaXMuZmxhdC50ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGEgbWF0Y2ggZ29lcyBhbG1vc3QgdG8gdGhlIGVuZCBvZiBhIG5vbmNvbXBsZXRlIGNodW5rLCB0cnlcbiAgICAgICAgICAgIC8vIGFnYWluLCBzaW5jZSBpdCdsbCBsaWtlbHkgYmUgYWJsZSB0byBtYXRjaCBtb3JlXG4gICAgICAgICAgICBpZiAobWF0Y2ggJiYgdGhpcy5mbGF0LnRvIDwgdGhpcy50byAmJiBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCA+IHRoaXMuZmxhdC50ZXh0Lmxlbmd0aCAtIDEwKVxuICAgICAgICAgICAgICAgIG1hdGNoID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gdGhpcy5mbGF0LmZyb20gKyBtYXRjaC5pbmRleCwgdG8gPSBmcm9tICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB7IGZyb20sIHRvLCBtYXRjaCB9O1xuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hQb3MgPSB0byArIChmcm9tID09IHRvID8gMSA6IDApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmxhdC50byA9PSB0aGlzLnRvKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBHcm93IHRoZSBmbGF0dGVuZWQgZG9jXG4gICAgICAgICAgICAgICAgdGhpcy5mbGF0ID0gRmxhdHRlbmVkRG9jLmdldCh0aGlzLnRleHQsIHRoaXMuZmxhdC5mcm9tLCB0aGlzLmNodW5rRW5kKHRoaXMuZmxhdC5mcm9tICsgdGhpcy5mbGF0LnRleHQubGVuZ3RoICogMikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRSZWdFeHAoc291cmNlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbmV3IFJlZ0V4cChzb3VyY2UsIGJhc2VGbGFncyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlTGluZURpYWxvZyh2aWV3KSB7XG4gICAgbGV0IGlucHV0ID0gZWx0X19kZWZhdWx0WydkZWZhdWx0J10oXCJpbnB1dFwiLCB7IGNsYXNzOiBcImNtLXRleHRmaWVsZFwiLCBuYW1lOiBcImxpbmVcIiB9KTtcbiAgICBsZXQgZG9tID0gZWx0X19kZWZhdWx0WydkZWZhdWx0J10oXCJmb3JtXCIsIHtcbiAgICAgICAgY2xhc3M6IFwiY20tZ290b0xpbmVcIixcbiAgICAgICAgb25rZXlkb3duOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IDI3KSB7IC8vIEVzY2FwZVxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IGRpYWxvZ0VmZmVjdC5vZihmYWxzZSkgfSk7XG4gICAgICAgICAgICAgICAgdmlldy5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PSAxMykgeyAvLyBFbnRlclxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZ28oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25zdWJtaXQ6IChldmVudCkgPT4ge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGdvKCk7XG4gICAgICAgIH1cbiAgICB9LCBlbHRfX2RlZmF1bHRbJ2RlZmF1bHQnXShcImxhYmVsXCIsIHZpZXcuc3RhdGUucGhyYXNlKFwiR28gdG8gbGluZVwiKSwgXCI6IFwiLCBpbnB1dCksIFwiIFwiLCBlbHRfX2RlZmF1bHRbJ2RlZmF1bHQnXShcImJ1dHRvblwiLCB7IGNsYXNzOiBcImNtLWJ1dHRvblwiLCB0eXBlOiBcInN1Ym1pdFwiIH0sIHZpZXcuc3RhdGUucGhyYXNlKFwiZ29cIikpKTtcbiAgICBmdW5jdGlvbiBnbygpIHtcbiAgICAgICAgbGV0IG1hdGNoID0gL14oWystXSk/KFxcZCspPyg6XFxkKyk/KCUpPyQvLmV4ZWMoaW5wdXQudmFsdWUpO1xuICAgICAgICBpZiAoIW1hdGNoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgeyBzdGF0ZTogc3RhdGUkMSB9ID0gdmlldywgc3RhcnRMaW5lID0gc3RhdGUkMS5kb2MubGluZUF0KHN0YXRlJDEuc2VsZWN0aW9uLm1haW4uaGVhZCk7XG4gICAgICAgIGxldCBbLCBzaWduLCBsbiwgY2wsIHBlcmNlbnRdID0gbWF0Y2g7XG4gICAgICAgIGxldCBjb2wgPSBjbCA/ICtjbC5zbGljZSgxKSA6IDA7XG4gICAgICAgIGxldCBsaW5lID0gbG4gPyArbG4gOiBzdGFydExpbmUubnVtYmVyO1xuICAgICAgICBpZiAobG4gJiYgcGVyY2VudCkge1xuICAgICAgICAgICAgbGV0IHBjID0gbGluZSAvIDEwMDtcbiAgICAgICAgICAgIGlmIChzaWduKVxuICAgICAgICAgICAgICAgIHBjID0gcGMgKiAoc2lnbiA9PSBcIi1cIiA/IC0xIDogMSkgKyAoc3RhcnRMaW5lLm51bWJlciAvIHN0YXRlJDEuZG9jLmxpbmVzKTtcbiAgICAgICAgICAgIGxpbmUgPSBNYXRoLnJvdW5kKHN0YXRlJDEuZG9jLmxpbmVzICogcGMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxuICYmIHNpZ24pIHtcbiAgICAgICAgICAgIGxpbmUgPSBsaW5lICogKHNpZ24gPT0gXCItXCIgPyAtMSA6IDEpICsgc3RhcnRMaW5lLm51bWJlcjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZG9jTGluZSA9IHN0YXRlJDEuZG9jLmxpbmUoTWF0aC5tYXgoMSwgTWF0aC5taW4oc3RhdGUkMS5kb2MubGluZXMsIGxpbmUpKSk7XG4gICAgICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICAgICAgZWZmZWN0czogZGlhbG9nRWZmZWN0Lm9mKGZhbHNlKSxcbiAgICAgICAgICAgIHNlbGVjdGlvbjogc3RhdGUuRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihkb2NMaW5lLmZyb20gKyBNYXRoLm1heCgwLCBNYXRoLm1pbihjb2wsIGRvY0xpbmUubGVuZ3RoKSkpLFxuICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZG9tLCBwb3M6IC0xMCB9O1xufVxuY29uc3QgZGlhbG9nRWZmZWN0ID0gc3RhdGUuU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCBkaWFsb2dGaWVsZCA9IHN0YXRlLlN0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7IHJldHVybiB0cnVlOyB9LFxuICAgIHVwZGF0ZSh2YWx1ZSwgdHIpIHtcbiAgICAgICAgZm9yIChsZXQgZSBvZiB0ci5lZmZlY3RzKVxuICAgICAgICAgICAgaWYgKGUuaXMoZGlhbG9nRWZmZWN0KSlcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGUudmFsdWU7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHByb3ZpZGU6IGYgPT4gcGFuZWwuc2hvd1BhbmVsLmZyb20oZiwgdmFsID0+IHZhbCA/IGNyZWF0ZUxpbmVEaWFsb2cgOiBudWxsKVxufSk7XG4vKipcbkNvbW1hbmQgdGhhdCBzaG93cyBhIGRpYWxvZyBhc2tpbmcgdGhlIHVzZXIgZm9yIGEgbGluZSBudW1iZXIsIGFuZFxud2hlbiBhIHZhbGlkIHBvc2l0aW9uIGlzIHByb3ZpZGVkLCBtb3ZlcyB0aGUgY3Vyc29yIHRvIHRoYXQgbGluZS5cblxuU3VwcG9ydHMgbGluZSBudW1iZXJzLCByZWxhdGl2ZSBsaW5lIG9mZnNldHMgcHJlZml4ZWQgd2l0aCBgK2Agb3JcbmAtYCwgZG9jdW1lbnQgcGVyY2VudGFnZXMgc3VmZml4ZWQgd2l0aCBgJWAsIGFuZCBhbiBvcHRpb25hbFxuY29sdW1uIHBvc2l0aW9uIGJ5IGFkZGluZyBgOmAgYW5kIGEgc2Vjb25kIG51bWJlciBhZnRlciB0aGUgbGluZVxubnVtYmVyLlxuXG5UaGUgZGlhbG9nIGNhbiBiZSBzdHlsZWQgd2l0aCB0aGUgYHBhbmVsLmdvdG9MaW5lYCB0aGVtZVxuc2VsZWN0b3IuXG4qL1xuY29uc3QgZ290b0xpbmUgPSB2aWV3ID0+IHtcbiAgICBsZXQgcGFuZWwkMSA9IHBhbmVsLmdldFBhbmVsKHZpZXcsIGNyZWF0ZUxpbmVEaWFsb2cpO1xuICAgIGlmICghcGFuZWwkMSkge1xuICAgICAgICBsZXQgZWZmZWN0cyA9IFtkaWFsb2dFZmZlY3Qub2YodHJ1ZSldO1xuICAgICAgICBpZiAodmlldy5zdGF0ZS5maWVsZChkaWFsb2dGaWVsZCwgZmFsc2UpID09IG51bGwpXG4gICAgICAgICAgICBlZmZlY3RzLnB1c2goc3RhdGUuU3RhdGVFZmZlY3QuYXBwZW5kQ29uZmlnLm9mKFtkaWFsb2dGaWVsZCwgYmFzZVRoZW1lJDFdKSk7XG4gICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzIH0pO1xuICAgICAgICBwYW5lbCQxID0gcGFuZWwuZ2V0UGFuZWwodmlldywgY3JlYXRlTGluZURpYWxvZyk7XG4gICAgfVxuICAgIGlmIChwYW5lbCQxKVxuICAgICAgICBwYW5lbCQxLmRvbS5xdWVyeVNlbGVjdG9yKFwiaW5wdXRcIikuZm9jdXMoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5jb25zdCBiYXNlVGhlbWUkMSA9IHZpZXcuRWRpdG9yVmlldy5iYXNlVGhlbWUoe1xuICAgIFwiLmNtLXBhbmVsLmNtLWdvdG9MaW5lXCI6IHtcbiAgICAgICAgcGFkZGluZzogXCIycHggNnB4IDRweFwiLFxuICAgICAgICBcIiYgbGFiZWxcIjogeyBmb250U2l6ZTogXCI4MCVcIiB9XG4gICAgfVxufSk7XG5cbmNvbnN0IGRlZmF1bHRIaWdobGlnaHRPcHRpb25zID0ge1xuICAgIGhpZ2hsaWdodFdvcmRBcm91bmRDdXJzb3I6IGZhbHNlLFxuICAgIG1pblNlbGVjdGlvbkxlbmd0aDogMSxcbiAgICBtYXhNYXRjaGVzOiAxMDBcbn07XG5jb25zdCBoaWdobGlnaHRDb25maWcgPSBzdGF0ZS5GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gc3RhdGUuY29tYmluZUNvbmZpZyhvcHRpb25zLCBkZWZhdWx0SGlnaGxpZ2h0T3B0aW9ucywge1xuICAgICAgICAgICAgaGlnaGxpZ2h0V29yZEFyb3VuZEN1cnNvcjogKGEsIGIpID0+IGEgfHwgYixcbiAgICAgICAgICAgIG1pblNlbGVjdGlvbkxlbmd0aDogTWF0aC5taW4sXG4gICAgICAgICAgICBtYXhNYXRjaGVzOiBNYXRoLm1pblxuICAgICAgICB9KTtcbiAgICB9XG59KTtcbi8qKlxuVGhpcyBleHRlbnNpb24gaGlnaGxpZ2h0cyB0ZXh0IHRoYXQgbWF0Y2hlcyB0aGUgc2VsZWN0aW9uLiBJdCB1c2VzXG50aGUgYFwiY20tc2VsZWN0aW9uTWF0Y2hcImAgY2xhc3MgZm9yIHRoZSBoaWdobGlnaHRpbmcuIFdoZW5cbmBoaWdobGlnaHRXb3JkQXJvdW5kQ3Vyc29yYCBpcyBlbmFibGVkLCB0aGUgd29yZCBhdCB0aGUgY3Vyc29yXG5pdHNlbGYgd2lsbCBiZSBoaWdobGlnaHRlZCB3aXRoIGBcImNtLXNlbGVjdGlvbk1hdGNoLW1haW5cImAuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0U2VsZWN0aW9uTWF0Y2hlcyhvcHRpb25zKSB7XG4gICAgbGV0IGV4dCA9IFtkZWZhdWx0VGhlbWUsIG1hdGNoSGlnaGxpZ2h0ZXJdO1xuICAgIGlmIChvcHRpb25zKVxuICAgICAgICBleHQucHVzaChoaWdobGlnaHRDb25maWcub2Yob3B0aW9ucykpO1xuICAgIHJldHVybiBleHQ7XG59XG5mdW5jdGlvbiB3b3JkQXQoZG9jLCBwb3MsIGNoZWNrKSB7XG4gICAgbGV0IGxpbmUgPSBkb2MubGluZUF0KHBvcyk7XG4gICAgbGV0IGZyb20gPSBwb3MgLSBsaW5lLmZyb20sIHRvID0gcG9zIC0gbGluZS5mcm9tO1xuICAgIHdoaWxlIChmcm9tID4gMCkge1xuICAgICAgICBsZXQgcHJldiA9IHRleHQuZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIGZyb20sIGZhbHNlKTtcbiAgICAgICAgaWYgKGNoZWNrKGxpbmUudGV4dC5zbGljZShwcmV2LCBmcm9tKSkgIT0gc3RhdGUuQ2hhckNhdGVnb3J5LldvcmQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZnJvbSA9IHByZXY7XG4gICAgfVxuICAgIHdoaWxlICh0byA8IGxpbmUubGVuZ3RoKSB7XG4gICAgICAgIGxldCBuZXh0ID0gdGV4dC5maW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgdG8pO1xuICAgICAgICBpZiAoY2hlY2sobGluZS50ZXh0LnNsaWNlKHRvLCBuZXh0KSkgIT0gc3RhdGUuQ2hhckNhdGVnb3J5LldvcmQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgdG8gPSBuZXh0O1xuICAgIH1cbiAgICByZXR1cm4gZnJvbSA9PSB0byA/IG51bGwgOiBsaW5lLnRleHQuc2xpY2UoZnJvbSwgdG8pO1xufVxuY29uc3QgbWF0Y2hEZWNvID0gdmlldy5EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1zZWxlY3Rpb25NYXRjaFwiIH0pO1xuY29uc3QgbWFpbk1hdGNoRGVjbyA9IHZpZXcuRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tc2VsZWN0aW9uTWF0Y2ggY20tc2VsZWN0aW9uTWF0Y2gtbWFpblwiIH0pO1xuY29uc3QgbWF0Y2hIaWdobGlnaHRlciA9IHZpZXcuVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZ2V0RGVjbyh2aWV3KTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodXBkYXRlLnNlbGVjdGlvblNldCB8fCB1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUudmlld3BvcnRDaGFuZ2VkKVxuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZ2V0RGVjbyh1cGRhdGUudmlldyk7XG4gICAgfVxuICAgIGdldERlY28odmlldyQxKSB7XG4gICAgICAgIGxldCBjb25mID0gdmlldyQxLnN0YXRlLmZhY2V0KGhpZ2hsaWdodENvbmZpZyk7XG4gICAgICAgIGxldCB7IHN0YXRlOiBzdGF0ZSQxIH0gPSB2aWV3JDEsIHNlbCA9IHN0YXRlJDEuc2VsZWN0aW9uO1xuICAgICAgICBpZiAoc2VsLnJhbmdlcy5sZW5ndGggPiAxKVxuICAgICAgICAgICAgcmV0dXJuIHZpZXcuRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICBsZXQgcmFuZ2UgPSBzZWwubWFpbiwgcXVlcnksIGNoZWNrID0gbnVsbDtcbiAgICAgICAgaWYgKHJhbmdlLmVtcHR5KSB7XG4gICAgICAgICAgICBpZiAoIWNvbmYuaGlnaGxpZ2h0V29yZEFyb3VuZEN1cnNvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlldy5EZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICBjaGVjayA9IHN0YXRlJDEuY2hhckNhdGVnb3JpemVyKHJhbmdlLmhlYWQpO1xuICAgICAgICAgICAgcXVlcnkgPSB3b3JkQXQoc3RhdGUkMS5kb2MsIHJhbmdlLmhlYWQsIGNoZWNrKTtcbiAgICAgICAgICAgIGlmICghcXVlcnkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZXcuRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGxlbiA9IHJhbmdlLnRvIC0gcmFuZ2UuZnJvbTtcbiAgICAgICAgICAgIGlmIChsZW4gPCBjb25mLm1pblNlbGVjdGlvbkxlbmd0aCB8fCBsZW4gPiAyMDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZXcuRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICAgICAgcXVlcnkgPSBzdGF0ZSQxLnNsaWNlRG9jKHJhbmdlLmZyb20sIHJhbmdlLnRvKS50cmltKCk7XG4gICAgICAgICAgICBpZiAoIXF1ZXJ5KVxuICAgICAgICAgICAgICAgIHJldHVybiB2aWV3LkRlY29yYXRpb24ubm9uZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGVjbyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwYXJ0IG9mIHZpZXckMS52aXNpYmxlUmFuZ2VzKSB7XG4gICAgICAgICAgICBsZXQgY3Vyc29yID0gbmV3IFNlYXJjaEN1cnNvcihzdGF0ZSQxLmRvYywgcXVlcnksIHBhcnQuZnJvbSwgcGFydC50byk7XG4gICAgICAgICAgICB3aGlsZSAoIWN1cnNvci5uZXh0T3ZlcmxhcHBpbmcoKS5kb25lKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IGN1cnNvci52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIWNoZWNrIHx8ICgoZnJvbSA9PSAwIHx8IGNoZWNrKHN0YXRlJDEuc2xpY2VEb2MoZnJvbSAtIDEsIGZyb20pKSAhPSBzdGF0ZS5DaGFyQ2F0ZWdvcnkuV29yZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKHRvID09IHN0YXRlJDEuZG9jLmxlbmd0aCB8fCBjaGVjayhzdGF0ZSQxLnNsaWNlRG9jKHRvLCB0byArIDEpKSAhPSBzdGF0ZS5DaGFyQ2F0ZWdvcnkuV29yZCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGVjayAmJiBmcm9tIDw9IHJhbmdlLmZyb20gJiYgdG8gPj0gcmFuZ2UudG8pXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvLnB1c2gobWFpbk1hdGNoRGVjby5yYW5nZShmcm9tLCB0bykpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmcm9tID49IHJhbmdlLnRvIHx8IHRvIDw9IHJhbmdlLmZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvLnB1c2gobWF0Y2hEZWNvLnJhbmdlKGZyb20sIHRvKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWNvLmxlbmd0aCA+IGNvbmYubWF4TWF0Y2hlcylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2aWV3LkRlY29yYXRpb24ubm9uZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZpZXcuRGVjb3JhdGlvbi5zZXQoZGVjbyk7XG4gICAgfVxufSwge1xuICAgIGRlY29yYXRpb25zOiB2ID0+IHYuZGVjb3JhdGlvbnNcbn0pO1xuY29uc3QgZGVmYXVsdFRoZW1lID0gdmlldy5FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCIuY20tc2VsZWN0aW9uTWF0Y2hcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiIzk5ZmY3NzgwXCIgfSxcbiAgICBcIi5jbS1zZWFyY2hNYXRjaCAuY20tc2VsZWN0aW9uTWF0Y2hcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwidHJhbnNwYXJlbnRcIiB9XG59KTtcblxuY2xhc3MgUXVlcnkge1xuICAgIGNvbnN0cnVjdG9yKHNlYXJjaCwgcmVwbGFjZSwgY2FzZUluc2Vuc2l0aXZlKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gc2VhcmNoO1xuICAgICAgICB0aGlzLnJlcGxhY2UgPSByZXBsYWNlO1xuICAgICAgICB0aGlzLmNhc2VJbnNlbnNpdGl2ZSA9IGNhc2VJbnNlbnNpdGl2ZTtcbiAgICB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VhcmNoID09IG90aGVyLnNlYXJjaCAmJiB0aGlzLnJlcGxhY2UgPT0gb3RoZXIucmVwbGFjZSAmJlxuICAgICAgICAgICAgdGhpcy5jYXNlSW5zZW5zaXRpdmUgPT0gb3RoZXIuY2FzZUluc2Vuc2l0aXZlICYmIHRoaXMuY29uc3RydWN0b3IgPT0gb3RoZXIuY29uc3RydWN0b3I7XG4gICAgfVxufVxuY2xhc3MgU3RyaW5nUXVlcnkgZXh0ZW5kcyBRdWVyeSB7XG4gICAgY29uc3RydWN0b3Ioc2VhcmNoLCByZXBsYWNlLCBjYXNlSW5zZW5zaXRpdmUpIHtcbiAgICAgICAgc3VwZXIoc2VhcmNoLCByZXBsYWNlLCBjYXNlSW5zZW5zaXRpdmUpO1xuICAgICAgICB0aGlzLnVucXVvdGVkID0gc2VhcmNoLnJlcGxhY2UoL1xcXFwoW25ydFxcXFxdKS9nLCAoXywgY2gpID0+IGNoID09IFwiblwiID8gXCJcXG5cIiA6IGNoID09IFwiclwiID8gXCJcXHJcIiA6IGNoID09IFwidFwiID8gXCJcXHRcIiA6IFwiXFxcXFwiKTtcbiAgICB9XG4gICAgY3Vyc29yKGRvYywgZnJvbSA9IDAsIHRvID0gZG9jLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV3IFNlYXJjaEN1cnNvcihkb2MsIHRoaXMudW5xdW90ZWQsIGZyb20sIHRvLCB0aGlzLmNhc2VJbnNlbnNpdGl2ZSA/IHggPT4geC50b0xvd2VyQ2FzZSgpIDogdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgbmV4dE1hdGNoKGRvYywgY3VyRnJvbSwgY3VyVG8pIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IHRoaXMuY3Vyc29yKGRvYywgY3VyVG8pLm5leHRPdmVybGFwcGluZygpO1xuICAgICAgICBpZiAoY3Vyc29yLmRvbmUpXG4gICAgICAgICAgICBjdXJzb3IgPSB0aGlzLmN1cnNvcihkb2MsIDAsIGN1ckZyb20pLm5leHRPdmVybGFwcGluZygpO1xuICAgICAgICByZXR1cm4gY3Vyc29yLmRvbmUgPyBudWxsIDogY3Vyc29yLnZhbHVlO1xuICAgIH1cbiAgICAvLyBTZWFyY2hpbmcgaW4gcmV2ZXJzZSBpcywgcmF0aGVyIHRoYW4gaW1wbGVtZW50aW5nIGludmVydGVkIHNlYXJjaFxuICAgIC8vIGN1cnNvciwgZG9uZSBieSBzY2FubmluZyBjaHVuayBhZnRlciBjaHVuayBmb3J3YXJkLlxuICAgIHByZXZNYXRjaEluUmFuZ2UoZG9jLCBmcm9tLCB0bykge1xuICAgICAgICBmb3IgKGxldCBwb3MgPSB0bzs7KSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChmcm9tLCBwb3MgLSAxMDAwMCAvKiBDaHVua1NpemUgKi8gLSB0aGlzLnVucXVvdGVkLmxlbmd0aCk7XG4gICAgICAgICAgICBsZXQgY3Vyc29yID0gdGhpcy5jdXJzb3IoZG9jLCBzdGFydCwgcG9zKSwgcmFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgd2hpbGUgKCFjdXJzb3IubmV4dE92ZXJsYXBwaW5nKCkuZG9uZSlcbiAgICAgICAgICAgICAgICByYW5nZSA9IGN1cnNvci52YWx1ZTtcbiAgICAgICAgICAgIGlmIChyYW5nZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPT0gZnJvbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHBvcyAtPSAxMDAwMCAvKiBDaHVua1NpemUgKi87XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJldk1hdGNoKGRvYywgY3VyRnJvbSwgY3VyVG8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJldk1hdGNoSW5SYW5nZShkb2MsIDAsIGN1ckZyb20pIHx8XG4gICAgICAgICAgICB0aGlzLnByZXZNYXRjaEluUmFuZ2UoZG9jLCBjdXJUbywgZG9jLmxlbmd0aCk7XG4gICAgfVxuICAgIGdldFJlcGxhY2VtZW50KF9yZXN1bHQpIHsgcmV0dXJuIHRoaXMucmVwbGFjZTsgfVxuICAgIG1hdGNoQWxsKGRvYywgbGltaXQpIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IHRoaXMuY3Vyc29yKGRvYyksIHJhbmdlcyA9IFtdO1xuICAgICAgICB3aGlsZSAoIWN1cnNvci5uZXh0KCkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPj0gbGltaXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByYW5nZXMucHVzaChjdXJzb3IudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYW5nZXM7XG4gICAgfVxuICAgIGhpZ2hsaWdodChkb2MsIGZyb20sIHRvLCBhZGQpIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IHRoaXMuY3Vyc29yKGRvYywgTWF0aC5tYXgoMCwgZnJvbSAtIHRoaXMudW5xdW90ZWQubGVuZ3RoKSwgTWF0aC5taW4odG8gKyB0aGlzLnVucXVvdGVkLmxlbmd0aCwgZG9jLmxlbmd0aCkpO1xuICAgICAgICB3aGlsZSAoIWN1cnNvci5uZXh0KCkuZG9uZSlcbiAgICAgICAgICAgIGFkZChjdXJzb3IudmFsdWUuZnJvbSwgY3Vyc29yLnZhbHVlLnRvKTtcbiAgICB9XG4gICAgZ2V0IHZhbGlkKCkgeyByZXR1cm4gISF0aGlzLnNlYXJjaDsgfVxufVxuY2xhc3MgUmVnRXhwUXVlcnkgZXh0ZW5kcyBRdWVyeSB7XG4gICAgY29uc3RydWN0b3Ioc2VhcmNoLCByZXBsYWNlLCBjYXNlSW5zZW5zaXRpdmUpIHtcbiAgICAgICAgc3VwZXIoc2VhcmNoLCByZXBsYWNlLCBjYXNlSW5zZW5zaXRpdmUpO1xuICAgICAgICB0aGlzLnZhbGlkID0gISFzZWFyY2ggJiYgdmFsaWRSZWdFeHAoc2VhcmNoKTtcbiAgICB9XG4gICAgY3Vyc29yKGRvYywgZnJvbSA9IDAsIHRvID0gZG9jLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cEN1cnNvcihkb2MsIHRoaXMuc2VhcmNoLCB0aGlzLmNhc2VJbnNlbnNpdGl2ZSA/IHsgaWdub3JlQ2FzZTogdHJ1ZSB9IDogdW5kZWZpbmVkLCBmcm9tLCB0byk7XG4gICAgfVxuICAgIG5leHRNYXRjaChkb2MsIGN1ckZyb20sIGN1clRvKSB7XG4gICAgICAgIGxldCBjdXJzb3IgPSB0aGlzLmN1cnNvcihkb2MsIGN1clRvKS5uZXh0KCk7XG4gICAgICAgIGlmIChjdXJzb3IuZG9uZSlcbiAgICAgICAgICAgIGN1cnNvciA9IHRoaXMuY3Vyc29yKGRvYywgMCwgY3VyRnJvbSkubmV4dCgpO1xuICAgICAgICByZXR1cm4gY3Vyc29yLmRvbmUgPyBudWxsIDogY3Vyc29yLnZhbHVlO1xuICAgIH1cbiAgICBwcmV2TWF0Y2hJblJhbmdlKGRvYywgZnJvbSwgdG8pIHtcbiAgICAgICAgZm9yIChsZXQgc2l6ZSA9IDE7OyBzaXplKyspIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IE1hdGgubWF4KGZyb20sIHRvIC0gc2l6ZSAqIDEwMDAwIC8qIENodW5rU2l6ZSAqLyk7XG4gICAgICAgICAgICBsZXQgY3Vyc29yID0gdGhpcy5jdXJzb3IoZG9jLCBzdGFydCwgdG8pLCByYW5nZSA9IG51bGw7XG4gICAgICAgICAgICB3aGlsZSAoIWN1cnNvci5uZXh0KCkuZG9uZSlcbiAgICAgICAgICAgICAgICByYW5nZSA9IGN1cnNvci52YWx1ZTtcbiAgICAgICAgICAgIGlmIChyYW5nZSAmJiAoc3RhcnQgPT0gZnJvbSB8fCByYW5nZS5mcm9tID4gc3RhcnQgKyAxMCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID09IGZyb20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJldk1hdGNoKGRvYywgY3VyRnJvbSwgY3VyVG8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJldk1hdGNoSW5SYW5nZShkb2MsIDAsIGN1ckZyb20pIHx8XG4gICAgICAgICAgICB0aGlzLnByZXZNYXRjaEluUmFuZ2UoZG9jLCBjdXJUbywgZG9jLmxlbmd0aCk7XG4gICAgfVxuICAgIGdldFJlcGxhY2VtZW50KHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlLnJlcGxhY2UoL1xcJChbJCZcXGQrXSkvZywgKG0sIGkpID0+IGkgPT0gXCIkXCIgPyBcIiRcIlxuICAgICAgICAgICAgOiBpID09IFwiJlwiID8gcmVzdWx0Lm1hdGNoWzBdXG4gICAgICAgICAgICAgICAgOiBpICE9IFwiMFwiICYmICtpIDwgcmVzdWx0Lm1hdGNoLmxlbmd0aCA/IHJlc3VsdC5tYXRjaFtpXVxuICAgICAgICAgICAgICAgICAgICA6IG0pO1xuICAgIH1cbiAgICBtYXRjaEFsbChkb2MsIGxpbWl0KSB7XG4gICAgICAgIGxldCBjdXJzb3IgPSB0aGlzLmN1cnNvcihkb2MpLCByYW5nZXMgPSBbXTtcbiAgICAgICAgd2hpbGUgKCFjdXJzb3IubmV4dCgpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChyYW5nZXMubGVuZ3RoID49IGxpbWl0KVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmFuZ2VzLnB1c2goY3Vyc29yLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmFuZ2VzO1xuICAgIH1cbiAgICBoaWdobGlnaHQoZG9jLCBmcm9tLCB0bywgYWRkKSB7XG4gICAgICAgIGxldCBjdXJzb3IgPSB0aGlzLmN1cnNvcihkb2MsIE1hdGgubWF4KDAsIGZyb20gLSAyNTAgLyogSGlnaGxpZ2h0TWFyZ2luICovKSwgTWF0aC5taW4odG8gKyAyNTAgLyogSGlnaGxpZ2h0TWFyZ2luICovLCBkb2MubGVuZ3RoKSk7XG4gICAgICAgIHdoaWxlICghY3Vyc29yLm5leHQoKS5kb25lKVxuICAgICAgICAgICAgYWRkKGN1cnNvci52YWx1ZS5mcm9tLCBjdXJzb3IudmFsdWUudG8pO1xuICAgIH1cbn1cbmNvbnN0IHNldFF1ZXJ5ID0gc3RhdGUuU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCB0b2dnbGVQYW5lbCA9IHN0YXRlLlN0YXRlRWZmZWN0LmRlZmluZSgpO1xuY29uc3Qgc2VhcmNoU3RhdGUgPSBzdGF0ZS5TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFNlYXJjaFN0YXRlKG5ldyBTdHJpbmdRdWVyeShcIlwiLCBcIlwiLCBmYWxzZSksIG51bGwpO1xuICAgIH0sXG4gICAgdXBkYXRlKHZhbHVlLCB0cikge1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhzZXRRdWVyeSkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgU2VhcmNoU3RhdGUoZWZmZWN0LnZhbHVlLCB2YWx1ZS5wYW5lbCk7XG4gICAgICAgICAgICBlbHNlIGlmIChlZmZlY3QuaXModG9nZ2xlUGFuZWwpKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IFNlYXJjaFN0YXRlKHZhbHVlLnF1ZXJ5LCBlZmZlY3QudmFsdWUgPyBjcmVhdGVTZWFyY2hQYW5lbCA6IG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHByb3ZpZGU6IGYgPT4gcGFuZWwuc2hvd1BhbmVsLmZyb20oZiwgdmFsID0+IHZhbC5wYW5lbClcbn0pO1xuY2xhc3MgU2VhcmNoU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKHF1ZXJ5LCBwYW5lbCkge1xuICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgIHRoaXMucGFuZWwgPSBwYW5lbDtcbiAgICB9XG59XG5jb25zdCBtYXRjaE1hcmsgPSB2aWV3LkRlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLXNlYXJjaE1hdGNoXCIgfSksIHNlbGVjdGVkTWF0Y2hNYXJrID0gdmlldy5EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1zZWFyY2hNYXRjaCBjbS1zZWFyY2hNYXRjaC1zZWxlY3RlZFwiIH0pO1xuY29uc3Qgc2VhcmNoSGlnaGxpZ2h0ZXIgPSB2aWV3LlZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmhpZ2hsaWdodCh2aWV3LnN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlKSk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gdXBkYXRlLnN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlKTtcbiAgICAgICAgaWYgKHN0YXRlICE9IHVwZGF0ZS5zdGFydFN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlKSB8fCB1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUuc2VsZWN0aW9uU2V0KVxuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuaGlnaGxpZ2h0KHN0YXRlKTtcbiAgICB9XG4gICAgaGlnaGxpZ2h0KHsgcXVlcnksIHBhbmVsIH0pIHtcbiAgICAgICAgaWYgKCFwYW5lbCB8fCAhcXVlcnkudmFsaWQpXG4gICAgICAgICAgICByZXR1cm4gdmlldy5EZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgIGxldCB7IHZpZXc6IHZpZXckMSB9ID0gdGhpcztcbiAgICAgICAgbGV0IGJ1aWxkZXIgPSBuZXcgcmFuZ2VzZXQuUmFuZ2VTZXRCdWlsZGVyKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCByYW5nZXMgPSB2aWV3JDEudmlzaWJsZVJhbmdlcywgbCA9IHJhbmdlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSByYW5nZXNbaV07XG4gICAgICAgICAgICB3aGlsZSAoaSA8IGwgLSAxICYmIHRvID4gcmFuZ2VzW2kgKyAxXS5mcm9tIC0gMiAqIDI1MCAvKiBIaWdobGlnaHRNYXJnaW4gKi8pXG4gICAgICAgICAgICAgICAgdG8gPSByYW5nZXNbKytpXS50bztcbiAgICAgICAgICAgIHF1ZXJ5LmhpZ2hsaWdodCh2aWV3JDEuc3RhdGUuZG9jLCBmcm9tLCB0bywgKGZyb20sIHRvKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHNlbGVjdGVkID0gdmlldyQxLnN0YXRlLnNlbGVjdGlvbi5yYW5nZXMuc29tZShyID0+IHIuZnJvbSA9PSBmcm9tICYmIHIudG8gPT0gdG8pO1xuICAgICAgICAgICAgICAgIGJ1aWxkZXIuYWRkKGZyb20sIHRvLCBzZWxlY3RlZCA/IHNlbGVjdGVkTWF0Y2hNYXJrIDogbWF0Y2hNYXJrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWlsZGVyLmZpbmlzaCgpO1xuICAgIH1cbn0sIHtcbiAgICBkZWNvcmF0aW9uczogdiA9PiB2LmRlY29yYXRpb25zXG59KTtcbmZ1bmN0aW9uIHNlYXJjaENvbW1hbmQoZikge1xuICAgIHJldHVybiB2aWV3ID0+IHtcbiAgICAgICAgbGV0IHN0YXRlID0gdmlldy5zdGF0ZS5maWVsZChzZWFyY2hTdGF0ZSwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gc3RhdGUgJiYgc3RhdGUucXVlcnkudmFsaWQgPyBmKHZpZXcsIHN0YXRlKSA6IG9wZW5TZWFyY2hQYW5lbCh2aWV3KTtcbiAgICB9O1xufVxuLyoqXG5PcGVuIHRoZSBzZWFyY2ggcGFuZWwgaWYgaXQgaXNuJ3QgYWxyZWFkeSBvcGVuLCBhbmQgbW92ZSB0aGVcbnNlbGVjdGlvbiB0byB0aGUgZmlyc3QgbWF0Y2ggYWZ0ZXIgdGhlIGN1cnJlbnQgbWFpbiBzZWxlY3Rpb24uXG5XaWxsIHdyYXAgYXJvdW5kIHRvIHRoZSBzdGFydCBvZiB0aGUgZG9jdW1lbnQgd2hlbiBpdCByZWFjaGVzIHRoZVxuZW5kLlxuKi9cbmNvbnN0IGZpbmROZXh0ID0gc2VhcmNoQ29tbWFuZCgodmlldywgeyBxdWVyeSB9KSA9PiB7XG4gICAgbGV0IHsgZnJvbSwgdG8gfSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgbGV0IG5leHQgPSBxdWVyeS5uZXh0TWF0Y2godmlldy5zdGF0ZS5kb2MsIGZyb20sIHRvKTtcbiAgICBpZiAoIW5leHQgfHwgbmV4dC5mcm9tID09IGZyb20gJiYgbmV4dC50byA9PSB0bylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICBzZWxlY3Rpb246IHsgYW5jaG9yOiBuZXh0LmZyb20sIGhlYWQ6IG5leHQudG8gfSxcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWUsXG4gICAgICAgIGVmZmVjdHM6IGFubm91bmNlTWF0Y2godmlldywgbmV4dClcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIHByZXZpb3VzIGluc3RhbmNlIG9mIHRoZSBzZWFyY2ggcXVlcnksXG5iZWZvcmUgdGhlIGN1cnJlbnQgbWFpbiBzZWxlY3Rpb24uIFdpbGwgd3JhcCBwYXN0IHRoZSBzdGFydFxub2YgdGhlIGRvY3VtZW50IHRvIHN0YXJ0IHNlYXJjaGluZyBhdCB0aGUgZW5kIGFnYWluLlxuKi9cbmNvbnN0IGZpbmRQcmV2aW91cyA9IHNlYXJjaENvbW1hbmQoKHZpZXcsIHsgcXVlcnkgfSkgPT4ge1xuICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCB7IGZyb20sIHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICBsZXQgcmFuZ2UgPSBxdWVyeS5wcmV2TWF0Y2goc3RhdGUuZG9jLCBmcm9tLCB0byk7XG4gICAgaWYgKCFyYW5nZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICBzZWxlY3Rpb246IHsgYW5jaG9yOiByYW5nZS5mcm9tLCBoZWFkOiByYW5nZS50byB9LFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZSxcbiAgICAgICAgZWZmZWN0czogYW5ub3VuY2VNYXRjaCh2aWV3LCByYW5nZSlcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuLyoqXG5TZWxlY3QgYWxsIGluc3RhbmNlcyBvZiB0aGUgc2VhcmNoIHF1ZXJ5LlxuKi9cbmNvbnN0IHNlbGVjdE1hdGNoZXMgPSBzZWFyY2hDb21tYW5kKCh2aWV3LCB7IHF1ZXJ5IH0pID0+IHtcbiAgICBsZXQgcmFuZ2VzID0gcXVlcnkubWF0Y2hBbGwodmlldy5zdGF0ZS5kb2MsIDEwMDApO1xuICAgIGlmICghcmFuZ2VzIHx8ICFyYW5nZXMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgIHNlbGVjdGlvbjogc3RhdGUuRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMubWFwKHIgPT4gc3RhdGUuRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHIuZnJvbSwgci50bykpKVxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xufSk7XG4vKipcblNlbGVjdCBhbGwgaW5zdGFuY2VzIG9mIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgdGV4dC5cbiovXG5jb25zdCBzZWxlY3RTZWxlY3Rpb25NYXRjaGVzID0gKHsgc3RhdGU6IHN0YXRlJDEsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBsZXQgc2VsID0gc3RhdGUkMS5zZWxlY3Rpb247XG4gICAgaWYgKHNlbC5yYW5nZXMubGVuZ3RoID4gMSB8fCBzZWwubWFpbi5lbXB0eSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB7IGZyb20sIHRvIH0gPSBzZWwubWFpbjtcbiAgICBsZXQgcmFuZ2VzID0gW10sIG1haW4gPSAwO1xuICAgIGZvciAobGV0IGN1ciA9IG5ldyBTZWFyY2hDdXJzb3Ioc3RhdGUkMS5kb2MsIHN0YXRlJDEuc2xpY2VEb2MoZnJvbSwgdG8pKTsgIWN1ci5uZXh0KCkuZG9uZTspIHtcbiAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPiAxMDAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoY3VyLnZhbHVlLmZyb20gPT0gZnJvbSlcbiAgICAgICAgICAgIG1haW4gPSByYW5nZXMubGVuZ3RoO1xuICAgICAgICByYW5nZXMucHVzaChzdGF0ZS5FZGl0b3JTZWxlY3Rpb24ucmFuZ2UoY3VyLnZhbHVlLmZyb20sIGN1ci52YWx1ZS50bykpO1xuICAgIH1cbiAgICBkaXNwYXRjaChzdGF0ZSQxLnVwZGF0ZSh7IHNlbGVjdGlvbjogc3RhdGUuRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMsIG1haW4pIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcblJlcGxhY2UgdGhlIGN1cnJlbnQgbWF0Y2ggb2YgdGhlIHNlYXJjaCBxdWVyeS5cbiovXG5jb25zdCByZXBsYWNlTmV4dCA9IHNlYXJjaENvbW1hbmQoKHZpZXcsIHsgcXVlcnkgfSkgPT4ge1xuICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCB7IGZyb20sIHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICBsZXQgbmV4dCA9IHF1ZXJ5Lm5leHRNYXRjaChzdGF0ZS5kb2MsIGZyb20sIGZyb20pO1xuICAgIGlmICghbmV4dClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBjaGFuZ2VzID0gW10sIHNlbGVjdGlvbiwgcmVwbGFjZW1lbnQ7XG4gICAgaWYgKG5leHQuZnJvbSA9PSBmcm9tICYmIG5leHQudG8gPT0gdG8pIHtcbiAgICAgICAgcmVwbGFjZW1lbnQgPSBzdGF0ZS50b1RleHQocXVlcnkuZ2V0UmVwbGFjZW1lbnQobmV4dCkpO1xuICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBuZXh0LmZyb20sIHRvOiBuZXh0LnRvLCBpbnNlcnQ6IHJlcGxhY2VtZW50IH0pO1xuICAgICAgICBuZXh0ID0gcXVlcnkubmV4dE1hdGNoKHN0YXRlLmRvYywgbmV4dC5mcm9tLCBuZXh0LnRvKTtcbiAgICB9XG4gICAgaWYgKG5leHQpIHtcbiAgICAgICAgbGV0IG9mZiA9IGNoYW5nZXMubGVuZ3RoID09IDAgfHwgY2hhbmdlc1swXS5mcm9tID49IG5leHQudG8gPyAwIDogbmV4dC50byAtIG5leHQuZnJvbSAtIHJlcGxhY2VtZW50Lmxlbmd0aDtcbiAgICAgICAgc2VsZWN0aW9uID0geyBhbmNob3I6IG5leHQuZnJvbSAtIG9mZiwgaGVhZDogbmV4dC50byAtIG9mZiB9O1xuICAgIH1cbiAgICB2aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgY2hhbmdlcywgc2VsZWN0aW9uLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogISFzZWxlY3Rpb24sXG4gICAgICAgIGVmZmVjdHM6IG5leHQgPyBhbm5vdW5jZU1hdGNoKHZpZXcsIG5leHQpIDogdW5kZWZpbmVkXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59KTtcbi8qKlxuUmVwbGFjZSBhbGwgaW5zdGFuY2VzIG9mIHRoZSBzZWFyY2ggcXVlcnkgd2l0aCB0aGUgZ2l2ZW5cbnJlcGxhY2VtZW50LlxuKi9cbmNvbnN0IHJlcGxhY2VBbGwgPSBzZWFyY2hDb21tYW5kKCh2aWV3LCB7IHF1ZXJ5IH0pID0+IHtcbiAgICBsZXQgY2hhbmdlcyA9IHF1ZXJ5Lm1hdGNoQWxsKHZpZXcuc3RhdGUuZG9jLCAxZTkpLm1hcChtYXRjaCA9PiB7XG4gICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSBtYXRjaDtcbiAgICAgICAgcmV0dXJuIHsgZnJvbSwgdG8sIGluc2VydDogcXVlcnkuZ2V0UmVwbGFjZW1lbnQobWF0Y2gpIH07XG4gICAgfSk7XG4gICAgaWYgKCFjaGFuZ2VzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZpZXcuZGlzcGF0Y2goeyBjaGFuZ2VzIH0pO1xuICAgIHJldHVybiB0cnVlO1xufSk7XG5mdW5jdGlvbiBjcmVhdGVTZWFyY2hQYW5lbCh2aWV3KSB7XG4gICAgbGV0IHsgcXVlcnkgfSA9IHZpZXcuc3RhdGUuZmllbGQoc2VhcmNoU3RhdGUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRvbTogYnVpbGRQYW5lbCh7XG4gICAgICAgICAgICB2aWV3LFxuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICB1cGRhdGVRdWVyeShxKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFxdWVyeS5lcShxKSkge1xuICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IHE7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBzZXRRdWVyeS5vZihxdWVyeSkgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgbW91bnQoKSB7XG4gICAgICAgICAgICB0aGlzLmRvbS5xdWVyeVNlbGVjdG9yKFwiW25hbWU9c2VhcmNoXVwiKS5zZWxlY3QoKTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9zOiA4MFxuICAgIH07XG59XG4vKipcbk1ha2Ugc3VyZSB0aGUgc2VhcmNoIHBhbmVsIGlzIG9wZW4gYW5kIGZvY3VzZWQuXG4qL1xuY29uc3Qgb3BlblNlYXJjaFBhbmVsID0gdmlldyA9PiB7XG4gICAgbGV0IHN0YXRlJDEgPSB2aWV3LnN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKHN0YXRlJDEgJiYgc3RhdGUkMS5wYW5lbCkge1xuICAgICAgICBsZXQgcGFuZWwkMSA9IHBhbmVsLmdldFBhbmVsKHZpZXcsIGNyZWF0ZVNlYXJjaFBhbmVsKTtcbiAgICAgICAgaWYgKCFwYW5lbCQxKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBwYW5lbCQxLmRvbS5xdWVyeVNlbGVjdG9yKFwiW25hbWU9c2VhcmNoXVwiKS5mb2N1cygpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IFt0b2dnbGVQYW5lbC5vZih0cnVlKSwgLi4uc3RhdGUkMSA/IFtdIDogW3N0YXRlLlN0YXRlRWZmZWN0LmFwcGVuZENvbmZpZy5vZihzZWFyY2hFeHRlbnNpb25zKV1dIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkNsb3NlIHRoZSBzZWFyY2ggcGFuZWwuXG4qL1xuY29uc3QgY2xvc2VTZWFyY2hQYW5lbCA9IHZpZXcgPT4ge1xuICAgIGxldCBzdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQoc2VhcmNoU3RhdGUsIGZhbHNlKTtcbiAgICBpZiAoIXN0YXRlIHx8ICFzdGF0ZS5wYW5lbClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBwYW5lbCQxID0gcGFuZWwuZ2V0UGFuZWwodmlldywgY3JlYXRlU2VhcmNoUGFuZWwpO1xuICAgIGlmIChwYW5lbCQxICYmIHBhbmVsJDEuZG9tLmNvbnRhaW5zKHZpZXcucm9vdC5hY3RpdmVFbGVtZW50KSlcbiAgICAgICAgdmlldy5mb2N1cygpO1xuICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiB0b2dnbGVQYW5lbC5vZihmYWxzZSkgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5EZWZhdWx0IHNlYXJjaC1yZWxhdGVkIGtleSBiaW5kaW5ncy5cblxuIC0gTW9kLWY6IFtgb3BlblNlYXJjaFBhbmVsYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2gub3BlblNlYXJjaFBhbmVsKVxuIC0gRjMsIE1vZC1nOiBbYGZpbmROZXh0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2guZmluZE5leHQpXG4gLSBTaGlmdC1GMywgU2hpZnQtTW9kLWc6IFtgZmluZFByZXZpb3VzYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2guZmluZFByZXZpb3VzKVxuIC0gQWx0LWc6IFtgZ290b0xpbmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5nb3RvTGluZSlcbiovXG5jb25zdCBzZWFyY2hLZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiTW9kLWZcIiwgcnVuOiBvcGVuU2VhcmNoUGFuZWwsIHNjb3BlOiBcImVkaXRvciBzZWFyY2gtcGFuZWxcIiB9LFxuICAgIHsga2V5OiBcIkYzXCIsIHJ1bjogZmluZE5leHQsIHNoaWZ0OiBmaW5kUHJldmlvdXMsIHNjb3BlOiBcImVkaXRvciBzZWFyY2gtcGFuZWxcIiB9LFxuICAgIHsga2V5OiBcIk1vZC1nXCIsIHJ1bjogZmluZE5leHQsIHNoaWZ0OiBmaW5kUHJldmlvdXMsIHNjb3BlOiBcImVkaXRvciBzZWFyY2gtcGFuZWxcIiB9LFxuICAgIHsga2V5OiBcIkVzY2FwZVwiLCBydW46IGNsb3NlU2VhcmNoUGFuZWwsIHNjb3BlOiBcImVkaXRvciBzZWFyY2gtcGFuZWxcIiB9LFxuICAgIHsga2V5OiBcIk1vZC1TaGlmdC1sXCIsIHJ1bjogc2VsZWN0U2VsZWN0aW9uTWF0Y2hlcyB9LFxuICAgIHsga2V5OiBcIkFsdC1nXCIsIHJ1bjogZ290b0xpbmUgfVxuXTtcbmZ1bmN0aW9uIGJ1aWxkUGFuZWwoY29uZikge1xuICAgIGZ1bmN0aW9uIHBocmFzZShwaHJhc2UpIHsgcmV0dXJuIGNvbmYudmlldy5zdGF0ZS5waHJhc2UocGhyYXNlKTsgfVxuICAgIGxldCBzZWFyY2hGaWVsZCA9IGVsdF9fZGVmYXVsdFsnZGVmYXVsdCddKFwiaW5wdXRcIiwge1xuICAgICAgICB2YWx1ZTogY29uZi5xdWVyeS5zZWFyY2gsXG4gICAgICAgIHBsYWNlaG9sZGVyOiBwaHJhc2UoXCJGaW5kXCIpLFxuICAgICAgICBcImFyaWEtbGFiZWxcIjogcGhyYXNlKFwiRmluZFwiKSxcbiAgICAgICAgY2xhc3M6IFwiY20tdGV4dGZpZWxkXCIsXG4gICAgICAgIG5hbWU6IFwic2VhcmNoXCIsXG4gICAgICAgIG9uY2hhbmdlOiB1cGRhdGUsXG4gICAgICAgIG9ua2V5dXA6IHVwZGF0ZVxuICAgIH0pO1xuICAgIGxldCByZXBsYWNlRmllbGQgPSBlbHRfX2RlZmF1bHRbJ2RlZmF1bHQnXShcImlucHV0XCIsIHtcbiAgICAgICAgdmFsdWU6IGNvbmYucXVlcnkucmVwbGFjZSxcbiAgICAgICAgcGxhY2Vob2xkZXI6IHBocmFzZShcIlJlcGxhY2VcIiksXG4gICAgICAgIFwiYXJpYS1sYWJlbFwiOiBwaHJhc2UoXCJSZXBsYWNlXCIpLFxuICAgICAgICBjbGFzczogXCJjbS10ZXh0ZmllbGRcIixcbiAgICAgICAgbmFtZTogXCJyZXBsYWNlXCIsXG4gICAgICAgIG9uY2hhbmdlOiB1cGRhdGUsXG4gICAgICAgIG9ua2V5dXA6IHVwZGF0ZVxuICAgIH0pO1xuICAgIGxldCBjYXNlRmllbGQgPSBlbHRfX2RlZmF1bHRbJ2RlZmF1bHQnXShcImlucHV0XCIsIHtcbiAgICAgICAgdHlwZTogXCJjaGVja2JveFwiLFxuICAgICAgICBuYW1lOiBcImNhc2VcIixcbiAgICAgICAgY2hlY2tlZDogIWNvbmYucXVlcnkuY2FzZUluc2Vuc2l0aXZlLFxuICAgICAgICBvbmNoYW5nZTogdXBkYXRlXG4gICAgfSk7XG4gICAgbGV0IHJlRmllbGQgPSBlbHRfX2RlZmF1bHRbJ2RlZmF1bHQnXShcImlucHV0XCIsIHtcbiAgICAgICAgdHlwZTogXCJjaGVja2JveFwiLFxuICAgICAgICBuYW1lOiBcInJlXCIsXG4gICAgICAgIGNoZWNrZWQ6IGNvbmYucXVlcnkgaW5zdGFuY2VvZiBSZWdFeHBRdWVyeSxcbiAgICAgICAgb25jaGFuZ2U6IHVwZGF0ZVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgICAgY29uZi51cGRhdGVRdWVyeShuZXcgKHJlRmllbGQuY2hlY2tlZCA/IFJlZ0V4cFF1ZXJ5IDogU3RyaW5nUXVlcnkpKHNlYXJjaEZpZWxkLnZhbHVlLCByZXBsYWNlRmllbGQudmFsdWUsICFjYXNlRmllbGQuY2hlY2tlZCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBrZXlkb3duKGUpIHtcbiAgICAgICAgaWYgKHZpZXcucnVuU2NvcGVIYW5kbGVycyhjb25mLnZpZXcsIGUsIFwic2VhcmNoLXBhbmVsXCIpKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZS5rZXlDb2RlID09IDEzICYmIGUudGFyZ2V0ID09IHNlYXJjaEZpZWxkKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAoZS5zaGlmdEtleSA/IGZpbmRQcmV2aW91cyA6IGZpbmROZXh0KShjb25mLnZpZXcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGUua2V5Q29kZSA9PSAxMyAmJiBlLnRhcmdldCA9PSByZXBsYWNlRmllbGQpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJlcGxhY2VOZXh0KGNvbmYudmlldyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYnV0dG9uKG5hbWUsIG9uY2xpY2ssIGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIGVsdF9fZGVmYXVsdFsnZGVmYXVsdCddKFwiYnV0dG9uXCIsIHsgY2xhc3M6IFwiY20tYnV0dG9uXCIsIG5hbWUsIG9uY2xpY2sgfSwgY29udGVudCk7XG4gICAgfVxuICAgIGxldCBwYW5lbCA9IGVsdF9fZGVmYXVsdFsnZGVmYXVsdCddKFwiZGl2XCIsIHsgb25rZXlkb3duOiBrZXlkb3duLCBjbGFzczogXCJjbS1zZWFyY2hcIiB9LCBbXG4gICAgICAgIHNlYXJjaEZpZWxkLFxuICAgICAgICBidXR0b24oXCJuZXh0XCIsICgpID0+IGZpbmROZXh0KGNvbmYudmlldyksIFtwaHJhc2UoXCJuZXh0XCIpXSksXG4gICAgICAgIGJ1dHRvbihcInByZXZcIiwgKCkgPT4gZmluZFByZXZpb3VzKGNvbmYudmlldyksIFtwaHJhc2UoXCJwcmV2aW91c1wiKV0pLFxuICAgICAgICBidXR0b24oXCJzZWxlY3RcIiwgKCkgPT4gc2VsZWN0TWF0Y2hlcyhjb25mLnZpZXcpLCBbcGhyYXNlKFwiYWxsXCIpXSksXG4gICAgICAgIGVsdF9fZGVmYXVsdFsnZGVmYXVsdCddKFwibGFiZWxcIiwgbnVsbCwgW2Nhc2VGaWVsZCwgcGhyYXNlKFwibWF0Y2ggY2FzZVwiKV0pLFxuICAgICAgICBlbHRfX2RlZmF1bHRbJ2RlZmF1bHQnXShcImxhYmVsXCIsIG51bGwsIFtyZUZpZWxkLCBwaHJhc2UoXCJyZWdleHBcIildKSxcbiAgICAgICAgZWx0X19kZWZhdWx0WydkZWZhdWx0J10oXCJiclwiKSxcbiAgICAgICAgcmVwbGFjZUZpZWxkLFxuICAgICAgICBidXR0b24oXCJyZXBsYWNlXCIsICgpID0+IHJlcGxhY2VOZXh0KGNvbmYudmlldyksIFtwaHJhc2UoXCJyZXBsYWNlXCIpXSksXG4gICAgICAgIGJ1dHRvbihcInJlcGxhY2VBbGxcIiwgKCkgPT4gcmVwbGFjZUFsbChjb25mLnZpZXcpLCBbcGhyYXNlKFwicmVwbGFjZSBhbGxcIildKSxcbiAgICAgICAgZWx0X19kZWZhdWx0WydkZWZhdWx0J10oXCJidXR0b25cIiwgeyBuYW1lOiBcImNsb3NlXCIsIG9uY2xpY2s6ICgpID0+IGNsb3NlU2VhcmNoUGFuZWwoY29uZi52aWV3KSwgXCJhcmlhLWxhYmVsXCI6IHBocmFzZShcImNsb3NlXCIpIH0sIFtcIsOXXCJdKVxuICAgIF0pO1xuICAgIHJldHVybiBwYW5lbDtcbn1cbmNvbnN0IEFubm91bmNlTWFyZ2luID0gMzA7XG5jb25zdCBCcmVhayA9IC9bXFxzXFwuLDo7PyFdLztcbmZ1bmN0aW9uIGFubm91bmNlTWF0Y2godmlldyQxLCB7IGZyb20sIHRvIH0pIHtcbiAgICBsZXQgbGluZVN0YXJ0ID0gdmlldyQxLnN0YXRlLmRvYy5saW5lQXQoZnJvbSkuZnJvbSwgbGluZUVuZCA9IHZpZXckMS5zdGF0ZS5kb2MubGluZUF0KHRvKS50bztcbiAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChsaW5lU3RhcnQsIGZyb20gLSBBbm5vdW5jZU1hcmdpbiksIGVuZCA9IE1hdGgubWluKGxpbmVFbmQsIHRvICsgQW5ub3VuY2VNYXJnaW4pO1xuICAgIGxldCB0ZXh0ID0gdmlldyQxLnN0YXRlLnNsaWNlRG9jKHN0YXJ0LCBlbmQpO1xuICAgIGlmIChzdGFydCAhPSBsaW5lU3RhcnQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBBbm5vdW5jZU1hcmdpbjsgaSsrKVxuICAgICAgICAgICAgaWYgKCFCcmVhay50ZXN0KHRleHRbaSArIDFdKSAmJiBCcmVhay50ZXN0KHRleHRbaV0pKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoaSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIGlmIChlbmQgIT0gbGluZUVuZCkge1xuICAgICAgICBmb3IgKGxldCBpID0gdGV4dC5sZW5ndGggLSAxOyBpID4gdGV4dC5sZW5ndGggLSBBbm5vdW5jZU1hcmdpbjsgaS0tKVxuICAgICAgICAgICAgaWYgKCFCcmVhay50ZXN0KHRleHRbaSAtIDFdKSAmJiBCcmVhay50ZXN0KHRleHRbaV0pKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2aWV3LkVkaXRvclZpZXcuYW5ub3VuY2Uub2YoYCR7dmlldyQxLnN0YXRlLnBocmFzZShcImN1cnJlbnQgbWF0Y2hcIil9LiAke3RleHR9ICR7dmlldyQxLnN0YXRlLnBocmFzZShcIm9uIGxpbmVcIil9ICR7dmlldyQxLnN0YXRlLmRvYy5saW5lQXQoZnJvbSkubnVtYmVyfWApO1xufVxuY29uc3QgYmFzZVRoZW1lID0gdmlldy5FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCIuY20tcGFuZWwuY20tc2VhcmNoXCI6IHtcbiAgICAgICAgcGFkZGluZzogXCIycHggNnB4IDRweFwiLFxuICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgICAgICBcIiYgW25hbWU9Y2xvc2VdXCI6IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgICB0b3A6IFwiMFwiLFxuICAgICAgICAgICAgcmlnaHQ6IFwiNHB4XCIsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiaW5oZXJpdFwiLFxuICAgICAgICAgICAgYm9yZGVyOiBcIm5vbmVcIixcbiAgICAgICAgICAgIGZvbnQ6IFwiaW5oZXJpdFwiLFxuICAgICAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgICAgIG1hcmdpbjogMFxuICAgICAgICB9LFxuICAgICAgICBcIiYgaW5wdXQsICYgYnV0dG9uLCAmIGxhYmVsXCI6IHtcbiAgICAgICAgICAgIG1hcmdpbjogXCIuMmVtIC42ZW0gLjJlbSAwXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCImIGlucHV0W3R5cGU9Y2hlY2tib3hdXCI6IHtcbiAgICAgICAgICAgIG1hcmdpblJpZ2h0OiBcIi4yZW1cIlxuICAgICAgICB9LFxuICAgICAgICBcIiYgbGFiZWxcIjoge1xuICAgICAgICAgICAgZm9udFNpemU6IFwiODAlXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXNlYXJjaE1hdGNoXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiNmZmZmMDA1NFwiIH0sXG4gICAgXCImZGFyayAuY20tc2VhcmNoTWF0Y2hcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiIzAwZmZmZjhhXCIgfSxcbiAgICBcIiZsaWdodCAuY20tc2VhcmNoTWF0Y2gtc2VsZWN0ZWRcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiI2ZmNmEwMDU0XCIgfSxcbiAgICBcIiZkYXJrIC5jbS1zZWFyY2hNYXRjaC1zZWxlY3RlZFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjZmYwMGZmOGFcIiB9XG59KTtcbmNvbnN0IHNlYXJjaEV4dGVuc2lvbnMgPSBbXG4gICAgc2VhcmNoU3RhdGUsXG4gICAgc3RhdGUuUHJlYy5vdmVycmlkZShzZWFyY2hIaWdobGlnaHRlciksXG4gICAgYmFzZVRoZW1lXG5dO1xuXG5leHBvcnRzLlJlZ0V4cEN1cnNvciA9IFJlZ0V4cEN1cnNvcjtcbmV4cG9ydHMuU2VhcmNoQ3Vyc29yID0gU2VhcmNoQ3Vyc29yO1xuZXhwb3J0cy5jbG9zZVNlYXJjaFBhbmVsID0gY2xvc2VTZWFyY2hQYW5lbDtcbmV4cG9ydHMuZmluZE5leHQgPSBmaW5kTmV4dDtcbmV4cG9ydHMuZmluZFByZXZpb3VzID0gZmluZFByZXZpb3VzO1xuZXhwb3J0cy5nb3RvTGluZSA9IGdvdG9MaW5lO1xuZXhwb3J0cy5oaWdobGlnaHRTZWxlY3Rpb25NYXRjaGVzID0gaGlnaGxpZ2h0U2VsZWN0aW9uTWF0Y2hlcztcbmV4cG9ydHMub3BlblNlYXJjaFBhbmVsID0gb3BlblNlYXJjaFBhbmVsO1xuZXhwb3J0cy5yZXBsYWNlQWxsID0gcmVwbGFjZUFsbDtcbmV4cG9ydHMucmVwbGFjZU5leHQgPSByZXBsYWNlTmV4dDtcbmV4cG9ydHMuc2VhcmNoS2V5bWFwID0gc2VhcmNoS2V5bWFwO1xuZXhwb3J0cy5zZWxlY3RNYXRjaGVzID0gc2VsZWN0TWF0Y2hlcztcbmV4cG9ydHMuc2VsZWN0U2VsZWN0aW9uTWF0Y2hlcyA9IHNlbGVjdFNlbGVjdGlvbk1hdGNoZXM7XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciB0ZXh0ID0gcmVxdWlyZSgnQGNvZGVtaXJyb3IvdGV4dCcpO1xuXG5jb25zdCBEZWZhdWx0U3BsaXQgPSAvXFxyXFxuP3xcXG4vO1xuLyoqXG5EaXN0aW5ndWlzaGVzIGRpZmZlcmVudCB3YXlzIGluIHdoaWNoIHBvc2l0aW9ucyBjYW4gYmUgbWFwcGVkLlxuKi9cbmV4cG9ydHMuTWFwTW9kZSA9IHZvaWQgMDtcbihmdW5jdGlvbiAoTWFwTW9kZSkge1xuICAgIC8qKlxuICAgIE1hcCBhIHBvc2l0aW9uIHRvIGEgdmFsaWQgbmV3IHBvc2l0aW9uLCBldmVuIHdoZW4gaXRzIGNvbnRleHRcbiAgICB3YXMgZGVsZXRlZC5cbiAgICAqL1xuICAgIE1hcE1vZGVbTWFwTW9kZVtcIlNpbXBsZVwiXSA9IDBdID0gXCJTaW1wbGVcIjtcbiAgICAvKipcbiAgICBSZXR1cm4gbnVsbCBpZiBkZWxldGlvbiBoYXBwZW5zIGFjcm9zcyB0aGUgcG9zaXRpb24uXG4gICAgKi9cbiAgICBNYXBNb2RlW01hcE1vZGVbXCJUcmFja0RlbFwiXSA9IDFdID0gXCJUcmFja0RlbFwiO1xuICAgIC8qKlxuICAgIFJldHVybiBudWxsIGlmIHRoZSBjaGFyYWN0ZXIgX2JlZm9yZV8gdGhlIHBvc2l0aW9uIGlzIGRlbGV0ZWQuXG4gICAgKi9cbiAgICBNYXBNb2RlW01hcE1vZGVbXCJUcmFja0JlZm9yZVwiXSA9IDJdID0gXCJUcmFja0JlZm9yZVwiO1xuICAgIC8qKlxuICAgIFJldHVybiBudWxsIGlmIHRoZSBjaGFyYWN0ZXIgX2FmdGVyXyB0aGUgcG9zaXRpb24gaXMgZGVsZXRlZC5cbiAgICAqL1xuICAgIE1hcE1vZGVbTWFwTW9kZVtcIlRyYWNrQWZ0ZXJcIl0gPSAzXSA9IFwiVHJhY2tBZnRlclwiO1xufSkoZXhwb3J0cy5NYXBNb2RlIHx8IChleHBvcnRzLk1hcE1vZGUgPSB7fSkpO1xuLyoqXG5BIGNoYW5nZSBkZXNjcmlwdGlvbiBpcyBhIHZhcmlhbnQgb2YgW2NoYW5nZSBzZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhbmdlU2V0KVxudGhhdCBkb2Vzbid0IHN0b3JlIHRoZSBpbnNlcnRlZCB0ZXh0LiBBcyBzdWNoLCBpdCBjYW4ndCBiZVxuYXBwbGllZCwgYnV0IGlzIGNoZWFwZXIgdG8gc3RvcmUgYW5kIG1hbmlwdWxhdGUuXG4qL1xuY2xhc3MgQ2hhbmdlRGVzYyB7XG4gICAgLy8gU2VjdGlvbnMgYXJlIGVuY29kZWQgYXMgcGFpcnMgb2YgaW50ZWdlcnMuIFRoZSBmaXJzdCBpcyB0aGVcbiAgICAvLyBsZW5ndGggaW4gdGhlIGN1cnJlbnQgZG9jdW1lbnQsIGFuZCB0aGUgc2Vjb25kIGlzIC0xIGZvclxuICAgIC8vIHVuYWZmZWN0ZWQgc2VjdGlvbnMsIGFuZCB0aGUgbGVuZ3RoIG9mIHRoZSByZXBsYWNlbWVudCBjb250ZW50XG4gICAgLy8gb3RoZXJ3aXNlLiBTbyBhbiBpbnNlcnRpb24gd291bGQgYmUgKDAsIG4+MCksIGEgZGVsZXRpb24gKG4+MCxcbiAgICAvLyAwKSwgYW5kIGEgcmVwbGFjZW1lbnQgdHdvIHBvc2l0aXZlIG51bWJlcnMuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNlY3Rpb25zKSB7XG4gICAgICAgIHRoaXMuc2VjdGlvbnMgPSBzZWN0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGxlbmd0aCBvZiB0aGUgZG9jdW1lbnQgYmVmb3JlIHRoZSBjaGFuZ2UuXG4gICAgKi9cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNlY3Rpb25zLmxlbmd0aDsgaSArPSAyKVxuICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuc2VjdGlvbnNbaV07XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBsZW5ndGggb2YgdGhlIGRvY3VtZW50IGFmdGVyIHRoZSBjaGFuZ2UuXG4gICAgKi9cbiAgICBnZXQgbmV3TGVuZ3RoKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNlY3Rpb25zLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBsZXQgaW5zID0gdGhpcy5zZWN0aW9uc1tpICsgMV07XG4gICAgICAgICAgICByZXN1bHQgKz0gaW5zIDwgMCA/IHRoaXMuc2VjdGlvbnNbaV0gOiBpbnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgRmFsc2Ugd2hlbiB0aGVyZSBhcmUgYWN0dWFsIGNoYW5nZXMgaW4gdGhpcyBzZXQuXG4gICAgKi9cbiAgICBnZXQgZW1wdHkoKSB7IHJldHVybiB0aGlzLnNlY3Rpb25zLmxlbmd0aCA9PSAwIHx8IHRoaXMuc2VjdGlvbnMubGVuZ3RoID09IDIgJiYgdGhpcy5zZWN0aW9uc1sxXSA8IDA7IH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIHVuY2hhbmdlZCBwYXJ0cyBsZWZ0IGJ5IHRoZXNlIGNoYW5nZXMuXG4gICAgKi9cbiAgICBpdGVyR2FwcyhmKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3NBID0gMCwgcG9zQiA9IDA7IGkgPCB0aGlzLnNlY3Rpb25zLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSB0aGlzLnNlY3Rpb25zW2krK10sIGlucyA9IHRoaXMuc2VjdGlvbnNbaSsrXTtcbiAgICAgICAgICAgIGlmIChpbnMgPCAwKSB7XG4gICAgICAgICAgICAgICAgZihwb3NBLCBwb3NCLCBsZW4pO1xuICAgICAgICAgICAgICAgIHBvc0IgKz0gbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9zQiArPSBpbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3NBICs9IGxlbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIHJhbmdlcyBjaGFuZ2VkIGJ5IHRoZXNlIGNoYW5nZXMuIChTZWVcbiAgICBbYENoYW5nZVNldC5pdGVyQ2hhbmdlc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhbmdlU2V0Lml0ZXJDaGFuZ2VzKSBmb3IgYVxuICAgIHZhcmlhbnQgdGhhdCBhbHNvIHByb3ZpZGVzIHlvdSB3aXRoIHRoZSBpbnNlcnRlZCB0ZXh0LilcbiAgICBcbiAgICBXaGVuIGBpbmRpdmlkdWFsYCBpcyB0cnVlLCBhZGphY2VudCBjaGFuZ2VzICh3aGljaCBhcmUga2VwdFxuICAgIHNlcGFyYXRlIGZvciBbcG9zaXRpb24gbWFwcGluZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFuZ2VEZXNjLm1hcFBvcykpIGFyZVxuICAgIHJlcG9ydGVkIHNlcGFyYXRlbHkuXG4gICAgKi9cbiAgICBpdGVyQ2hhbmdlZFJhbmdlcyhmLCBpbmRpdmlkdWFsID0gZmFsc2UpIHtcbiAgICAgICAgaXRlckNoYW5nZXModGhpcywgZiwgaW5kaXZpZHVhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCBhIGRlc2NyaXB0aW9uIG9mIHRoZSBpbnZlcnRlZCBmb3JtIG9mIHRoZXNlIGNoYW5nZXMuXG4gICAgKi9cbiAgICBnZXQgaW52ZXJ0ZWREZXNjKCkge1xuICAgICAgICBsZXQgc2VjdGlvbnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNlY3Rpb25zLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSB0aGlzLnNlY3Rpb25zW2krK10sIGlucyA9IHRoaXMuc2VjdGlvbnNbaSsrXTtcbiAgICAgICAgICAgIGlmIChpbnMgPCAwKVxuICAgICAgICAgICAgICAgIHNlY3Rpb25zLnB1c2gobGVuLCBpbnMpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goaW5zLCBsZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlRGVzYyhzZWN0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXB1dGUgdGhlIGNvbWJpbmVkIGVmZmVjdCBvZiBhcHBseWluZyBhbm90aGVyIHNldCBvZiBjaGFuZ2VzXG4gICAgYWZ0ZXIgdGhpcyBvbmUuIFRoZSBsZW5ndGggb2YgdGhlIGRvY3VtZW50IGFmdGVyIHRoaXMgc2V0IHNob3VsZFxuICAgIG1hdGNoIHRoZSBsZW5ndGggYmVmb3JlIGBvdGhlcmAuXG4gICAgKi9cbiAgICBjb21wb3NlRGVzYyhvdGhlcikgeyByZXR1cm4gdGhpcy5lbXB0eSA/IG90aGVyIDogb3RoZXIuZW1wdHkgPyB0aGlzIDogY29tcG9zZVNldHModGhpcywgb3RoZXIpOyB9XG4gICAgLyoqXG4gICAgTWFwIHRoaXMgZGVzY3JpcHRpb24sIHdoaWNoIHNob3VsZCBzdGFydCB3aXRoIHRoZSBzYW1lIGRvY3VtZW50XG4gICAgYXMgYG90aGVyYCwgb3ZlciBhbm90aGVyIHNldCBvZiBjaGFuZ2VzLCBzbyB0aGF0IGl0IGNhbiBiZVxuICAgIGFwcGxpZWQgYWZ0ZXIgaXQuIFdoZW4gYGJlZm9yZWAgaXMgdHJ1ZSwgbWFwIGFzIGlmIHRoZSBjaGFuZ2VzXG4gICAgaW4gYG90aGVyYCBoYXBwZW5lZCBiZWZvcmUgdGhlIG9uZXMgaW4gYHRoaXNgLlxuICAgICovXG4gICAgbWFwRGVzYyhvdGhlciwgYmVmb3JlID0gZmFsc2UpIHsgcmV0dXJuIG90aGVyLmVtcHR5ID8gdGhpcyA6IG1hcFNldCh0aGlzLCBvdGhlciwgYmVmb3JlKTsgfVxuICAgIG1hcFBvcyhwb3MsIGFzc29jID0gLTEsIG1vZGUgPSBleHBvcnRzLk1hcE1vZGUuU2ltcGxlKSB7XG4gICAgICAgIGxldCBwb3NBID0gMCwgcG9zQiA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gdGhpcy5zZWN0aW9uc1tpKytdLCBpbnMgPSB0aGlzLnNlY3Rpb25zW2krK10sIGVuZEEgPSBwb3NBICsgbGVuO1xuICAgICAgICAgICAgaWYgKGlucyA8IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoZW5kQSA+IHBvcylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvc0IgKyAocG9zIC0gcG9zQSk7XG4gICAgICAgICAgICAgICAgcG9zQiArPSBsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobW9kZSAhPSBleHBvcnRzLk1hcE1vZGUuU2ltcGxlICYmIGVuZEEgPj0gcG9zICYmXG4gICAgICAgICAgICAgICAgICAgIChtb2RlID09IGV4cG9ydHMuTWFwTW9kZS5UcmFja0RlbCAmJiBwb3NBIDwgcG9zICYmIGVuZEEgPiBwb3MgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPT0gZXhwb3J0cy5NYXBNb2RlLlRyYWNrQmVmb3JlICYmIHBvc0EgPCBwb3MgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPT0gZXhwb3J0cy5NYXBNb2RlLlRyYWNrQWZ0ZXIgJiYgZW5kQSA+IHBvcykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChlbmRBID4gcG9zIHx8IGVuZEEgPT0gcG9zICYmIGFzc29jIDwgMCAmJiAhbGVuKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9zID09IHBvc0EgfHwgYXNzb2MgPCAwID8gcG9zQiA6IHBvc0IgKyBpbnM7XG4gICAgICAgICAgICAgICAgcG9zQiArPSBpbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3NBID0gZW5kQTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zID4gcG9zQSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBQb3NpdGlvbiAke3Bvc30gaXMgb3V0IG9mIHJhbmdlIGZvciBjaGFuZ2VzZXQgb2YgbGVuZ3RoICR7cG9zQX1gKTtcbiAgICAgICAgcmV0dXJuIHBvc0I7XG4gICAgfVxuICAgIC8qKlxuICAgIENoZWNrIHdoZXRoZXIgdGhlc2UgY2hhbmdlcyB0b3VjaCBhIGdpdmVuIHJhbmdlLiBXaGVuIG9uZSBvZiB0aGVcbiAgICBjaGFuZ2VzIGVudGlyZWx5IGNvdmVycyB0aGUgcmFuZ2UsIHRoZSBzdHJpbmcgYFwiY292ZXJcImAgaXNcbiAgICByZXR1cm5lZC5cbiAgICAqL1xuICAgIHRvdWNoZXNSYW5nZShmcm9tLCB0byA9IGZyb20pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7IGkgPCB0aGlzLnNlY3Rpb25zLmxlbmd0aCAmJiBwb3MgPD0gdG87KSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gdGhpcy5zZWN0aW9uc1tpKytdLCBpbnMgPSB0aGlzLnNlY3Rpb25zW2krK10sIGVuZCA9IHBvcyArIGxlbjtcbiAgICAgICAgICAgIGlmIChpbnMgPj0gMCAmJiBwb3MgPD0gdG8gJiYgZW5kID49IGZyb20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcyA8IGZyb20gJiYgZW5kID4gdG8gPyBcImNvdmVyXCIgOiB0cnVlO1xuICAgICAgICAgICAgcG9zID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gdGhpcy5zZWN0aW9uc1tpKytdLCBpbnMgPSB0aGlzLnNlY3Rpb25zW2krK107XG4gICAgICAgICAgICByZXN1bHQgKz0gKHJlc3VsdCA/IFwiIFwiIDogXCJcIikgKyBsZW4gKyAoaW5zID49IDAgPyBcIjpcIiArIGlucyA6IFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFNlcmlhbGl6ZSB0aGlzIGNoYW5nZSBkZXNjIHRvIGEgSlNPTi1yZXByZXNlbnRhYmxlIHZhbHVlLlxuICAgICovXG4gICAgdG9KU09OKCkgeyByZXR1cm4gdGhpcy5zZWN0aW9uczsgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGNoYW5nZSBkZXNjIGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24gKGFzIHByb2R1Y2VkXG4gICAgYnkgW2B0b0pTT05gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNoYW5nZURlc2MudG9KU09OKS5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShqc29uKSB8fCBqc29uLmxlbmd0aCAlIDIgfHwganNvbi5zb21lKGEgPT4gdHlwZW9mIGEgIT0gXCJudW1iZXJcIikpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBDaGFuZ2VEZXNjXCIpO1xuICAgICAgICByZXR1cm4gbmV3IENoYW5nZURlc2MoanNvbik7XG4gICAgfVxufVxuLyoqXG5BIGNoYW5nZSBzZXQgcmVwcmVzZW50cyBhIGdyb3VwIG9mIG1vZGlmaWNhdGlvbnMgdG8gYSBkb2N1bWVudC4gSXRcbnN0b3JlcyB0aGUgZG9jdW1lbnQgbGVuZ3RoLCBhbmQgY2FuIG9ubHkgYmUgYXBwbGllZCB0byBkb2N1bWVudHNcbndpdGggZXhhY3RseSB0aGF0IGxlbmd0aC5cbiovXG5jbGFzcyBDaGFuZ2VTZXQgZXh0ZW5kcyBDaGFuZ2VEZXNjIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNlY3Rpb25zLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGluc2VydGVkKSB7XG4gICAgICAgIHN1cGVyKHNlY3Rpb25zKTtcbiAgICAgICAgdGhpcy5pbnNlcnRlZCA9IGluc2VydGVkO1xuICAgIH1cbiAgICAvKipcbiAgICBBcHBseSB0aGUgY2hhbmdlcyB0byBhIGRvY3VtZW50LCByZXR1cm5pbmcgdGhlIG1vZGlmaWVkXG4gICAgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoICE9IGRvYy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkFwcGx5aW5nIGNoYW5nZSBzZXQgdG8gYSBkb2N1bWVudCB3aXRoIHRoZSB3cm9uZyBsZW5ndGhcIik7XG4gICAgICAgIGl0ZXJDaGFuZ2VzKHRoaXMsIChmcm9tQSwgdG9BLCBmcm9tQiwgX3RvQiwgdGV4dCkgPT4gZG9jID0gZG9jLnJlcGxhY2UoZnJvbUIsIGZyb21CICsgKHRvQSAtIGZyb21BKSwgdGV4dCksIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIGRvYztcbiAgICB9XG4gICAgbWFwRGVzYyhvdGhlciwgYmVmb3JlID0gZmFsc2UpIHsgcmV0dXJuIG1hcFNldCh0aGlzLCBvdGhlciwgYmVmb3JlLCB0cnVlKTsgfVxuICAgIC8qKlxuICAgIEdpdmVuIHRoZSBkb2N1bWVudCBhcyBpdCBleGlzdGVkIF9iZWZvcmVfIHRoZSBjaGFuZ2VzLCByZXR1cm4gYVxuICAgIGNoYW5nZSBzZXQgdGhhdCByZXByZXNlbnRzIHRoZSBpbnZlcnNlIG9mIHRoaXMgc2V0LCB3aGljaCBjb3VsZFxuICAgIGJlIHVzZWQgdG8gZ28gZnJvbSB0aGUgZG9jdW1lbnQgY3JlYXRlZCBieSB0aGUgY2hhbmdlcyBiYWNrIHRvXG4gICAgdGhlIGRvY3VtZW50IGFzIGl0IGV4aXN0ZWQgYmVmb3JlIHRoZSBjaGFuZ2VzLlxuICAgICovXG4gICAgaW52ZXJ0KGRvYykge1xuICAgICAgICBsZXQgc2VjdGlvbnMgPSB0aGlzLnNlY3Rpb25zLnNsaWNlKCksIGluc2VydGVkID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOyBpIDwgc2VjdGlvbnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSBzZWN0aW9uc1tpXSwgaW5zID0gc2VjdGlvbnNbaSArIDFdO1xuICAgICAgICAgICAgaWYgKGlucyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgc2VjdGlvbnNbaV0gPSBpbnM7XG4gICAgICAgICAgICAgICAgc2VjdGlvbnNbaSArIDFdID0gbGVuO1xuICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IGkgPj4gMTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaW5zZXJ0ZWQubGVuZ3RoIDwgaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIGluc2VydGVkLnB1c2godGV4dC5UZXh0LmVtcHR5KTtcbiAgICAgICAgICAgICAgICBpbnNlcnRlZC5wdXNoKGxlbiA/IGRvYy5zbGljZShwb3MsIHBvcyArIGxlbikgOiB0ZXh0LlRleHQuZW1wdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zICs9IGxlbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENoYW5nZVNldChzZWN0aW9ucywgaW5zZXJ0ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21iaW5lIHR3byBzdWJzZXF1ZW50IGNoYW5nZSBzZXRzIGludG8gYSBzaW5nbGUgc2V0LiBgb3RoZXJgXG4gICAgbXVzdCBzdGFydCBpbiB0aGUgZG9jdW1lbnQgcHJvZHVjZWQgYnkgYHRoaXNgLiBJZiBgdGhpc2AgZ29lc1xuICAgIGBkb2NBYCDihpIgYGRvY0JgIGFuZCBgb3RoZXJgIHJlcHJlc2VudHMgYGRvY0JgIOKGkiBgZG9jQ2AsIHRoZVxuICAgIHJldHVybmVkIHZhbHVlIHdpbGwgcmVwcmVzZW50IHRoZSBjaGFuZ2UgYGRvY0FgIOKGkiBgZG9jQ2AuXG4gICAgKi9cbiAgICBjb21wb3NlKG90aGVyKSB7IHJldHVybiB0aGlzLmVtcHR5ID8gb3RoZXIgOiBvdGhlci5lbXB0eSA/IHRoaXMgOiBjb21wb3NlU2V0cyh0aGlzLCBvdGhlciwgdHJ1ZSk7IH1cbiAgICAvKipcbiAgICBHaXZlbiBhbm90aGVyIGNoYW5nZSBzZXQgc3RhcnRpbmcgaW4gdGhlIHNhbWUgZG9jdW1lbnQsIG1hcHMgdGhpc1xuICAgIGNoYW5nZSBzZXQgb3ZlciB0aGUgb3RoZXIsIHByb2R1Y2luZyBhIG5ldyBjaGFuZ2Ugc2V0IHRoYXQgY2FuIGJlXG4gICAgYXBwbGllZCB0byB0aGUgZG9jdW1lbnQgcHJvZHVjZWQgYnkgYXBwbHlpbmcgYG90aGVyYC4gV2hlblxuICAgIGBiZWZvcmVgIGlzIGB0cnVlYCwgb3JkZXIgY2hhbmdlcyBhcyBpZiBgdGhpc2AgY29tZXMgYmVmb3JlXG4gICAgYG90aGVyYCwgb3RoZXJ3aXNlICh0aGUgZGVmYXVsdCkgdHJlYXQgYG90aGVyYCBhcyBjb21pbmcgZmlyc3QuXG4gICAgXG4gICAgR2l2ZW4gdHdvIGNoYW5nZXMgYEFgIGFuZCBgQmAsIGBBLmNvbXBvc2UoQi5tYXAoQSkpYCBhbmRcbiAgICBgQi5jb21wb3NlKEEubWFwKEIsIHRydWUpKWAgd2lsbCBwcm9kdWNlIHRoZSBzYW1lIGRvY3VtZW50LiBUaGlzXG4gICAgcHJvdmlkZXMgYSBiYXNpYyBmb3JtIG9mIFtvcGVyYXRpb25hbFxuICAgIHRyYW5zZm9ybWF0aW9uXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9PcGVyYXRpb25hbF90cmFuc2Zvcm1hdGlvbiksXG4gICAgYW5kIGNhbiBiZSB1c2VkIGZvciBjb2xsYWJvcmF0aXZlIGVkaXRpbmcuXG4gICAgKi9cbiAgICBtYXAob3RoZXIsIGJlZm9yZSA9IGZhbHNlKSB7IHJldHVybiBvdGhlci5lbXB0eSA/IHRoaXMgOiBtYXBTZXQodGhpcywgb3RoZXIsIGJlZm9yZSwgdHJ1ZSk7IH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIGNoYW5nZWQgcmFuZ2VzIGluIHRoZSBkb2N1bWVudCwgY2FsbGluZyBgZmAgZm9yXG4gICAgZWFjaC5cbiAgICBcbiAgICBXaGVuIGBpbmRpdmlkdWFsYCBpcyB0cnVlLCBhZGphY2VudCBjaGFuZ2VzIGFyZSByZXBvcnRlZFxuICAgIHNlcGFyYXRlbHkuXG4gICAgKi9cbiAgICBpdGVyQ2hhbmdlcyhmLCBpbmRpdmlkdWFsID0gZmFsc2UpIHtcbiAgICAgICAgaXRlckNoYW5nZXModGhpcywgZiwgaW5kaXZpZHVhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCBhIFtjaGFuZ2UgZGVzY3JpcHRpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhbmdlRGVzYykgZm9yIHRoaXMgY2hhbmdlXG4gICAgc2V0LlxuICAgICovXG4gICAgZ2V0IGRlc2MoKSB7IHJldHVybiBuZXcgQ2hhbmdlRGVzYyh0aGlzLnNlY3Rpb25zKTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZmlsdGVyKHJhbmdlcykge1xuICAgICAgICBsZXQgcmVzdWx0U2VjdGlvbnMgPSBbXSwgcmVzdWx0SW5zZXJ0ZWQgPSBbXSwgZmlsdGVyZWRTZWN0aW9ucyA9IFtdO1xuICAgICAgICBsZXQgaXRlciA9IG5ldyBTZWN0aW9uSXRlcih0aGlzKTtcbiAgICAgICAgZG9uZTogZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7Oykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBpID09IHJhbmdlcy5sZW5ndGggPyAxZTkgOiByYW5nZXNbaSsrXTtcbiAgICAgICAgICAgIHdoaWxlIChwb3MgPCBuZXh0IHx8IHBvcyA9PSBuZXh0ICYmIGl0ZXIubGVuID09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlci5kb25lKVxuICAgICAgICAgICAgICAgICAgICBicmVhayBkb25lO1xuICAgICAgICAgICAgICAgIGxldCBsZW4gPSBNYXRoLm1pbihpdGVyLmxlbiwgbmV4dCAtIHBvcyk7XG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihmaWx0ZXJlZFNlY3Rpb25zLCBsZW4sIC0xKTtcbiAgICAgICAgICAgICAgICBsZXQgaW5zID0gaXRlci5pbnMgPT0gLTEgPyAtMSA6IGl0ZXIub2ZmID09IDAgPyBpdGVyLmlucyA6IDA7XG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihyZXN1bHRTZWN0aW9ucywgbGVuLCBpbnMpO1xuICAgICAgICAgICAgICAgIGlmIChpbnMgPiAwKVxuICAgICAgICAgICAgICAgICAgICBhZGRJbnNlcnQocmVzdWx0SW5zZXJ0ZWQsIHJlc3VsdFNlY3Rpb25zLCBpdGVyLnRleHQpO1xuICAgICAgICAgICAgICAgIGl0ZXIuZm9yd2FyZChsZW4pO1xuICAgICAgICAgICAgICAgIHBvcyArPSBsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZW5kID0gcmFuZ2VzW2krK107XG4gICAgICAgICAgICB3aGlsZSAocG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZXIuZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgZG9uZTtcbiAgICAgICAgICAgICAgICBsZXQgbGVuID0gTWF0aC5taW4oaXRlci5sZW4sIGVuZCAtIHBvcyk7XG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihyZXN1bHRTZWN0aW9ucywgbGVuLCAtMSk7XG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihmaWx0ZXJlZFNlY3Rpb25zLCBsZW4sIGl0ZXIuaW5zID09IC0xID8gLTEgOiBpdGVyLm9mZiA9PSAwID8gaXRlci5pbnMgOiAwKTtcbiAgICAgICAgICAgICAgICBpdGVyLmZvcndhcmQobGVuKTtcbiAgICAgICAgICAgICAgICBwb3MgKz0gbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGNoYW5nZXM6IG5ldyBDaGFuZ2VTZXQocmVzdWx0U2VjdGlvbnMsIHJlc3VsdEluc2VydGVkKSxcbiAgICAgICAgICAgIGZpbHRlcmVkOiBuZXcgQ2hhbmdlRGVzYyhmaWx0ZXJlZFNlY3Rpb25zKSB9O1xuICAgIH1cbiAgICAvKipcbiAgICBTZXJpYWxpemUgdGhpcyBjaGFuZ2Ugc2V0IHRvIGEgSlNPTi1yZXByZXNlbnRhYmxlIHZhbHVlLlxuICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQgcGFydHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNlY3Rpb25zLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gdGhpcy5zZWN0aW9uc1tpXSwgaW5zID0gdGhpcy5zZWN0aW9uc1tpICsgMV07XG4gICAgICAgICAgICBpZiAoaW5zIDwgMClcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKGxlbik7XG4gICAgICAgICAgICBlbHNlIGlmIChpbnMgPT0gMClcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKFtsZW5dKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKFtsZW5dLmNvbmNhdCh0aGlzLmluc2VydGVkW2kgPj4gMV0udG9KU09OKCkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFydHM7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGNoYW5nZSBzZXQgZm9yIHRoZSBnaXZlbiBjaGFuZ2VzLCBmb3IgYSBkb2N1bWVudCBvZiB0aGVcbiAgICBnaXZlbiBsZW5ndGgsIHVzaW5nIGBsaW5lU2VwYCBhcyBsaW5lIHNlcGFyYXRvci5cbiAgICAqL1xuICAgIHN0YXRpYyBvZihjaGFuZ2VzLCBsZW5ndGgsIGxpbmVTZXApIHtcbiAgICAgICAgbGV0IHNlY3Rpb25zID0gW10sIGluc2VydGVkID0gW10sIHBvcyA9IDA7XG4gICAgICAgIGxldCB0b3RhbCA9IG51bGw7XG4gICAgICAgIGZ1bmN0aW9uIGZsdXNoKGZvcmNlID0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmICghZm9yY2UgJiYgIXNlY3Rpb25zLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAocG9zIDwgbGVuZ3RoKVxuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGxlbmd0aCAtIHBvcywgLTEpO1xuICAgICAgICAgICAgbGV0IHNldCA9IG5ldyBDaGFuZ2VTZXQoc2VjdGlvbnMsIGluc2VydGVkKTtcbiAgICAgICAgICAgIHRvdGFsID0gdG90YWwgPyB0b3RhbC5jb21wb3NlKHNldC5tYXAodG90YWwpKSA6IHNldDtcbiAgICAgICAgICAgIHNlY3Rpb25zID0gW107XG4gICAgICAgICAgICBpbnNlcnRlZCA9IFtdO1xuICAgICAgICAgICAgcG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBwcm9jZXNzKHNwZWMpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNwZWMpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgc3ViIG9mIHNwZWMpXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3Moc3ViKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNwZWMgaW5zdGFuY2VvZiBDaGFuZ2VTZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3BlYy5sZW5ndGggIT0gbGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgTWlzbWF0Y2hlZCBjaGFuZ2Ugc2V0IGxlbmd0aCAoZ290ICR7c3BlYy5sZW5ndGh9LCBleHBlY3RlZCAke2xlbmd0aH0pYCk7XG4gICAgICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgICAgICAgICB0b3RhbCA9IHRvdGFsID8gdG90YWwuY29tcG9zZShzcGVjLm1hcCh0b3RhbCkpIDogc3BlYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCB7IGZyb20sIHRvID0gZnJvbSwgaW5zZXJ0IH0gPSBzcGVjO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tID4gdG8gfHwgZnJvbSA8IDAgfHwgdG8gPiBsZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIGNoYW5nZSByYW5nZSAke2Zyb219IHRvICR7dG99IChpbiBkb2Mgb2YgbGVuZ3RoICR7bGVuZ3RofSlgKTtcbiAgICAgICAgICAgICAgICBsZXQgaW5zVGV4dCA9ICFpbnNlcnQgPyB0ZXh0LlRleHQuZW1wdHkgOiB0eXBlb2YgaW5zZXJ0ID09IFwic3RyaW5nXCIgPyB0ZXh0LlRleHQub2YoaW5zZXJ0LnNwbGl0KGxpbmVTZXAgfHwgRGVmYXVsdFNwbGl0KSkgOiBpbnNlcnQ7XG4gICAgICAgICAgICAgICAgbGV0IGluc0xlbiA9IGluc1RleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tID09IHRvICYmIGluc0xlbiA9PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPCBwb3MpXG4gICAgICAgICAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPiBwb3MpXG4gICAgICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGZyb20gLSBwb3MsIC0xKTtcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCB0byAtIGZyb20sIGluc0xlbik7XG4gICAgICAgICAgICAgICAgYWRkSW5zZXJ0KGluc2VydGVkLCBzZWN0aW9ucywgaW5zVGV4dCk7XG4gICAgICAgICAgICAgICAgcG9zID0gdG87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2VzcyhjaGFuZ2VzKTtcbiAgICAgICAgZmx1c2goIXRvdGFsKTtcbiAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gZW1wdHkgY2hhbmdlc2V0IG9mIHRoZSBnaXZlbiBsZW5ndGguXG4gICAgKi9cbiAgICBzdGF0aWMgZW1wdHkobGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlU2V0KGxlbmd0aCA/IFtsZW5ndGgsIC0xXSA6IFtdLCBbXSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGNoYW5nZXNldCBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uIChhcyBwcm9kdWNlZCBieVxuICAgIFtgdG9KU09OYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFuZ2VTZXQudG9KU09OKS5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShqc29uKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBKU09OIHJlcHJlc2VudGF0aW9uIG9mIENoYW5nZVNldFwiKTtcbiAgICAgICAgbGV0IHNlY3Rpb25zID0gW10sIGluc2VydGVkID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwganNvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHBhcnQgPSBqc29uW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJ0ID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHBhcnQsIC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KHBhcnQpIHx8IHR5cGVvZiBwYXJ0WzBdICE9IFwibnVtYmVyXCIgfHwgcGFydC5zb21lKChlLCBpKSA9PiBpICYmIHR5cGVvZiBlICE9IFwic3RyaW5nXCIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gcmVwcmVzZW50YXRpb24gb2YgQ2hhbmdlU2V0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFydC5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgIHNlY3Rpb25zLnB1c2gocGFydFswXSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaW5zZXJ0ZWQubGVuZ3RoIDwgaSlcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0ZWQucHVzaCh0ZXh0LlRleHQuZW1wdHkpO1xuICAgICAgICAgICAgICAgIGluc2VydGVkW2ldID0gdGV4dC5UZXh0Lm9mKHBhcnQuc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgIHNlY3Rpb25zLnB1c2gocGFydFswXSwgaW5zZXJ0ZWRbaV0ubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENoYW5nZVNldChzZWN0aW9ucywgaW5zZXJ0ZWQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGxlbiwgaW5zLCBmb3JjZUpvaW4gPSBmYWxzZSkge1xuICAgIGlmIChsZW4gPT0gMCAmJiBpbnMgPD0gMClcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBsYXN0ID0gc2VjdGlvbnMubGVuZ3RoIC0gMjtcbiAgICBpZiAobGFzdCA+PSAwICYmIGlucyA8PSAwICYmIGlucyA9PSBzZWN0aW9uc1tsYXN0ICsgMV0pXG4gICAgICAgIHNlY3Rpb25zW2xhc3RdICs9IGxlbjtcbiAgICBlbHNlIGlmIChsZW4gPT0gMCAmJiBzZWN0aW9uc1tsYXN0XSA9PSAwKVxuICAgICAgICBzZWN0aW9uc1tsYXN0ICsgMV0gKz0gaW5zO1xuICAgIGVsc2UgaWYgKGZvcmNlSm9pbikge1xuICAgICAgICBzZWN0aW9uc1tsYXN0XSArPSBsZW47XG4gICAgICAgIHNlY3Rpb25zW2xhc3QgKyAxXSArPSBpbnM7XG4gICAgfVxuICAgIGVsc2VcbiAgICAgICAgc2VjdGlvbnMucHVzaChsZW4sIGlucyk7XG59XG5mdW5jdGlvbiBhZGRJbnNlcnQodmFsdWVzLCBzZWN0aW9ucywgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUubGVuZ3RoID09IDApXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgaW5kZXggPSAoc2VjdGlvbnMubGVuZ3RoIC0gMikgPj4gMTtcbiAgICBpZiAoaW5kZXggPCB2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gMV0gPSB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdLmFwcGVuZCh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB3aGlsZSAodmFsdWVzLmxlbmd0aCA8IGluZGV4KVxuICAgICAgICAgICAgdmFsdWVzLnB1c2godGV4dC5UZXh0LmVtcHR5KTtcbiAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGl0ZXJDaGFuZ2VzKGRlc2MsIGYsIGluZGl2aWR1YWwpIHtcbiAgICBsZXQgaW5zZXJ0ZWQgPSBkZXNjLmluc2VydGVkO1xuICAgIGZvciAobGV0IHBvc0EgPSAwLCBwb3NCID0gMCwgaSA9IDA7IGkgPCBkZXNjLnNlY3Rpb25zLmxlbmd0aDspIHtcbiAgICAgICAgbGV0IGxlbiA9IGRlc2Muc2VjdGlvbnNbaSsrXSwgaW5zID0gZGVzYy5zZWN0aW9uc1tpKytdO1xuICAgICAgICBpZiAoaW5zIDwgMCkge1xuICAgICAgICAgICAgcG9zQSArPSBsZW47XG4gICAgICAgICAgICBwb3NCICs9IGxlbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBlbmRBID0gcG9zQSwgZW5kQiA9IHBvc0IsIHRleHQkMSA9IHRleHQuVGV4dC5lbXB0eTtcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBlbmRBICs9IGxlbjtcbiAgICAgICAgICAgICAgICBlbmRCICs9IGlucztcbiAgICAgICAgICAgICAgICBpZiAoaW5zICYmIGluc2VydGVkKVxuICAgICAgICAgICAgICAgICAgICB0ZXh0JDEgPSB0ZXh0JDEuYXBwZW5kKGluc2VydGVkWyhpIC0gMikgPj4gMV0pO1xuICAgICAgICAgICAgICAgIGlmIChpbmRpdmlkdWFsIHx8IGkgPT0gZGVzYy5zZWN0aW9ucy5sZW5ndGggfHwgZGVzYy5zZWN0aW9uc1tpICsgMV0gPCAwKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBsZW4gPSBkZXNjLnNlY3Rpb25zW2krK107XG4gICAgICAgICAgICAgICAgaW5zID0gZGVzYy5zZWN0aW9uc1tpKytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZihwb3NBLCBlbmRBLCBwb3NCLCBlbmRCLCB0ZXh0JDEpO1xuICAgICAgICAgICAgcG9zQSA9IGVuZEE7XG4gICAgICAgICAgICBwb3NCID0gZW5kQjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIG1hcFNldChzZXRBLCBzZXRCLCBiZWZvcmUsIG1rU2V0ID0gZmFsc2UpIHtcbiAgICBsZXQgc2VjdGlvbnMgPSBbXSwgaW5zZXJ0ID0gbWtTZXQgPyBbXSA6IG51bGw7XG4gICAgbGV0IGEgPSBuZXcgU2VjdGlvbkl0ZXIoc2V0QSksIGIgPSBuZXcgU2VjdGlvbkl0ZXIoc2V0Qik7XG4gICAgZm9yIChsZXQgcG9zQSA9IDAsIHBvc0IgPSAwOzspIHtcbiAgICAgICAgaWYgKGEuaW5zID09IC0xKSB7XG4gICAgICAgICAgICBwb3NBICs9IGEubGVuO1xuICAgICAgICAgICAgYS5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYi5pbnMgPT0gLTEgJiYgcG9zQiA8IHBvc0EpIHtcbiAgICAgICAgICAgIGxldCBza2lwID0gTWF0aC5taW4oYi5sZW4sIHBvc0EgLSBwb3NCKTtcbiAgICAgICAgICAgIGIuZm9yd2FyZChza2lwKTtcbiAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIHNraXAsIC0xKTtcbiAgICAgICAgICAgIHBvc0IgKz0gc2tpcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiLmlucyA+PSAwICYmIChhLmRvbmUgfHwgcG9zQiA8IHBvc0EgfHwgcG9zQiA9PSBwb3NBICYmIChiLmxlbiA8IGEubGVuIHx8IGIubGVuID09IGEubGVuICYmICFiZWZvcmUpKSkge1xuICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgYi5pbnMsIC0xKTtcbiAgICAgICAgICAgIHdoaWxlIChwb3NBID4gcG9zQiAmJiAhYS5kb25lICYmIHBvc0EgKyBhLmxlbiA8IHBvc0IgKyBiLmxlbikge1xuICAgICAgICAgICAgICAgIHBvc0EgKz0gYS5sZW47XG4gICAgICAgICAgICAgICAgYS5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3NCICs9IGIubGVuO1xuICAgICAgICAgICAgYi5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYS5pbnMgPj0gMCkge1xuICAgICAgICAgICAgbGV0IGxlbiA9IDAsIGVuZCA9IHBvc0EgKyBhLmxlbjtcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBpZiAoYi5pbnMgPj0gMCAmJiBwb3NCID4gcG9zQSAmJiBwb3NCICsgYi5sZW4gPCBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVuICs9IGIuaW5zO1xuICAgICAgICAgICAgICAgICAgICBwb3NCICs9IGIubGVuO1xuICAgICAgICAgICAgICAgICAgICBiLm5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYi5pbnMgPT0gLTEgJiYgcG9zQiA8IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2tpcCA9IE1hdGgubWluKGIubGVuLCBlbmQgLSBwb3NCKTtcbiAgICAgICAgICAgICAgICAgICAgbGVuICs9IHNraXA7XG4gICAgICAgICAgICAgICAgICAgIGIuZm9yd2FyZChza2lwKTtcbiAgICAgICAgICAgICAgICAgICAgcG9zQiArPSBza2lwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgbGVuLCBhLmlucyk7XG4gICAgICAgICAgICBpZiAoaW5zZXJ0KVxuICAgICAgICAgICAgICAgIGFkZEluc2VydChpbnNlcnQsIHNlY3Rpb25zLCBhLnRleHQpO1xuICAgICAgICAgICAgcG9zQSA9IGVuZDtcbiAgICAgICAgICAgIGEubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGEuZG9uZSAmJiBiLmRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnNlcnQgPyBuZXcgQ2hhbmdlU2V0KHNlY3Rpb25zLCBpbnNlcnQpIDogbmV3IENoYW5nZURlc2Moc2VjdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzbWF0Y2hlZCBjaGFuZ2Ugc2V0IGxlbmd0aHNcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjb21wb3NlU2V0cyhzZXRBLCBzZXRCLCBta1NldCA9IGZhbHNlKSB7XG4gICAgbGV0IHNlY3Rpb25zID0gW107XG4gICAgbGV0IGluc2VydCA9IG1rU2V0ID8gW10gOiBudWxsO1xuICAgIGxldCBhID0gbmV3IFNlY3Rpb25JdGVyKHNldEEpLCBiID0gbmV3IFNlY3Rpb25JdGVyKHNldEIpO1xuICAgIGZvciAobGV0IG9wZW4gPSBmYWxzZTs7KSB7XG4gICAgICAgIGlmIChhLmRvbmUgJiYgYi5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zZXJ0ID8gbmV3IENoYW5nZVNldChzZWN0aW9ucywgaW5zZXJ0KSA6IG5ldyBDaGFuZ2VEZXNjKHNlY3Rpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhLmlucyA9PSAwKSB7IC8vIERlbGV0aW9uIGluIEFcbiAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGEubGVuLCAwLCBvcGVuKTtcbiAgICAgICAgICAgIGEubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGIubGVuID09IDAgJiYgIWIuZG9uZSkgeyAvLyBJbnNlcnRpb24gaW4gQlxuICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgMCwgYi5pbnMsIG9wZW4pO1xuICAgICAgICAgICAgaWYgKGluc2VydClcbiAgICAgICAgICAgICAgICBhZGRJbnNlcnQoaW5zZXJ0LCBzZWN0aW9ucywgYi50ZXh0KTtcbiAgICAgICAgICAgIGIubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGEuZG9uZSB8fCBiLmRvbmUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc21hdGNoZWQgY2hhbmdlIHNldCBsZW5ndGhzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGxlbiA9IE1hdGgubWluKGEubGVuMiwgYi5sZW4pLCBzZWN0aW9uTGVuID0gc2VjdGlvbnMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGEuaW5zID09IC0xKSB7XG4gICAgICAgICAgICAgICAgbGV0IGluc0IgPSBiLmlucyA9PSAtMSA/IC0xIDogYi5vZmYgPyAwIDogYi5pbnM7XG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgbGVuLCBpbnNCLCBvcGVuKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0ICYmIGluc0IpXG4gICAgICAgICAgICAgICAgICAgIGFkZEluc2VydChpbnNlcnQsIHNlY3Rpb25zLCBiLnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYi5pbnMgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBhLm9mZiA/IDAgOiBhLmxlbiwgbGVuLCBvcGVuKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0KVxuICAgICAgICAgICAgICAgICAgICBhZGRJbnNlcnQoaW5zZXJ0LCBzZWN0aW9ucywgYS50ZXh0Qml0KGxlbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgYS5vZmYgPyAwIDogYS5sZW4sIGIub2ZmID8gMCA6IGIuaW5zLCBvcGVuKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0ICYmICFiLm9mZilcbiAgICAgICAgICAgICAgICAgICAgYWRkSW5zZXJ0KGluc2VydCwgc2VjdGlvbnMsIGIudGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcGVuID0gKGEuaW5zID4gbGVuIHx8IGIuaW5zID49IDAgJiYgYi5sZW4gPiBsZW4pICYmIChvcGVuIHx8IHNlY3Rpb25zLmxlbmd0aCA+IHNlY3Rpb25MZW4pO1xuICAgICAgICAgICAgYS5mb3J3YXJkMihsZW4pO1xuICAgICAgICAgICAgYi5mb3J3YXJkKGxlbik7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBTZWN0aW9uSXRlciB7XG4gICAgY29uc3RydWN0b3Ioc2V0KSB7XG4gICAgICAgIHRoaXMuc2V0ID0gc2V0O1xuICAgICAgICB0aGlzLmkgPSAwO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgbGV0IHsgc2VjdGlvbnMgfSA9IHRoaXMuc2V0O1xuICAgICAgICBpZiAodGhpcy5pIDwgc2VjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmxlbiA9IHNlY3Rpb25zW3RoaXMuaSsrXTtcbiAgICAgICAgICAgIHRoaXMuaW5zID0gc2VjdGlvbnNbdGhpcy5pKytdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sZW4gPSAwO1xuICAgICAgICAgICAgdGhpcy5pbnMgPSAtMjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9mZiA9IDA7XG4gICAgfVxuICAgIGdldCBkb25lKCkgeyByZXR1cm4gdGhpcy5pbnMgPT0gLTI7IH1cbiAgICBnZXQgbGVuMigpIHsgcmV0dXJuIHRoaXMuaW5zIDwgMCA/IHRoaXMubGVuIDogdGhpcy5pbnM7IH1cbiAgICBnZXQgdGV4dCgpIHtcbiAgICAgICAgbGV0IHsgaW5zZXJ0ZWQgfSA9IHRoaXMuc2V0LCBpbmRleCA9ICh0aGlzLmkgLSAyKSA+PiAxO1xuICAgICAgICByZXR1cm4gaW5kZXggPj0gaW5zZXJ0ZWQubGVuZ3RoID8gdGV4dC5UZXh0LmVtcHR5IDogaW5zZXJ0ZWRbaW5kZXhdO1xuICAgIH1cbiAgICB0ZXh0Qml0KGxlbikge1xuICAgICAgICBsZXQgeyBpbnNlcnRlZCB9ID0gdGhpcy5zZXQsIGluZGV4ID0gKHRoaXMuaSAtIDIpID4+IDE7XG4gICAgICAgIHJldHVybiBpbmRleCA+PSBpbnNlcnRlZC5sZW5ndGggJiYgIWxlbiA/IHRleHQuVGV4dC5lbXB0eVxuICAgICAgICAgICAgOiBpbnNlcnRlZFtpbmRleF0uc2xpY2UodGhpcy5vZmYsIGxlbiA9PSBudWxsID8gdW5kZWZpbmVkIDogdGhpcy5vZmYgKyBsZW4pO1xuICAgIH1cbiAgICBmb3J3YXJkKGxlbikge1xuICAgICAgICBpZiAobGVuID09IHRoaXMubGVuKVxuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sZW4gLT0gbGVuO1xuICAgICAgICAgICAgdGhpcy5vZmYgKz0gbGVuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvcndhcmQyKGxlbikge1xuICAgICAgICBpZiAodGhpcy5pbnMgPT0gLTEpXG4gICAgICAgICAgICB0aGlzLmZvcndhcmQobGVuKTtcbiAgICAgICAgZWxzZSBpZiAobGVuID09IHRoaXMuaW5zKVxuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbnMgLT0gbGVuO1xuICAgICAgICAgICAgdGhpcy5vZmYgKz0gbGVuO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbkEgc2luZ2xlIHNlbGVjdGlvbiByYW5nZS4gV2hlblxuW2BhbGxvd011bHRpcGxlU2VsZWN0aW9uc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVeYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnMpXG5pcyBlbmFibGVkLCBhIFtzZWxlY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU2VsZWN0aW9uKSBtYXkgaG9sZFxubXVsdGlwbGUgcmFuZ2VzLiBCeSBkZWZhdWx0LCBzZWxlY3Rpb25zIGhvbGQgZXhhY3RseSBvbmUgcmFuZ2UuXG4qL1xuY2xhc3MgU2VsZWN0aW9uUmFuZ2Uge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGxvd2VyIGJvdW5kYXJ5IG9mIHRoZSByYW5nZS5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSB1cHBlciBib3VuZGFyeSBvZiB0aGUgcmFuZ2UuXG4gICAgKi9cbiAgICB0bywgZmxhZ3MpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBhbmNob3Igb2YgdGhlIHJhbmdl4oCUdGhlIHNpZGUgdGhhdCBkb2Vzbid0IG1vdmUgd2hlbiB5b3VcbiAgICBleHRlbmQgaXQuXG4gICAgKi9cbiAgICBnZXQgYW5jaG9yKCkgeyByZXR1cm4gdGhpcy5mbGFncyAmIDE2IC8qIEludmVydGVkICovID8gdGhpcy50byA6IHRoaXMuZnJvbTsgfVxuICAgIC8qKlxuICAgIFRoZSBoZWFkIG9mIHRoZSByYW5nZSwgd2hpY2ggaXMgbW92ZWQgd2hlbiB0aGUgcmFuZ2UgaXNcbiAgICBbZXh0ZW5kZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU2VsZWN0aW9uUmFuZ2UuZXh0ZW5kKS5cbiAgICAqL1xuICAgIGdldCBoZWFkKCkgeyByZXR1cm4gdGhpcy5mbGFncyAmIDE2IC8qIEludmVydGVkICovID8gdGhpcy5mcm9tIDogdGhpcy50bzsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiBgYW5jaG9yYCBhbmQgYGhlYWRgIGFyZSBhdCB0aGUgc2FtZSBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGdldCBlbXB0eSgpIHsgcmV0dXJuIHRoaXMuZnJvbSA9PSB0aGlzLnRvOyB9XG4gICAgLyoqXG4gICAgSWYgdGhpcyBpcyBhIGN1cnNvciB0aGF0IGlzIGV4cGxpY2l0bHkgYXNzb2NpYXRlZCB3aXRoIHRoZVxuICAgIGNoYXJhY3RlciBvbiBvbmUgb2YgaXRzIHNpZGVzLCB0aGlzIHJldHVybnMgdGhlIHNpZGUuIC0xIG1lYW5zXG4gICAgdGhlIGNoYXJhY3RlciBiZWZvcmUgaXRzIHBvc2l0aW9uLCAxIHRoZSBjaGFyYWN0ZXIgYWZ0ZXIsIGFuZCAwXG4gICAgbWVhbnMgbm8gYXNzb2NpYXRpb24uXG4gICAgKi9cbiAgICBnZXQgYXNzb2MoKSB7IHJldHVybiB0aGlzLmZsYWdzICYgNCAvKiBBc3NvY0JlZm9yZSAqLyA/IC0xIDogdGhpcy5mbGFncyAmIDggLyogQXNzb2NBZnRlciAqLyA/IDEgOiAwOyB9XG4gICAgLyoqXG4gICAgVGhlIGJpZGlyZWN0aW9uYWwgdGV4dCBsZXZlbCBhc3NvY2lhdGVkIHdpdGggdGhpcyBjdXJzb3IsIGlmXG4gICAgYW55LlxuICAgICovXG4gICAgZ2V0IGJpZGlMZXZlbCgpIHtcbiAgICAgICAgbGV0IGxldmVsID0gdGhpcy5mbGFncyAmIDMgLyogQmlkaUxldmVsTWFzayAqLztcbiAgICAgICAgcmV0dXJuIGxldmVsID09IDMgPyBudWxsIDogbGV2ZWw7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBnb2FsIGNvbHVtbiAoc3RvcmVkIHZlcnRpY2FsIG9mZnNldCkgYXNzb2NpYXRlZCB3aXRoIGFcbiAgICBjdXJzb3IuIFRoaXMgaXMgdXNlZCB0byBwcmVzZXJ2ZSB0aGUgdmVydGljYWwgcG9zaXRpb24gd2hlblxuICAgIFttb3ZpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3Lm1vdmVWZXJ0aWNhbGx5KSBhY3Jvc3NcbiAgICBsaW5lcyBvZiBkaWZmZXJlbnQgbGVuZ3RoLlxuICAgICovXG4gICAgZ2V0IGdvYWxDb2x1bW4oKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuZmxhZ3MgPj4gNSAvKiBHb2FsQ29sdW1uT2Zmc2V0ICovO1xuICAgICAgICByZXR1cm4gdmFsdWUgPT0gMzM1NTQ0MzEgLyogTm9Hb2FsQ29sdW1uICovID8gdW5kZWZpbmVkIDogdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hcCB0aGlzIHJhbmdlIHRocm91Z2ggYSBjaGFuZ2UsIHByb2R1Y2luZyBhIHZhbGlkIHJhbmdlIGluIHRoZVxuICAgIHVwZGF0ZWQgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBtYXAoY2hhbmdlLCBhc3NvYyA9IC0xKSB7XG4gICAgICAgIGxldCBmcm9tID0gY2hhbmdlLm1hcFBvcyh0aGlzLmZyb20sIGFzc29jKSwgdG8gPSBjaGFuZ2UubWFwUG9zKHRoaXMudG8sIGFzc29jKTtcbiAgICAgICAgcmV0dXJuIGZyb20gPT0gdGhpcy5mcm9tICYmIHRvID09IHRoaXMudG8gPyB0aGlzIDogbmV3IFNlbGVjdGlvblJhbmdlKGZyb20sIHRvLCB0aGlzLmZsYWdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRXh0ZW5kIHRoaXMgcmFuZ2UgdG8gY292ZXIgYXQgbGVhc3QgYGZyb21gIHRvIGB0b2AuXG4gICAgKi9cbiAgICBleHRlbmQoZnJvbSwgdG8gPSBmcm9tKSB7XG4gICAgICAgIGlmIChmcm9tIDw9IHRoaXMuYW5jaG9yICYmIHRvID49IHRoaXMuYW5jaG9yKVxuICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5yYW5nZShmcm9tLCB0byk7XG4gICAgICAgIGxldCBoZWFkID0gTWF0aC5hYnMoZnJvbSAtIHRoaXMuYW5jaG9yKSA+IE1hdGguYWJzKHRvIC0gdGhpcy5hbmNob3IpID8gZnJvbSA6IHRvO1xuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHRoaXMuYW5jaG9yLCBoZWFkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGlzIHJhbmdlIHRvIGFub3RoZXIgcmFuZ2UuXG4gICAgKi9cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5hbmNob3IgPT0gb3RoZXIuYW5jaG9yICYmIHRoaXMuaGVhZCA9PSBvdGhlci5oZWFkO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm4gYSBKU09OLXNlcmlhbGl6YWJsZSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSByYW5nZS5cbiAgICAqL1xuICAgIHRvSlNPTigpIHsgcmV0dXJuIHsgYW5jaG9yOiB0aGlzLmFuY2hvciwgaGVhZDogdGhpcy5oZWFkIH07IH1cbiAgICAvKipcbiAgICBDb252ZXJ0IGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhIHJhbmdlIHRvIGEgYFNlbGVjdGlvblJhbmdlYFxuICAgIGluc3RhbmNlLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgaWYgKCFqc29uIHx8IHR5cGVvZiBqc29uLmFuY2hvciAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLmhlYWQgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBKU09OIHJlcHJlc2VudGF0aW9uIGZvciBTZWxlY3Rpb25SYW5nZVwiKTtcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5yYW5nZShqc29uLmFuY2hvciwganNvbi5oZWFkKTtcbiAgICB9XG59XG4vKipcbkFuIGVkaXRvciBzZWxlY3Rpb24gaG9sZHMgb25lIG9yIG1vcmUgc2VsZWN0aW9uIHJhbmdlcy5cbiovXG5jbGFzcyBFZGl0b3JTZWxlY3Rpb24ge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHJhbmdlcyBpbiB0aGUgc2VsZWN0aW9uLCBzb3J0ZWQgYnkgcG9zaXRpb24uIFJhbmdlcyBjYW5ub3RcbiAgICBvdmVybGFwIChidXQgdGhleSBtYXkgdG91Y2gsIGlmIHRoZXkgYXJlbid0IGVtcHR5KS5cbiAgICAqL1xuICAgIHJhbmdlcywgXG4gICAgLyoqXG4gICAgVGhlIGluZGV4IG9mIHRoZSBfbWFpbl8gcmFuZ2UgaW4gdGhlIHNlbGVjdGlvbiAod2hpY2ggaXNcbiAgICB1c3VhbGx5IHRoZSByYW5nZSB0aGF0IHdhcyBhZGRlZCBsYXN0KS5cbiAgICAqL1xuICAgIG1haW5JbmRleCA9IDApIHtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIHRoaXMubWFpbkluZGV4ID0gbWFpbkluZGV4O1xuICAgIH1cbiAgICAvKipcbiAgICBNYXAgYSBzZWxlY3Rpb24gdGhyb3VnaCBhIGNoYW5nZS4gVXNlZCB0byBhZGp1c3QgdGhlIHNlbGVjdGlvblxuICAgIHBvc2l0aW9uIGZvciBjaGFuZ2VzLlxuICAgICovXG4gICAgbWFwKGNoYW5nZSwgYXNzb2MgPSAtMSkge1xuICAgICAgICBpZiAoY2hhbmdlLmVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHRoaXMucmFuZ2VzLm1hcChyID0+IHIubWFwKGNoYW5nZSwgYXNzb2MpKSwgdGhpcy5tYWluSW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21wYXJlIHRoaXMgc2VsZWN0aW9uIHRvIGFub3RoZXIgc2VsZWN0aW9uLlxuICAgICovXG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMucmFuZ2VzLmxlbmd0aCAhPSBvdGhlci5yYW5nZXMubGVuZ3RoIHx8XG4gICAgICAgICAgICB0aGlzLm1haW5JbmRleCAhPSBvdGhlci5tYWluSW5kZXgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIXRoaXMucmFuZ2VzW2ldLmVxKG90aGVyLnJhbmdlc1tpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBwcmltYXJ5IHNlbGVjdGlvbiByYW5nZS4gVXN1YWxseSwgeW91IHNob3VsZCBtYWtlIHN1cmVcbiAgICB5b3VyIGNvZGUgYXBwbGllcyB0byBfYWxsXyByYW5nZXMsIGJ5IHVzaW5nIG1ldGhvZHMgbGlrZVxuICAgIFtgY2hhbmdlQnlSYW5nZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuY2hhbmdlQnlSYW5nZSkuXG4gICAgKi9cbiAgICBnZXQgbWFpbigpIHsgcmV0dXJuIHRoaXMucmFuZ2VzW3RoaXMubWFpbkluZGV4XTsgfVxuICAgIC8qKlxuICAgIE1ha2Ugc3VyZSB0aGUgc2VsZWN0aW9uIG9ubHkgaGFzIG9uZSByYW5nZS4gUmV0dXJucyBhIHNlbGVjdGlvblxuICAgIGhvbGRpbmcgb25seSB0aGUgbWFpbiByYW5nZSBmcm9tIHRoaXMgc2VsZWN0aW9uLlxuICAgICovXG4gICAgYXNTaW5nbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhbmdlcy5sZW5ndGggPT0gMSA/IHRoaXMgOiBuZXcgRWRpdG9yU2VsZWN0aW9uKFt0aGlzLm1haW5dKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRXh0ZW5kIHRoaXMgc2VsZWN0aW9uIHdpdGggYW4gZXh0cmEgcmFuZ2UuXG4gICAgKi9cbiAgICBhZGRSYW5nZShyYW5nZSwgbWFpbiA9IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUoW3JhbmdlXS5jb25jYXQodGhpcy5yYW5nZXMpLCBtYWluID8gMCA6IHRoaXMubWFpbkluZGV4ICsgMSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgYSBnaXZlbiByYW5nZSB3aXRoIGFub3RoZXIgcmFuZ2UsIGFuZCB0aGVuIG5vcm1hbGl6ZSB0aGVcbiAgICBzZWxlY3Rpb24gdG8gbWVyZ2UgYW5kIHNvcnQgcmFuZ2VzIGlmIG5lY2Vzc2FyeS5cbiAgICAqL1xuICAgIHJlcGxhY2VSYW5nZShyYW5nZSwgd2hpY2ggPSB0aGlzLm1haW5JbmRleCkge1xuICAgICAgICBsZXQgcmFuZ2VzID0gdGhpcy5yYW5nZXMuc2xpY2UoKTtcbiAgICAgICAgcmFuZ2VzW3doaWNoXSA9IHJhbmdlO1xuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMsIHRoaXMubWFpbkluZGV4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29udmVydCB0aGlzIHNlbGVjdGlvbiB0byBhbiBvYmplY3QgdGhhdCBjYW4gYmUgc2VyaWFsaXplZCB0b1xuICAgIEpTT04uXG4gICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlczogdGhpcy5yYW5nZXMubWFwKHIgPT4gci50b0pTT04oKSksIG1haW46IHRoaXMubWFpbkluZGV4IH07XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNlbGVjdGlvbiBmcm9tIGEgSlNPTiByZXByZXNlbnRhdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGlmICghanNvbiB8fCAhQXJyYXkuaXNBcnJheShqc29uLnJhbmdlcykgfHwgdHlwZW9mIGpzb24ubWFpbiAhPSBcIm51bWJlclwiIHx8IGpzb24ubWFpbiA+PSBqc29uLnJhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiByZXByZXNlbnRhdGlvbiBmb3IgRWRpdG9yU2VsZWN0aW9uXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEVkaXRvclNlbGVjdGlvbihqc29uLnJhbmdlcy5tYXAoKHIpID0+IFNlbGVjdGlvblJhbmdlLmZyb21KU09OKHIpKSwganNvbi5tYWluKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2VsZWN0aW9uIGhvbGRpbmcgYSBzaW5nbGUgcmFuZ2UuXG4gICAgKi9cbiAgICBzdGF0aWMgc2luZ2xlKGFuY2hvciwgaGVhZCA9IGFuY2hvcikge1xuICAgICAgICByZXR1cm4gbmV3IEVkaXRvclNlbGVjdGlvbihbRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGFuY2hvciwgaGVhZCldLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgU29ydCBhbmQgbWVyZ2UgdGhlIGdpdmVuIHNldCBvZiByYW5nZXMsIGNyZWF0aW5nIGEgdmFsaWRcbiAgICBzZWxlY3Rpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKHJhbmdlcywgbWFpbkluZGV4ID0gMCkge1xuICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBIHNlbGVjdGlvbiBuZWVkcyBhdCBsZWFzdCBvbmUgcmFuZ2VcIik7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDAsIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcmFuZ2UgPSByYW5nZXNbaV07XG4gICAgICAgICAgICBpZiAocmFuZ2UuZW1wdHkgPyByYW5nZS5mcm9tIDw9IHBvcyA6IHJhbmdlLmZyb20gPCBwb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWQocmFuZ2VzLnNsaWNlKCksIG1haW5JbmRleCk7XG4gICAgICAgICAgICBwb3MgPSByYW5nZS50bztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEVkaXRvclNlbGVjdGlvbihyYW5nZXMsIG1haW5JbmRleCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGN1cnNvciBzZWxlY3Rpb24gcmFuZ2UgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLiBZb3UgY2FuXG4gICAgc2FmZWx5IGlnbm9yZSB0aGUgb3B0aW9uYWwgYXJndW1lbnRzIGluIG1vc3Qgc2l0dWF0aW9ucy5cbiAgICAqL1xuICAgIHN0YXRpYyBjdXJzb3IocG9zLCBhc3NvYyA9IDAsIGJpZGlMZXZlbCwgZ29hbENvbHVtbikge1xuICAgICAgICByZXR1cm4gbmV3IFNlbGVjdGlvblJhbmdlKHBvcywgcG9zLCAoYXNzb2MgPT0gMCA/IDAgOiBhc3NvYyA8IDAgPyA0IC8qIEFzc29jQmVmb3JlICovIDogOCAvKiBBc3NvY0FmdGVyICovKSB8XG4gICAgICAgICAgICAoYmlkaUxldmVsID09IG51bGwgPyAzIDogTWF0aC5taW4oMiwgYmlkaUxldmVsKSkgfFxuICAgICAgICAgICAgKChnb2FsQ29sdW1uICE9PSBudWxsICYmIGdvYWxDb2x1bW4gIT09IHZvaWQgMCA/IGdvYWxDb2x1bW4gOiAzMzU1NDQzMSAvKiBOb0dvYWxDb2x1bW4gKi8pIDw8IDUgLyogR29hbENvbHVtbk9mZnNldCAqLykpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBzZWxlY3Rpb24gcmFuZ2UuXG4gICAgKi9cbiAgICBzdGF0aWMgcmFuZ2UoYW5jaG9yLCBoZWFkLCBnb2FsQ29sdW1uKSB7XG4gICAgICAgIGxldCBnb2FsID0gKGdvYWxDb2x1bW4gIT09IG51bGwgJiYgZ29hbENvbHVtbiAhPT0gdm9pZCAwID8gZ29hbENvbHVtbiA6IDMzNTU0NDMxIC8qIE5vR29hbENvbHVtbiAqLykgPDwgNSAvKiBHb2FsQ29sdW1uT2Zmc2V0ICovO1xuICAgICAgICByZXR1cm4gaGVhZCA8IGFuY2hvciA/IG5ldyBTZWxlY3Rpb25SYW5nZShoZWFkLCBhbmNob3IsIDE2IC8qIEludmVydGVkICovIHwgZ29hbCkgOiBuZXcgU2VsZWN0aW9uUmFuZ2UoYW5jaG9yLCBoZWFkLCBnb2FsKTtcbiAgICB9XG59XG5mdW5jdGlvbiBub3JtYWxpemVkKHJhbmdlcywgbWFpbkluZGV4ID0gMCkge1xuICAgIGxldCBtYWluID0gcmFuZ2VzW21haW5JbmRleF07XG4gICAgcmFuZ2VzLnNvcnQoKGEsIGIpID0+IGEuZnJvbSAtIGIuZnJvbSk7XG4gICAgbWFpbkluZGV4ID0gcmFuZ2VzLmluZGV4T2YobWFpbik7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHJhbmdlID0gcmFuZ2VzW2ldLCBwcmV2ID0gcmFuZ2VzW2kgLSAxXTtcbiAgICAgICAgaWYgKHJhbmdlLmVtcHR5ID8gcmFuZ2UuZnJvbSA8PSBwcmV2LnRvIDogcmFuZ2UuZnJvbSA8IHByZXYudG8pIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gcHJldi5mcm9tLCB0byA9IE1hdGgubWF4KHJhbmdlLnRvLCBwcmV2LnRvKTtcbiAgICAgICAgICAgIGlmIChpIDw9IG1haW5JbmRleClcbiAgICAgICAgICAgICAgICBtYWluSW5kZXgtLTtcbiAgICAgICAgICAgIHJhbmdlcy5zcGxpY2UoLS1pLCAyLCByYW5nZS5hbmNob3IgPiByYW5nZS5oZWFkID8gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHRvLCBmcm9tKSA6IEVkaXRvclNlbGVjdGlvbi5yYW5nZShmcm9tLCB0bykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgRWRpdG9yU2VsZWN0aW9uKHJhbmdlcywgbWFpbkluZGV4KTtcbn1cbmZ1bmN0aW9uIGNoZWNrU2VsZWN0aW9uKHNlbGVjdGlvbiwgZG9jTGVuZ3RoKSB7XG4gICAgZm9yIChsZXQgcmFuZ2Ugb2Ygc2VsZWN0aW9uLnJhbmdlcylcbiAgICAgICAgaWYgKHJhbmdlLnRvID4gZG9jTGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJTZWxlY3Rpb24gcG9pbnRzIG91dHNpZGUgb2YgZG9jdW1lbnRcIik7XG59XG5cbmxldCBuZXh0SUQgPSAwO1xuLyoqXG5BIGZhY2V0IGlzIGEgbGFiZWxlZCB2YWx1ZSB0aGF0IGlzIGFzc29jaWF0ZWQgd2l0aCBhbiBlZGl0b3JcbnN0YXRlLiBJdCB0YWtlcyBpbnB1dHMgZnJvbSBhbnkgbnVtYmVyIG9mIGV4dGVuc2lvbnMsIGFuZCBjb21iaW5lc1xudGhvc2UgaW50byBhIHNpbmdsZSBvdXRwdXQgdmFsdWUuXG5cbkV4YW1wbGVzIG9mIGZhY2V0cyBhcmUgdGhlIFt0aGVtZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdedGhlbWUpIHN0eWxlc1xuYXNzb2NpYXRlZCB3aXRoIGFuIGVkaXRvciBvciB0aGUgW3RhYlxuc2l6ZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV50YWJTaXplKSAod2hpY2ggaXMgcmVkdWNlZCB0byBhIHNpbmdsZVxudmFsdWUsIHVzaW5nIHRoZSBpbnB1dCB3aXRoIHRoZSBoaWdodGVzdCBwcmVjZWRlbmNlKS5cbiovXG5jbGFzcyBGYWNldCB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb21iaW5lLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbXBhcmVJbnB1dCwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb21wYXJlLCBpc1N0YXRpYywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBleHRlbnNpb25zKSB7XG4gICAgICAgIHRoaXMuY29tYmluZSA9IGNvbWJpbmU7XG4gICAgICAgIHRoaXMuY29tcGFyZUlucHV0ID0gY29tcGFyZUlucHV0O1xuICAgICAgICB0aGlzLmNvbXBhcmUgPSBjb21wYXJlO1xuICAgICAgICB0aGlzLmlzU3RhdGljID0gaXNTdGF0aWM7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZCA9IG5leHRJRCsrO1xuICAgICAgICB0aGlzLmRlZmF1bHQgPSBjb21iaW5lKFtdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgbmV3IGZhY2V0LlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZShjb25maWcgPSB7fSkge1xuICAgICAgICByZXR1cm4gbmV3IEZhY2V0KGNvbmZpZy5jb21iaW5lIHx8ICgoYSkgPT4gYSksIGNvbmZpZy5jb21wYXJlSW5wdXQgfHwgKChhLCBiKSA9PiBhID09PSBiKSwgY29uZmlnLmNvbXBhcmUgfHwgKCFjb25maWcuY29tYmluZSA/IHNhbWVBcnJheSA6IChhLCBiKSA9PiBhID09PSBiKSwgISFjb25maWcuc3RhdGljLCBjb25maWcuZW5hYmxlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgYWRkcyB0aGUgZ2l2ZW4gdmFsdWUgZm9yIHRoaXMgZmFjZXQuXG4gICAgKi9cbiAgICBvZih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IEZhY2V0UHJvdmlkZXIoW10sIHRoaXMsIDAgLyogU3RhdGljICovLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBleHRlbnNpb24gdGhhdCBjb21wdXRlcyBhIHZhbHVlIGZvciB0aGUgZmFjZXQgZnJvbSBhXG4gICAgc3RhdGUuIFlvdSBtdXN0IHRha2UgY2FyZSB0byBkZWNsYXJlIHRoZSBwYXJ0cyBvZiB0aGUgc3RhdGUgdGhhdFxuICAgIHRoaXMgdmFsdWUgZGVwZW5kcyBvbiwgc2luY2UgeW91ciBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZCBhZ2FpblxuICAgIGZvciBhIG5ldyBzdGF0ZSB3aGVuIG9uZSBvZiB0aG9zZSBwYXJ0cyBjaGFuZ2VkLlxuICAgIFxuICAgIEluIG1vc3QgY2FzZXMsIHlvdSdsbCB3YW50IHRvIHVzZSB0aGVcbiAgICBbYHByb3ZpZGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRmllbGReZGVmaW5lXmNvbmZpZy5wcm92aWRlKSBvcHRpb24gd2hlblxuICAgIGRlZmluaW5nIGEgZmllbGQgaW5zdGVhZC5cbiAgICAqL1xuICAgIGNvbXB1dGUoZGVwcywgZ2V0KSB7XG4gICAgICAgIGlmICh0aGlzLmlzU3RhdGljKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgY29tcHV0ZSBhIHN0YXRpYyBmYWNldFwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGYWNldFByb3ZpZGVyKGRlcHMsIHRoaXMsIDEgLyogU2luZ2xlICovLCBnZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgY29tcHV0ZXMgemVybyBvciBtb3JlIHZhbHVlcyBmb3IgdGhpc1xuICAgIGZhY2V0IGZyb20gYSBzdGF0ZS5cbiAgICAqL1xuICAgIGNvbXB1dGVOKGRlcHMsIGdldCkge1xuICAgICAgICBpZiAodGhpcy5pc1N0YXRpYylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGNvbXB1dGUgYSBzdGF0aWMgZmFjZXRcIik7XG4gICAgICAgIHJldHVybiBuZXcgRmFjZXRQcm92aWRlcihkZXBzLCB0aGlzLCAyIC8qIE11bHRpICovLCBnZXQpO1xuICAgIH1cbiAgICBmcm9tKGZpZWxkLCBnZXQpIHtcbiAgICAgICAgaWYgKCFnZXQpXG4gICAgICAgICAgICBnZXQgPSB4ID0+IHg7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGUoW2ZpZWxkXSwgc3RhdGUgPT4gZ2V0KHN0YXRlLmZpZWxkKGZpZWxkKSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNhbWVBcnJheShhLCBiKSB7XG4gICAgcmV0dXJuIGEgPT0gYiB8fCBhLmxlbmd0aCA9PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KChlLCBpKSA9PiBlID09PSBiW2ldKTtcbn1cbmNsYXNzIEZhY2V0UHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKGRlcGVuZGVuY2llcywgZmFjZXQsIHR5cGUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzO1xuICAgICAgICB0aGlzLmZhY2V0ID0gZmFjZXQ7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5pZCA9IG5leHRJRCsrO1xuICAgIH1cbiAgICBkeW5hbWljU2xvdChhZGRyZXNzZXMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgZ2V0dGVyID0gdGhpcy52YWx1ZTtcbiAgICAgICAgbGV0IGNvbXBhcmUgPSB0aGlzLmZhY2V0LmNvbXBhcmVJbnB1dDtcbiAgICAgICAgbGV0IGlkeCA9IGFkZHJlc3Nlc1t0aGlzLmlkXSA+PiAxLCBtdWx0aSA9IHRoaXMudHlwZSA9PSAyIC8qIE11bHRpICovO1xuICAgICAgICBsZXQgZGVwRG9jID0gZmFsc2UsIGRlcFNlbCA9IGZhbHNlLCBkZXBBZGRycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBkZXAgb2YgdGhpcy5kZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgIGlmIChkZXAgPT0gXCJkb2NcIilcbiAgICAgICAgICAgICAgICBkZXBEb2MgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoZGVwID09IFwic2VsZWN0aW9uXCIpXG4gICAgICAgICAgICAgICAgZGVwU2VsID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKCgoKF9hID0gYWRkcmVzc2VzW2RlcC5pZF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDEpICYgMSkgPT0gMClcbiAgICAgICAgICAgICAgICBkZXBBZGRycy5wdXNoKGFkZHJlc3Nlc1tkZXAuaWRdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHN0YXRlLCB0cikgPT4ge1xuICAgICAgICAgICAgaWYgKCF0ciB8fCB0ci5yZWNvbmZpZ3VyZWQpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IGdldHRlcihzdGF0ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogQ2hhbmdlZCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBkZXBDaGFuZ2VkID0gKGRlcERvYyAmJiB0ci5kb2NDaGFuZ2VkKSB8fCAoZGVwU2VsICYmICh0ci5kb2NDaGFuZ2VkIHx8IHRyLnNlbGVjdGlvbikpIHx8XG4gICAgICAgICAgICAgICAgICAgIGRlcEFkZHJzLnNvbWUoYWRkciA9PiAoZW5zdXJlQWRkcihzdGF0ZSwgYWRkcikgJiAxIC8qIENoYW5nZWQgKi8pID4gMCk7XG4gICAgICAgICAgICAgICAgaWYgKCFkZXBDaGFuZ2VkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICBsZXQgbmV3VmFsID0gZ2V0dGVyKHN0YXRlKSwgb2xkVmFsID0gdHIuc3RhcnRTdGF0ZS52YWx1ZXNbaWR4XTtcbiAgICAgICAgICAgICAgICBpZiAobXVsdGkgPyBjb21wYXJlQXJyYXkobmV3VmFsLCBvbGRWYWwsIGNvbXBhcmUpIDogY29tcGFyZShuZXdWYWwsIG9sZFZhbCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gbmV3VmFsO1xuICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIENoYW5nZWQgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcGFyZUFycmF5KGEsIGIsIGNvbXBhcmUpIHtcbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICghY29tcGFyZShhW2ldLCBiW2ldKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGR5bmFtaWNGYWNldFNsb3QoYWRkcmVzc2VzLCBmYWNldCwgcHJvdmlkZXJzKSB7XG4gICAgbGV0IHByb3ZpZGVyQWRkcnMgPSBwcm92aWRlcnMubWFwKHAgPT4gYWRkcmVzc2VzW3AuaWRdKTtcbiAgICBsZXQgcHJvdmlkZXJUeXBlcyA9IHByb3ZpZGVycy5tYXAocCA9PiBwLnR5cGUpO1xuICAgIGxldCBkeW5hbWljID0gcHJvdmlkZXJBZGRycy5maWx0ZXIocCA9PiAhKHAgJiAxKSk7XG4gICAgbGV0IGlkeCA9IGFkZHJlc3Nlc1tmYWNldC5pZF0gPj4gMTtcbiAgICByZXR1cm4gKHN0YXRlLCB0cikgPT4ge1xuICAgICAgICBsZXQgb2xkQWRkciA9ICF0ciA/IG51bGwgOiB0ci5yZWNvbmZpZ3VyZWQgPyB0ci5zdGFydFN0YXRlLmNvbmZpZy5hZGRyZXNzW2ZhY2V0LmlkXSA6IGlkeCA8PCAxO1xuICAgICAgICBsZXQgY2hhbmdlZCA9IG9sZEFkZHIgPT0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgZHluQWRkciBvZiBkeW5hbWljKSB7XG4gICAgICAgICAgICBpZiAoZW5zdXJlQWRkcihzdGF0ZSwgZHluQWRkcikgJiAxIC8qIENoYW5nZWQgKi8pXG4gICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjaGFuZ2VkKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGxldCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm92aWRlckFkZHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBnZXRBZGRyKHN0YXRlLCBwcm92aWRlckFkZHJzW2ldKTtcbiAgICAgICAgICAgIGlmIChwcm92aWRlclR5cGVzW2ldID09IDIgLyogTXVsdGkgKi8pXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgdmFsIG9mIHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh2YWwpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV3VmFsID0gZmFjZXQuY29tYmluZSh2YWx1ZXMpO1xuICAgICAgICBpZiAob2xkQWRkciAhPSBudWxsICYmIGZhY2V0LmNvbXBhcmUobmV3VmFsLCBnZXRBZGRyKHRyLnN0YXJ0U3RhdGUsIG9sZEFkZHIpKSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IG5ld1ZhbDtcbiAgICAgICAgcmV0dXJuIDEgLyogQ2hhbmdlZCAqLztcbiAgICB9O1xufVxuZnVuY3Rpb24gbWF5YmVJbmRleChzdGF0ZSwgaWQpIHtcbiAgICBsZXQgZm91bmQgPSBzdGF0ZS5jb25maWcuYWRkcmVzc1tpZF07XG4gICAgcmV0dXJuIGZvdW5kID09IG51bGwgPyBudWxsIDogZm91bmQgPj4gMTtcbn1cbmNvbnN0IGluaXRGaWVsZCA9IEZhY2V0LmRlZmluZSh7IHN0YXRpYzogdHJ1ZSB9KTtcbi8qKlxuRmllbGRzIGNhbiBzdG9yZSBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGluIGFuIGVkaXRvciBzdGF0ZSwgYW5kXG5rZWVwIGl0IGluIHN5bmMgd2l0aCB0aGUgcmVzdCBvZiB0aGUgc3RhdGUuXG4qL1xuY2xhc3MgU3RhdGVGaWVsZCB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBpZCwgY3JlYXRlRiwgdXBkYXRlRiwgY29tcGFyZUYsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3BlYykge1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMuY3JlYXRlRiA9IGNyZWF0ZUY7XG4gICAgICAgIHRoaXMudXBkYXRlRiA9IHVwZGF0ZUY7XG4gICAgICAgIHRoaXMuY29tcGFyZUYgPSBjb21wYXJlRjtcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYztcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnByb3ZpZGVzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBzdGF0ZSBmaWVsZC5cbiAgICAqL1xuICAgIHN0YXRpYyBkZWZpbmUoY29uZmlnKSB7XG4gICAgICAgIGxldCBmaWVsZCA9IG5ldyBTdGF0ZUZpZWxkKG5leHRJRCsrLCBjb25maWcuY3JlYXRlLCBjb25maWcudXBkYXRlLCBjb25maWcuY29tcGFyZSB8fCAoKGEsIGIpID0+IGEgPT09IGIpLCBjb25maWcpO1xuICAgICAgICBpZiAoY29uZmlnLnByb3ZpZGUpXG4gICAgICAgICAgICBmaWVsZC5wcm92aWRlcyA9IGNvbmZpZy5wcm92aWRlKGZpZWxkKTtcbiAgICAgICAgcmV0dXJuIGZpZWxkO1xuICAgIH1cbiAgICBjcmVhdGUoc3RhdGUpIHtcbiAgICAgICAgbGV0IGluaXQgPSBzdGF0ZS5mYWNldChpbml0RmllbGQpLmZpbmQoaSA9PiBpLmZpZWxkID09IHRoaXMpO1xuICAgICAgICByZXR1cm4gKChpbml0ID09PSBudWxsIHx8IGluaXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluaXQuY3JlYXRlKSB8fCB0aGlzLmNyZWF0ZUYpKHN0YXRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzbG90KGFkZHJlc3Nlcykge1xuICAgICAgICBsZXQgaWR4ID0gYWRkcmVzc2VzW3RoaXMuaWRdID4+IDE7XG4gICAgICAgIHJldHVybiAoc3RhdGUsIHRyKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRyKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSB0aGlzLmNyZWF0ZShzdGF0ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogQ2hhbmdlZCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBvbGRWYWwsIGNoYW5nZWQgPSAwO1xuICAgICAgICAgICAgaWYgKHRyLnJlY29uZmlndXJlZCkge1xuICAgICAgICAgICAgICAgIGxldCBvbGRJZHggPSBtYXliZUluZGV4KHRyLnN0YXJ0U3RhdGUsIHRoaXMuaWQpO1xuICAgICAgICAgICAgICAgIG9sZFZhbCA9IG9sZElkeCA9PSBudWxsID8gdGhpcy5jcmVhdGUodHIuc3RhcnRTdGF0ZSkgOiB0ci5zdGFydFN0YXRlLnZhbHVlc1tvbGRJZHhdO1xuICAgICAgICAgICAgICAgIGNoYW5nZWQgPSAxIC8qIENoYW5nZWQgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvbGRWYWwgPSB0ci5zdGFydFN0YXRlLnZhbHVlc1tpZHhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHZhbHVlID0gdGhpcy51cGRhdGVGKG9sZFZhbCwgdHIpO1xuICAgICAgICAgICAgaWYgKCFjaGFuZ2VkICYmICF0aGlzLmNvbXBhcmVGKG9sZFZhbCwgdmFsdWUpKVxuICAgICAgICAgICAgICAgIGNoYW5nZWQgPSAxIC8qIENoYW5nZWQgKi87XG4gICAgICAgICAgICBpZiAoY2hhbmdlZClcbiAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZWQ7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgZW5hYmxlcyB0aGlzIGZpZWxkIGFuZCBvdmVycmlkZXMgdGhlXG4gICAgd2F5IGl0IGlzIGluaXRpYWxpemVkLiBDYW4gYmUgdXNlZnVsIHdoZW4geW91IG5lZWQgdG8gcHJvdmlkZSBhXG4gICAgbm9uLWRlZmF1bHQgc3RhcnRpbmcgdmFsdWUgZm9yIHRoZSBmaWVsZC5cbiAgICAqL1xuICAgIGluaXQoY3JlYXRlKSB7XG4gICAgICAgIHJldHVybiBbdGhpcywgaW5pdEZpZWxkLm9mKHsgZmllbGQ6IHRoaXMsIGNyZWF0ZSB9KV07XG4gICAgfVxuICAgIC8qKlxuICAgIFN0YXRlIGZpZWxkIGluc3RhbmNlcyBjYW4gYmUgdXNlZCBhc1xuICAgIFtgRXh0ZW5zaW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FeHRlbnNpb24pIHZhbHVlcyB0byBlbmFibGUgdGhlIGZpZWxkIGluIGFcbiAgICBnaXZlbiBzdGF0ZS5cbiAgICAqL1xuICAgIGdldCBleHRlbnNpb24oKSB7IHJldHVybiB0aGlzOyB9XG59XG5jb25zdCBQcmVjXyA9IHsgZmFsbGJhY2s6IDMsIGRlZmF1bHQ6IDIsIGV4dGVuZDogMSwgb3ZlcnJpZGU6IDAgfTtcbmZ1bmN0aW9uIHByZWModmFsdWUpIHtcbiAgICByZXR1cm4gKGV4dCkgPT4gbmV3IFByZWNFeHRlbnNpb24oZXh0LCB2YWx1ZSk7XG59XG4vKipcbkJ5IGRlZmF1bHQgZXh0ZW5zaW9ucyBhcmUgcmVnaXN0ZXJlZCBpbiB0aGUgb3JkZXIgdGhleSBhcmUgZm91bmRcbmluIHRoZSBmbGF0dGVuZWQgZm9ybSBvZiBuZXN0ZWQgYXJyYXkgdGhhdCB3YXMgcHJvdmlkZWQuXG5JbmRpdmlkdWFsIGV4dGVuc2lvbiB2YWx1ZXMgY2FuIGJlIGFzc2lnbmVkIGEgcHJlY2VkZW5jZSB0b1xub3ZlcnJpZGUgdGhpcy4gRXh0ZW5zaW9ucyB0aGF0IGRvIG5vdCBoYXZlIGEgcHJlY2VkZW5jZSBzZXQgZ2V0XG50aGUgcHJlY2VkZW5jZSBvZiB0aGUgbmVhcmVzdCBwYXJlbnQgd2l0aCBhIHByZWNlZGVuY2UsIG9yXG5bYGRlZmF1bHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlByZWMuZGVmYXVsdCkgaWYgdGhlcmUgaXMgbm8gc3VjaCBwYXJlbnQuIFRoZVxuZmluYWwgb3JkZXJpbmcgb2YgZXh0ZW5zaW9ucyBpcyBkZXRlcm1pbmVkIGJ5IGZpcnN0IHNvcnRpbmcgYnlcbnByZWNlZGVuY2UgYW5kIHRoZW4gYnkgb3JkZXIgd2l0aGluIGVhY2ggcHJlY2VkZW5jZS5cbiovXG5jb25zdCBQcmVjID0ge1xuICAgIC8qKlxuICAgIEEgcHJlY2VkZW5jZSBiZWxvdyB0aGUgZGVmYXVsdCBwcmVjZWRlbmNlLCB3aGljaCB3aWxsIGNhdXNlXG4gICAgZGVmYXVsdC1wcmVjZWRlbmNlIGV4dGVuc2lvbnMgdG8gb3ZlcnJpZGUgaXQgZXZlbiBpZiB0aGV5IGFyZVxuICAgIHNwZWNpZmllZCBsYXRlciBpbiB0aGUgZXh0ZW5zaW9uIG9yZGVyaW5nLlxuICAgICovXG4gICAgZmFsbGJhY2s6IHByZWMoUHJlY18uZmFsbGJhY2spLFxuICAgIC8qKlxuICAgIFRoZSByZWd1bGFyIGRlZmF1bHQgcHJlY2VkZW5jZS5cbiAgICAqL1xuICAgIGRlZmF1bHQ6IHByZWMoUHJlY18uZGVmYXVsdCksXG4gICAgLyoqXG4gICAgQSBoaWdoZXItdGhhbi1kZWZhdWx0IHByZWNlZGVuY2UuXG4gICAgKi9cbiAgICBleHRlbmQ6IHByZWMoUHJlY18uZXh0ZW5kKSxcbiAgICAvKipcbiAgICBQcmVjZWRlbmNlIGFib3ZlIHRoZSBgZGVmYXVsdGAgYW5kIGBleHRlbmRgIHByZWNlZGVuY2VzLlxuICAgICovXG4gICAgb3ZlcnJpZGU6IHByZWMoUHJlY18ub3ZlcnJpZGUpXG59O1xuY2xhc3MgUHJlY0V4dGVuc2lvbiB7XG4gICAgY29uc3RydWN0b3IoaW5uZXIsIHByZWMpIHtcbiAgICAgICAgdGhpcy5pbm5lciA9IGlubmVyO1xuICAgICAgICB0aGlzLnByZWMgPSBwcmVjO1xuICAgIH1cbn1cbi8qKlxuRXh0ZW5zaW9uIGNvbXBhcnRtZW50cyBjYW4gYmUgdXNlZCB0byBtYWtlIGEgY29uZmlndXJhdGlvblxuZHluYW1pYy4gQnkgW3dyYXBwaW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNvbXBhcnRtZW50Lm9mKSBwYXJ0IG9mIHlvdXJcbmNvbmZpZ3VyYXRpb24gaW4gYSBjb21wYXJ0bWVudCwgeW91IGNhbiBsYXRlclxuW3JlcGxhY2VdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ29tcGFydG1lbnQucmVjb25maWd1cmUpIHRoYXQgcGFydCB0aHJvdWdoIGFcbnRyYW5zYWN0aW9uLlxuKi9cbmNsYXNzIENvbXBhcnRtZW50IHtcbiAgICAvKipcbiAgICBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjb21wYXJ0bWVudCB0byBhZGQgdG8geW91ciBbc3RhdGVcbiAgICBjb25maWd1cmF0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlQ29uZmlnLmV4dGVuc2lvbnMpLlxuICAgICovXG4gICAgb2YoZXh0KSB7IHJldHVybiBuZXcgQ29tcGFydG1lbnRJbnN0YW5jZSh0aGlzLCBleHQpOyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIFtlZmZlY3RdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmVmZmVjdHMpIHRoYXRcbiAgICByZWNvbmZpZ3VyZXMgdGhpcyBjb21wYXJ0bWVudC5cbiAgICAqL1xuICAgIHJlY29uZmlndXJlKGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIENvbXBhcnRtZW50LnJlY29uZmlndXJlLm9mKHsgY29tcGFydG1lbnQ6IHRoaXMsIGV4dGVuc2lvbjogY29udGVudCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBjdXJyZW50IGNvbnRlbnQgb2YgdGhlIGNvbXBhcnRtZW50IGluIHRoZSBzdGF0ZSwgb3JcbiAgICBgdW5kZWZpbmVkYCBpZiBpdCBpc24ndCBwcmVzZW50LlxuICAgICovXG4gICAgZ2V0KHN0YXRlKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZS5jb25maWcuY29tcGFydG1lbnRzLmdldCh0aGlzKTtcbiAgICB9XG59XG5jbGFzcyBDb21wYXJ0bWVudEluc3RhbmNlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb21wYXJ0bWVudCwgaW5uZXIpIHtcbiAgICAgICAgdGhpcy5jb21wYXJ0bWVudCA9IGNvbXBhcnRtZW50O1xuICAgICAgICB0aGlzLmlubmVyID0gaW5uZXI7XG4gICAgfVxufVxuY2xhc3MgQ29uZmlndXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3IoYmFzZSwgY29tcGFydG1lbnRzLCBkeW5hbWljU2xvdHMsIGFkZHJlc3MsIHN0YXRpY1ZhbHVlcykge1xuICAgICAgICB0aGlzLmJhc2UgPSBiYXNlO1xuICAgICAgICB0aGlzLmNvbXBhcnRtZW50cyA9IGNvbXBhcnRtZW50cztcbiAgICAgICAgdGhpcy5keW5hbWljU2xvdHMgPSBkeW5hbWljU2xvdHM7XG4gICAgICAgIHRoaXMuYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgICAgIHRoaXMuc3RhdGljVmFsdWVzID0gc3RhdGljVmFsdWVzO1xuICAgICAgICB0aGlzLnN0YXR1c1RlbXBsYXRlID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnN0YXR1c1RlbXBsYXRlLmxlbmd0aCA8IGR5bmFtaWNTbG90cy5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLnN0YXR1c1RlbXBsYXRlLnB1c2goMCAvKiBVbmluaXRpYWxpemVkICovKTtcbiAgICB9XG4gICAgc3RhdGljRmFjZXQoZmFjZXQpIHtcbiAgICAgICAgbGV0IGFkZHIgPSB0aGlzLmFkZHJlc3NbZmFjZXQuaWRdO1xuICAgICAgICByZXR1cm4gYWRkciA9PSBudWxsID8gZmFjZXQuZGVmYXVsdCA6IHRoaXMuc3RhdGljVmFsdWVzW2FkZHIgPj4gMV07XG4gICAgfVxuICAgIHN0YXRpYyByZXNvbHZlKGJhc2UsIGNvbXBhcnRtZW50cywgb2xkU3RhdGUpIHtcbiAgICAgICAgbGV0IGZpZWxkcyA9IFtdO1xuICAgICAgICBsZXQgZmFjZXRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgbGV0IG5ld0NvbXBhcnRtZW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChsZXQgZXh0IG9mIGZsYXR0ZW4oYmFzZSwgY29tcGFydG1lbnRzLCBuZXdDb21wYXJ0bWVudHMpKSB7XG4gICAgICAgICAgICBpZiAoZXh0IGluc3RhbmNlb2YgU3RhdGVGaWVsZClcbiAgICAgICAgICAgICAgICBmaWVsZHMucHVzaChleHQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIChmYWNldHNbZXh0LmZhY2V0LmlkXSB8fCAoZmFjZXRzW2V4dC5mYWNldC5pZF0gPSBbXSkpLnB1c2goZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYWRkcmVzcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGxldCBzdGF0aWNWYWx1ZXMgPSBbXTtcbiAgICAgICAgbGV0IGR5bmFtaWNTbG90cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBmaWVsZCBvZiBmaWVsZHMpIHtcbiAgICAgICAgICAgIGFkZHJlc3NbZmllbGQuaWRdID0gZHluYW1pY1Nsb3RzLmxlbmd0aCA8PCAxO1xuICAgICAgICAgICAgZHluYW1pY1Nsb3RzLnB1c2goYSA9PiBmaWVsZC5zbG90KGEpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpZCBpbiBmYWNldHMpIHtcbiAgICAgICAgICAgIGxldCBwcm92aWRlcnMgPSBmYWNldHNbaWRdLCBmYWNldCA9IHByb3ZpZGVyc1swXS5mYWNldDtcbiAgICAgICAgICAgIGlmIChwcm92aWRlcnMuZXZlcnkocCA9PiBwLnR5cGUgPT0gMCAvKiBTdGF0aWMgKi8pKSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzc1tmYWNldC5pZF0gPSAoc3RhdGljVmFsdWVzLmxlbmd0aCA8PCAxKSB8IDE7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gZmFjZXQuY29tYmluZShwcm92aWRlcnMubWFwKHAgPT4gcC52YWx1ZSkpO1xuICAgICAgICAgICAgICAgIGxldCBvbGRBZGRyID0gb2xkU3RhdGUgPyBvbGRTdGF0ZS5jb25maWcuYWRkcmVzc1tmYWNldC5pZF0gOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChvbGRBZGRyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9sZFZhbCA9IGdldEFkZHIob2xkU3RhdGUsIG9sZEFkZHIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmFjZXQuY29tcGFyZSh2YWx1ZSwgb2xkVmFsKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gb2xkVmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGF0aWNWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwIG9mIHByb3ZpZGVycykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocC50eXBlID09IDAgLyogU3RhdGljICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzW3AuaWRdID0gKHN0YXRpY1ZhbHVlcy5sZW5ndGggPDwgMSkgfCAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljVmFsdWVzLnB1c2gocC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzW3AuaWRdID0gZHluYW1pY1Nsb3RzLmxlbmd0aCA8PCAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgZHluYW1pY1Nsb3RzLnB1c2goYSA9PiBwLmR5bmFtaWNTbG90KGEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRyZXNzW2ZhY2V0LmlkXSA9IGR5bmFtaWNTbG90cy5sZW5ndGggPDwgMTtcbiAgICAgICAgICAgICAgICBkeW5hbWljU2xvdHMucHVzaChhID0+IGR5bmFtaWNGYWNldFNsb3QoYSwgZmFjZXQsIHByb3ZpZGVycykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ29uZmlndXJhdGlvbihiYXNlLCBuZXdDb21wYXJ0bWVudHMsIGR5bmFtaWNTbG90cy5tYXAoZiA9PiBmKGFkZHJlc3MpKSwgYWRkcmVzcywgc3RhdGljVmFsdWVzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBmbGF0dGVuKGV4dGVuc2lvbiwgY29tcGFydG1lbnRzLCBuZXdDb21wYXJ0bWVudHMpIHtcbiAgICBsZXQgcmVzdWx0ID0gW1tdLCBbXSwgW10sIFtdXTtcbiAgICBsZXQgc2VlbiA9IG5ldyBNYXAoKTtcbiAgICBmdW5jdGlvbiBpbm5lcihleHQsIHByZWMpIHtcbiAgICAgICAgbGV0IGtub3duID0gc2Vlbi5nZXQoZXh0KTtcbiAgICAgICAgaWYgKGtub3duICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChrbm93biA+PSBwcmVjKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IHJlc3VsdFtrbm93bl0uaW5kZXhPZihleHQpO1xuICAgICAgICAgICAgaWYgKGZvdW5kID4gLTEpXG4gICAgICAgICAgICAgICAgcmVzdWx0W2tub3duXS5zcGxpY2UoZm91bmQsIDEpO1xuICAgICAgICAgICAgaWYgKGV4dCBpbnN0YW5jZW9mIENvbXBhcnRtZW50SW5zdGFuY2UpXG4gICAgICAgICAgICAgICAgbmV3Q29tcGFydG1lbnRzLmRlbGV0ZShleHQuY29tcGFydG1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHNlZW4uc2V0KGV4dCwgcHJlYyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGV4dCkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGUgb2YgZXh0KVxuICAgICAgICAgICAgICAgIGlubmVyKGUsIHByZWMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4dCBpbnN0YW5jZW9mIENvbXBhcnRtZW50SW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGlmIChuZXdDb21wYXJ0bWVudHMuaGFzKGV4dC5jb21wYXJ0bWVudCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYER1cGxpY2F0ZSB1c2Ugb2YgY29tcGFydG1lbnQgaW4gZXh0ZW5zaW9uc2ApO1xuICAgICAgICAgICAgbGV0IGNvbnRlbnQgPSBjb21wYXJ0bWVudHMuZ2V0KGV4dC5jb21wYXJ0bWVudCkgfHwgZXh0LmlubmVyO1xuICAgICAgICAgICAgbmV3Q29tcGFydG1lbnRzLnNldChleHQuY29tcGFydG1lbnQsIGNvbnRlbnQpO1xuICAgICAgICAgICAgaW5uZXIoY29udGVudCwgcHJlYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXh0IGluc3RhbmNlb2YgUHJlY0V4dGVuc2lvbikge1xuICAgICAgICAgICAgaW5uZXIoZXh0LmlubmVyLCBleHQucHJlYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXh0IGluc3RhbmNlb2YgU3RhdGVGaWVsZCkge1xuICAgICAgICAgICAgcmVzdWx0W3ByZWNdLnB1c2goZXh0KTtcbiAgICAgICAgICAgIGlmIChleHQucHJvdmlkZXMpXG4gICAgICAgICAgICAgICAgaW5uZXIoZXh0LnByb3ZpZGVzLCBwcmVjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHQgaW5zdGFuY2VvZiBGYWNldFByb3ZpZGVyKSB7XG4gICAgICAgICAgICByZXN1bHRbcHJlY10ucHVzaChleHQpO1xuICAgICAgICAgICAgaWYgKGV4dC5mYWNldC5leHRlbnNpb25zKVxuICAgICAgICAgICAgICAgIGlubmVyKGV4dC5mYWNldC5leHRlbnNpb25zLCBwcmVjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBjb250ZW50ID0gZXh0LmV4dGVuc2lvbjtcbiAgICAgICAgICAgIGlmICghY29udGVudClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBleHRlbnNpb24gdmFsdWUgaW4gZXh0ZW5zaW9uIHNldCAoJHtleHR9KS4gVGhpcyBzb21ldGltZXMgaGFwcGVucyBiZWNhdXNlIG11bHRpcGxlIGluc3RhbmNlcyBvZiBAY29kZW1pcnJvci9zdGF0ZSBhcmUgbG9hZGVkLCBicmVha2luZyBpbnN0YW5jZW9mIGNoZWNrcy5gKTtcbiAgICAgICAgICAgIGlubmVyKGNvbnRlbnQsIHByZWMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlubmVyKGV4dGVuc2lvbiwgUHJlY18uZGVmYXVsdCk7XG4gICAgcmV0dXJuIHJlc3VsdC5yZWR1Y2UoKGEsIGIpID0+IGEuY29uY2F0KGIpKTtcbn1cbmZ1bmN0aW9uIGVuc3VyZUFkZHIoc3RhdGUsIGFkZHIpIHtcbiAgICBpZiAoYWRkciAmIDEpXG4gICAgICAgIHJldHVybiAyIC8qIENvbXB1dGVkICovO1xuICAgIGxldCBpZHggPSBhZGRyID4+IDE7XG4gICAgbGV0IHN0YXR1cyA9IHN0YXRlLnN0YXR1c1tpZHhdO1xuICAgIGlmIChzdGF0dXMgPT0gNCAvKiBDb21wdXRpbmcgKi8pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkN5Y2xpYyBkZXBlbmRlbmN5IGJldHdlZW4gZmllbGRzIGFuZC9vciBmYWNldHNcIik7XG4gICAgaWYgKHN0YXR1cyAmIDIgLyogQ29tcHV0ZWQgKi8pXG4gICAgICAgIHJldHVybiBzdGF0dXM7XG4gICAgc3RhdGUuc3RhdHVzW2lkeF0gPSA0IC8qIENvbXB1dGluZyAqLztcbiAgICBsZXQgY2hhbmdlZCA9IHN0YXRlLmNvbmZpZy5keW5hbWljU2xvdHNbaWR4XShzdGF0ZSwgc3RhdGUuYXBwbHlpbmcpO1xuICAgIHJldHVybiBzdGF0ZS5zdGF0dXNbaWR4XSA9IDIgLyogQ29tcHV0ZWQgKi8gfCBjaGFuZ2VkO1xufVxuZnVuY3Rpb24gZ2V0QWRkcihzdGF0ZSwgYWRkcikge1xuICAgIHJldHVybiBhZGRyICYgMSA/IHN0YXRlLmNvbmZpZy5zdGF0aWNWYWx1ZXNbYWRkciA+PiAxXSA6IHN0YXRlLnZhbHVlc1thZGRyID4+IDFdO1xufVxuXG5jb25zdCBsYW5ndWFnZURhdGEgPSBGYWNldC5kZWZpbmUoKTtcbmNvbnN0IGFsbG93TXVsdGlwbGVTZWxlY3Rpb25zID0gRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLnNvbWUodiA9PiB2KSxcbiAgICBzdGF0aWM6IHRydWVcbn0pO1xuY29uc3QgbGluZVNlcGFyYXRvciA9IEZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5sZW5ndGggPyB2YWx1ZXNbMF0gOiB1bmRlZmluZWQsXG4gICAgc3RhdGljOiB0cnVlXG59KTtcbmNvbnN0IGNoYW5nZUZpbHRlciA9IEZhY2V0LmRlZmluZSgpO1xuY29uc3QgdHJhbnNhY3Rpb25GaWx0ZXIgPSBGYWNldC5kZWZpbmUoKTtcbmNvbnN0IHRyYW5zYWN0aW9uRXh0ZW5kZXIgPSBGYWNldC5kZWZpbmUoKTtcblxuLyoqXG5Bbm5vdGF0aW9ucyBhcmUgdGFnZ2VkIHZhbHVlcyB0aGF0IGFyZSB1c2VkIHRvIGFkZCBtZXRhZGF0YSB0b1xudHJhbnNhY3Rpb25zIGluIGFuIGV4dGVuc2libGUgd2F5LiBUaGV5IHNob3VsZCBiZSB1c2VkIHRvIG1vZGVsXG50aGluZ3MgdGhhdCBlZmZlY3QgdGhlIGVudGlyZSB0cmFuc2FjdGlvbiAoc3VjaCBhcyBpdHMgW3RpbWVcbnN0YW1wXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uXnRpbWUpIG9yIGluZm9ybWF0aW9uIGFib3V0IGl0c1xuW29yaWdpbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbl51c2VyRXZlbnQpKS4gRm9yIGVmZmVjdHMgdGhhdCBoYXBwZW5cbl9hbG9uZ3NpZGVfIHRoZSBvdGhlciBjaGFuZ2VzIG1hZGUgYnkgdGhlIHRyYW5zYWN0aW9uLCBbc3RhdGVcbmVmZmVjdHNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVFZmZlY3QpIGFyZSBtb3JlIGFwcHJvcHJpYXRlLlxuKi9cbmNsYXNzIEFubm90YXRpb24ge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGFubm90YXRpb24gdHlwZS5cbiAgICAqL1xuICAgIHR5cGUsIFxuICAgIC8qKlxuICAgIFRoZSB2YWx1ZSBvZiB0aGlzIGFubm90YXRpb24uXG4gICAgKi9cbiAgICB2YWx1ZSkge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIG5ldyB0eXBlIG9mIGFubm90YXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKCkgeyByZXR1cm4gbmV3IEFubm90YXRpb25UeXBlKCk7IH1cbn1cbi8qKlxuTWFya2VyIHRoYXQgaWRlbnRpZmllcyBhIHR5cGUgb2YgW2Fubm90YXRpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQW5ub3RhdGlvbikuXG4qL1xuY2xhc3MgQW5ub3RhdGlvblR5cGUge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGFubm90YXRpb24uXG4gICAgKi9cbiAgICBvZih2YWx1ZSkgeyByZXR1cm4gbmV3IEFubm90YXRpb24odGhpcywgdmFsdWUpOyB9XG59XG4vKipcblJlcHJlc2VudGF0aW9uIG9mIGEgdHlwZSBvZiBzdGF0ZSBlZmZlY3QuIERlZmluZWQgd2l0aFxuW2BTdGF0ZUVmZmVjdC5kZWZpbmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRWZmZWN0XmRlZmluZSkuXG4qL1xuY2xhc3MgU3RhdGVFZmZlY3RUeXBlIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vIFRoZSBgYW55YCB0eXBlcyBpbiB0aGVzZSBmdW5jdGlvbiB0eXBlcyBhcmUgdGhlcmUgdG8gd29ya1xuICAgIC8vIGFyb3VuZCBUeXBlU2NyaXB0IGlzc3VlICMzNzYzMSwgd2hlcmUgdGhlIHR5cGUgZ3VhcmQgb25cbiAgICAvLyBgU3RhdGVFZmZlY3QuaXNgIG15c3RlcmlvdXNseSBzdG9wcyB3b3JraW5nIHdoZW4gdGhlc2UgcHJvcGVybHlcbiAgICAvLyBoYXZlIHR5cGUgYFZhbHVlYC5cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG1hcCkge1xuICAgICAgICB0aGlzLm1hcCA9IG1hcDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgW3N0YXRlIGVmZmVjdF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUVmZmVjdCkgaW5zdGFuY2Ugb2YgdGhpc1xuICAgIHR5cGUuXG4gICAgKi9cbiAgICBvZih2YWx1ZSkgeyByZXR1cm4gbmV3IFN0YXRlRWZmZWN0KHRoaXMsIHZhbHVlKTsgfVxufVxuLyoqXG5TdGF0ZSBlZmZlY3RzIGNhbiBiZSB1c2VkIHRvIHJlcHJlc2VudCBhZGRpdGlvbmFsIGVmZmVjdHNcbmFzc29jaWF0ZWQgd2l0aCBhIFt0cmFuc2FjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbi5lZmZlY3RzKS4gVGhleVxuYXJlIG9mdGVuIHVzZWZ1bCB0byBtb2RlbCBjaGFuZ2VzIHRvIGN1c3RvbSBbc3RhdGVcbmZpZWxkc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUZpZWxkKSwgd2hlbiB0aG9zZSBjaGFuZ2VzIGFyZW4ndCBpbXBsaWNpdCBpblxuZG9jdW1lbnQgb3Igc2VsZWN0aW9uIGNoYW5nZXMuXG4qL1xuY2xhc3MgU3RhdGVFZmZlY3Qge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0eXBlLCBcbiAgICAvKipcbiAgICBUaGUgdmFsdWUgb2YgdGhpcyBlZmZlY3QuXG4gICAgKi9cbiAgICB2YWx1ZSkge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hcCB0aGlzIGVmZmVjdCB0aHJvdWdoIGEgcG9zaXRpb24gbWFwcGluZy4gV2lsbCByZXR1cm5cbiAgICBgdW5kZWZpbmVkYCB3aGVuIHRoYXQgZW5kcyB1cCBkZWxldGluZyB0aGUgZWZmZWN0LlxuICAgICovXG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgbGV0IG1hcHBlZCA9IHRoaXMudHlwZS5tYXAodGhpcy52YWx1ZSwgbWFwcGluZyk7XG4gICAgICAgIHJldHVybiBtYXBwZWQgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG1hcHBlZCA9PSB0aGlzLnZhbHVlID8gdGhpcyA6IG5ldyBTdGF0ZUVmZmVjdCh0aGlzLnR5cGUsIG1hcHBlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlbGxzIHlvdSB3aGV0aGVyIHRoaXMgZWZmZWN0IG9iamVjdCBpcyBvZiBhIGdpdmVuXG4gICAgW3R5cGVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVFZmZlY3RUeXBlKS5cbiAgICAqL1xuICAgIGlzKHR5cGUpIHsgcmV0dXJuIHRoaXMudHlwZSA9PSB0eXBlOyB9XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgbmV3IGVmZmVjdCB0eXBlLiBUaGUgdHlwZSBwYXJhbWV0ZXIgaW5kaWNhdGVzIHRoZSB0eXBlXG4gICAgb2YgdmFsdWVzIHRoYXQgaGlzIGVmZmVjdCBob2xkcy5cbiAgICAqL1xuICAgIHN0YXRpYyBkZWZpbmUoc3BlYyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RhdGVFZmZlY3RUeXBlKHNwZWMubWFwIHx8ICh2ID0+IHYpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTWFwIGFuIGFycmF5IG9mIGVmZmVjdHMgdGhyb3VnaCBhIGNoYW5nZSBzZXQuXG4gICAgKi9cbiAgICBzdGF0aWMgbWFwRWZmZWN0cyhlZmZlY3RzLCBtYXBwaW5nKSB7XG4gICAgICAgIGlmICghZWZmZWN0cy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZWZmZWN0cztcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgICAgICAgbGV0IG1hcHBlZCA9IGVmZmVjdC5tYXAobWFwcGluZyk7XG4gICAgICAgICAgICBpZiAobWFwcGVkKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG1hcHBlZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vKipcblRoaXMgZWZmZWN0IGNhbiBiZSB1c2VkIHRvIHJlY29uZmlndXJlIHRoZSByb290IGV4dGVuc2lvbnMgb2ZcbnRoZSBlZGl0b3IuIERvaW5nIHRoaXMgd2lsbCBkaXNjYXJkIGFueSBleHRlbnNpb25zXG5bYXBwZW5kZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVFZmZlY3ReYXBwZW5kQ29uZmlnKSwgYnV0IGRvZXMgbm90IHJlc2V0XG50aGUgY29udGVudCBvZiBbcmVjb25maWd1cmVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNvbXBhcnRtZW50LnJlY29uZmlndXJlKVxuY29tcGFydG1lbnRzLlxuKi9cblN0YXRlRWZmZWN0LnJlY29uZmlndXJlID0gU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG4vKipcbkFwcGVuZCBleHRlbnNpb25zIHRvIHRoZSB0b3AtbGV2ZWwgY29uZmlndXJhdGlvbiBvZiB0aGUgZWRpdG9yLlxuKi9cblN0YXRlRWZmZWN0LmFwcGVuZENvbmZpZyA9IFN0YXRlRWZmZWN0LmRlZmluZSgpO1xuLyoqXG5DaGFuZ2VzIHRvIHRoZSBlZGl0b3Igc3RhdGUgYXJlIGdyb3VwZWQgaW50byB0cmFuc2FjdGlvbnMuXG5UeXBpY2FsbHksIGEgdXNlciBhY3Rpb24gY3JlYXRlcyBhIHNpbmdsZSB0cmFuc2FjdGlvbiwgd2hpY2ggbWF5XG5jb250YWluIGFueSBudW1iZXIgb2YgZG9jdW1lbnQgY2hhbmdlcywgbWF5IGNoYW5nZSB0aGUgc2VsZWN0aW9uLFxub3IgaGF2ZSBvdGhlciBlZmZlY3RzLiBDcmVhdGUgYSB0cmFuc2FjdGlvbiBieSBjYWxsaW5nXG5bYEVkaXRvclN0YXRlLnVwZGF0ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUudXBkYXRlKS5cbiovXG5jbGFzcyBUcmFuc2FjdGlvbiB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc3RhdGUgZnJvbSB3aGljaCB0aGUgdHJhbnNhY3Rpb24gc3RhcnRzLlxuICAgICovXG4gICAgc3RhcnRTdGF0ZSwgXG4gICAgLyoqXG4gICAgVGhlIGRvY3VtZW50IGNoYW5nZXMgbWFkZSBieSB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICovXG4gICAgY2hhbmdlcywgXG4gICAgLyoqXG4gICAgVGhlIHNlbGVjdGlvbiBzZXQgYnkgdGhpcyB0cmFuc2FjdGlvbiwgb3IgdW5kZWZpbmVkIGlmIGl0XG4gICAgZG9lc24ndCBleHBsaWNpdGx5IHNldCBhIHNlbGVjdGlvbi5cbiAgICAqL1xuICAgIHNlbGVjdGlvbiwgXG4gICAgLyoqXG4gICAgVGhlIGVmZmVjdHMgYWRkZWQgdG8gdGhlIHRyYW5zYWN0aW9uLlxuICAgICovXG4gICAgZWZmZWN0cywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBhbm5vdGF0aW9ucywgXG4gICAgLyoqXG4gICAgV2hldGhlciB0aGUgc2VsZWN0aW9uIHNob3VsZCBiZSBzY3JvbGxlZCBpbnRvIHZpZXcgYWZ0ZXIgdGhpc1xuICAgIHRyYW5zYWN0aW9uIGlzIGRpc3BhdGNoZWQuXG4gICAgKi9cbiAgICBzY3JvbGxJbnRvVmlldykge1xuICAgICAgICB0aGlzLnN0YXJ0U3RhdGUgPSBzdGFydFN0YXRlO1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBjaGFuZ2VzO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbiAgICAgICAgdGhpcy5lZmZlY3RzID0gZWZmZWN0cztcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9ucyA9IGFubm90YXRpb25zO1xuICAgICAgICB0aGlzLnNjcm9sbEludG9WaWV3ID0gc2Nyb2xsSW50b1ZpZXc7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZG9jID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IG51bGw7XG4gICAgICAgIGlmIChzZWxlY3Rpb24pXG4gICAgICAgICAgICBjaGVja1NlbGVjdGlvbihzZWxlY3Rpb24sIGNoYW5nZXMubmV3TGVuZ3RoKTtcbiAgICAgICAgaWYgKCFhbm5vdGF0aW9ucy5zb21lKChhKSA9PiBhLnR5cGUgPT0gVHJhbnNhY3Rpb24udGltZSkpXG4gICAgICAgICAgICB0aGlzLmFubm90YXRpb25zID0gYW5ub3RhdGlvbnMuY29uY2F0KFRyYW5zYWN0aW9uLnRpbWUub2YoRGF0ZS5ub3coKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgbmV3IGRvY3VtZW50IHByb2R1Y2VkIGJ5IHRoZSB0cmFuc2FjdGlvbi4gQ29udHJhcnkgdG9cbiAgICBbYC5zdGF0ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24uc3RhdGUpYC5kb2NgLCBhY2Nlc3NpbmcgdGhpcyB3b24ndFxuICAgIGZvcmNlIHRoZSBlbnRpcmUgbmV3IHN0YXRlIHRvIGJlIGNvbXB1dGVkIHJpZ2h0IGF3YXksIHNvIGl0IGlzXG4gICAgcmVjb21tZW5kZWQgdGhhdCBbdHJhbnNhY3Rpb25cbiAgICBmaWx0ZXJzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXnRyYW5zYWN0aW9uRmlsdGVyKSB1c2UgdGhpcyBnZXR0ZXJcbiAgICB3aGVuIHRoZXkgbmVlZCB0byBsb29rIGF0IHRoZSBuZXcgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBnZXQgbmV3RG9jKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZG9jIHx8ICh0aGlzLl9kb2MgPSB0aGlzLmNoYW5nZXMuYXBwbHkodGhpcy5zdGFydFN0YXRlLmRvYykpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgbmV3IHNlbGVjdGlvbiBwcm9kdWNlZCBieSB0aGUgdHJhbnNhY3Rpb24uIElmXG4gICAgW2B0aGlzLnNlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24uc2VsZWN0aW9uKSBpcyB1bmRlZmluZWQsXG4gICAgdGhpcyB3aWxsIFttYXBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU2VsZWN0aW9uLm1hcCkgdGhlIHN0YXJ0IHN0YXRlJ3NcbiAgICBjdXJyZW50IHNlbGVjdGlvbiB0aHJvdWdoIHRoZSBjaGFuZ2VzIG1hZGUgYnkgdGhlIHRyYW5zYWN0aW9uLlxuICAgICovXG4gICAgZ2V0IG5ld1NlbGVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uIHx8IHRoaXMuc3RhcnRTdGF0ZS5zZWxlY3Rpb24ubWFwKHRoaXMuY2hhbmdlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBuZXcgc3RhdGUgY3JlYXRlZCBieSB0aGUgdHJhbnNhY3Rpb24uIENvbXB1dGVkIG9uIGRlbWFuZFxuICAgIChidXQgcmV0YWluZWQgZm9yIHN1YnNlcXVlbnQgYWNjZXNzKSwgc28gaXRpcyByZWNvbW1lbmRlZCBub3QgdG9cbiAgICBhY2Nlc3MgaXQgaW4gW3RyYW5zYWN0aW9uXG4gICAgZmlsdGVyc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV50cmFuc2FjdGlvbkZpbHRlcikgd2hlbiBwb3NzaWJsZS5cbiAgICAqL1xuICAgIGdldCBzdGF0ZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zdGF0ZSlcbiAgICAgICAgICAgIHRoaXMuc3RhcnRTdGF0ZS5hcHBseVRyYW5zYWN0aW9uKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgdmFsdWUgb2YgdGhlIGdpdmVuIGFubm90YXRpb24gdHlwZSwgaWYgYW55LlxuICAgICovXG4gICAgYW5ub3RhdGlvbih0eXBlKSB7XG4gICAgICAgIGZvciAobGV0IGFubiBvZiB0aGlzLmFubm90YXRpb25zKVxuICAgICAgICAgICAgaWYgKGFubi50eXBlID09IHR5cGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFubi52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHRyYW5zYWN0aW9uIGNoYW5nZWQgdGhlIGRvY3VtZW50LlxuICAgICovXG4gICAgZ2V0IGRvY0NoYW5nZWQoKSB7IHJldHVybiAhdGhpcy5jaGFuZ2VzLmVtcHR5OyB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyB0cmFuc2FjdGlvbiByZWNvbmZpZ3VyZXMgdGhlIHN0YXRlXG4gICAgKHRocm91Z2ggYSBbY29uZmlndXJhdGlvbiBjb21wYXJ0bWVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5Db21wYXJ0bWVudCkgb3JcbiAgICB3aXRoIGEgdG9wLWxldmVsIGNvbmZpZ3VyYXRpb25cbiAgICBbZWZmZWN0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRWZmZWN0XnJlY29uZmlndXJlKS5cbiAgICAqL1xuICAgIGdldCByZWNvbmZpZ3VyZWQoKSB7IHJldHVybiB0aGlzLnN0YXJ0U3RhdGUuY29uZmlnICE9IHRoaXMuc3RhdGUuY29uZmlnOyB9XG59XG4vKipcbkFubm90YXRpb24gdXNlZCB0byBzdG9yZSB0cmFuc2FjdGlvbiB0aW1lc3RhbXBzLlxuKi9cblRyYW5zYWN0aW9uLnRpbWUgPSBBbm5vdGF0aW9uLmRlZmluZSgpO1xuLyoqXG5Bbm5vdGF0aW9uIHVzZWQgdG8gYXNzb2NpYXRlIGEgdHJhbnNhY3Rpb24gd2l0aCBhIHVzZXIgaW50ZXJmYWNlXG5ldmVudC4gVGhlIHZpZXcgd2lsbCBzZXQgdGhpcyB0by4uLlxuXG4gLSBgXCJpbnB1dFwiYCB3aGVuIHRoZSB1c2VyIHR5cGVzIHRleHRcbiAtIGBcImRlbGV0ZVwiYCB3aGVuIHRoZSB1c2VyIGRlbGV0ZXMgdGhlIHNlbGVjdGlvbiBvciB0ZXh0IG5lYXIgdGhlIHNlbGVjdGlvblxuIC0gYFwia2V5Ym9hcmRzZWxlY3Rpb25cImAgd2hlbiBtb3ZpbmcgdGhlIHNlbGVjdGlvbiB2aWEgdGhlIGtleWJvYXJkXG4gLSBgXCJwb2ludGVyc2VsZWN0aW9uXCJgIHdoZW4gbW92aW5nIHRoZSBzZWxlY3Rpb24gdGhyb3VnaCB0aGUgcG9pbnRpbmcgZGV2aWNlXG4gLSBgXCJwYXN0ZVwiYCB3aGVuIHBhc3RpbmcgY29udGVudFxuIC0gYFwiY3V0XCJgIHdoZW4gY3V0dGluZ1xuIC0gYFwiZHJvcFwiYCB3aGVuIGNvbnRlbnQgaXMgaW5zZXJ0ZWQgdmlhIGRyYWctYW5kLWRyb3BcbiovXG5UcmFuc2FjdGlvbi51c2VyRXZlbnQgPSBBbm5vdGF0aW9uLmRlZmluZSgpO1xuLyoqXG5Bbm5vdGF0aW9uIGluZGljYXRpbmcgd2hldGhlciBhIHRyYW5zYWN0aW9uIHNob3VsZCBiZSBhZGRlZCB0b1xudGhlIHVuZG8gaGlzdG9yeSBvciBub3QuXG4qL1xuVHJhbnNhY3Rpb24uYWRkVG9IaXN0b3J5ID0gQW5ub3RhdGlvbi5kZWZpbmUoKTtcbi8qKlxuQW5ub3RhdGlvbiBpbmRpY2F0aW5nICh3aGVuIHByZXNlbnQgYW5kIHRydWUpIHRoYXQgYSB0cmFuc2FjdGlvblxucmVwcmVzZW50cyBhIGNoYW5nZSBtYWRlIGJ5IHNvbWUgb3RoZXIgYWN0b3IsIG5vdCB0aGUgdXNlci4gVGhpc1xuaXMgdXNlZCwgZm9yIGV4YW1wbGUsIHRvIHRhZyBvdGhlciBwZW9wbGUncyBjaGFuZ2VzIGluXG5jb2xsYWJvcmF0aXZlIGVkaXRpbmcuXG4qL1xuVHJhbnNhY3Rpb24ucmVtb3RlID0gQW5ub3RhdGlvbi5kZWZpbmUoKTtcbmZ1bmN0aW9uIGpvaW5SYW5nZXMoYSwgYikge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpQSA9IDAsIGlCID0gMDs7KSB7XG4gICAgICAgIGxldCBmcm9tLCB0bztcbiAgICAgICAgaWYgKGlBIDwgYS5sZW5ndGggJiYgKGlCID09IGIubGVuZ3RoIHx8IGJbaUJdID49IGFbaUFdKSkge1xuICAgICAgICAgICAgZnJvbSA9IGFbaUErK107XG4gICAgICAgICAgICB0byA9IGFbaUErK107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaUIgPCBiLmxlbmd0aCkge1xuICAgICAgICAgICAgZnJvbSA9IGJbaUIrK107XG4gICAgICAgICAgICB0byA9IGJbaUIrK107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgaWYgKCFyZXN1bHQubGVuZ3RoIHx8IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPCBmcm9tKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJvbSwgdG8pO1xuICAgICAgICBlbHNlIGlmIChyZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdIDwgdG8pXG4gICAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID0gdG87XG4gICAgfVxufVxuZnVuY3Rpb24gbWVyZ2VUcmFuc2FjdGlvbihhLCBiLCBzZXF1ZW50aWFsKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBtYXBGb3JBLCBtYXBGb3JCLCBjaGFuZ2VzO1xuICAgIGlmIChzZXF1ZW50aWFsKSB7XG4gICAgICAgIG1hcEZvckEgPSBiLmNoYW5nZXM7XG4gICAgICAgIG1hcEZvckIgPSBDaGFuZ2VTZXQuZW1wdHkoYi5jaGFuZ2VzLmxlbmd0aCk7XG4gICAgICAgIGNoYW5nZXMgPSBhLmNoYW5nZXMuY29tcG9zZShiLmNoYW5nZXMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbWFwRm9yQSA9IGIuY2hhbmdlcy5tYXAoYS5jaGFuZ2VzKTtcbiAgICAgICAgbWFwRm9yQiA9IGEuY2hhbmdlcy5tYXBEZXNjKGIuY2hhbmdlcywgdHJ1ZSk7XG4gICAgICAgIGNoYW5nZXMgPSBhLmNoYW5nZXMuY29tcG9zZShtYXBGb3JBKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2hhbmdlcyxcbiAgICAgICAgc2VsZWN0aW9uOiBiLnNlbGVjdGlvbiA/IGIuc2VsZWN0aW9uLm1hcChtYXBGb3JCKSA6IChfYSA9IGEuc2VsZWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKG1hcEZvckEpLFxuICAgICAgICBlZmZlY3RzOiBTdGF0ZUVmZmVjdC5tYXBFZmZlY3RzKGEuZWZmZWN0cywgbWFwRm9yQSkuY29uY2F0KFN0YXRlRWZmZWN0Lm1hcEVmZmVjdHMoYi5lZmZlY3RzLCBtYXBGb3JCKSksXG4gICAgICAgIGFubm90YXRpb25zOiBhLmFubm90YXRpb25zLmxlbmd0aCA/IGEuYW5ub3RhdGlvbnMuY29uY2F0KGIuYW5ub3RhdGlvbnMpIDogYi5hbm5vdGF0aW9ucyxcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IGEuc2Nyb2xsSW50b1ZpZXcgfHwgYi5zY3JvbGxJbnRvVmlld1xuICAgIH07XG59XG5mdW5jdGlvbiByZXNvbHZlVHJhbnNhY3Rpb25Jbm5lcihzdGF0ZSwgc3BlYywgZG9jU2l6ZSkge1xuICAgIGxldCBzZWwgPSBzcGVjLnNlbGVjdGlvbjtcbiAgICByZXR1cm4ge1xuICAgICAgICBjaGFuZ2VzOiBzcGVjLmNoYW5nZXMgaW5zdGFuY2VvZiBDaGFuZ2VTZXQgPyBzcGVjLmNoYW5nZXNcbiAgICAgICAgICAgIDogQ2hhbmdlU2V0Lm9mKHNwZWMuY2hhbmdlcyB8fCBbXSwgZG9jU2l6ZSwgc3RhdGUuZmFjZXQobGluZVNlcGFyYXRvcikpLFxuICAgICAgICBzZWxlY3Rpb246IHNlbCAmJiAoc2VsIGluc3RhbmNlb2YgRWRpdG9yU2VsZWN0aW9uID8gc2VsIDogRWRpdG9yU2VsZWN0aW9uLnNpbmdsZShzZWwuYW5jaG9yLCBzZWwuaGVhZCkpLFxuICAgICAgICBlZmZlY3RzOiBhc0FycmF5KHNwZWMuZWZmZWN0cyksXG4gICAgICAgIGFubm90YXRpb25zOiBhc0FycmF5KHNwZWMuYW5ub3RhdGlvbnMpLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogISFzcGVjLnNjcm9sbEludG9WaWV3XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2FjdGlvbihzdGF0ZSwgc3BlY3MsIGZpbHRlcikge1xuICAgIGxldCBzID0gcmVzb2x2ZVRyYW5zYWN0aW9uSW5uZXIoc3RhdGUsIHNwZWNzLmxlbmd0aCA/IHNwZWNzWzBdIDoge30sIHN0YXRlLmRvYy5sZW5ndGgpO1xuICAgIGlmIChzcGVjcy5sZW5ndGggJiYgc3BlY3NbMF0uZmlsdGVyID09PSBmYWxzZSlcbiAgICAgICAgZmlsdGVyID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzcGVjcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc3BlY3NbaV0uZmlsdGVyID09PSBmYWxzZSlcbiAgICAgICAgICAgIGZpbHRlciA9IGZhbHNlO1xuICAgICAgICBsZXQgc2VxID0gISFzcGVjc1tpXS5zZXF1ZW50aWFsO1xuICAgICAgICBzID0gbWVyZ2VUcmFuc2FjdGlvbihzLCByZXNvbHZlVHJhbnNhY3Rpb25Jbm5lcihzdGF0ZSwgc3BlY3NbaV0sIHNlcSA/IHMuY2hhbmdlcy5uZXdMZW5ndGggOiBzdGF0ZS5kb2MubGVuZ3RoKSwgc2VxKTtcbiAgICB9XG4gICAgbGV0IHRyID0gbmV3IFRyYW5zYWN0aW9uKHN0YXRlLCBzLmNoYW5nZXMsIHMuc2VsZWN0aW9uLCBzLmVmZmVjdHMsIHMuYW5ub3RhdGlvbnMsIHMuc2Nyb2xsSW50b1ZpZXcpO1xuICAgIHJldHVybiBleHRlbmRUcmFuc2FjdGlvbihmaWx0ZXIgPyBmaWx0ZXJUcmFuc2FjdGlvbih0cikgOiB0cik7XG59XG4vLyBGaW5pc2ggYSB0cmFuc2FjdGlvbiBieSBhcHBseWluZyBmaWx0ZXJzIGlmIG5lY2Vzc2FyeS5cbmZ1bmN0aW9uIGZpbHRlclRyYW5zYWN0aW9uKHRyKSB7XG4gICAgbGV0IHN0YXRlID0gdHIuc3RhcnRTdGF0ZTtcbiAgICAvLyBDaGFuZ2UgZmlsdGVyc1xuICAgIGxldCByZXN1bHQgPSB0cnVlO1xuICAgIGZvciAobGV0IGZpbHRlciBvZiBzdGF0ZS5mYWNldChjaGFuZ2VGaWx0ZXIpKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGZpbHRlcih0cik7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ID09PSB0cnVlID8gdmFsdWUgOiBqb2luUmFuZ2VzKHJlc3VsdCwgdmFsdWUpO1xuICAgIH1cbiAgICBpZiAocmVzdWx0ICE9PSB0cnVlKSB7XG4gICAgICAgIGxldCBjaGFuZ2VzLCBiYWNrO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYmFjayA9IHRyLmNoYW5nZXMuaW52ZXJ0ZWREZXNjO1xuICAgICAgICAgICAgY2hhbmdlcyA9IENoYW5nZVNldC5lbXB0eShzdGF0ZS5kb2MubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBmaWx0ZXJlZCA9IHRyLmNoYW5nZXMuZmlsdGVyKHJlc3VsdCk7XG4gICAgICAgICAgICBjaGFuZ2VzID0gZmlsdGVyZWQuY2hhbmdlcztcbiAgICAgICAgICAgIGJhY2sgPSBmaWx0ZXJlZC5maWx0ZXJlZC5pbnZlcnRlZERlc2M7XG4gICAgICAgIH1cbiAgICAgICAgdHIgPSBuZXcgVHJhbnNhY3Rpb24oc3RhdGUsIGNoYW5nZXMsIHRyLnNlbGVjdGlvbiAmJiB0ci5zZWxlY3Rpb24ubWFwKGJhY2spLCBTdGF0ZUVmZmVjdC5tYXBFZmZlY3RzKHRyLmVmZmVjdHMsIGJhY2spLCB0ci5hbm5vdGF0aW9ucywgdHIuc2Nyb2xsSW50b1ZpZXcpO1xuICAgIH1cbiAgICAvLyBUcmFuc2FjdGlvbiBmaWx0ZXJzXG4gICAgbGV0IGZpbHRlcnMgPSBzdGF0ZS5mYWNldCh0cmFuc2FjdGlvbkZpbHRlcik7XG4gICAgZm9yIChsZXQgaSA9IGZpbHRlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbGV0IGZpbHRlcmVkID0gZmlsdGVyc1tpXSh0cik7XG4gICAgICAgIGlmIChmaWx0ZXJlZCBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgdHIgPSBmaWx0ZXJlZDtcbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShmaWx0ZXJlZCkgJiYgZmlsdGVyZWQubGVuZ3RoID09IDEgJiYgZmlsdGVyZWRbMF0gaW5zdGFuY2VvZiBUcmFuc2FjdGlvbilcbiAgICAgICAgICAgIHRyID0gZmlsdGVyZWRbMF07XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRyID0gcmVzb2x2ZVRyYW5zYWN0aW9uKHN0YXRlLCBhc0FycmF5KGZpbHRlcmVkKSwgZmFsc2UpO1xuICAgIH1cbiAgICByZXR1cm4gdHI7XG59XG5mdW5jdGlvbiBleHRlbmRUcmFuc2FjdGlvbih0cikge1xuICAgIGxldCBzdGF0ZSA9IHRyLnN0YXJ0U3RhdGUsIGV4dGVuZGVycyA9IHN0YXRlLmZhY2V0KHRyYW5zYWN0aW9uRXh0ZW5kZXIpLCBzcGVjID0gdHI7XG4gICAgZm9yIChsZXQgaSA9IGV4dGVuZGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBsZXQgZXh0ZW5zaW9uID0gZXh0ZW5kZXJzW2ldKHRyKTtcbiAgICAgICAgaWYgKGV4dGVuc2lvbiAmJiBPYmplY3Qua2V5cyhleHRlbnNpb24pLmxlbmd0aClcbiAgICAgICAgICAgIHNwZWMgPSBtZXJnZVRyYW5zYWN0aW9uKHRyLCByZXNvbHZlVHJhbnNhY3Rpb25Jbm5lcihzdGF0ZSwgZXh0ZW5zaW9uLCB0ci5jaGFuZ2VzLm5ld0xlbmd0aCksIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gc3BlYyA9PSB0ciA/IHRyIDogbmV3IFRyYW5zYWN0aW9uKHN0YXRlLCB0ci5jaGFuZ2VzLCB0ci5zZWxlY3Rpb24sIHNwZWMuZWZmZWN0cywgc3BlYy5hbm5vdGF0aW9ucywgc3BlYy5zY3JvbGxJbnRvVmlldyk7XG59XG5jb25zdCBub25lID0gW107XG5mdW5jdGlvbiBhc0FycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyBub25lIDogQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG59XG5cbi8qKlxuVGhlIGNhdGVnb3JpZXMgcHJvZHVjZWQgYnkgYSBbY2hhcmFjdGVyXG5jYXRlZ29yaXplcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIpLiBUaGVzZSBhcmUgdXNlZFxuZG8gdGhpbmdzIGxpa2Ugc2VsZWN0aW5nIGJ5IHdvcmQuXG4qL1xuZXhwb3J0cy5DaGFyQ2F0ZWdvcnkgPSB2b2lkIDA7XG4oZnVuY3Rpb24gKENoYXJDYXRlZ29yeSkge1xuICAgIC8qKlxuICAgIFdvcmQgY2hhcmFjdGVycy5cbiAgICAqL1xuICAgIENoYXJDYXRlZ29yeVtDaGFyQ2F0ZWdvcnlbXCJXb3JkXCJdID0gMF0gPSBcIldvcmRcIjtcbiAgICAvKipcbiAgICBXaGl0ZXNwYWNlLlxuICAgICovXG4gICAgQ2hhckNhdGVnb3J5W0NoYXJDYXRlZ29yeVtcIlNwYWNlXCJdID0gMV0gPSBcIlNwYWNlXCI7XG4gICAgLyoqXG4gICAgQW55dGhpbmcgZWxzZS5cbiAgICAqL1xuICAgIENoYXJDYXRlZ29yeVtDaGFyQ2F0ZWdvcnlbXCJPdGhlclwiXSA9IDJdID0gXCJPdGhlclwiO1xufSkoZXhwb3J0cy5DaGFyQ2F0ZWdvcnkgfHwgKGV4cG9ydHMuQ2hhckNhdGVnb3J5ID0ge30pKTtcbmNvbnN0IG5vbkFTQ0lJU2luZ2xlQ2FzZVdvcmRDaGFyID0gL1tcXHUwMGRmXFx1MDU4N1xcdTA1OTAtXFx1MDVmNFxcdTA2MDAtXFx1MDZmZlxcdTMwNDAtXFx1MzA5ZlxcdTMwYTAtXFx1MzBmZlxcdTM0MDAtXFx1NGRiNVxcdTRlMDAtXFx1OWZjY1xcdWFjMDAtXFx1ZDdhZl0vO1xubGV0IHdvcmRDaGFyO1xudHJ5IHtcbiAgICB3b3JkQ2hhciA9IG5ldyBSZWdFeHAoXCJbXFxcXHB7QWxwaGFiZXRpY31cXFxccHtOdW1iZXJ9X11cIiwgXCJ1XCIpO1xufVxuY2F0Y2ggKF8pIHsgfVxuZnVuY3Rpb24gaGFzV29yZENoYXIoc3RyKSB7XG4gICAgaWYgKHdvcmRDaGFyKVxuICAgICAgICByZXR1cm4gd29yZENoYXIudGVzdChzdHIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBjaCA9IHN0cltpXTtcbiAgICAgICAgaWYgKC9cXHcvLnRlc3QoY2gpIHx8IGNoID4gXCJcXHg4MFwiICYmIChjaC50b1VwcGVyQ2FzZSgpICE9IGNoLnRvTG93ZXJDYXNlKCkgfHwgbm9uQVNDSUlTaW5nbGVDYXNlV29yZENoYXIudGVzdChjaCkpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIG1ha2VDYXRlZ29yaXplcih3b3JkQ2hhcnMpIHtcbiAgICByZXR1cm4gKGNoYXIpID0+IHtcbiAgICAgICAgaWYgKCEvXFxTLy50ZXN0KGNoYXIpKVxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQ2hhckNhdGVnb3J5LlNwYWNlO1xuICAgICAgICBpZiAoaGFzV29yZENoYXIoY2hhcikpXG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5DaGFyQ2F0ZWdvcnkuV29yZDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3JkQ2hhcnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoY2hhci5pbmRleE9mKHdvcmRDaGFyc1tpXSkgPiAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5DaGFyQ2F0ZWdvcnkuV29yZDtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuQ2hhckNhdGVnb3J5Lk90aGVyO1xuICAgIH07XG59XG5cbi8qKlxuVGhlIGVkaXRvciBzdGF0ZSBjbGFzcyBpcyBhIHBlcnNpc3RlbnQgKGltbXV0YWJsZSkgZGF0YSBzdHJ1Y3R1cmUuXG5UbyB1cGRhdGUgYSBzdGF0ZSwgeW91IFtjcmVhdGVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUudXBkYXRlKSBhXG5bdHJhbnNhY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24pLCB3aGljaCBwcm9kdWNlcyBhIF9uZXdfIHN0YXRlXG5pbnN0YW5jZSwgd2l0aG91dCBtb2RpZnlpbmcgdGhlIG9yaWdpbmFsIG9iamVjdC5cblxuQXMgc3VjaCwgX25ldmVyXyBtdXRhdGUgcHJvcGVydGllcyBvZiBhIHN0YXRlIGRpcmVjdGx5LiBUaGF0J2xsXG5qdXN0IGJyZWFrIHRoaW5ncy5cbiovXG5jbGFzcyBFZGl0b3JTdGF0ZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbmZpZywgXG4gICAgLyoqXG4gICAgVGhlIGN1cnJlbnQgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBkb2MsIFxuICAgIC8qKlxuICAgIFRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAgICAqL1xuICAgIHNlbGVjdGlvbiwgdHIgPSBudWxsKSB7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLmRvYyA9IGRvYztcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hcHBseWluZyA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gY29uZmlnLnN0YXR1c1RlbXBsYXRlLnNsaWNlKCk7XG4gICAgICAgIGlmICh0ciAmJiB0ci5zdGFydFN0YXRlLmNvbmZpZyA9PSBjb25maWcpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVzID0gdHIuc3RhcnRTdGF0ZS52YWx1ZXMuc2xpY2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVzID0gY29uZmlnLmR5bmFtaWNTbG90cy5tYXAoXyA9PiBudWxsKTtcbiAgICAgICAgICAgIC8vIENvcHkgb3ZlciBvbGQgdmFsdWVzIGZvciBzaGFyZWQgZmFjZXRzL2ZpZWxkcyBpZiB0aGlzIGlzIGEgcmVjb25maWd1cmVcbiAgICAgICAgICAgIGlmICh0cilcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpZCBpbiBjb25maWcuYWRkcmVzcykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY3VyID0gY29uZmlnLmFkZHJlc3NbaWRdLCBwcmV2ID0gdHIuc3RhcnRTdGF0ZS5jb25maWcuYWRkcmVzc1tpZF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2ICE9IG51bGwgJiYgKGN1ciAmIDEpID09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlc1tjdXIgPj4gMV0gPSBnZXRBZGRyKHRyLnN0YXJ0U3RhdGUsIHByZXYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFwcGx5aW5nID0gdHI7XG4gICAgICAgIC8vIEZpbGwgaW4gdGhlIGNvbXB1dGVkIHN0YXRlIGltbWVkaWF0ZWx5LCBzbyB0aGF0IGZ1cnRoZXIgcXVlcmllc1xuICAgICAgICAvLyBmb3IgaXQgbWFkZSBkdXJpbmcgdGhlIHVwZGF0ZSByZXR1cm4gdGhpcyBzdGF0ZVxuICAgICAgICBpZiAodHIpXG4gICAgICAgICAgICB0ci5fc3RhdGUgPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY29uZmlnLmR5bmFtaWNTbG90cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGVuc3VyZUFkZHIodGhpcywgaSA8PCAxKTtcbiAgICAgICAgdGhpcy5hcHBseWluZyA9IG51bGw7XG4gICAgfVxuICAgIGZpZWxkKGZpZWxkLCByZXF1aXJlID0gdHJ1ZSkge1xuICAgICAgICBsZXQgYWRkciA9IHRoaXMuY29uZmlnLmFkZHJlc3NbZmllbGQuaWRdO1xuICAgICAgICBpZiAoYWRkciA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAocmVxdWlyZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkZpZWxkIGlzIG5vdCBwcmVzZW50IGluIHRoaXMgc3RhdGVcIik7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVuc3VyZUFkZHIodGhpcywgYWRkcik7XG4gICAgICAgIHJldHVybiBnZXRBZGRyKHRoaXMsIGFkZHIpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBbdHJhbnNhY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24pIHRoYXQgdXBkYXRlcyB0aGlzXG4gICAgc3RhdGUuIEFueSBudW1iZXIgb2YgW3RyYW5zYWN0aW9uIHNwZWNzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYylcbiAgICBjYW4gYmUgcGFzc2VkLiBVbmxlc3NcbiAgICBbYHNlcXVlbnRpYWxgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5zZXF1ZW50aWFsKSBpcyBzZXQsIHRoZVxuICAgIFtjaGFuZ2VzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5jaGFuZ2VzKSAoaWYgYW55KSBvZiBlYWNoIHNwZWNcbiAgICBhcmUgYXNzdW1lZCB0byBzdGFydCBpbiB0aGUgX2N1cnJlbnRfIGRvY3VtZW50IChub3QgdGhlIGRvY3VtZW50XG4gICAgcHJvZHVjZWQgYnkgcHJldmlvdXMgc3BlY3MpLCBhbmQgaXRzXG4gICAgW3NlbGVjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuc2VsZWN0aW9uKSBhbmRcbiAgICBbZWZmZWN0c10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuZWZmZWN0cykgYXJlIGFzc3VtZWQgdG8gcmVmZXJcbiAgICB0byB0aGUgZG9jdW1lbnQgY3JlYXRlZCBieSBpdHMgX293bl8gY2hhbmdlcy4gVGhlIHJlc3VsdGluZ1xuICAgIHRyYW5zYWN0aW9uIGNvbnRhaW5zIHRoZSBjb21iaW5lZCBlZmZlY3Qgb2YgYWxsIHRoZSBkaWZmZXJlbnRcbiAgICBzcGVjcy4gRm9yIFtzZWxlY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLnNlbGVjdGlvbiksIGxhdGVyXG4gICAgc3BlY3MgdGFrZSBwcmVjZWRlbmNlIG92ZXIgZWFybGllciBvbmVzLlxuICAgICovXG4gICAgdXBkYXRlKC4uLnNwZWNzKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlVHJhbnNhY3Rpb24odGhpcywgc3BlY3MsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGFwcGx5VHJhbnNhY3Rpb24odHIpIHtcbiAgICAgICAgbGV0IGNvbmYgPSB0aGlzLmNvbmZpZywgeyBiYXNlLCBjb21wYXJ0bWVudHMgfSA9IGNvbmY7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKENvbXBhcnRtZW50LnJlY29uZmlndXJlKSkge1xuICAgICAgICAgICAgICAgIGlmIChjb25mKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBhcnRtZW50cyA9IG5ldyBNYXA7XG4gICAgICAgICAgICAgICAgICAgIGNvbmYuY29tcGFydG1lbnRzLmZvckVhY2goKHZhbCwga2V5KSA9PiBjb21wYXJ0bWVudHMuc2V0KGtleSwgdmFsKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbmYgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb21wYXJ0bWVudHMuc2V0KGVmZmVjdC52YWx1ZS5jb21wYXJ0bWVudCwgZWZmZWN0LnZhbHVlLmV4dGVuc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlZmZlY3QuaXMoU3RhdGVFZmZlY3QucmVjb25maWd1cmUpKSB7XG4gICAgICAgICAgICAgICAgY29uZiA9IG51bGw7XG4gICAgICAgICAgICAgICAgYmFzZSA9IGVmZmVjdC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVmZmVjdC5pcyhTdGF0ZUVmZmVjdC5hcHBlbmRDb25maWcpKSB7XG4gICAgICAgICAgICAgICAgY29uZiA9IG51bGw7XG4gICAgICAgICAgICAgICAgYmFzZSA9IGFzQXJyYXkoYmFzZSkuY29uY2F0KGVmZmVjdC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV3IEVkaXRvclN0YXRlKGNvbmYgfHwgQ29uZmlndXJhdGlvbi5yZXNvbHZlKGJhc2UsIGNvbXBhcnRtZW50cywgdGhpcyksIHRyLm5ld0RvYywgdHIubmV3U2VsZWN0aW9uLCB0cik7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIFt0cmFuc2FjdGlvbiBzcGVjXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYykgdGhhdFxuICAgIHJlcGxhY2VzIGV2ZXJ5IHNlbGVjdGlvbiByYW5nZSB3aXRoIHRoZSBnaXZlbiBjb250ZW50LlxuICAgICovXG4gICAgcmVwbGFjZVNlbGVjdGlvbih0ZXh0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGV4dCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgdGV4dCA9IHRoaXMudG9UZXh0KHRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+ICh7IGNoYW5nZXM6IHsgZnJvbTogcmFuZ2UuZnJvbSwgdG86IHJhbmdlLnRvLCBpbnNlcnQ6IHRleHQgfSxcbiAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmZyb20gKyB0ZXh0Lmxlbmd0aCkgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBzZXQgb2YgY2hhbmdlcyBhbmQgYSBuZXcgc2VsZWN0aW9uIGJ5IHJ1bm5pbmcgdGhlIGdpdmVuXG4gICAgZnVuY3Rpb24gZm9yIGVhY2ggcmFuZ2UgaW4gdGhlIGFjdGl2ZSBzZWxlY3Rpb24uIFRoZSBmdW5jdGlvblxuICAgIGNhbiByZXR1cm4gYW4gb3B0aW9uYWwgc2V0IG9mIGNoYW5nZXMgKGluIHRoZSBjb29yZGluYXRlIHNwYWNlXG4gICAgb2YgdGhlIHN0YXJ0IGRvY3VtZW50KSwgcGx1cyBhbiB1cGRhdGVkIHJhbmdlIChpbiB0aGUgY29vcmRpbmF0ZVxuICAgIHNwYWNlIG9mIHRoZSBkb2N1bWVudCBwcm9kdWNlZCBieSB0aGUgY2FsbCdzIG93biBjaGFuZ2VzKS4gVGhpc1xuICAgIG1ldGhvZCB3aWxsIG1lcmdlIGFsbCB0aGUgY2hhbmdlcyBhbmQgcmFuZ2VzIGludG8gYSBzaW5nbGVcbiAgICBjaGFuZ2VzZXQgYW5kIHNlbGVjdGlvbiwgYW5kIHJldHVybiBpdCBhcyBhIFt0cmFuc2FjdGlvblxuICAgIHNwZWNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjKSwgd2hpY2ggY2FuIGJlIHBhc3NlZCB0b1xuICAgIFtgdXBkYXRlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS51cGRhdGUpLlxuICAgICovXG4gICAgY2hhbmdlQnlSYW5nZShmKSB7XG4gICAgICAgIGxldCBzZWwgPSB0aGlzLnNlbGVjdGlvbjtcbiAgICAgICAgbGV0IHJlc3VsdDEgPSBmKHNlbC5yYW5nZXNbMF0pO1xuICAgICAgICBsZXQgY2hhbmdlcyA9IHRoaXMuY2hhbmdlcyhyZXN1bHQxLmNoYW5nZXMpLCByYW5nZXMgPSBbcmVzdWx0MS5yYW5nZV07XG4gICAgICAgIGxldCBlZmZlY3RzID0gYXNBcnJheShyZXN1bHQxLmVmZmVjdHMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHNlbC5yYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBmKHNlbC5yYW5nZXNbaV0pO1xuICAgICAgICAgICAgbGV0IG5ld0NoYW5nZXMgPSB0aGlzLmNoYW5nZXMocmVzdWx0LmNoYW5nZXMpLCBuZXdNYXBwZWQgPSBuZXdDaGFuZ2VzLm1hcChjaGFuZ2VzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaTsgaisrKVxuICAgICAgICAgICAgICAgIHJhbmdlc1tqXSA9IHJhbmdlc1tqXS5tYXAobmV3TWFwcGVkKTtcbiAgICAgICAgICAgIGxldCBtYXBCeSA9IGNoYW5nZXMubWFwRGVzYyhuZXdDaGFuZ2VzLCB0cnVlKTtcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKHJlc3VsdC5yYW5nZS5tYXAobWFwQnkpKTtcbiAgICAgICAgICAgIGNoYW5nZXMgPSBjaGFuZ2VzLmNvbXBvc2UobmV3TWFwcGVkKTtcbiAgICAgICAgICAgIGVmZmVjdHMgPSBTdGF0ZUVmZmVjdC5tYXBFZmZlY3RzKGVmZmVjdHMsIG5ld01hcHBlZCkuY29uY2F0KFN0YXRlRWZmZWN0Lm1hcEVmZmVjdHMoYXNBcnJheShyZXN1bHQuZWZmZWN0cyksIG1hcEJ5KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNoYW5nZXMsXG4gICAgICAgICAgICBzZWxlY3Rpb246IEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzLCBzZWwubWFpbkluZGV4KSxcbiAgICAgICAgICAgIGVmZmVjdHNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgW2NoYW5nZSBzZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhbmdlU2V0KSBmcm9tIHRoZSBnaXZlbiBjaGFuZ2VcbiAgICBkZXNjcmlwdGlvbiwgdGFraW5nIHRoZSBzdGF0ZSdzIGRvY3VtZW50IGxlbmd0aCBhbmQgbGluZVxuICAgIHNlcGFyYXRvciBpbnRvIGFjY291bnQuXG4gICAgKi9cbiAgICBjaGFuZ2VzKHNwZWMgPSBbXSkge1xuICAgICAgICBpZiAoc3BlYyBpbnN0YW5jZW9mIENoYW5nZVNldClcbiAgICAgICAgICAgIHJldHVybiBzcGVjO1xuICAgICAgICByZXR1cm4gQ2hhbmdlU2V0Lm9mKHNwZWMsIHRoaXMuZG9jLmxlbmd0aCwgdGhpcy5mYWNldChFZGl0b3JTdGF0ZS5saW5lU2VwYXJhdG9yKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFVzaW5nIHRoZSBzdGF0ZSdzIFtsaW5lXG4gICAgc2VwYXJhdG9yXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXmxpbmVTZXBhcmF0b3IpLCBjcmVhdGUgYVxuICAgIFtgVGV4dGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdGV4dC5UZXh0KSBpbnN0YW5jZSBmcm9tIHRoZSBnaXZlbiBzdHJpbmcuXG4gICAgKi9cbiAgICB0b1RleHQoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiB0ZXh0LlRleHQub2Yoc3RyaW5nLnNwbGl0KHRoaXMuZmFjZXQoRWRpdG9yU3RhdGUubGluZVNlcGFyYXRvcikgfHwgRGVmYXVsdFNwbGl0KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiB0aGUgZ2l2ZW4gcmFuZ2Ugb2YgdGhlIGRvY3VtZW50IGFzIGEgc3RyaW5nLlxuICAgICovXG4gICAgc2xpY2VEb2MoZnJvbSA9IDAsIHRvID0gdGhpcy5kb2MubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvYy5zbGljZVN0cmluZyhmcm9tLCB0bywgdGhpcy5saW5lQnJlYWspO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHZhbHVlIG9mIGEgc3RhdGUgW2ZhY2V0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkZhY2V0KS5cbiAgICAqL1xuICAgIGZhY2V0KGZhY2V0KSB7XG4gICAgICAgIGxldCBhZGRyID0gdGhpcy5jb25maWcuYWRkcmVzc1tmYWNldC5pZF07XG4gICAgICAgIGlmIChhZGRyID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFjZXQuZGVmYXVsdDtcbiAgICAgICAgZW5zdXJlQWRkcih0aGlzLCBhZGRyKTtcbiAgICAgICAgcmV0dXJuIGdldEFkZHIodGhpcywgYWRkcik7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbnZlcnQgdGhpcyBzdGF0ZSB0byBhIEpTT04tc2VyaWFsaXphYmxlIG9iamVjdC4gV2hlbiBjdXN0b21cbiAgICBmaWVsZHMgc2hvdWxkIGJlIHNlcmlhbGl6ZWQsIHlvdSBjYW4gcGFzcyB0aGVtIGluIGFzIGFuIG9iamVjdFxuICAgIG1hcHBpbmcgcHJvcGVydHkgbmFtZXMgKGluIHRoZSByZXN1bHRpbmcgb2JqZWN0LCB3aGljaCBzaG91bGRcbiAgICBub3QgdXNlIGBkb2NgIG9yIGBzZWxlY3Rpb25gKSB0byBmaWVsZHMuXG4gICAgKi9cbiAgICB0b0pTT04oZmllbGRzKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgICAgICBkb2M6IHRoaXMuc2xpY2VEb2MoKSxcbiAgICAgICAgICAgIHNlbGVjdGlvbjogdGhpcy5zZWxlY3Rpb24udG9KU09OKClcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGZpZWxkcylcbiAgICAgICAgICAgIGZvciAobGV0IHByb3AgaW4gZmllbGRzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gZmllbGRzW3Byb3BdO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFN0YXRlRmllbGQpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtwcm9wXSA9IHZhbHVlLnNwZWMudG9KU09OKHRoaXMuZmllbGQoZmllbGRzW3Byb3BdKSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIERlc2VyaWFsaXplIGEgc3RhdGUgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi4gV2hlbiBjdXN0b21cbiAgICBmaWVsZHMgc2hvdWxkIGJlIGRlc2VyaWFsaXplZCwgcGFzcyB0aGUgc2FtZSBvYmplY3QgeW91IHBhc3NlZFxuICAgIHRvIFtgdG9KU09OYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS50b0pTT04pIHdoZW4gc2VyaWFsaXppbmcgYXNcbiAgICB0aGlyZCBhcmd1bWVudC5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uLCBjb25maWcgPSB7fSwgZmllbGRzKSB7XG4gICAgICAgIGlmICghanNvbiB8fCB0eXBlb2YganNvbi5kb2MgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBKU09OIHJlcHJlc2VudGF0aW9uIGZvciBFZGl0b3JTdGF0ZVwiKTtcbiAgICAgICAgbGV0IGZpZWxkSW5pdCA9IFtdO1xuICAgICAgICBpZiAoZmllbGRzKVxuICAgICAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBmaWVsZHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgZmllbGQgPSBmaWVsZHNbcHJvcF0sIHZhbHVlID0ganNvbltwcm9wXTtcbiAgICAgICAgICAgICAgICBmaWVsZEluaXQucHVzaChmaWVsZC5pbml0KHN0YXRlID0+IGZpZWxkLnNwZWMuZnJvbUpTT04odmFsdWUsIHN0YXRlKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gRWRpdG9yU3RhdGUuY3JlYXRlKHtcbiAgICAgICAgICAgIGRvYzoganNvbi5kb2MsXG4gICAgICAgICAgICBzZWxlY3Rpb246IEVkaXRvclNlbGVjdGlvbi5mcm9tSlNPTihqc29uLnNlbGVjdGlvbiksXG4gICAgICAgICAgICBleHRlbnNpb25zOiBjb25maWcuZXh0ZW5zaW9ucyA/IGZpZWxkSW5pdC5jb25jYXQoW2NvbmZpZy5leHRlbnNpb25zXSkgOiBmaWVsZEluaXRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBzdGF0ZS4gWW91J2xsIHVzdWFsbHkgb25seSBuZWVkIHRoaXMgd2hlblxuICAgIGluaXRpYWxpemluZyBhbiBlZGl0b3LigJR1cGRhdGVkIHN0YXRlcyBhcmUgY3JlYXRlZCBieSBhcHBseWluZ1xuICAgIHRyYW5zYWN0aW9ucy5cbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoY29uZmlnID0ge30pIHtcbiAgICAgICAgbGV0IGNvbmZpZ3VyYXRpb24gPSBDb25maWd1cmF0aW9uLnJlc29sdmUoY29uZmlnLmV4dGVuc2lvbnMgfHwgW10sIG5ldyBNYXApO1xuICAgICAgICBsZXQgZG9jID0gY29uZmlnLmRvYyBpbnN0YW5jZW9mIHRleHQuVGV4dCA/IGNvbmZpZy5kb2NcbiAgICAgICAgICAgIDogdGV4dC5UZXh0Lm9mKChjb25maWcuZG9jIHx8IFwiXCIpLnNwbGl0KGNvbmZpZ3VyYXRpb24uc3RhdGljRmFjZXQoRWRpdG9yU3RhdGUubGluZVNlcGFyYXRvcikgfHwgRGVmYXVsdFNwbGl0KSk7XG4gICAgICAgIGxldCBzZWxlY3Rpb24gPSAhY29uZmlnLnNlbGVjdGlvbiA/IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUoMClcbiAgICAgICAgICAgIDogY29uZmlnLnNlbGVjdGlvbiBpbnN0YW5jZW9mIEVkaXRvclNlbGVjdGlvbiA/IGNvbmZpZy5zZWxlY3Rpb25cbiAgICAgICAgICAgICAgICA6IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUoY29uZmlnLnNlbGVjdGlvbi5hbmNob3IsIGNvbmZpZy5zZWxlY3Rpb24uaGVhZCk7XG4gICAgICAgIGNoZWNrU2VsZWN0aW9uKHNlbGVjdGlvbiwgZG9jLmxlbmd0aCk7XG4gICAgICAgIGlmICghY29uZmlndXJhdGlvbi5zdGF0aWNGYWNldChhbGxvd011bHRpcGxlU2VsZWN0aW9ucykpXG4gICAgICAgICAgICBzZWxlY3Rpb24gPSBzZWxlY3Rpb24uYXNTaW5nbGUoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBFZGl0b3JTdGF0ZShjb25maWd1cmF0aW9uLCBkb2MsIHNlbGVjdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBzaXplIChpbiBjb2x1bW5zKSBvZiBhIHRhYiBpbiB0aGUgZG9jdW1lbnQsIGRldGVybWluZWQgYnlcbiAgICB0aGUgW2B0YWJTaXplYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV50YWJTaXplKSBmYWNldC5cbiAgICAqL1xuICAgIGdldCB0YWJTaXplKCkgeyByZXR1cm4gdGhpcy5mYWNldChFZGl0b3JTdGF0ZS50YWJTaXplKTsgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgcHJvcGVyIFtsaW5lLWJyZWFrXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXmxpbmVTZXBhcmF0b3IpXG4gICAgc3RyaW5nIGZvciB0aGlzIHN0YXRlLlxuICAgICovXG4gICAgZ2V0IGxpbmVCcmVhaygpIHsgcmV0dXJuIHRoaXMuZmFjZXQoRWRpdG9yU3RhdGUubGluZVNlcGFyYXRvcikgfHwgXCJcXG5cIjsgfVxuICAgIC8qKlxuICAgIExvb2sgdXAgYSB0cmFuc2xhdGlvbiBmb3IgdGhlIGdpdmVuIHBocmFzZSAodmlhIHRoZVxuICAgIFtgcGhyYXNlc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVecGhyYXNlcykgZmFjZXQpLCBvciByZXR1cm4gdGhlXG4gICAgb3JpZ2luYWwgc3RyaW5nIGlmIG5vIHRyYW5zbGF0aW9uIGlzIGZvdW5kLlxuICAgICovXG4gICAgcGhyYXNlKHBocmFzZSkge1xuICAgICAgICBmb3IgKGxldCBtYXAgb2YgdGhpcy5mYWNldChFZGl0b3JTdGF0ZS5waHJhc2VzKSlcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWFwLCBwaHJhc2UpKVxuICAgICAgICAgICAgICAgIHJldHVybiBtYXBbcGhyYXNlXTtcbiAgICAgICAgcmV0dXJuIHBocmFzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgdmFsdWVzIGZvciBhIGdpdmVuIGxhbmd1YWdlIGRhdGEgZmllbGQsIHByb3ZpZGVkIGJ5IHRoZVxuICAgIHRoZSBbYGxhbmd1YWdlRGF0YWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVebGFuZ3VhZ2VEYXRhKSBmYWNldC5cbiAgICAqL1xuICAgIGxhbmd1YWdlRGF0YUF0KG5hbWUsIHBvcykge1xuICAgICAgICBsZXQgdmFsdWVzID0gW107XG4gICAgICAgIGZvciAobGV0IHByb3ZpZGVyIG9mIHRoaXMuZmFjZXQobGFuZ3VhZ2VEYXRhKSkge1xuICAgICAgICAgICAgZm9yIChsZXQgcmVzdWx0IG9mIHByb3ZpZGVyKHRoaXMsIHBvcykpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwgbmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHJlc3VsdFtuYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBjYW4gY2F0ZWdvcml6ZSBzdHJpbmdzIChleHBlY3RlZCB0b1xuICAgIHJlcHJlc2VudCBhIHNpbmdsZSBbZ3JhcGhlbWUgY2x1c3Rlcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN0ZXh0LmZpbmRDbHVzdGVyQnJlYWspKVxuICAgIGludG8gb25lIG9mOlxuICAgIFxuICAgICAtIFdvcmQgKGNvbnRhaW5zIGFuIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXIgb3IgYSBjaGFyYWN0ZXJcbiAgICAgICBleHBsaWNpdGx5IGxpc3RlZCBpbiB0aGUgbG9jYWwgbGFuZ3VhZ2UncyBgXCJ3b3JkQ2hhcnNcImBcbiAgICAgICBsYW5ndWFnZSBkYXRhLCB3aGljaCBzaG91bGQgYmUgYSBzdHJpbmcpXG4gICAgIC0gU3BhY2UgKGNvbnRhaW5zIG9ubHkgd2hpdGVzcGFjZSlcbiAgICAgLSBPdGhlciAoYW55dGhpbmcgZWxzZSlcbiAgICAqL1xuICAgIGNoYXJDYXRlZ29yaXplcihhdCkge1xuICAgICAgICByZXR1cm4gbWFrZUNhdGVnb3JpemVyKHRoaXMubGFuZ3VhZ2VEYXRhQXQoXCJ3b3JkQ2hhcnNcIiwgYXQpLmpvaW4oXCJcIikpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSB3b3JkIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiwgbWVhbmluZyB0aGUgcmFuZ2VcbiAgICBjb250YWluaW5nIGFsbCBbd29yZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFyQ2F0ZWdvcnkuV29yZCkgY2hhcmFjdGVyc1xuICAgIGFyb3VuZCBpdC4gSWYgbm8gd29yZCBjaGFyYWN0ZXJzIGFyZSBhZGphY2VudCB0byB0aGUgcG9zaXRpb24sXG4gICAgdGhpcyByZXR1cm5zIG51bGwuXG4gICAgKi9cbiAgICB3b3JkQXQocG9zKSB7XG4gICAgICAgIGxldCB7IHRleHQ6IHRleHQkMSwgZnJvbSwgbGVuZ3RoIH0gPSB0aGlzLmRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgbGV0IGNhdCA9IHRoaXMuY2hhckNhdGVnb3JpemVyKHBvcyk7XG4gICAgICAgIGxldCBzdGFydCA9IHBvcyAtIGZyb20sIGVuZCA9IHBvcyAtIGZyb207XG4gICAgICAgIHdoaWxlIChzdGFydCA+IDApIHtcbiAgICAgICAgICAgIGxldCBwcmV2ID0gdGV4dC5maW5kQ2x1c3RlckJyZWFrKHRleHQkMSwgc3RhcnQsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChjYXQodGV4dCQxLnNsaWNlKHByZXYsIHN0YXJ0KSkgIT0gZXhwb3J0cy5DaGFyQ2F0ZWdvcnkuV29yZClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHN0YXJ0ID0gcHJldjtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoZW5kIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRleHQuZmluZENsdXN0ZXJCcmVhayh0ZXh0JDEsIGVuZCk7XG4gICAgICAgICAgICBpZiAoY2F0KHRleHQkMS5zbGljZShlbmQsIG5leHQpKSAhPSBleHBvcnRzLkNoYXJDYXRlZ29yeS5Xb3JkKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZW5kID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhcnQgPT0gZW5kID8gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHN0YXJ0ICsgZnJvbSwgZW5kICsgZnJvbSkgOiBudWxsO1xuICAgIH1cbn1cbi8qKlxuQSBmYWNldCB0aGF0LCB3aGVuIGVuYWJsZWQsIGNhdXNlcyB0aGUgZWRpdG9yIHRvIGFsbG93IG11bHRpcGxlXG5yYW5nZXMgdG8gYmUgc2VsZWN0ZWQuIEJlIGNhcmVmdWwgdGhvdWdoLCBiZWNhdXNlIGJ5IGRlZmF1bHQgdGhlXG5lZGl0b3IgcmVsaWVzIG9uIHRoZSBuYXRpdmUgRE9NIHNlbGVjdGlvbiwgd2hpY2ggY2Fubm90IGhhbmRsZVxubXVsdGlwbGUgc2VsZWN0aW9ucy4gQW4gZXh0ZW5zaW9uIGxpa2VcbltgZHJhd1NlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5kcmF3U2VsZWN0aW9uKSBjYW4gYmUgdXNlZCB0byBtYWtlXG5zZWNvbmRhcnkgc2VsZWN0aW9ucyB2aXNpYmxlIHRvIHRoZSB1c2VyLlxuKi9cbkVkaXRvclN0YXRlLmFsbG93TXVsdGlwbGVTZWxlY3Rpb25zID0gYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnM7XG4vKipcbkNvbmZpZ3VyZXMgdGhlIHRhYiBzaXplIHRvIHVzZSBpbiB0aGlzIHN0YXRlLiBUaGUgZmlyc3RcbihoaWdoZXN0LXByZWNlZGVuY2UpIHZhbHVlIG9mIHRoZSBmYWNldCBpcyB1c2VkLiBJZiBubyB2YWx1ZSBpc1xuZ2l2ZW4sIHRoaXMgZGVmYXVsdHMgdG8gNC5cbiovXG5FZGl0b3JTdGF0ZS50YWJTaXplID0gRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLmxlbmd0aCA/IHZhbHVlc1swXSA6IDRcbn0pO1xuLyoqXG5UaGUgbGluZSBzZXBhcmF0b3IgdG8gdXNlLiBCeSBkZWZhdWx0LCBhbnkgb2YgYFwiXFxuXCJgLCBgXCJcXHJcXG5cImBcbmFuZCBgXCJcXHJcImAgaXMgdHJlYXRlZCBhcyBhIHNlcGFyYXRvciB3aGVuIHNwbGl0dGluZyBsaW5lcywgYW5kXG5saW5lcyBhcmUgam9pbmVkIHdpdGggYFwiXFxuXCJgLlxuXG5XaGVuIHlvdSBjb25maWd1cmUgYSB2YWx1ZSBoZXJlLCBvbmx5IHRoYXQgcHJlY2lzZSBzZXBhcmF0b3JcbndpbGwgYmUgdXNlZCwgYWxsb3dpbmcgeW91IHRvIHJvdW5kLXRyaXAgZG9jdW1lbnRzIHRocm91Z2ggdGhlXG5lZGl0b3Igd2l0aG91dCBub3JtYWxpemluZyBsaW5lIHNlcGFyYXRvcnMuXG4qL1xuRWRpdG9yU3RhdGUubGluZVNlcGFyYXRvciA9IGxpbmVTZXBhcmF0b3I7XG4vKipcblJlZ2lzdGVycyB0cmFuc2xhdGlvbiBwaHJhc2VzLiBUaGVcbltgcGhyYXNlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5waHJhc2UpIG1ldGhvZCB3aWxsIGxvb2sgdGhyb3VnaFxuYWxsIG9iamVjdHMgcmVnaXN0ZXJlZCB3aXRoIHRoaXMgZmFjZXQgdG8gZmluZCB0cmFuc2xhdGlvbnMgZm9yXG5pdHMgYXJndW1lbnQuXG4qL1xuRWRpdG9yU3RhdGUucGhyYXNlcyA9IEZhY2V0LmRlZmluZSgpO1xuLyoqXG5BIGZhY2V0IHVzZWQgdG8gcmVnaXN0ZXIgW2xhbmd1YWdlXG5kYXRhXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmxhbmd1YWdlRGF0YUF0KSBwcm92aWRlcnMuXG4qL1xuRWRpdG9yU3RhdGUubGFuZ3VhZ2VEYXRhID0gbGFuZ3VhZ2VEYXRhO1xuLyoqXG5GYWNldCB1c2VkIHRvIHJlZ2lzdGVyIGNoYW5nZSBmaWx0ZXJzLCB3aGljaCBhcmUgY2FsbGVkIGZvciBlYWNoXG50cmFuc2FjdGlvbiAodW5sZXNzIGV4cGxpY2l0bHlcbltkaXNhYmxlZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuZmlsdGVyKSksIGFuZCBjYW4gc3VwcHJlc3NcbnBhcnQgb2YgdGhlIHRyYW5zYWN0aW9uJ3MgY2hhbmdlcy5cblxuU3VjaCBhIGZ1bmN0aW9uIGNhbiByZXR1cm4gYHRydWVgIHRvIGluZGljYXRlIHRoYXQgaXQgZG9lc24ndFxud2FudCB0byBkbyBhbnl0aGluZywgYGZhbHNlYCB0byBjb21wbGV0ZWx5IHN0b3AgdGhlIGNoYW5nZXMgaW5cbnRoZSB0cmFuc2FjdGlvbiwgb3IgYSBzZXQgb2YgcmFuZ2VzIGluIHdoaWNoIGNoYW5nZXMgc2hvdWxkIGJlXG5zdXBwcmVzc2VkLiBTdWNoIHJhbmdlcyBhcmUgcmVwcmVzZW50ZWQgYXMgYW4gYXJyYXkgb2YgbnVtYmVycyxcbndpdGggZWFjaCBwYWlyIG9mIHR3byBudW1iZXIgaW5kaWNhdGluZyB0aGUgc3RhcnQgYW5kIGVuZCBvZiBhXG5yYW5nZS4gU28gZm9yIGV4YW1wbGUgYFsxMCwgMjAsIDEwMCwgMTEwXWAgc3VwcHJlc3NlcyBjaGFuZ2VzXG5iZXR3ZWVuIDEwIGFuZCAyMCwgYW5kIGJldHdlZW4gMTAwIGFuZCAxMTAuXG4qL1xuRWRpdG9yU3RhdGUuY2hhbmdlRmlsdGVyID0gY2hhbmdlRmlsdGVyO1xuLyoqXG5GYWNldCB1c2VkIHRvIHJlZ2lzdGVyIGEgaG9vayB0aGF0IGdldHMgYSBjaGFuY2UgdG8gdXBkYXRlIG9yXG5yZXBsYWNlIHRyYW5zYWN0aW9uIHNwZWNzIGJlZm9yZSB0aGV5IGFyZSBhcHBsaWVkLiBUaGlzIHdpbGxcbm9ubHkgYmUgYXBwbGllZCBmb3IgdHJhbnNhY3Rpb25zIHRoYXQgZG9uJ3QgaGF2ZVxuW2BmaWx0ZXJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5maWx0ZXIpIHNldCB0byBgZmFsc2VgLiBZb3VcbmNhbiBlaXRoZXIgcmV0dXJuIGEgc2luZ2xlIChwb3NzaWJseSB0aGUgaW5wdXQgdHJhbnNhY3Rpb24pLCBvclxuYW4gYXJyYXkgb2Ygc3BlY3MgKHdoaWNoIHdpbGwgYmUgY29tYmluZWQgaW4gdGhlIHNhbWUgd2F5IGFzIHRoZVxuYXJndW1lbnRzIHRvIFtgRWRpdG9yU3RhdGUudXBkYXRlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS51cGRhdGUpKS5cblxuV2hlbiBwb3NzaWJsZSwgaXQgaXMgcmVjb21tZW5kZWQgdG8gYXZvaWQgYWNjZXNzaW5nXG5bYFRyYW5zYWN0aW9uLnN0YXRlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbi5zdGF0ZSkgaW4gYSBmaWx0ZXIsXG5zaW5jZSBpdCB3aWxsIGZvcmNlIGNyZWF0aW9uIG9mIGEgc3RhdGUgdGhhdCB3aWxsIHRoZW4gYmVcbmRpc2NhcmRlZCBhZ2FpbiwgaWYgdGhlIHRyYW5zYWN0aW9uIGlzIGFjdHVhbGx5IGZpbHRlcmVkLlxuXG4oVGhpcyBmdW5jdGlvbmFsaXR5IHNob3VsZCBiZSB1c2VkIHdpdGggY2FyZS4gSW5kaXNjcmltaW5hdGVseVxubW9kaWZ5aW5nIHRyYW5zYWN0aW9uIGlzIGxpa2VseSB0byBicmVhayBzb21ldGhpbmcgb3IgZGVncmFkZVxudGhlIHVzZXIgZXhwZXJpZW5jZS4pXG4qL1xuRWRpdG9yU3RhdGUudHJhbnNhY3Rpb25GaWx0ZXIgPSB0cmFuc2FjdGlvbkZpbHRlcjtcbi8qKlxuVGhpcyBpcyBhIG1vcmUgbGltaXRlZCBmb3JtIG9mXG5bYHRyYW5zYWN0aW9uRmlsdGVyYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV50cmFuc2FjdGlvbkZpbHRlciksXG53aGljaCBjYW4gb25seSBhZGRcblthbm5vdGF0aW9uc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuYW5ub3RhdGlvbnMpIGFuZFxuW2VmZmVjdHNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmVmZmVjdHMpLiBfQnV0XywgdGhpcyB0eXBlXG5vZiBmaWx0ZXIgcnVucyBldmVuIHRoZSB0cmFuc2FjdGlvbiBoYXMgZGlzYWJsZWQgcmVndWxhclxuW2ZpbHRlcmluZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuZmlsdGVyKSwgbWFraW5nIGl0IHN1aXRhYmxlXG5mb3IgZWZmZWN0cyB0aGF0IGRvbid0IG5lZWQgdG8gdG91Y2ggdGhlIGNoYW5nZXMgb3Igc2VsZWN0aW9uLFxuYnV0IGRvIHdhbnQgdG8gcHJvY2VzcyBldmVyeSB0cmFuc2FjdGlvbi5cblxuRXh0ZW5kZXJzIHJ1biBfYWZ0ZXJfIGZpbHRlcnMsIHdoZW4gYm90aCBhcmUgYXBwbGllZC5cbiovXG5FZGl0b3JTdGF0ZS50cmFuc2FjdGlvbkV4dGVuZGVyID0gdHJhbnNhY3Rpb25FeHRlbmRlcjtcbkNvbXBhcnRtZW50LnJlY29uZmlndXJlID0gU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5cbi8qKlxuVXRpbGl0eSBmdW5jdGlvbiBmb3IgY29tYmluaW5nIGJlaGF2aW9ycyB0byBmaWxsIGluIGEgY29uZmlnXG5vYmplY3QgZnJvbSBhbiBhcnJheSBvZiBwcm92aWRlZCBjb25maWdzLiBXaWxsLCBieSBkZWZhdWx0LCBlcnJvclxud2hlbiBhIGZpZWxkIGdldHMgdHdvIHZhbHVlcyB0aGF0IGFyZW4ndCBgPT09YC1lcXVhbCwgYnV0IHlvdSBjYW5cbnByb3ZpZGUgY29tYmluZSBmdW5jdGlvbnMgcGVyIGZpZWxkIHRvIGRvIHNvbWV0aGluZyBlbHNlLlxuKi9cbmZ1bmN0aW9uIGNvbWJpbmVDb25maWcoY29uZmlncywgZGVmYXVsdHMsIC8vIFNob3VsZCBob2xkIG9ubHkgdGhlIG9wdGlvbmFsIHByb3BlcnRpZXMgb2YgQ29uZmlnLCBidXQgSSBoYXZlbid0IG1hbmFnZWQgdG8gZXhwcmVzcyB0aGF0XG5jb21iaW5lID0ge30pIHtcbiAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgZm9yIChsZXQgY29uZmlnIG9mIGNvbmZpZ3MpXG4gICAgICAgIGZvciAobGV0IGtleSBvZiBPYmplY3Qua2V5cyhjb25maWcpKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBjb25maWdba2V5XSwgY3VycmVudCA9IHJlc3VsdFtrZXldO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudCA9PT0gdmFsdWUgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgOyAvLyBObyBjb25mbGljdFxuICAgICAgICAgICAgZWxzZSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoY29tYmluZSwga2V5KSlcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IGNvbWJpbmVba2V5XShjdXJyZW50LCB2YWx1ZSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29uZmlnIG1lcmdlIGNvbmZsaWN0IGZvciBmaWVsZCBcIiArIGtleSk7XG4gICAgICAgIH1cbiAgICBmb3IgKGxldCBrZXkgaW4gZGVmYXVsdHMpXG4gICAgICAgIGlmIChyZXN1bHRba2V5XSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBkZWZhdWx0c1trZXldO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnVGV4dCcsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGV4dC5UZXh0O1xuICAgIH1cbn0pO1xuZXhwb3J0cy5Bbm5vdGF0aW9uID0gQW5ub3RhdGlvbjtcbmV4cG9ydHMuQW5ub3RhdGlvblR5cGUgPSBBbm5vdGF0aW9uVHlwZTtcbmV4cG9ydHMuQ2hhbmdlRGVzYyA9IENoYW5nZURlc2M7XG5leHBvcnRzLkNoYW5nZVNldCA9IENoYW5nZVNldDtcbmV4cG9ydHMuQ29tcGFydG1lbnQgPSBDb21wYXJ0bWVudDtcbmV4cG9ydHMuRWRpdG9yU2VsZWN0aW9uID0gRWRpdG9yU2VsZWN0aW9uO1xuZXhwb3J0cy5FZGl0b3JTdGF0ZSA9IEVkaXRvclN0YXRlO1xuZXhwb3J0cy5GYWNldCA9IEZhY2V0O1xuZXhwb3J0cy5QcmVjID0gUHJlYztcbmV4cG9ydHMuU2VsZWN0aW9uUmFuZ2UgPSBTZWxlY3Rpb25SYW5nZTtcbmV4cG9ydHMuU3RhdGVFZmZlY3QgPSBTdGF0ZUVmZmVjdDtcbmV4cG9ydHMuU3RhdGVFZmZlY3RUeXBlID0gU3RhdGVFZmZlY3RUeXBlO1xuZXhwb3J0cy5TdGF0ZUZpZWxkID0gU3RhdGVGaWVsZDtcbmV4cG9ydHMuVHJhbnNhY3Rpb24gPSBUcmFuc2FjdGlvbjtcbmV4cG9ydHMuY29tYmluZUNvbmZpZyA9IGNvbWJpbmVDb25maWc7XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8vIENvbXByZXNzZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIEdyYXBoZW1lX0NsdXN0ZXJfQnJlYWs9RXh0ZW5kXG4vLyBpbmZvcm1hdGlvbiBmcm9tXG4vLyBodHRwOi8vd3d3LnVuaWNvZGUub3JnL1B1YmxpYy8xMy4wLjAvdWNkL2F1eGlsaWFyeS9HcmFwaGVtZUJyZWFrUHJvcGVydHkudHh0LlxuLy8gRWFjaCBwYWlyIG9mIGVsZW1lbnRzIHJlcHJlc2VudHMgYSByYW5nZSwgYXMgYW4gb2ZmZXQgZnJvbSB0aGVcbi8vIHByZXZpb3VzIHJhbmdlIGFuZCBhIGxlbmd0aC4gTnVtYmVycyBhcmUgaW4gYmFzZS0zNiwgd2l0aCB0aGUgZW1wdHlcbi8vIHN0cmluZyBiZWluZyBhIHNob3J0aGFuZCBmb3IgMS5cbmxldCBleHRlbmQgPSBcImxjLDM0LDduLDcsN2IsMTksLCwsMiwsMiwsLDIwLGIsMWMsbCxnLCwydCw3LDIsNiwyLDIsLDQseiwsdSxyLDJqLGIsMW0sOSw5LCxvLDQsLDksLDMsLDUsMTcsMywzYixmLCx3LDFqLCwsLDQsOCw0LCwzLDcsYSwyLHQsLDFtLCwsLDIsNCw4LCw5LCxhLDIscSwsMiwyLDFsLCw0LDIsNCwyLDIsMywzLCx1LDIsMywsYiwyLDFsLCw0LDUsLDIsNCwsaywyLG0sNiwsLDFtLCwsMiwsNCw4LCw3LDMsYSwyLHUsLDFuLCwsLGMsLDksLDE0LCwzLCwxbCwzLDUsMywsNCw3LDIsYiwyLHQsLDFtLCwyLCwyLCwzLCw1LDIsNywyLGIsMixzLDIsMWwsMiwsLDIsNCw4LCw5LCxhLDIsdCwsMjAsLDQsLDIsMywsLDgsLDI5LCwyLDcsYyw4LDJxLCwyLDksYiw2LDIyLDIsciwsLCwsLDFqLGUsLDUsLDIsNSxiLCwxMCw5LCwydSw0LCw2LCwyLDIsMixwLDIsNCwzLGcsNCxkLCwyLDIsNiwsZiwsamosMyxxYSwzLHQsMyx0LDIsdSwyLDFzLDIsLDcsOCwsMixiLDksLDE5LDMsM2IsMix5LCwzYSwzLDQsMiw5LCw2LDMsNjMsMiwyLCwxbSwsLDcsLCwsLDIsOCw2LGEsMiwsMWMsaCwxciw0LDFjLDcsLCw1LCwxNCw5LGMsMix3LDQsMiwyLCwzLDFrLCwsMiwzLCwsMywxbSw4LDIsMiw0OCwzLCxkLCw3LDQsLDYsLDMsMiw1aSwxbSwsNSxlaywsNWYseCwyZGEsMywzeCwsMm8sdyxmZSw2LDJ4LDIsbjl3LDQsLGEsdywyLDI4LDIsN2ssLDMsLDQsLHAsMiw1LCw0NywyLHEsaSxkLCwxMiw4LHAsYiwxYSwzLDFjLCwyLDQsMiwyLDEzLCwxdiw2LDIsMiwyLDIsYywsOCwsMWIsLDFmLCwsMywyLDIsNSwyLCwsMTYsMiw4LCw2bSwsMiwsNCwsZm40LCxraCxnLGcsZyxhNiwyLGd0LCw2YSwsNDUsNSwxYWUsMywsMiw1LDQsMTQsMyw0LCw0bCwyLGZ4LDQsYXIsMiw0OSxiLDR3LCwxaSxmLDFrLDMsMWQsNCwyLDIsMXgsMywxMCw1LCw4LDFxLCxjLDIsMWcsOSxhLDQsMiwsMm4sMywyLCwsMiw2LCw0ZywsMyw4LGwsMiwxbCwyLCwsLCxtLCxlLDcsMyw1LDVmLDgsMiwzLCwsbiwsMjksLDIsNiwsLDIsLCwyLCwyLDZqLCwyLDQsNiwyLCwyLHIsMiwyZCw4LDIsLCwyLDJ5LCwsLDIsNiwsLDJ0LDMsMiw0LCw1LDc3LDksLDIsNnQsLGEsMiwsLDQsLDQwLDQsMiwyLDQsLHcsYSwxNCw2LDIsNCw4LCw5LDYsMiwzLDFhLGQsLDIsYmEsNywsNiwsLDJhLG0sMiw3LCwyLCwyLDNlLDYsMywsLDIsLDcsLCwyMCwyLDMsLCwsOW4sMixmMGIsNSwxbiw3LHQ0LCwxciw0LDI5LCxmNWssMiw0M3EsLCwzLDQsNSw4LDgsMiw3LHUsNCw0NCwzLDFpeiwxaiw0LDFlLDgsLGUsLG0sNSwsZiwxMXMsNywsaCwyLDcsLDIsLDUsNzksNyxjNSw0LDE1cyw3LDMxLDcsMjQwLDUsZ3g3aywybywzayw2b1wiLnNwbGl0KFwiLFwiKS5tYXAocyA9PiBzID8gcGFyc2VJbnQocywgMzYpIDogMSk7XG4vLyBDb252ZXJ0IG9mZnNldHMgaW50byBhYnNvbHV0ZSB2YWx1ZXNcbmZvciAobGV0IGkgPSAxOyBpIDwgZXh0ZW5kLmxlbmd0aDsgaSsrKVxuICAgIGV4dGVuZFtpXSArPSBleHRlbmRbaSAtIDFdO1xuZnVuY3Rpb24gaXNFeHRlbmRpbmdDaGFyKGNvZGUpIHtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGV4dGVuZC5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgaWYgKGV4dGVuZFtpXSA+IGNvZGUpXG4gICAgICAgICAgICByZXR1cm4gZXh0ZW5kW2kgLSAxXSA8PSBjb2RlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzUmVnaW9uYWxJbmRpY2F0b3IoY29kZSkge1xuICAgIHJldHVybiBjb2RlID49IDB4MUYxRTYgJiYgY29kZSA8PSAweDFGMUZGO1xufVxuY29uc3QgWldKID0gMHgyMDBkO1xuLy8vIFJldHVybnMgYSBuZXh0IGdyYXBoZW1lIGNsdXN0ZXIgYnJlYWsgX2FmdGVyXyAobm90IGVxdWFsIHRvKVxuLy8vIGBwb3NgLCBpZiBgZm9yd2FyZGAgaXMgdHJ1ZSwgb3IgYmVmb3JlIG90aGVyd2lzZS4gUmV0dXJucyBgcG9zYFxuLy8vIGl0c2VsZiBpZiBubyBmdXJ0aGVyIGNsdXN0ZXIgYnJlYWsgaXMgYXZhaWxhYmxlIGluIHRoZSBzdHJpbmcuXG4vLy8gTW92ZXMgYWNyb3NzIHN1cnJvZ2F0ZSBwYWlycywgZXh0ZW5kaW5nIGNoYXJhY3RlcnMsIGNoYXJhY3RlcnNcbi8vLyBqb2luZWQgd2l0aCB6ZXJvLXdpZHRoIGpvaW5lcnMsIGFuZCBmbGFnIGVtb2ppLlxuZnVuY3Rpb24gZmluZENsdXN0ZXJCcmVhayhzdHIsIHBvcywgZm9yd2FyZCA9IHRydWUpIHtcbiAgICByZXR1cm4gKGZvcndhcmQgPyBuZXh0Q2x1c3RlckJyZWFrIDogcHJldkNsdXN0ZXJCcmVhaykoc3RyLCBwb3MpO1xufVxuZnVuY3Rpb24gbmV4dENsdXN0ZXJCcmVhayhzdHIsIHBvcykge1xuICAgIGlmIChwb3MgPT0gc3RyLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICAvLyBJZiBwb3MgaXMgaW4gdGhlIG1pZGRsZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyLCBtb3ZlIHRvIGl0cyBzdGFydFxuICAgIGlmIChwb3MgJiYgc3Vycm9nYXRlTG93KHN0ci5jaGFyQ29kZUF0KHBvcykpICYmIHN1cnJvZ2F0ZUhpZ2goc3RyLmNoYXJDb2RlQXQocG9zIC0gMSkpKVxuICAgICAgICBwb3MtLTtcbiAgICBsZXQgcHJldiA9IGNvZGVQb2ludEF0KHN0ciwgcG9zKTtcbiAgICBwb3MgKz0gY29kZVBvaW50U2l6ZShwcmV2KTtcbiAgICB3aGlsZSAocG9zIDwgc3RyLmxlbmd0aCkge1xuICAgICAgICBsZXQgbmV4dCA9IGNvZGVQb2ludEF0KHN0ciwgcG9zKTtcbiAgICAgICAgaWYgKHByZXYgPT0gWldKIHx8IG5leHQgPT0gWldKIHx8IGlzRXh0ZW5kaW5nQ2hhcihuZXh0KSkge1xuICAgICAgICAgICAgcG9zICs9IGNvZGVQb2ludFNpemUobmV4dCk7XG4gICAgICAgICAgICBwcmV2ID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1JlZ2lvbmFsSW5kaWNhdG9yKG5leHQpKSB7XG4gICAgICAgICAgICBsZXQgY291bnRCZWZvcmUgPSAwLCBpID0gcG9zIC0gMjtcbiAgICAgICAgICAgIHdoaWxlIChpID49IDAgJiYgaXNSZWdpb25hbEluZGljYXRvcihjb2RlUG9pbnRBdChzdHIsIGkpKSkge1xuICAgICAgICAgICAgICAgIGNvdW50QmVmb3JlKys7XG4gICAgICAgICAgICAgICAgaSAtPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvdW50QmVmb3JlICUgMiA9PSAwKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBvcztcbn1cbmZ1bmN0aW9uIHByZXZDbHVzdGVyQnJlYWsoc3RyLCBwb3MpIHtcbiAgICB3aGlsZSAocG9zID4gMCkge1xuICAgICAgICBsZXQgZm91bmQgPSBuZXh0Q2x1c3RlckJyZWFrKHN0ciwgcG9zIC0gMik7XG4gICAgICAgIGlmIChmb3VuZCA8IHBvcylcbiAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgcG9zLS07XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuZnVuY3Rpb24gc3Vycm9nYXRlTG93KGNoKSB7IHJldHVybiBjaCA+PSAweERDMDAgJiYgY2ggPCAweEUwMDA7IH1cbmZ1bmN0aW9uIHN1cnJvZ2F0ZUhpZ2goY2gpIHsgcmV0dXJuIGNoID49IDB4RDgwMCAmJiBjaCA8IDB4REMwMDsgfVxuLy8vIEZpbmQgdGhlIGNvZGUgcG9pbnQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uIGluIGEgc3RyaW5nIChsaWtlIHRoZVxuLy8vIFtgY29kZVBvaW50QXRgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvY29kZVBvaW50QXQpXG4vLy8gc3RyaW5nIG1ldGhvZCkuXG5mdW5jdGlvbiBjb2RlUG9pbnRBdChzdHIsIHBvcykge1xuICAgIGxldCBjb2RlMCA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgaWYgKCFzdXJyb2dhdGVIaWdoKGNvZGUwKSB8fCBwb3MgKyAxID09IHN0ci5sZW5ndGgpXG4gICAgICAgIHJldHVybiBjb2RlMDtcbiAgICBsZXQgY29kZTEgPSBzdHIuY2hhckNvZGVBdChwb3MgKyAxKTtcbiAgICBpZiAoIXN1cnJvZ2F0ZUxvdyhjb2RlMSkpXG4gICAgICAgIHJldHVybiBjb2RlMDtcbiAgICByZXR1cm4gKChjb2RlMCAtIDB4ZDgwMCkgPDwgMTApICsgKGNvZGUxIC0gMHhkYzAwKSArIDB4MTAwMDA7XG59XG4vLy8gR2l2ZW4gYSBVbmljb2RlIGNvZGVwb2ludCwgcmV0dXJuIHRoZSBKYXZhU2NyaXB0IHN0cmluZyB0aGF0XG4vLy8gcmVzcHJlc2VudHMgaXQgKGxpa2Vcbi8vLyBbYFN0cmluZy5mcm9tQ29kZVBvaW50YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2Zyb21Db2RlUG9pbnQpKS5cbmZ1bmN0aW9uIGZyb21Db2RlUG9pbnQoY29kZSkge1xuICAgIGlmIChjb2RlIDw9IDB4ZmZmZilcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgY29kZSAtPSAweDEwMDAwO1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKChjb2RlID4+IDEwKSArIDB4ZDgwMCwgKGNvZGUgJiAxMDIzKSArIDB4ZGMwMCk7XG59XG4vLy8gVGhlIGZpcnN0IGNoYXJhY3RlciB0aGF0IHRha2VzIHVwIHR3byBwb3NpdGlvbnMgaW4gYSBKYXZhU2NyaXB0XG4vLy8gc3RyaW5nLiBJdCBpcyBvZnRlbiB1c2VmdWwgdG8gY29tcGFyZSB3aXRoIHRoaXMgYWZ0ZXIgY2FsbGluZ1xuLy8vIGBjb2RlUG9pbnRBdGAsIHRvIGZpZ3VyZSBvdXQgd2hldGhlciB5b3VyIGNoYXJhY3RlciB0YWtlcyB1cCAxIG9yXG4vLy8gMiBpbmRleCBwb3NpdGlvbnMuXG5mdW5jdGlvbiBjb2RlUG9pbnRTaXplKGNvZGUpIHsgcmV0dXJuIGNvZGUgPCAweDEwMDAwID8gMSA6IDI7IH1cblxuLy8vIENvdW50IHRoZSBjb2x1bW4gcG9zaXRpb24gYXQgdGhlIGdpdmVuIG9mZnNldCBpbnRvIHRoZSBzdHJpbmcsXG4vLy8gdGFraW5nIGV4dGVuZGluZyBjaGFyYWN0ZXJzIGFuZCB0YWIgc2l6ZSBpbnRvIGFjY291bnQuXG5mdW5jdGlvbiBjb3VudENvbHVtbihzdHJpbmcsIG4sIHRhYlNpemUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7KSB7XG4gICAgICAgIGlmIChzdHJpbmcuY2hhckNvZGVBdChpKSA9PSA5KSB7XG4gICAgICAgICAgICBuICs9IHRhYlNpemUgLSAobiAlIHRhYlNpemUpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbisrO1xuICAgICAgICAgICAgaSA9IGZpbmRDbHVzdGVyQnJlYWsoc3RyaW5nLCBpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbjtcbn1cbi8vLyBGaW5kIHRoZSBvZmZzZXQgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgZ2l2ZW4gY29sdW1uIHBvc2l0aW9uIGluIGFcbi8vLyBzdHJpbmcsIHRha2luZyBleHRlbmRpbmcgY2hhcmFjdGVycyBhbmQgdGFiIHNpemUgaW50byBhY2NvdW50LlxuZnVuY3Rpb24gZmluZENvbHVtbihzdHJpbmcsIG4sIGNvbCwgdGFiU2l6ZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDspIHtcbiAgICAgICAgaWYgKG4gPj0gY29sKVxuICAgICAgICAgICAgcmV0dXJuIHsgb2Zmc2V0OiBpLCBsZWZ0T3ZlcjogMCB9O1xuICAgICAgICBuICs9IHN0cmluZy5jaGFyQ29kZUF0KGkpID09IDkgPyB0YWJTaXplIC0gKG4gJSB0YWJTaXplKSA6IDE7XG4gICAgICAgIGkgPSBmaW5kQ2x1c3RlckJyZWFrKHN0cmluZywgaSk7XG4gICAgfVxuICAgIHJldHVybiB7IG9mZnNldDogc3RyaW5nLmxlbmd0aCwgbGVmdE92ZXI6IGNvbCAtIG4gfTtcbn1cblxuLy8vIFRoZSBkYXRhIHN0cnVjdHVyZSBmb3IgZG9jdW1lbnRzLlxuY2xhc3MgVGV4dCB7XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGNvbnN0cnVjdG9yKCkgeyB9XG4gICAgLy8vIEdldCB0aGUgbGluZSBkZXNjcmlwdGlvbiBhcm91bmQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgIGxpbmVBdChwb3MpIHtcbiAgICAgICAgaWYgKHBvcyA8IDAgfHwgcG9zID4gdGhpcy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBwb3NpdGlvbiAke3Bvc30gaW4gZG9jdW1lbnQgb2YgbGVuZ3RoICR7dGhpcy5sZW5ndGh9YCk7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmVJbm5lcihwb3MsIGZhbHNlLCAxLCAwKTtcbiAgICB9XG4gICAgLy8vIEdldCB0aGUgZGVzY3JpcHRpb24gZm9yIHRoZSBnaXZlbiAoMS1iYXNlZCkgbGluZSBudW1iZXIuXG4gICAgbGluZShuKSB7XG4gICAgICAgIGlmIChuIDwgMSB8fCBuID4gdGhpcy5saW5lcylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIGxpbmUgbnVtYmVyICR7bn0gaW4gJHt0aGlzLmxpbmVzfS1saW5lIGRvY3VtZW50YCk7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmVJbm5lcihuLCB0cnVlLCAxLCAwKTtcbiAgICB9XG4gICAgLy8vIFJlcGxhY2UgYSByYW5nZSBvZiB0aGUgdGV4dCB3aXRoIHRoZSBnaXZlbiBjb250ZW50LlxuICAgIHJlcGxhY2UoZnJvbSwgdG8sIHRleHQpIHtcbiAgICAgICAgbGV0IHBhcnRzID0gW107XG4gICAgICAgIHRoaXMuZGVjb21wb3NlKDAsIGZyb20sIHBhcnRzLCAyIC8qIFRvICovKTtcbiAgICAgICAgaWYgKHRleHQubGVuZ3RoKVxuICAgICAgICAgICAgdGV4dC5kZWNvbXBvc2UoMCwgdGV4dC5sZW5ndGgsIHBhcnRzLCAxIC8qIEZyb20gKi8gfCAyIC8qIFRvICovKTtcbiAgICAgICAgdGhpcy5kZWNvbXBvc2UodG8sIHRoaXMubGVuZ3RoLCBwYXJ0cywgMSAvKiBGcm9tICovKTtcbiAgICAgICAgcmV0dXJuIFRleHROb2RlLmZyb20ocGFydHMsIHRoaXMubGVuZ3RoIC0gKHRvIC0gZnJvbSkgKyB0ZXh0Lmxlbmd0aCk7XG4gICAgfVxuICAgIC8vLyBBcHBlbmQgYW5vdGhlciBkb2N1bWVudCB0byB0aGlzIG9uZS5cbiAgICBhcHBlbmQob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZSh0aGlzLmxlbmd0aCwgdGhpcy5sZW5ndGgsIG90aGVyKTtcbiAgICB9XG4gICAgLy8vIFJldHJpZXZlIHRoZSB0ZXh0IGJldHdlZW4gdGhlIGdpdmVuIHBvaW50cy5cbiAgICBzbGljZShmcm9tLCB0byA9IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgIGxldCBwYXJ0cyA9IFtdO1xuICAgICAgICB0aGlzLmRlY29tcG9zZShmcm9tLCB0bywgcGFydHMsIDApO1xuICAgICAgICByZXR1cm4gVGV4dE5vZGUuZnJvbShwYXJ0cywgdG8gLSBmcm9tKTtcbiAgICB9XG4gICAgLy8vIFRlc3Qgd2hldGhlciB0aGlzIHRleHQgaXMgZXF1YWwgdG8gYW5vdGhlciBpbnN0YW5jZS5cbiAgICBlcShvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIgPT0gdGhpcylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAob3RoZXIubGVuZ3RoICE9IHRoaXMubGVuZ3RoIHx8IG90aGVyLmxpbmVzICE9IHRoaXMubGluZXMpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBhID0gbmV3IFJhd1RleHRDdXJzb3IodGhpcyksIGIgPSBuZXcgUmF3VGV4dEN1cnNvcihvdGhlcik7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGEubmV4dCgpO1xuICAgICAgICAgICAgYi5uZXh0KCk7XG4gICAgICAgICAgICBpZiAoYS5saW5lQnJlYWsgIT0gYi5saW5lQnJlYWsgfHwgYS5kb25lICE9IGIuZG9uZSB8fCBhLnZhbHVlICE9IGIudmFsdWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKGEuZG9uZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gSXRlcmF0ZSBvdmVyIHRoZSB0ZXh0LiBXaGVuIGBkaXJgIGlzIGAtMWAsIGl0ZXJhdGlvbiBoYXBwZW5zXG4gICAgLy8vIGZyb20gZW5kIHRvIHN0YXJ0LiBUaGlzIHdpbGwgcmV0dXJuIGxpbmVzIGFuZCB0aGUgYnJlYWtzIGJldHdlZW5cbiAgICAvLy8gdGhlbSBhcyBzZXBhcmF0ZSBzdHJpbmdzLCBhbmQgZm9yIGxvbmcgbGluZXMsIG1pZ2h0IHNwbGl0IGxpbmVzXG4gICAgLy8vIHRoZW1zZWx2ZXMgaW50byBtdWx0aXBsZSBjaHVua3MgYXMgd2VsbC5cbiAgICBpdGVyKGRpciA9IDEpIHsgcmV0dXJuIG5ldyBSYXdUZXh0Q3Vyc29yKHRoaXMsIGRpcik7IH1cbiAgICAvLy8gSXRlcmF0ZSBvdmVyIGEgcmFuZ2Ugb2YgdGhlIHRleHQuIFdoZW4gYGZyb21gID4gYHRvYCwgdGhlXG4gICAgLy8vIGl0ZXJhdG9yIHdpbGwgcnVuIGluIHJldmVyc2UuXG4gICAgaXRlclJhbmdlKGZyb20sIHRvID0gdGhpcy5sZW5ndGgpIHsgcmV0dXJuIG5ldyBQYXJ0aWFsVGV4dEN1cnNvcih0aGlzLCBmcm9tLCB0byk7IH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLnNsaWNlU3RyaW5nKDApOyB9XG4gICAgLy8vIENvbnZlcnQgdGhlIGRvY3VtZW50IHRvIGFuIGFycmF5IG9mIGxpbmVzICh3aGljaCBjYW4gYmVcbiAgICAvLy8gZGVzZXJpYWxpemVkIGFnYWluIHZpYSBbYFRleHQub2ZgXSgjdGV4dC5UZXh0Xm9mKSkuXG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQgbGluZXMgPSBbXTtcbiAgICAgICAgdGhpcy5mbGF0dGVuKGxpbmVzKTtcbiAgICAgICAgcmV0dXJuIGxpbmVzO1xuICAgIH1cbiAgICAvLy8gQ3JlYXRlIGEgYFRleHRgIGluc3RhbmNlIGZvciB0aGUgZ2l2ZW4gYXJyYXkgb2YgbGluZXMuXG4gICAgc3RhdGljIG9mKHRleHQpIHtcbiAgICAgICAgaWYgKHRleHQubGVuZ3RoID09IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkEgZG9jdW1lbnQgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBsaW5lXCIpO1xuICAgICAgICBpZiAodGV4dC5sZW5ndGggPT0gMSAmJiAhdGV4dFswXSlcbiAgICAgICAgICAgIHJldHVybiBUZXh0LmVtcHR5O1xuICAgICAgICByZXR1cm4gdGV4dC5sZW5ndGggPD0gMzIgLyogQnJhbmNoICovID8gbmV3IFRleHRMZWFmKHRleHQpIDogVGV4dE5vZGUuZnJvbShUZXh0TGVhZi5zcGxpdCh0ZXh0LCBbXSkpO1xuICAgIH1cbn1cbmlmICh0eXBlb2YgU3ltYm9sICE9IFwidW5kZWZpbmVkXCIpXG4gICAgVGV4dC5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuaXRlcigpOyB9O1xuLy8gTGVhdmVzIHN0b3JlIGFuIGFycmF5IG9mIGxpbmUgc3RyaW5ncy4gVGhlcmUgYXJlIGFsd2F5cyBsaW5lIGJyZWFrc1xuLy8gYmV0d2VlbiB0aGVzZSBzdHJpbmdzLiBMZWF2ZXMgYXJlIGxpbWl0ZWQgaW4gc2l6ZSBhbmQgaGF2ZSB0byBiZVxuLy8gY29udGFpbmVkIGluIFRleHROb2RlIGluc3RhbmNlcyBmb3IgYmlnZ2VyIGRvY3VtZW50cy5cbmNsYXNzIFRleHRMZWFmIGV4dGVuZHMgVGV4dCB7XG4gICAgY29uc3RydWN0b3IodGV4dCwgbGVuZ3RoID0gdGV4dExlbmd0aCh0ZXh0KSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICB9XG4gICAgZ2V0IGxpbmVzKCkgeyByZXR1cm4gdGhpcy50ZXh0Lmxlbmd0aDsgfVxuICAgIGdldCBjaGlsZHJlbigpIHsgcmV0dXJuIG51bGw7IH1cbiAgICBsaW5lSW5uZXIodGFyZ2V0LCBpc0xpbmUsIGxpbmUsIG9mZnNldCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDs7IGkrKykge1xuICAgICAgICAgICAgbGV0IHN0cmluZyA9IHRoaXMudGV4dFtpXSwgZW5kID0gb2Zmc2V0ICsgc3RyaW5nLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICgoaXNMaW5lID8gbGluZSA6IGVuZCkgPj0gdGFyZ2V0KVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTGluZShvZmZzZXQsIGVuZCwgbGluZSwgc3RyaW5nKTtcbiAgICAgICAgICAgIG9mZnNldCA9IGVuZCArIDE7XG4gICAgICAgICAgICBsaW5lKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVjb21wb3NlKGZyb20sIHRvLCB0YXJnZXQsIG9wZW4pIHtcbiAgICAgICAgbGV0IHRleHQgPSBmcm9tIDw9IDAgJiYgdG8gPj0gdGhpcy5sZW5ndGggPyB0aGlzXG4gICAgICAgICAgICA6IG5ldyBUZXh0TGVhZihzbGljZVRleHQodGhpcy50ZXh0LCBmcm9tLCB0byksIE1hdGgubWluKHRvLCB0aGlzLmxlbmd0aCkgLSBNYXRoLm1heCgwLCBmcm9tKSk7XG4gICAgICAgIGlmIChvcGVuICYgMSAvKiBGcm9tICovKSB7XG4gICAgICAgICAgICBsZXQgcHJldiA9IHRhcmdldC5wb3AoKTtcbiAgICAgICAgICAgIGxldCBqb2luZWQgPSBhcHBlbmRUZXh0KHRleHQudGV4dCwgcHJldi50ZXh0LnNsaWNlKCksIDAsIHRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChqb2luZWQubGVuZ3RoIDw9IDMyIC8qIEJyYW5jaCAqLykge1xuICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKG5ldyBUZXh0TGVhZihqb2luZWQsIHByZXYubGVuZ3RoICsgdGV4dC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBtaWQgPSBqb2luZWQubGVuZ3RoID4+IDE7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2gobmV3IFRleHRMZWFmKGpvaW5lZC5zbGljZSgwLCBtaWQpKSwgbmV3IFRleHRMZWFmKGpvaW5lZC5zbGljZShtaWQpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXQucHVzaCh0ZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXBsYWNlKGZyb20sIHRvLCB0ZXh0KSB7XG4gICAgICAgIGlmICghKHRleHQgaW5zdGFuY2VvZiBUZXh0TGVhZikpXG4gICAgICAgICAgICByZXR1cm4gc3VwZXIucmVwbGFjZShmcm9tLCB0bywgdGV4dCk7XG4gICAgICAgIGxldCBsaW5lcyA9IGFwcGVuZFRleHQodGhpcy50ZXh0LCBhcHBlbmRUZXh0KHRleHQudGV4dCwgc2xpY2VUZXh0KHRoaXMudGV4dCwgMCwgZnJvbSkpLCB0byk7XG4gICAgICAgIGxldCBuZXdMZW4gPSB0aGlzLmxlbmd0aCArIHRleHQubGVuZ3RoIC0gKHRvIC0gZnJvbSk7XG4gICAgICAgIGlmIChsaW5lcy5sZW5ndGggPD0gMzIgLyogQnJhbmNoICovKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0TGVhZihsaW5lcywgbmV3TGVuKTtcbiAgICAgICAgcmV0dXJuIFRleHROb2RlLmZyb20oVGV4dExlYWYuc3BsaXQobGluZXMsIFtdKSwgbmV3TGVuKTtcbiAgICB9XG4gICAgc2xpY2VTdHJpbmcoZnJvbSwgdG8gPSB0aGlzLmxlbmd0aCwgbGluZVNlcCA9IFwiXFxuXCIpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDAsIGkgPSAwOyBwb3MgPD0gdG8gJiYgaSA8IHRoaXMudGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSB0aGlzLnRleHRbaV0sIGVuZCA9IHBvcyArIGxpbmUubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHBvcyA+IGZyb20gJiYgaSlcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gbGluZVNlcDtcbiAgICAgICAgICAgIGlmIChmcm9tIDwgZW5kICYmIHRvID4gcG9zKVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBsaW5lLnNsaWNlKE1hdGgubWF4KDAsIGZyb20gLSBwb3MpLCB0byAtIHBvcyk7XG4gICAgICAgICAgICBwb3MgPSBlbmQgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZsYXR0ZW4odGFyZ2V0KSB7XG4gICAgICAgIGZvciAobGV0IGxpbmUgb2YgdGhpcy50ZXh0KVxuICAgICAgICAgICAgdGFyZ2V0LnB1c2gobGluZSk7XG4gICAgfVxuICAgIHN0YXRpYyBzcGxpdCh0ZXh0LCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IHBhcnQgPSBbXSwgbGVuID0gLTE7XG4gICAgICAgIGZvciAobGV0IGxpbmUgb2YgdGV4dCkge1xuICAgICAgICAgICAgcGFydC5wdXNoKGxpbmUpO1xuICAgICAgICAgICAgbGVuICs9IGxpbmUubGVuZ3RoICsgMTtcbiAgICAgICAgICAgIGlmIChwYXJ0Lmxlbmd0aCA9PSAzMiAvKiBCcmFuY2ggKi8pIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChuZXcgVGV4dExlYWYocGFydCwgbGVuKSk7XG4gICAgICAgICAgICAgICAgcGFydCA9IFtdO1xuICAgICAgICAgICAgICAgIGxlbiA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsZW4gPiAtMSlcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKG5ldyBUZXh0TGVhZihwYXJ0LCBsZW4pKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG59XG4vLyBOb2RlcyBwcm92aWRlIHRoZSB0cmVlIHN0cnVjdHVyZSBvZiB0aGUgYFRleHRgIHR5cGUuIFRoZXkgc3RvcmUgYVxuLy8gbnVtYmVyIG9mIG90aGVyIG5vZGVzIG9yIGxlYXZlcywgdGFraW5nIGNhcmUgdG8gYmFsYW5jZSB0aGVtc2VsdmVzXG4vLyBvbiBjaGFuZ2VzLiBUaGVyZSBhcmUgaW1wbGllZCBsaW5lIGJyZWFrcyBfYmV0d2Vlbl8gdGhlIGNoaWxkcmVuIG9mXG4vLyBhIG5vZGUgKGJ1dCBub3QgYmVmb3JlIHRoZSBmaXJzdCBvciBhZnRlciB0aGUgbGFzdCBjaGlsZCkuXG5jbGFzcyBUZXh0Tm9kZSBleHRlbmRzIFRleHQge1xuICAgIGNvbnN0cnVjdG9yKGNoaWxkcmVuLCBsZW5ndGgpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5saW5lcyA9IDA7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIGNoaWxkcmVuKVxuICAgICAgICAgICAgdGhpcy5saW5lcyArPSBjaGlsZC5saW5lcztcbiAgICB9XG4gICAgbGluZUlubmVyKHRhcmdldCwgaXNMaW5lLCBsaW5lLCBvZmZzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IG9mZnNldCArIGNoaWxkLmxlbmd0aCwgZW5kTGluZSA9IGxpbmUgKyBjaGlsZC5saW5lcyAtIDE7XG4gICAgICAgICAgICBpZiAoKGlzTGluZSA/IGVuZExpbmUgOiBlbmQpID49IHRhcmdldClcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQubGluZUlubmVyKHRhcmdldCwgaXNMaW5lLCBsaW5lLCBvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gZW5kICsgMTtcbiAgICAgICAgICAgIGxpbmUgPSBlbmRMaW5lICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWNvbXBvc2UoZnJvbSwgdG8sIHRhcmdldCwgb3Blbikge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgcG9zIDw9IHRvICYmIGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoZnJvbSA8PSBlbmQgJiYgdG8gPj0gcG9zKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkT3BlbiA9IG9wZW4gJiAoKHBvcyA8PSBmcm9tID8gMSAvKiBGcm9tICovIDogMCkgfCAoZW5kID49IHRvID8gMiAvKiBUbyAqLyA6IDApKTtcbiAgICAgICAgICAgICAgICBpZiAocG9zID49IGZyb20gJiYgZW5kIDw9IHRvICYmICFjaGlsZE9wZW4pXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmRlY29tcG9zZShmcm9tIC0gcG9zLCB0byAtIHBvcywgdGFyZ2V0LCBjaGlsZE9wZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zID0gZW5kICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXBsYWNlKGZyb20sIHRvLCB0ZXh0KSB7XG4gICAgICAgIGlmICh0ZXh0LmxpbmVzIDwgdGhpcy5saW5lcylcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IHBvcyArIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAvLyBGYXN0IHBhdGg6IGlmIHRoZSBjaGFuZ2Ugb25seSBhZmZlY3RzIG9uZSBjaGlsZCBhbmQgdGhlXG4gICAgICAgICAgICAgICAgLy8gY2hpbGQncyBzaXplIHJlbWFpbnMgaW4gdGhlIGFjY2VwdGFibGUgcmFuZ2UsIG9ubHkgdXBkYXRlXG4gICAgICAgICAgICAgICAgLy8gdGhhdCBjaGlsZFxuICAgICAgICAgICAgICAgIGlmIChmcm9tID49IHBvcyAmJiB0byA8PSBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHVwZGF0ZWQgPSBjaGlsZC5yZXBsYWNlKGZyb20gLSBwb3MsIHRvIC0gcG9zLCB0ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRvdGFsTGluZXMgPSB0aGlzLmxpbmVzIC0gY2hpbGQubGluZXMgKyB1cGRhdGVkLmxpbmVzO1xuICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlZC5saW5lcyA8ICh0b3RhbExpbmVzID4+ICg1IC8qIEJyYW5jaFNoaWZ0ICovIC0gMSkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkLmxpbmVzID4gKHRvdGFsTGluZXMgPj4gKDUgLyogQnJhbmNoU2hpZnQgKi8gKyAxKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb3B5ID0gdGhpcy5jaGlsZHJlbi5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29weVtpXSA9IHVwZGF0ZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRleHROb2RlKGNvcHksIHRoaXMubGVuZ3RoIC0gKHRvIC0gZnJvbSkgKyB0ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1cGVyLnJlcGxhY2UocG9zLCBlbmQsIHVwZGF0ZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb3MgPSBlbmQgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIucmVwbGFjZShmcm9tLCB0bywgdGV4dCk7XG4gICAgfVxuICAgIHNsaWNlU3RyaW5nKGZyb20sIHRvID0gdGhpcy5sZW5ndGgsIGxpbmVTZXAgPSBcIlxcblwiKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoICYmIHBvcyA8PSB0bzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAocG9zID4gZnJvbSAmJiBpKVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBsaW5lU2VwO1xuICAgICAgICAgICAgaWYgKGZyb20gPCBlbmQgJiYgdG8gPiBwb3MpXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGNoaWxkLnNsaWNlU3RyaW5nKGZyb20gLSBwb3MsIHRvIC0gcG9zLCBsaW5lU2VwKTtcbiAgICAgICAgICAgIHBvcyA9IGVuZCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZmxhdHRlbih0YXJnZXQpIHtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbilcbiAgICAgICAgICAgIGNoaWxkLmZsYXR0ZW4odGFyZ2V0KTtcbiAgICB9XG4gICAgc3RhdGljIGZyb20oY2hpbGRyZW4sIGxlbmd0aCA9IGNoaWxkcmVuLnJlZHVjZSgobCwgY2gpID0+IGwgKyBjaC5sZW5ndGggKyAxLCAtMSkpIHtcbiAgICAgICAgbGV0IGxpbmVzID0gMDtcbiAgICAgICAgZm9yIChsZXQgY2ggb2YgY2hpbGRyZW4pXG4gICAgICAgICAgICBsaW5lcyArPSBjaC5saW5lcztcbiAgICAgICAgaWYgKGxpbmVzIDwgMzIgLyogQnJhbmNoICovKSB7XG4gICAgICAgICAgICBsZXQgZmxhdCA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgY2ggb2YgY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgY2guZmxhdHRlbihmbGF0KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dExlYWYoZmxhdCwgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2h1bmsgPSBNYXRoLm1heCgzMiAvKiBCcmFuY2ggKi8sIGxpbmVzID4+IDUgLyogQnJhbmNoU2hpZnQgKi8pLCBtYXhDaHVuayA9IGNodW5rIDw8IDEsIG1pbkNodW5rID0gY2h1bmsgPj4gMTtcbiAgICAgICAgbGV0IGNodW5rZWQgPSBbXSwgY3VycmVudExpbmVzID0gMCwgY3VycmVudExlbiA9IC0xLCBjdXJyZW50Q2h1bmsgPSBbXTtcbiAgICAgICAgZnVuY3Rpb24gYWRkKGNoaWxkKSB7XG4gICAgICAgICAgICBsZXQgbGFzdDtcbiAgICAgICAgICAgIGlmIChjaGlsZC5saW5lcyA+IG1heENodW5rICYmIGNoaWxkIGluc3RhbmNlb2YgVGV4dE5vZGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBub2RlIG9mIGNoaWxkLmNoaWxkcmVuKVxuICAgICAgICAgICAgICAgICAgICBhZGQobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGlsZC5saW5lcyA+IG1pbkNodW5rICYmIChjdXJyZW50TGluZXMgPiBtaW5DaHVuayB8fCAhY3VycmVudExpbmVzKSkge1xuICAgICAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgICAgICAgICAgY2h1bmtlZC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkIGluc3RhbmNlb2YgVGV4dExlYWYgJiYgY3VycmVudExpbmVzICYmXG4gICAgICAgICAgICAgICAgKGxhc3QgPSBjdXJyZW50Q2h1bmtbY3VycmVudENodW5rLmxlbmd0aCAtIDFdKSBpbnN0YW5jZW9mIFRleHRMZWFmICYmXG4gICAgICAgICAgICAgICAgY2hpbGQubGluZXMgKyBsYXN0LmxpbmVzIDw9IDMyIC8qIEJyYW5jaCAqLykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMaW5lcyArPSBjaGlsZC5saW5lcztcbiAgICAgICAgICAgICAgICBjdXJyZW50TGVuICs9IGNoaWxkLmxlbmd0aCArIDE7XG4gICAgICAgICAgICAgICAgY3VycmVudENodW5rW2N1cnJlbnRDaHVuay5sZW5ndGggLSAxXSA9IG5ldyBUZXh0TGVhZihsYXN0LnRleHQuY29uY2F0KGNoaWxkLnRleHQpLCBsYXN0Lmxlbmd0aCArIDEgKyBjaGlsZC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRMaW5lcyArIGNoaWxkLmxpbmVzID4gY2h1bmspXG4gICAgICAgICAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgICAgICAgICAgY3VycmVudExpbmVzICs9IGNoaWxkLmxpbmVzO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMZW4gKz0gY2hpbGQubGVuZ3RoICsgMTtcbiAgICAgICAgICAgICAgICBjdXJyZW50Q2h1bmsucHVzaChjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudExpbmVzID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2h1bmtlZC5wdXNoKGN1cnJlbnRDaHVuay5sZW5ndGggPT0gMSA/IGN1cnJlbnRDaHVua1swXSA6IFRleHROb2RlLmZyb20oY3VycmVudENodW5rLCBjdXJyZW50TGVuKSk7XG4gICAgICAgICAgICBjdXJyZW50TGVuID0gLTE7XG4gICAgICAgICAgICBjdXJyZW50TGluZXMgPSBjdXJyZW50Q2h1bmsubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBjaGlsZHJlbilcbiAgICAgICAgICAgIGFkZChjaGlsZCk7XG4gICAgICAgIGZsdXNoKCk7XG4gICAgICAgIHJldHVybiBjaHVua2VkLmxlbmd0aCA9PSAxID8gY2h1bmtlZFswXSA6IG5ldyBUZXh0Tm9kZShjaHVua2VkLCBsZW5ndGgpO1xuICAgIH1cbn1cblRleHQuZW1wdHkgPSBuZXcgVGV4dExlYWYoW1wiXCJdLCAwKTtcbmZ1bmN0aW9uIHRleHRMZW5ndGgodGV4dCkge1xuICAgIGxldCBsZW5ndGggPSAtMTtcbiAgICBmb3IgKGxldCBsaW5lIG9mIHRleHQpXG4gICAgICAgIGxlbmd0aCArPSBsaW5lLmxlbmd0aCArIDE7XG4gICAgcmV0dXJuIGxlbmd0aDtcbn1cbmZ1bmN0aW9uIGFwcGVuZFRleHQodGV4dCwgdGFyZ2V0LCBmcm9tID0gMCwgdG8gPSAxZTkpIHtcbiAgICBmb3IgKGxldCBwb3MgPSAwLCBpID0gMCwgZmlyc3QgPSB0cnVlOyBpIDwgdGV4dC5sZW5ndGggJiYgcG9zIDw9IHRvOyBpKyspIHtcbiAgICAgICAgbGV0IGxpbmUgPSB0ZXh0W2ldLCBlbmQgPSBwb3MgKyBsaW5lLmxlbmd0aDtcbiAgICAgICAgaWYgKGVuZCA+PSBmcm9tKSB7XG4gICAgICAgICAgICBpZiAoZW5kID4gdG8pXG4gICAgICAgICAgICAgICAgbGluZSA9IGxpbmUuc2xpY2UoMCwgdG8gLSBwb3MpO1xuICAgICAgICAgICAgaWYgKHBvcyA8IGZyb20pXG4gICAgICAgICAgICAgICAgbGluZSA9IGxpbmUuc2xpY2UoZnJvbSAtIHBvcyk7XG4gICAgICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbdGFyZ2V0Lmxlbmd0aCAtIDFdICs9IGxpbmU7XG4gICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChsaW5lKTtcbiAgICAgICAgfVxuICAgICAgICBwb3MgPSBlbmQgKyAxO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gc2xpY2VUZXh0KHRleHQsIGZyb20sIHRvKSB7XG4gICAgcmV0dXJuIGFwcGVuZFRleHQodGV4dCwgW1wiXCJdLCBmcm9tLCB0byk7XG59XG5jbGFzcyBSYXdUZXh0Q3Vyc29yIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBkaXIgPSAxKSB7XG4gICAgICAgIHRoaXMuZGlyID0gZGlyO1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5saW5lQnJlYWsgPSBmYWxzZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IFwiXCI7XG4gICAgICAgIHRoaXMubm9kZXMgPSBbdGV4dF07XG4gICAgICAgIHRoaXMub2Zmc2V0cyA9IFtkaXIgPiAwID8gMCA6IHRleHQgaW5zdGFuY2VvZiBUZXh0TGVhZiA/IHRleHQudGV4dC5sZW5ndGggOiB0ZXh0LmNoaWxkcmVuLmxlbmd0aF07XG4gICAgfVxuICAgIG5leHQoc2tpcCA9IDApIHtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGxhc3QgPSB0aGlzLm5vZGVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBpZiAobGFzdCA8IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHRoaXMubGluZUJyZWFrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdG9wID0gdGhpcy5ub2Rlc1tsYXN0XSwgb2Zmc2V0ID0gdGhpcy5vZmZzZXRzW2xhc3RdO1xuICAgICAgICAgICAgbGV0IHNpemUgPSB0b3AgaW5zdGFuY2VvZiBUZXh0TGVhZiA/IHRvcC50ZXh0Lmxlbmd0aCA6IHRvcC5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID09ICh0aGlzLmRpciA+IDAgPyBzaXplIDogMCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0cy5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLmxpbmVCcmVhayAmJiBvZmZzZXQgIT0gKHRoaXMuZGlyID4gMCA/IDAgOiBzaXplKSkge1xuICAgICAgICAgICAgICAgIC8vIEludGVybmFsIG9mZnNldCB3aXRoIGxpbmVCcmVhayA9PSBmYWxzZSBtZWFucyB3ZSBoYXZlIHRvXG4gICAgICAgICAgICAgICAgLy8gY291bnQgdGhlIGxpbmUgYnJlYWsgYXQgdGhpcyBwb3NpdGlvblxuICAgICAgICAgICAgICAgIHRoaXMubGluZUJyZWFrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcIlxcblwiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2tpcC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodG9wIGluc3RhbmNlb2YgVGV4dExlYWYpIHtcbiAgICAgICAgICAgICAgICAvLyBNb3ZlIHRvIHRoZSBuZXh0IHN0cmluZ1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gdG9wLnRleHRbb2Zmc2V0IC0gKHRoaXMuZGlyIDwgMCA/IDEgOiAwKV07XG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRzW2xhc3RdID0gKG9mZnNldCArPSB0aGlzLmRpcik7XG4gICAgICAgICAgICAgICAgdGhpcy5saW5lQnJlYWsgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dC5sZW5ndGggPiBNYXRoLm1heCgwLCBza2lwKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gc2tpcCA9PSAwID8gbmV4dCA6IHRoaXMuZGlyID4gMCA/IG5leHQuc2xpY2Uoc2tpcCkgOiBuZXh0LnNsaWNlKDAsIG5leHQubGVuZ3RoIC0gc2tpcCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBza2lwIC09IG5leHQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSB0b3AuY2hpbGRyZW5bdGhpcy5kaXIgPiAwID8gb2Zmc2V0IDogb2Zmc2V0IC0gMV07XG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRzW2xhc3RdID0gb2Zmc2V0ICsgdGhpcy5kaXI7XG4gICAgICAgICAgICAgICAgdGhpcy5saW5lQnJlYWsgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcCA+IG5leHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNraXAgLT0gbmV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2gobmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0cy5wdXNoKHRoaXMuZGlyID4gMCA/IDAgOiBuZXh0IGluc3RhbmNlb2YgVGV4dExlYWYgPyBuZXh0LnRleHQubGVuZ3RoIDogbmV4dC5jaGlsZHJlbi5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIFBhcnRpYWxUZXh0Q3Vyc29yIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBzdGFydCwgZW5kKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgICB0aGlzLmN1cnNvciA9IG5ldyBSYXdUZXh0Q3Vyc29yKHRleHQsIHN0YXJ0ID4gZW5kID8gLTEgOiAxKTtcbiAgICAgICAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgICAgICAgICB0aGlzLnNraXAgPSB0ZXh0Lmxlbmd0aCAtIHN0YXJ0O1xuICAgICAgICAgICAgdGhpcy5saW1pdCA9IHN0YXJ0IC0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5za2lwID0gc3RhcnQ7XG4gICAgICAgICAgICB0aGlzLmxpbWl0ID0gZW5kIC0gc3RhcnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmV4dChza2lwID0gMCkge1xuICAgICAgICBpZiAodGhpcy5saW1pdCA8PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmxpbWl0ID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgeyB2YWx1ZSwgbGluZUJyZWFrLCBkb25lIH0gPSB0aGlzLmN1cnNvci5uZXh0KHRoaXMuc2tpcCArIHNraXApO1xuICAgICAgICAgICAgdGhpcy5za2lwID0gMDtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIGxldCBsZW4gPSBsaW5lQnJlYWsgPyAxIDogdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGxlbiA+IHRoaXMubGltaXQpXG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuY3Vyc29yLmRpciA+IDAgPyB2YWx1ZS5zbGljZSgwLCB0aGlzLmxpbWl0KSA6IHZhbHVlLnNsaWNlKGxlbiAtIHRoaXMubGltaXQpO1xuICAgICAgICAgICAgaWYgKGRvbmUgfHwgdGhpcy52YWx1ZS5sZW5ndGggPT0gMClcbiAgICAgICAgICAgICAgICB0aGlzLmxpbWl0ID0gLTE7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5saW1pdCAtPSB0aGlzLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IGxpbmVCcmVhaygpIHsgcmV0dXJuIHRoaXMuY3Vyc29yLmxpbmVCcmVhazsgfVxuICAgIGdldCBkb25lKCkgeyByZXR1cm4gdGhpcy5saW1pdCA8IDA7IH1cbn1cbi8vLyBUaGlzIHR5cGUgZGVzY3JpYmVzIGEgbGluZSBpbiB0aGUgZG9jdW1lbnQuIEl0IGlzIGNyZWF0ZWRcbi8vLyBvbi1kZW1hbmQgd2hlbiBsaW5lcyBhcmUgW3F1ZXJpZWRdKCN0ZXh0LlRleHQubGluZUF0KS5cbmNsYXNzIExpbmUge1xuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gVGhlIHBvc2l0aW9uIG9mIHRoZSBzdGFydCBvZiB0aGUgbGluZS5cbiAgICBmcm9tLCBcbiAgICAvLy8gVGhlIHBvc2l0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIGxpbmUgKF9iZWZvcmVfIHRoZSBsaW5lIGJyZWFrLFxuICAgIC8vLyBvciBhdCB0aGUgZW5kIG9mIGRvY3VtZW50IGZvciB0aGUgbGFzdCBsaW5lKS5cbiAgICB0bywgXG4gICAgLy8vIFRoaXMgbGluZSdzIGxpbmUgbnVtYmVyICgxLWJhc2VkKS5cbiAgICBudW1iZXIsIFxuICAgIC8vLyBUaGUgbGluZSdzIGNvbnRlbnQuXG4gICAgdGV4dCkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMubnVtYmVyID0gbnVtYmVyO1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIH1cbiAgICAvLy8gVGhlIGxlbmd0aCBvZiB0aGUgbGluZSAobm90IGluY2x1ZGluZyBhbnkgbGluZSBicmVhayBhZnRlciBpdCkuXG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMudG8gLSB0aGlzLmZyb207IH1cbn1cblxuZXhwb3J0cy5MaW5lID0gTGluZTtcbmV4cG9ydHMuVGV4dCA9IFRleHQ7XG5leHBvcnRzLmNvZGVQb2ludEF0ID0gY29kZVBvaW50QXQ7XG5leHBvcnRzLmNvZGVQb2ludFNpemUgPSBjb2RlUG9pbnRTaXplO1xuZXhwb3J0cy5jb3VudENvbHVtbiA9IGNvdW50Q29sdW1uO1xuZXhwb3J0cy5maW5kQ2x1c3RlckJyZWFrID0gZmluZENsdXN0ZXJCcmVhaztcbmV4cG9ydHMuZmluZENvbHVtbiA9IGZpbmRDb2x1bW47XG5leHBvcnRzLmZyb21Db2RlUG9pbnQgPSBmcm9tQ29kZVBvaW50O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgdmlldyA9IHJlcXVpcmUoJ0Bjb2RlbWlycm9yL3ZpZXcnKTtcbnZhciBzdGF0ZSA9IHJlcXVpcmUoJ0Bjb2RlbWlycm9yL3N0YXRlJyk7XG5cbmNvbnN0IGlvcyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICEvRWRnZVxcLyhcXGQrKS8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAvQXBwbGUgQ29tcHV0ZXIvLnRlc3QobmF2aWdhdG9yLnZlbmRvcikgJiZcbiAgICAoL01vYmlsZVxcL1xcdysvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMik7XG5jb25zdCBPdXRzaWRlID0gXCItMTAwMDBweFwiO1xuY29uc3QgdG9vbHRpcFBsdWdpbiA9IHZpZXcuVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5pblZpZXcgPSB0cnVlO1xuICAgICAgICB0aGlzLm1lYXN1cmVSZXEgPSB7IHJlYWQ6IHRoaXMucmVhZE1lYXN1cmUuYmluZCh0aGlzKSwgd3JpdGU6IHRoaXMud3JpdGVNZWFzdXJlLmJpbmQodGhpcyksIGtleTogdGhpcyB9O1xuICAgICAgICB0aGlzLmlucHV0ID0gdmlldy5zdGF0ZS5mYWNldChzaG93VG9vbHRpcCk7XG4gICAgICAgIHRoaXMudG9vbHRpcHMgPSB0aGlzLmlucHV0LmZpbHRlcih0ID0+IHQpO1xuICAgICAgICB0aGlzLnRvb2x0aXBWaWV3cyA9IHRoaXMudG9vbHRpcHMubWFwKHRwID0+IHRoaXMuY3JlYXRlVG9vbHRpcCh0cCkpO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGxldCBpbnB1dCA9IHVwZGF0ZS5zdGF0ZS5mYWNldChzaG93VG9vbHRpcCk7XG4gICAgICAgIGlmIChpbnB1dCA9PSB0aGlzLmlucHV0KSB7XG4gICAgICAgICAgICBmb3IgKGxldCB0IG9mIHRoaXMudG9vbHRpcFZpZXdzKVxuICAgICAgICAgICAgICAgIGlmICh0LnVwZGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgdC51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCB0b29sdGlwcyA9IGlucHV0LmZpbHRlcih4ID0+IHgpO1xuICAgICAgICAgICAgbGV0IHZpZXdzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvb2x0aXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRpcCA9IHRvb2x0aXBzW2ldLCBrbm93biA9IC0xO1xuICAgICAgICAgICAgICAgIGlmICghdGlwKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudG9vbHRpcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG90aGVyID0gdGhpcy50b29sdGlwc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVyICYmIG90aGVyLmNyZWF0ZSA9PSB0aXAuY3JlYXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAga25vd24gPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoa25vd24gPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdzW2ldID0gdGhpcy5jcmVhdGVUb29sdGlwKHRpcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdG9vbHRpcFZpZXcgPSB2aWV3c1tpXSA9IHRoaXMudG9vbHRpcFZpZXdzW2tub3duXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvb2x0aXBWaWV3LnVwZGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2x0aXBWaWV3LnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgdGhpcy50b29sdGlwVmlld3MpXG4gICAgICAgICAgICAgICAgaWYgKHZpZXdzLmluZGV4T2YodCkgPCAwKVxuICAgICAgICAgICAgICAgICAgICB0LmRvbS5yZW1vdmUoKTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgICAgIHRoaXMudG9vbHRpcHMgPSB0b29sdGlwcztcbiAgICAgICAgICAgIHRoaXMudG9vbHRpcFZpZXdzID0gdmlld3M7XG4gICAgICAgICAgICB0aGlzLm1heWJlTWVhc3VyZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZVRvb2x0aXAodG9vbHRpcCkge1xuICAgICAgICBsZXQgdG9vbHRpcFZpZXcgPSB0b29sdGlwLmNyZWF0ZSh0aGlzLnZpZXcpO1xuICAgICAgICB0b29sdGlwVmlldy5kb20uY2xhc3NMaXN0LmFkZChcImNtLXRvb2x0aXBcIik7XG4gICAgICAgIC8vIEZJWE1FIGRyb3AgdGhpcyBvbiB0aGUgbmV4dCBicmVha2luZyByZWxlYXNlXG4gICAgICAgIGlmICh0b29sdGlwLmNsYXNzKVxuICAgICAgICAgICAgdG9vbHRpcFZpZXcuZG9tLmNsYXNzTGlzdC5hZGQodG9vbHRpcC5jbGFzcyk7XG4gICAgICAgIHRvb2x0aXBWaWV3LmRvbS5zdHlsZS50b3AgPSBPdXRzaWRlO1xuICAgICAgICB0aGlzLnZpZXcuZG9tLmFwcGVuZENoaWxkKHRvb2x0aXBWaWV3LmRvbSk7XG4gICAgICAgIGlmICh0b29sdGlwVmlldy5tb3VudClcbiAgICAgICAgICAgIHRvb2x0aXBWaWV3Lm1vdW50KHRoaXMudmlldyk7XG4gICAgICAgIHJldHVybiB0b29sdGlwVmlldztcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgZm9yIChsZXQgeyBkb20gfSBvZiB0aGlzLnRvb2x0aXBWaWV3cylcbiAgICAgICAgICAgIGRvbS5yZW1vdmUoKTtcbiAgICB9XG4gICAgcmVhZE1lYXN1cmUoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlZGl0b3I6IHRoaXMudmlldy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgICBwb3M6IHRoaXMudG9vbHRpcHMubWFwKHQgPT4gdGhpcy52aWV3LmNvb3Jkc0F0UG9zKHQucG9zKSksXG4gICAgICAgICAgICBzaXplOiB0aGlzLnRvb2x0aXBWaWV3cy5tYXAoKHsgZG9tIH0pID0+IGRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSksXG4gICAgICAgICAgICBpbm5lcldpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCxcbiAgICAgICAgICAgIGlubmVySGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHRcbiAgICAgICAgfTtcbiAgICB9XG4gICAgd3JpdGVNZWFzdXJlKG1lYXN1cmVkKSB7XG4gICAgICAgIGxldCB7IGVkaXRvciB9ID0gbWVhc3VyZWQ7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy50b29sdGlwVmlld3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB0b29sdGlwID0gdGhpcy50b29sdGlwc1tpXSwgdFZpZXcgPSB0aGlzLnRvb2x0aXBWaWV3c1tpXSwgeyBkb20gfSA9IHRWaWV3O1xuICAgICAgICAgICAgbGV0IHBvcyA9IG1lYXN1cmVkLnBvc1tpXSwgc2l6ZSA9IG1lYXN1cmVkLnNpemVbaV07XG4gICAgICAgICAgICAvLyBIaWRlIHRvb2x0aXBzIHRoYXQgYXJlIG91dHNpZGUgb2YgdGhlIGVkaXRvci5cbiAgICAgICAgICAgIGlmICghcG9zIHx8IHBvcy5ib3R0b20gPD0gZWRpdG9yLnRvcCB8fCBwb3MudG9wID49IGVkaXRvci5ib3R0b20gfHwgcG9zLnJpZ2h0IDw9IGVkaXRvci5sZWZ0IHx8IHBvcy5sZWZ0ID49IGVkaXRvci5yaWdodCkge1xuICAgICAgICAgICAgICAgIGRvbS5zdHlsZS50b3AgPSBPdXRzaWRlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHdpZHRoID0gc2l6ZS5yaWdodCAtIHNpemUubGVmdCwgaGVpZ2h0ID0gc2l6ZS5ib3R0b20gLSBzaXplLnRvcDtcbiAgICAgICAgICAgIGxldCBsZWZ0ID0gdGhpcy52aWV3LnRleHREaXJlY3Rpb24gPT0gdmlldy5EaXJlY3Rpb24uTFRSID8gTWF0aC5taW4ocG9zLmxlZnQsIG1lYXN1cmVkLmlubmVyV2lkdGggLSB3aWR0aClcbiAgICAgICAgICAgICAgICA6IE1hdGgubWF4KDAsIHBvcy5sZWZ0IC0gd2lkdGgpO1xuICAgICAgICAgICAgbGV0IGFib3ZlID0gISF0b29sdGlwLmFib3ZlO1xuICAgICAgICAgICAgaWYgKCF0b29sdGlwLnN0cmljdFNpZGUgJiZcbiAgICAgICAgICAgICAgICAoYWJvdmUgPyBwb3MudG9wIC0gKHNpemUuYm90dG9tIC0gc2l6ZS50b3ApIDwgMCA6IHBvcy5ib3R0b20gKyAoc2l6ZS5ib3R0b20gLSBzaXplLnRvcCkgPiBtZWFzdXJlZC5pbm5lckhlaWdodCkpXG4gICAgICAgICAgICAgICAgYWJvdmUgPSAhYWJvdmU7XG4gICAgICAgICAgICBpZiAoaW9zKSB7XG4gICAgICAgICAgICAgICAgZG9tLnN0eWxlLnRvcCA9ICgoYWJvdmUgPyBwb3MudG9wIC0gaGVpZ2h0IDogcG9zLmJvdHRvbSkgLSBlZGl0b3IudG9wKSArIFwicHhcIjtcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUubGVmdCA9IChsZWZ0IC0gZWRpdG9yLmxlZnQpICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIGRvbS5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvbS5zdHlsZS50b3AgPSAoYWJvdmUgPyBwb3MudG9wIC0gaGVpZ2h0IDogcG9zLmJvdHRvbSkgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgZG9tLnN0eWxlLmxlZnQgPSBsZWZ0ICsgXCJweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9tLmNsYXNzTGlzdC50b2dnbGUoXCJjbS10b29sdGlwLWFib3ZlXCIsIGFib3ZlKTtcbiAgICAgICAgICAgIGRvbS5jbGFzc0xpc3QudG9nZ2xlKFwiY20tdG9vbHRpcC1iZWxvd1wiLCAhYWJvdmUpO1xuICAgICAgICAgICAgaWYgKHRWaWV3LnBvc2l0aW9uZWQpXG4gICAgICAgICAgICAgICAgdFZpZXcucG9zaXRpb25lZCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1heWJlTWVhc3VyZSgpIHtcbiAgICAgICAgaWYgKHRoaXMudG9vbHRpcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy52aWV3LmluVmlldyB8fCB0aGlzLmluVmlldylcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUodGhpcy5tZWFzdXJlUmVxKTtcbiAgICAgICAgICAgIHRoaXMuaW5WaWV3ID0gdGhpcy52aWV3LmluVmlldztcbiAgICAgICAgfVxuICAgIH1cbn0sIHtcbiAgICBldmVudEhhbmRsZXJzOiB7XG4gICAgICAgIHNjcm9sbCgpIHsgdGhpcy5tYXliZU1lYXN1cmUoKTsgfVxuICAgIH1cbn0pO1xuY29uc3QgYmFzZVRoZW1lID0gdmlldy5FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCIuY20tdG9vbHRpcFwiOiB7XG4gICAgICAgIHBvc2l0aW9uOiBcImZpeGVkXCIsXG4gICAgICAgIHpJbmRleDogMTAwXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tdG9vbHRpcFwiOiB7XG4gICAgICAgIGJvcmRlcjogXCIxcHggc29saWQgI2RkZFwiLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2Y1ZjVmNVwiXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS10b29sdGlwXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiMzMzMzMzhcIixcbiAgICAgICAgY29sb3I6IFwid2hpdGVcIlxuICAgIH1cbn0pO1xuLy8gRklYTUUgYmFja3dhcmQtY29tcGF0IHNoaW0uIERlbGV0ZSBvbiBuZXh0IG1ham9yIHZlcnNpb24uXG4vKipcbkBpbnRlcm5hbFxuKi9cbmZ1bmN0aW9uIHRvb2x0aXBzKCkge1xuICAgIHJldHVybiBbXTtcbn1cbi8qKlxuQmVoYXZpb3IgYnkgd2hpY2ggYW4gZXh0ZW5zaW9uIGNhbiBwcm92aWRlIGEgdG9vbHRpcCB0byBiZSBzaG93bi5cbiovXG5jb25zdCBzaG93VG9vbHRpcCA9IHN0YXRlLkZhY2V0LmRlZmluZSh7XG4gICAgZW5hYmxlczogW3Rvb2x0aXBQbHVnaW4sIGJhc2VUaGVtZV1cbn0pO1xuY29uc3QgSG92ZXJUaW1lID0gNzUwLCBIb3Zlck1heERpc3QgPSA2O1xuY2xhc3MgSG92ZXJQbHVnaW4ge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIHNvdXJjZSwgZmllbGQsIHNldEhvdmVyKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQ7XG4gICAgICAgIHRoaXMuc2V0SG92ZXIgPSBzZXRIb3ZlcjtcbiAgICAgICAgdGhpcy5sYXN0TW91c2VNb3ZlID0gbnVsbDtcbiAgICAgICAgdGhpcy5ob3ZlclRpbWVvdXQgPSAtMTtcbiAgICAgICAgdGhpcy5yZXN0YXJ0VGltZW91dCA9IC0xO1xuICAgICAgICB0aGlzLnBlbmRpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLmNoZWNrSG92ZXIgPSB0aGlzLmNoZWNrSG92ZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgdGhpcy5tb3VzZWxlYXZlID0gdGhpcy5tb3VzZWxlYXZlLmJpbmQodGhpcykpO1xuICAgICAgICB2aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMubW91c2Vtb3ZlID0gdGhpcy5tb3VzZW1vdmUuYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZykge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nID0gbnVsbDtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlc3RhcnRUaW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMucmVzdGFydFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc3RhcnRIb3ZlcigpLCAyMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGFjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5zdGF0ZS5maWVsZCh0aGlzLmZpZWxkKTtcbiAgICB9XG4gICAgY2hlY2tIb3ZlcigpIHtcbiAgICAgICAgdGhpcy5ob3ZlclRpbWVvdXQgPSAtMTtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgbm93ID0gRGF0ZS5ub3coKSwgbGFzdE1vdmUgPSB0aGlzLmxhc3RNb3VzZU1vdmU7XG4gICAgICAgIGlmIChub3cgLSBsYXN0TW92ZS50aW1lU3RhbXAgPCBIb3ZlclRpbWUpXG4gICAgICAgICAgICB0aGlzLmhvdmVyVGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5jaGVja0hvdmVyLCBIb3ZlclRpbWUgLSAobm93IC0gbGFzdE1vdmUudGltZVN0YW1wKSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuc3RhcnRIb3ZlcigpO1xuICAgIH1cbiAgICBzdGFydEhvdmVyKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlc3RhcnRUaW1lb3V0KTtcbiAgICAgICAgbGV0IGxhc3RNb3ZlID0gdGhpcy5sYXN0TW91c2VNb3ZlO1xuICAgICAgICBsZXQgY29vcmRzID0geyB4OiBsYXN0TW92ZS5jbGllbnRYLCB5OiBsYXN0TW92ZS5jbGllbnRZIH07XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLnZpZXcuY29udGVudERPTS5jb250YWlucyhsYXN0TW92ZS50YXJnZXQpXG4gICAgICAgICAgICA/IHRoaXMudmlldy5wb3NBdENvb3Jkcyhjb29yZHMpIDogbnVsbDtcbiAgICAgICAgaWYgKHBvcyA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgcG9zQ29vcmRzID0gdGhpcy52aWV3LmNvb3Jkc0F0UG9zKHBvcyk7XG4gICAgICAgIGlmIChwb3NDb29yZHMgPT0gbnVsbCB8fCBjb29yZHMueSA8IHBvc0Nvb3Jkcy50b3AgfHwgY29vcmRzLnkgPiBwb3NDb29yZHMuYm90dG9tIHx8XG4gICAgICAgICAgICBjb29yZHMueCA8IHBvc0Nvb3Jkcy5sZWZ0IC0gdGhpcy52aWV3LmRlZmF1bHRDaGFyYWN0ZXJXaWR0aCB8fFxuICAgICAgICAgICAgY29vcmRzLnggPiBwb3NDb29yZHMucmlnaHQgKyB0aGlzLnZpZXcuZGVmYXVsdENoYXJhY3RlcldpZHRoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgYmlkaSA9IHRoaXMudmlldy5iaWRpU3BhbnModGhpcy52aWV3LnN0YXRlLmRvYy5saW5lQXQocG9zKSkuZmluZChzID0+IHMuZnJvbSA8PSBwb3MgJiYgcy50byA+PSBwb3MpO1xuICAgICAgICBsZXQgcnRsID0gYmlkaSAmJiBiaWRpLmRpciA9PSB2aWV3LkRpcmVjdGlvbi5SVEwgPyAtMSA6IDE7XG4gICAgICAgIGxldCBvcGVuID0gdGhpcy5zb3VyY2UodGhpcy52aWV3LCBwb3MsIChjb29yZHMueCA8IHBvc0Nvb3Jkcy5sZWZ0ID8gLXJ0bCA6IHJ0bCkpO1xuICAgICAgICBpZiAoKF9hID0gb3BlbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRoZW4pIHtcbiAgICAgICAgICAgIGxldCBwZW5kaW5nID0gdGhpcy5wZW5kaW5nID0geyBwb3MgfTtcbiAgICAgICAgICAgIG9wZW4udGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmcgPT0gcGVuZGluZykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmcgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0KVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogdGhpcy5zZXRIb3Zlci5vZihyZXN1bHQpIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGUgPT4gdmlldy5sb2dFeGNlcHRpb24odGhpcy52aWV3LnN0YXRlLCBlLCBcImhvdmVyIHRvb2x0aXBcIikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wZW4pIHtcbiAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHRoaXMuc2V0SG92ZXIub2Yob3BlbikgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbW91c2Vtb3ZlKGV2ZW50KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5sYXN0TW91c2VNb3ZlID0gZXZlbnQ7XG4gICAgICAgIGlmICh0aGlzLmhvdmVyVGltZW91dCA8IDApXG4gICAgICAgICAgICB0aGlzLmhvdmVyVGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5jaGVja0hvdmVyLCBIb3ZlclRpbWUpO1xuICAgICAgICBsZXQgdG9vbHRpcCA9IHRoaXMuYWN0aXZlO1xuICAgICAgICBpZiAodG9vbHRpcCAmJiAhaXNJblRvb2x0aXAoZXZlbnQudGFyZ2V0KSB8fCB0aGlzLnBlbmRpbmcpIHtcbiAgICAgICAgICAgIGxldCB7IHBvcyB9ID0gdG9vbHRpcCB8fCB0aGlzLnBlbmRpbmcsIGVuZCA9IChfYSA9IHRvb2x0aXAgPT09IG51bGwgfHwgdG9vbHRpcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdG9vbHRpcC5lbmQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHBvcztcbiAgICAgICAgICAgIGlmICgocG9zID09IGVuZCA/IHRoaXMudmlldy5wb3NBdENvb3Jkcyh7IHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFkgfSkgIT0gcG9zXG4gICAgICAgICAgICAgICAgOiAhaXNPdmVyUmFuZ2UodGhpcy52aWV3LCBwb3MsIGVuZCwgZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSwgSG92ZXJNYXhEaXN0KSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiB0aGlzLnNldEhvdmVyLm9mKG51bGwpIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbW91c2VsZWF2ZSgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaG92ZXJUaW1lb3V0KTtcbiAgICAgICAgdGhpcy5ob3ZlclRpbWVvdXQgPSAtMTtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlKVxuICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogdGhpcy5zZXRIb3Zlci5vZihudWxsKSB9KTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaG92ZXJUaW1lb3V0KTtcbiAgICAgICAgdGhpcy52aWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCB0aGlzLm1vdXNlbGVhdmUpO1xuICAgICAgICB0aGlzLnZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5tb3VzZW1vdmUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzSW5Ub29sdGlwKGVsdCkge1xuICAgIGZvciAobGV0IGN1ciA9IGVsdDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSlcbiAgICAgICAgaWYgKGN1ci5ub2RlVHlwZSA9PSAxICYmIGN1ci5jbGFzc0xpc3QuY29udGFpbnMoXCJjbS10b29sdGlwXCIpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNPdmVyUmFuZ2UodmlldywgZnJvbSwgdG8sIHgsIHksIG1hcmdpbikge1xuICAgIGxldCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgbGV0IGZyb21ET00gPSB2aWV3LmRvbUF0UG9zKGZyb20pLCB0b0RPTSA9IHZpZXcuZG9tQXRQb3ModG8pO1xuICAgIHJhbmdlLnNldEVuZCh0b0RPTS5ub2RlLCB0b0RPTS5vZmZzZXQpO1xuICAgIHJhbmdlLnNldFN0YXJ0KGZyb21ET00ubm9kZSwgZnJvbURPTS5vZmZzZXQpO1xuICAgIGxldCByZWN0cyA9IHJhbmdlLmdldENsaWVudFJlY3RzKCk7XG4gICAgcmFuZ2UuZGV0YWNoKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgcmVjdCA9IHJlY3RzW2ldO1xuICAgICAgICBsZXQgZGlzdCA9IE1hdGgubWF4KHJlY3QudG9wIC0geSwgeSAtIHJlY3QuYm90dG9tLCByZWN0LmxlZnQgLSB4LCB4IC0gcmVjdC5yaWdodCk7XG4gICAgICAgIGlmIChkaXN0IDw9IG1hcmdpbilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbkVuYWJsZSBhIGhvdmVyIHRvb2x0aXAsIHdoaWNoIHNob3dzIHVwIHdoZW4gdGhlIHBvaW50ZXIgaG92ZXJzXG5vdmVyIHJhbmdlcyBvZiB0ZXh0LiBUaGUgY2FsbGJhY2sgaXMgY2FsbGVkIHdoZW4gdGhlIG1vdXNlIGhvdmVyc1xub3ZlciB0aGUgZG9jdW1lbnQgdGV4dC4gSXQgc2hvdWxkLCBpZiB0aGVyZSBpcyBhIHRvb2x0aXBcbmFzc29jaWF0ZWQgd2l0aCBwb3NpdGlvbiBgcG9zYCByZXR1cm4gdGhlIHRvb2x0aXAgZGVzY3JpcHRpb25cbihlaXRoZXIgZGlyZWN0bHkgb3IgaW4gYSBwcm9taXNlKS4gVGhlIGBzaWRlYCBhcmd1bWVudCBpbmRpY2F0ZXNcbm9uIHdoaWNoIHNpZGUgb2YgdGhlIHBvc2l0aW9uIHRoZSBwb2ludGVyIGlz4oCUaXQgd2lsbCBiZSAtMSBpZiB0aGVcbnBvaW50ZXIgaXMgYmVmb3JlIHRoZSBwb3NpdGlvbiwgMSBpZiBhZnRlciB0aGUgcG9zaXRpb24uXG4qL1xuZnVuY3Rpb24gaG92ZXJUb29sdGlwKHNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qgc2V0SG92ZXIgPSBzdGF0ZS5TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbiAgICBjb25zdCBob3ZlclN0YXRlID0gc3RhdGUuU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgICAgICBjcmVhdGUoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICB1cGRhdGUodmFsdWUsIHRyKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgKG9wdGlvbnMuaGlkZU9uQ2hhbmdlICYmICh0ci5kb2NDaGFuZ2VkIHx8IHRyLnNlbGVjdGlvbikpKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpXG4gICAgICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhzZXRIb3ZlcikpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlZmZlY3QudmFsdWU7XG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgdHIuZG9jQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIGxldCBuZXdQb3MgPSB0ci5jaGFuZ2VzLm1hcFBvcyh2YWx1ZS5wb3MsIC0xLCBzdGF0ZS5NYXBNb2RlLlRyYWNrRGVsKTtcbiAgICAgICAgICAgICAgICBpZiAobmV3UG9zID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBjb3B5ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgY29weS5wb3MgPSBuZXdQb3M7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmVuZCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBjb3B5LmVuZCA9IHRyLmNoYW5nZXMubWFwUG9zKHZhbHVlLmVuZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHByb3ZpZGU6IGYgPT4gc2hvd1Rvb2x0aXAuZnJvbShmKVxuICAgIH0pO1xuICAgIHJldHVybiBbXG4gICAgICAgIGhvdmVyU3RhdGUsXG4gICAgICAgIHZpZXcuVmlld1BsdWdpbi5kZWZpbmUodmlldyA9PiBuZXcgSG92ZXJQbHVnaW4odmlldywgc291cmNlLCBob3ZlclN0YXRlLCBzZXRIb3ZlcikpXG4gICAgXTtcbn1cblxuZXhwb3J0cy5ob3ZlclRvb2x0aXAgPSBob3ZlclRvb2x0aXA7XG5leHBvcnRzLnNob3dUb29sdGlwID0gc2hvd1Rvb2x0aXA7XG5leHBvcnRzLnRvb2x0aXBzID0gdG9vbHRpcHM7XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBzdGF0ZSA9IHJlcXVpcmUoJ0Bjb2RlbWlycm9yL3N0YXRlJyk7XG52YXIgc3R5bGVNb2QgPSByZXF1aXJlKCdzdHlsZS1tb2QnKTtcbnZhciByYW5nZXNldCA9IHJlcXVpcmUoJ0Bjb2RlbWlycm9yL3Jhbmdlc2V0Jyk7XG52YXIgdGV4dCA9IHJlcXVpcmUoJ0Bjb2RlbWlycm9yL3RleHQnKTtcbnZhciB3M2NLZXluYW1lID0gcmVxdWlyZSgndzNjLWtleW5hbWUnKTtcblxubGV0IFtuYXYsIGRvY10gPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCJcbiAgICA/IFtuYXZpZ2F0b3IsIGRvY3VtZW50XVxuICAgIDogW3sgdXNlckFnZW50OiBcIlwiLCB2ZW5kb3I6IFwiXCIsIHBsYXRmb3JtOiBcIlwiIH0sIHsgZG9jdW1lbnRFbGVtZW50OiB7IHN0eWxlOiB7fSB9IH1dO1xuY29uc3QgaWVfZWRnZSA9IC9FZGdlXFwvKFxcZCspLy5leGVjKG5hdi51c2VyQWdlbnQpO1xuY29uc3QgaWVfdXB0bzEwID0gL01TSUUgXFxkLy50ZXN0KG5hdi51c2VyQWdlbnQpO1xuY29uc3QgaWVfMTF1cCA9IC9UcmlkZW50XFwvKD86WzctOV18XFxkezIsfSlcXC4uKnJ2OihcXGQrKS8uZXhlYyhuYXYudXNlckFnZW50KTtcbmNvbnN0IGllID0gISEoaWVfdXB0bzEwIHx8IGllXzExdXAgfHwgaWVfZWRnZSk7XG5jb25zdCBnZWNrbyA9ICFpZSAmJiAvZ2Vja29cXC8oXFxkKykvaS50ZXN0KG5hdi51c2VyQWdlbnQpO1xuY29uc3QgY2hyb21lID0gIWllICYmIC9DaHJvbWVcXC8oXFxkKykvLmV4ZWMobmF2LnVzZXJBZ2VudCk7XG5jb25zdCB3ZWJraXQgPSBcIndlYmtpdEZvbnRTbW9vdGhpbmdcIiBpbiBkb2MuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xuY29uc3Qgc2FmYXJpID0gIWllICYmIC9BcHBsZSBDb21wdXRlci8udGVzdChuYXYudmVuZG9yKTtcbnZhciBicm93c2VyID0ge1xuICAgIG1hYzogL01hYy8udGVzdChuYXYucGxhdGZvcm0pLFxuICAgIGllLFxuICAgIGllX3ZlcnNpb246IGllX3VwdG8xMCA/IGRvYy5kb2N1bWVudE1vZGUgfHwgNiA6IGllXzExdXAgPyAraWVfMTF1cFsxXSA6IGllX2VkZ2UgPyAraWVfZWRnZVsxXSA6IDAsXG4gICAgZ2Vja28sXG4gICAgZ2Vja29fdmVyc2lvbjogZ2Vja28gPyArKC9GaXJlZm94XFwvKFxcZCspLy5leGVjKG5hdi51c2VyQWdlbnQpIHx8IFswLCAwXSlbMV0gOiAwLFxuICAgIGNocm9tZTogISFjaHJvbWUsXG4gICAgY2hyb21lX3ZlcnNpb246IGNocm9tZSA/ICtjaHJvbWVbMV0gOiAwLFxuICAgIGlvczogc2FmYXJpICYmICgvTW9iaWxlXFwvXFx3Ky8udGVzdChuYXYudXNlckFnZW50KSB8fCBuYXYubWF4VG91Y2hQb2ludHMgPiAyKSxcbiAgICBhbmRyb2lkOiAvQW5kcm9pZFxcYi8udGVzdChuYXYudXNlckFnZW50KSxcbiAgICB3ZWJraXQsXG4gICAgc2FmYXJpLFxuICAgIHdlYmtpdF92ZXJzaW9uOiB3ZWJraXQgPyArKC9cXGJBcHBsZVdlYktpdFxcLyhcXGQrKS8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KSB8fCBbMCwgMF0pWzFdIDogMCxcbiAgICB0YWJTaXplOiBkb2MuZG9jdW1lbnRFbGVtZW50LnN0eWxlLnRhYlNpemUgIT0gbnVsbCA/IFwidGFiLXNpemVcIiA6IFwiLW1vei10YWItc2l6ZVwiXG59O1xuXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb24ocm9vdCkge1xuICAgIHJldHVybiAocm9vdC5nZXRTZWxlY3Rpb24gPyByb290LmdldFNlbGVjdGlvbigpIDogZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCkpO1xufVxuLy8gV29yayBhcm91bmQgQ2hyb21lIGlzc3VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0NzUyM1xuLy8gKGlzQ29sbGFwc2VkIGluYXBwcm9wcmlhdGVseSByZXR1cm5zIHRydWUgaW4gc2hhZG93IGRvbSlcbmZ1bmN0aW9uIHNlbGVjdGlvbkNvbGxhcHNlZChkb21TZWwpIHtcbiAgICBsZXQgY29sbGFwc2VkID0gZG9tU2VsLmlzQ29sbGFwc2VkO1xuICAgIGlmIChjb2xsYXBzZWQgJiYgYnJvd3Nlci5jaHJvbWUgJiYgZG9tU2VsLnJhbmdlQ291bnQgJiYgIWRvbVNlbC5nZXRSYW5nZUF0KDApLmNvbGxhcHNlZClcbiAgICAgICAgY29sbGFwc2VkID0gZmFsc2U7XG4gICAgcmV0dXJuIGNvbGxhcHNlZDtcbn1cbmZ1bmN0aW9uIGNvbnRhaW5zKGRvbSwgbm9kZSkge1xuICAgIHJldHVybiBub2RlID8gZG9tLmNvbnRhaW5zKG5vZGUubm9kZVR5cGUgIT0gMSA/IG5vZGUucGFyZW50Tm9kZSA6IG5vZGUpIDogZmFsc2U7XG59XG5mdW5jdGlvbiBoYXNTZWxlY3Rpb24oZG9tLCBzZWxlY3Rpb24pIHtcbiAgICBpZiAoIXNlbGVjdGlvbi5hbmNob3JOb2RlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gRmlyZWZveCB3aWxsIHJhaXNlICdwZXJtaXNzaW9uIGRlbmllZCcgZXJyb3JzIHdoZW4gYWNjZXNzaW5nXG4gICAgICAgIC8vIHByb3BlcnRpZXMgb2YgYHNlbC5hbmNob3JOb2RlYCB3aGVuIGl0J3MgaW4gYSBnZW5lcmF0ZWQgQ1NTXG4gICAgICAgIC8vIGVsZW1lbnQuXG4gICAgICAgIHJldHVybiBjb250YWlucyhkb20sIHNlbGVjdGlvbi5hbmNob3JOb2RlKTtcbiAgICB9XG4gICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNsaWVudFJlY3RzRm9yKGRvbSkge1xuICAgIGlmIChkb20ubm9kZVR5cGUgPT0gMylcbiAgICAgICAgcmV0dXJuIHRleHRSYW5nZShkb20sIDAsIGRvbS5ub2RlVmFsdWUubGVuZ3RoKS5nZXRDbGllbnRSZWN0cygpO1xuICAgIGVsc2UgaWYgKGRvbS5ub2RlVHlwZSA9PSAxKVxuICAgICAgICByZXR1cm4gZG9tLmdldENsaWVudFJlY3RzKCk7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gW107XG59XG4vLyBTY2FucyBmb3J3YXJkIGFuZCBiYWNrd2FyZCB0aHJvdWdoIERPTSBwb3NpdGlvbnMgZXF1aXZhbGVudCB0byB0aGVcbi8vIGdpdmVuIG9uZSB0byBzZWUgaWYgdGhlIHR3byBhcmUgaW4gdGhlIHNhbWUgcGxhY2UgKGkuZS4gYWZ0ZXIgYVxuLy8gdGV4dCBub2RlIHZzIGF0IHRoZSBlbmQgb2YgdGhhdCB0ZXh0IG5vZGUpXG5mdW5jdGlvbiBpc0VxdWl2YWxlbnRQb3NpdGlvbihub2RlLCBvZmYsIHRhcmdldE5vZGUsIHRhcmdldE9mZikge1xuICAgIHJldHVybiB0YXJnZXROb2RlID8gKHNjYW5Gb3Iobm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYsIC0xKSB8fFxuICAgICAgICBzY2FuRm9yKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmLCAxKSkgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGRvbUluZGV4KG5vZGUpIHtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7OyBpbmRleCsrKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNjYW5Gb3Iobm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYsIGRpcikge1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gdGFyZ2V0Tm9kZSAmJiBvZmYgPT0gdGFyZ2V0T2ZmKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChvZmYgPT0gKGRpciA8IDAgPyAwIDogbWF4T2Zmc2V0KG5vZGUpKSkge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT0gXCJESVZcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQgfHwgcGFyZW50Lm5vZGVUeXBlICE9IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgb2ZmID0gZG9tSW5kZXgobm9kZSkgKyAoZGlyIDwgMCA/IDAgOiAxKTtcbiAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZE5vZGVzW29mZiArIChkaXIgPCAwID8gLTEgOiAwKV07XG4gICAgICAgICAgICBvZmYgPSBkaXIgPCAwID8gbWF4T2Zmc2V0KG5vZGUpIDogMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIG1heE9mZnNldChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT0gMyA/IG5vZGUubm9kZVZhbHVlLmxlbmd0aCA6IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7XG59XG5jb25zdCBSZWN0MCA9IHsgbGVmdDogMCwgcmlnaHQ6IDAsIHRvcDogMCwgYm90dG9tOiAwIH07XG5mdW5jdGlvbiBmbGF0dGVuUmVjdChyZWN0LCBsZWZ0KSB7XG4gICAgbGV0IHggPSBsZWZ0ID8gcmVjdC5sZWZ0IDogcmVjdC5yaWdodDtcbiAgICByZXR1cm4geyBsZWZ0OiB4LCByaWdodDogeCwgdG9wOiByZWN0LnRvcCwgYm90dG9tOiByZWN0LmJvdHRvbSB9O1xufVxuZnVuY3Rpb24gd2luZG93UmVjdCh3aW4pIHtcbiAgICByZXR1cm4geyBsZWZ0OiAwLCByaWdodDogd2luLmlubmVyV2lkdGgsXG4gICAgICAgIHRvcDogMCwgYm90dG9tOiB3aW4uaW5uZXJIZWlnaHQgfTtcbn1cbmNvbnN0IFNjcm9sbFNwYWNlID0gNTtcbmZ1bmN0aW9uIHNjcm9sbFJlY3RJbnRvVmlldyhkb20sIHJlY3QpIHtcbiAgICBsZXQgZG9jID0gZG9tLm93bmVyRG9jdW1lbnQsIHdpbiA9IGRvYy5kZWZhdWx0VmlldztcbiAgICBmb3IgKGxldCBjdXIgPSBkb20ucGFyZW50Tm9kZTsgY3VyOykge1xuICAgICAgICBpZiAoY3VyLm5vZGVUeXBlID09IDEpIHsgLy8gRWxlbWVudFxuICAgICAgICAgICAgbGV0IGJvdW5kaW5nLCB0b3AgPSBjdXIgPT0gZG9jdW1lbnQuYm9keTtcbiAgICAgICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICAgICAgICBib3VuZGluZyA9IHdpbmRvd1JlY3Qod2luKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjdXIuc2Nyb2xsSGVpZ2h0IDw9IGN1ci5jbGllbnRIZWlnaHQgJiYgY3VyLnNjcm9sbFdpZHRoIDw9IGN1ci5jbGllbnRXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBjdXIgPSBjdXIucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCByZWN0ID0gY3VyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBzY3JvbGxiYXIgd2lkdGggaXNuJ3QgaW5jbHVkZWQgaW4gdGhlIHJlY3RhbmdsZVxuICAgICAgICAgICAgICAgIGJvdW5kaW5nID0geyBsZWZ0OiByZWN0LmxlZnQsIHJpZ2h0OiByZWN0LmxlZnQgKyBjdXIuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIHRvcDogcmVjdC50b3AsIGJvdHRvbTogcmVjdC50b3AgKyBjdXIuY2xpZW50SGVpZ2h0IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbW92ZVggPSAwLCBtb3ZlWSA9IDA7XG4gICAgICAgICAgICBpZiAocmVjdC50b3AgPCBib3VuZGluZy50b3ApXG4gICAgICAgICAgICAgICAgbW92ZVkgPSAtKGJvdW5kaW5nLnRvcCAtIHJlY3QudG9wICsgU2Nyb2xsU3BhY2UpO1xuICAgICAgICAgICAgZWxzZSBpZiAocmVjdC5ib3R0b20gPiBib3VuZGluZy5ib3R0b20pXG4gICAgICAgICAgICAgICAgbW92ZVkgPSByZWN0LmJvdHRvbSAtIGJvdW5kaW5nLmJvdHRvbSArIFNjcm9sbFNwYWNlO1xuICAgICAgICAgICAgaWYgKHJlY3QubGVmdCA8IGJvdW5kaW5nLmxlZnQpXG4gICAgICAgICAgICAgICAgbW92ZVggPSAtKGJvdW5kaW5nLmxlZnQgLSByZWN0LmxlZnQgKyBTY3JvbGxTcGFjZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChyZWN0LnJpZ2h0ID4gYm91bmRpbmcucmlnaHQpXG4gICAgICAgICAgICAgICAgbW92ZVggPSByZWN0LnJpZ2h0IC0gYm91bmRpbmcucmlnaHQgKyBTY3JvbGxTcGFjZTtcbiAgICAgICAgICAgIGlmIChtb3ZlWCB8fCBtb3ZlWSkge1xuICAgICAgICAgICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgd2luLnNjcm9sbEJ5KG1vdmVYLCBtb3ZlWSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW92ZVkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IGN1ci5zY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXIuc2Nyb2xsVG9wICs9IG1vdmVZO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZVkgPSBjdXIuc2Nyb2xsVG9wIC0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vdmVYKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSBjdXIuc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ci5zY3JvbGxMZWZ0ICs9IG1vdmVYO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZVggPSBjdXIuc2Nyb2xsTGVmdCAtIHN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlY3QgPSB7IGxlZnQ6IHJlY3QubGVmdCAtIG1vdmVYLCB0b3A6IHJlY3QudG9wIC0gbW92ZVksXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogcmVjdC5yaWdodCAtIG1vdmVYLCBib3R0b206IHJlY3QuYm90dG9tIC0gbW92ZVkgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9wKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY3VyID0gY3VyLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VyLm5vZGVUeXBlID09IDExKSB7IC8vIEEgc2hhZG93IHJvb3RcbiAgICAgICAgICAgIGN1ciA9IGN1ci5ob3N0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBET01TZWxlY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmFuY2hvck5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmFuY2hvck9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuZm9jdXNOb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5mb2N1c09mZnNldCA9IDA7XG4gICAgfVxuICAgIGVxKGRvbVNlbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbmNob3JOb2RlID09IGRvbVNlbC5hbmNob3JOb2RlICYmIHRoaXMuYW5jaG9yT2Zmc2V0ID09IGRvbVNlbC5hbmNob3JPZmZzZXQgJiZcbiAgICAgICAgICAgIHRoaXMuZm9jdXNOb2RlID09IGRvbVNlbC5mb2N1c05vZGUgJiYgdGhpcy5mb2N1c09mZnNldCA9PSBkb21TZWwuZm9jdXNPZmZzZXQ7XG4gICAgfVxuICAgIHNldChkb21TZWwpIHtcbiAgICAgICAgdGhpcy5hbmNob3JOb2RlID0gZG9tU2VsLmFuY2hvck5vZGU7XG4gICAgICAgIHRoaXMuYW5jaG9yT2Zmc2V0ID0gZG9tU2VsLmFuY2hvck9mZnNldDtcbiAgICAgICAgdGhpcy5mb2N1c05vZGUgPSBkb21TZWwuZm9jdXNOb2RlO1xuICAgICAgICB0aGlzLmZvY3VzT2Zmc2V0ID0gZG9tU2VsLmZvY3VzT2Zmc2V0O1xuICAgIH1cbn1cbmxldCBwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID0gbnVsbDtcbi8vIEZlYXR1cmUtZGV0ZWN0cyBzdXBwb3J0IGZvciAuZm9jdXMoe3ByZXZlbnRTY3JvbGw6IHRydWV9KSwgYW5kIHVzZXNcbi8vIGEgZmFsbGJhY2sga2x1ZGdlIHdoZW4gbm90IHN1cHBvcnRlZC5cbmZ1bmN0aW9uIGZvY3VzUHJldmVudFNjcm9sbChkb20pIHtcbiAgICBpZiAoZG9tLnNldEFjdGl2ZSlcbiAgICAgICAgcmV0dXJuIGRvbS5zZXRBY3RpdmUoKTsgLy8gaW4gSUVcbiAgICBpZiAocHJldmVudFNjcm9sbFN1cHBvcnRlZClcbiAgICAgICAgcmV0dXJuIGRvbS5mb2N1cyhwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkKTtcbiAgICBsZXQgc3RhY2sgPSBbXTtcbiAgICBmb3IgKGxldCBjdXIgPSBkb207IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgc3RhY2sucHVzaChjdXIsIGN1ci5zY3JvbGxUb3AsIGN1ci5zY3JvbGxMZWZ0KTtcbiAgICAgICAgaWYgKGN1ciA9PSBjdXIub3duZXJEb2N1bWVudClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkb20uZm9jdXMocHJldmVudFNjcm9sbFN1cHBvcnRlZCA9PSBudWxsID8ge1xuICAgICAgICBnZXQgcHJldmVudFNjcm9sbCgpIHtcbiAgICAgICAgICAgIHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSB7IHByZXZlbnRTY3JvbGw6IHRydWUgfTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSA6IHVuZGVmaW5lZCk7XG4gICAgaWYgKCFwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkKSB7XG4gICAgICAgIHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgZWx0ID0gc3RhY2tbaSsrXSwgdG9wID0gc3RhY2tbaSsrXSwgbGVmdCA9IHN0YWNrW2krK107XG4gICAgICAgICAgICBpZiAoZWx0LnNjcm9sbFRvcCAhPSB0b3ApXG4gICAgICAgICAgICAgICAgZWx0LnNjcm9sbFRvcCA9IHRvcDtcbiAgICAgICAgICAgIGlmIChlbHQuc2Nyb2xsTGVmdCAhPSBsZWZ0KVxuICAgICAgICAgICAgICAgIGVsdC5zY3JvbGxMZWZ0ID0gbGVmdDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmxldCBzY3JhdGNoUmFuZ2U7XG5mdW5jdGlvbiB0ZXh0UmFuZ2Uobm9kZSwgZnJvbSwgdG8gPSBmcm9tKSB7XG4gICAgbGV0IHJhbmdlID0gc2NyYXRjaFJhbmdlIHx8IChzY3JhdGNoUmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpKTtcbiAgICByYW5nZS5zZXRFbmQobm9kZSwgdG8pO1xuICAgIHJhbmdlLnNldFN0YXJ0KG5vZGUsIGZyb20pO1xuICAgIHJldHVybiByYW5nZTtcbn1cblxuY2xhc3MgRE9NUG9zIHtcbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBvZmZzZXQsIHByZWNpc2UgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLnByZWNpc2UgPSBwcmVjaXNlO1xuICAgIH1cbiAgICBzdGF0aWMgYmVmb3JlKGRvbSwgcHJlY2lzZSkgeyByZXR1cm4gbmV3IERPTVBvcyhkb20ucGFyZW50Tm9kZSwgZG9tSW5kZXgoZG9tKSwgcHJlY2lzZSk7IH1cbiAgICBzdGF0aWMgYWZ0ZXIoZG9tLCBwcmVjaXNlKSB7IHJldHVybiBuZXcgRE9NUG9zKGRvbS5wYXJlbnROb2RlLCBkb21JbmRleChkb20pICsgMSwgcHJlY2lzZSk7IH1cbn1cbmNvbnN0IG5vbmUkMyA9IFtdO1xuY2xhc3MgQ29udGVudFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuZG9tID0gbnVsbDtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IDIgLyogTm9kZSAqLztcbiAgICB9XG4gICAgZ2V0IGVkaXRvclZpZXcoKSB7XG4gICAgICAgIGlmICghdGhpcy5wYXJlbnQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBY2Nlc3NpbmcgdmlldyBpbiBvcnBoYW4gY29udGVudCB2aWV3XCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuZWRpdG9yVmlldztcbiAgICB9XG4gICAgZ2V0IG92ZXJyaWRlRE9NVGV4dCgpIHsgcmV0dXJuIG51bGw7IH1cbiAgICBnZXQgcG9zQXRTdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQucG9zQmVmb3JlKHRoaXMpIDogMDtcbiAgICB9XG4gICAgZ2V0IHBvc0F0RW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NBdFN0YXJ0ICsgdGhpcy5sZW5ndGg7XG4gICAgfVxuICAgIHBvc0JlZm9yZSh2aWV3KSB7XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLnBvc0F0U3RhcnQ7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChjaGlsZCA9PSB2aWV3KVxuICAgICAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgICAgICBwb3MgKz0gY2hpbGQubGVuZ3RoICsgY2hpbGQuYnJlYWtBZnRlcjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgY2hpbGQgaW4gcG9zQmVmb3JlXCIpO1xuICAgIH1cbiAgICBwb3NBZnRlcih2aWV3KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc0JlZm9yZSh2aWV3KSArIHZpZXcubGVuZ3RoO1xuICAgIH1cbiAgICAvLyBXaWxsIHJldHVybiBhIHJlY3RhbmdsZSBkaXJlY3RseSBiZWZvcmUgKHdoZW4gc2lkZSA8IDApLCBhZnRlclxuICAgIC8vIChzaWRlID4gMCkgb3IgZGlyZWN0bHkgb24gKHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgaXQpIHRoZVxuICAgIC8vIGdpdmVuIHBvc2l0aW9uLlxuICAgIGNvb3Jkc0F0KF9wb3MsIF9zaWRlKSB7IHJldHVybiBudWxsOyB9XG4gICAgc3luYyh0cmFjaykge1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSAmIDIgLyogTm9kZSAqLykge1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMuZG9tLCBwb3MgPSBudWxsO1xuICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5kaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHBvcyA/IHBvcy5uZXh0U2libGluZyA6IHBhcmVudC5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCAmJiAhY2hpbGQuZG9tICYmICFDb250ZW50Vmlldy5nZXQobmV4dCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5yZXVzZURPTShuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuc3luYyh0cmFjayk7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmRpcnR5ID0gMCAvKiBOb3QgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0cmFjayAmJiB0cmFjay5ub2RlID09IHBhcmVudCAmJiBwb3MgIT0gY2hpbGQuZG9tKVxuICAgICAgICAgICAgICAgICAgICB0cmFjay53cml0dGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzeW5jTm9kZUludG8ocGFyZW50LCBwb3MsIGNoaWxkLmRvbSk7XG4gICAgICAgICAgICAgICAgcG9zID0gY2hpbGQuZG9tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG5leHQgPSBwb3MgPyBwb3MubmV4dFNpYmxpbmcgOiBwYXJlbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGlmIChuZXh0ICYmIHRyYWNrICYmIHRyYWNrLm5vZGUgPT0gcGFyZW50KVxuICAgICAgICAgICAgICAgIHRyYWNrLndyaXR0ZW4gPSB0cnVlO1xuICAgICAgICAgICAgd2hpbGUgKG5leHQpXG4gICAgICAgICAgICAgICAgbmV4dCA9IHJtKG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZGlydHkgJiAxIC8qIENoaWxkICovKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKVxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5kaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5zeW5jKHRyYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuZGlydHkgPSAwIC8qIE5vdCAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV1c2VET00oX2RvbSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBsb2NhbFBvc0Zyb21ET00obm9kZSwgb2Zmc2V0KSB7XG4gICAgICAgIGxldCBhZnRlcjtcbiAgICAgICAgaWYgKG5vZGUgPT0gdGhpcy5kb20pIHtcbiAgICAgICAgICAgIGFmdGVyID0gdGhpcy5kb20uY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGJpYXMgPSBtYXhPZmZzZXQobm9kZSkgPT0gMCA/IDAgOiBvZmZzZXQgPT0gMCA/IC0xIDogMTtcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBsZXQgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgPT0gdGhpcy5kb20pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmIChiaWFzID09IDAgJiYgcGFyZW50LmZpcnN0Q2hpbGQgIT0gcGFyZW50Lmxhc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSA9PSBwYXJlbnQuZmlyc3RDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpYXMgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgYmlhcyA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmlhcyA8IDApXG4gICAgICAgICAgICAgICAgYWZ0ZXIgPSBub2RlO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGFmdGVyID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWZ0ZXIgPT0gdGhpcy5kb20uZmlyc3RDaGlsZClcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB3aGlsZSAoYWZ0ZXIgJiYgIUNvbnRlbnRWaWV3LmdldChhZnRlcikpXG4gICAgICAgICAgICBhZnRlciA9IGFmdGVyLm5leHRTaWJsaW5nO1xuICAgICAgICBpZiAoIWFmdGVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDs7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChjaGlsZC5kb20gPT0gYWZ0ZXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgICAgIHBvcyArPSBjaGlsZC5sZW5ndGggKyBjaGlsZC5icmVha0FmdGVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRvbUJvdW5kc0Fyb3VuZChmcm9tLCB0bywgb2Zmc2V0ID0gMCkge1xuICAgICAgICBsZXQgZnJvbUkgPSAtMSwgZnJvbVN0YXJ0ID0gLTEsIHRvSSA9IC0xLCB0b0VuZCA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gb2Zmc2V0OyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gcG9zICsgY2hpbGQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHBvcyA8IGZyb20gJiYgZW5kID4gdG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmRvbUJvdW5kc0Fyb3VuZChmcm9tLCB0bywgcG9zKTtcbiAgICAgICAgICAgIGlmIChlbmQgPj0gZnJvbSAmJiBmcm9tSSA9PSAtMSkge1xuICAgICAgICAgICAgICAgIGZyb21JID0gaTtcbiAgICAgICAgICAgICAgICBmcm9tU3RhcnQgPSBwb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW5kID49IHRvICYmIGVuZCAhPSBwb3MgJiYgdG9JID09IC0xKSB7XG4gICAgICAgICAgICAgICAgdG9JID0gaTtcbiAgICAgICAgICAgICAgICB0b0VuZCA9IGVuZDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyA9IGVuZCArIGNoaWxkLmJyZWFrQWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZnJvbTogZnJvbVN0YXJ0LCB0bzogdG9FbmQgPCAwID8gb2Zmc2V0ICsgdGhpcy5sZW5ndGggOiB0b0VuZCwgc3RhcnRET006IChmcm9tSSA/IHRoaXMuY2hpbGRyZW5bZnJvbUkgLSAxXS5kb20ubmV4dFNpYmxpbmcgOiBudWxsKSB8fCB0aGlzLmRvbS5maXJzdENoaWxkLCBlbmRET006IHRvSSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMSAmJiB0b0kgPj0gMCA/IHRoaXMuY2hpbGRyZW5bdG9JICsgMV0uZG9tIDogbnVsbCB9O1xuICAgIH1cbiAgICBtYXJrRGlydHkoYW5kUGFyZW50ID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkgJiAyIC8qIE5vZGUgKi8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuZGlydHkgfD0gMiAvKiBOb2RlICovO1xuICAgICAgICB0aGlzLm1hcmtQYXJlbnRzRGlydHkoYW5kUGFyZW50KTtcbiAgICB9XG4gICAgbWFya1BhcmVudHNEaXJ0eShjaGlsZExpc3QpIHtcbiAgICAgICAgZm9yIChsZXQgcGFyZW50ID0gdGhpcy5wYXJlbnQ7IHBhcmVudDsgcGFyZW50ID0gcGFyZW50LnBhcmVudCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkTGlzdClcbiAgICAgICAgICAgICAgICBwYXJlbnQuZGlydHkgfD0gMiAvKiBOb2RlICovO1xuICAgICAgICAgICAgaWYgKHBhcmVudC5kaXJ0eSAmIDEgLyogQ2hpbGQgKi8pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgcGFyZW50LmRpcnR5IHw9IDEgLyogQ2hpbGQgKi87XG4gICAgICAgICAgICBjaGlsZExpc3QgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRQYXJlbnQocGFyZW50KSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCAhPSBwYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgICAgaWYgKHRoaXMuZGlydHkpXG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrUGFyZW50c0RpcnR5KHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldERPTShkb20pIHtcbiAgICAgICAgdGhpcy5kb20gPSBkb207XG4gICAgICAgIGRvbS5jbVZpZXcgPSB0aGlzO1xuICAgIH1cbiAgICBnZXQgcm9vdFZpZXcoKSB7XG4gICAgICAgIGZvciAobGV0IHYgPSB0aGlzOzspIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSB2LnBhcmVudDtcbiAgICAgICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgdiA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXBsYWNlQ2hpbGRyZW4oZnJvbSwgdG8sIGNoaWxkcmVuID0gbm9uZSQzKSB7XG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87IGkrKylcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0ucGFyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoZnJvbSwgdG8gLSBmcm9tLCAuLi5jaGlsZHJlbik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBjaGlsZHJlbltpXS5zZXRQYXJlbnQodGhpcyk7XG4gICAgfVxuICAgIGlnbm9yZU11dGF0aW9uKF9yZWMpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgaWdub3JlRXZlbnQoX2V2ZW50KSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGNoaWxkQ3Vyc29yKHBvcyA9IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hpbGRDdXJzb3IodGhpcy5jaGlsZHJlbiwgcG9zLCB0aGlzLmNoaWxkcmVuLmxlbmd0aCk7XG4gICAgfVxuICAgIGNoaWxkUG9zKHBvcywgYmlhcyA9IDEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRDdXJzb3IoKS5maW5kUG9zKHBvcywgYmlhcyk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgbmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZS5yZXBsYWNlKFwiVmlld1wiLCBcIlwiKTtcbiAgICAgICAgcmV0dXJuIG5hbWUgKyAodGhpcy5jaGlsZHJlbi5sZW5ndGggPyBcIihcIiArIHRoaXMuY2hpbGRyZW4uam9pbigpICsgXCIpXCIgOlxuICAgICAgICAgICAgdGhpcy5sZW5ndGggPyBcIltcIiArIChuYW1lID09IFwiVGV4dFwiID8gdGhpcy50ZXh0IDogdGhpcy5sZW5ndGgpICsgXCJdXCIgOiBcIlwiKSArXG4gICAgICAgICAgICAodGhpcy5icmVha0FmdGVyID8gXCIjXCIgOiBcIlwiKTtcbiAgICB9XG4gICAgc3RhdGljIGdldChub2RlKSB7IHJldHVybiBub2RlLmNtVmlldzsgfVxufVxuQ29udGVudFZpZXcucHJvdG90eXBlLmJyZWFrQWZ0ZXIgPSAwO1xuLy8gUmVtb3ZlIGEgRE9NIG5vZGUgYW5kIHJldHVybiBpdHMgbmV4dCBzaWJsaW5nLlxuZnVuY3Rpb24gcm0oZG9tKSB7XG4gICAgbGV0IG5leHQgPSBkb20ubmV4dFNpYmxpbmc7XG4gICAgZG9tLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZG9tKTtcbiAgICByZXR1cm4gbmV4dDtcbn1cbmZ1bmN0aW9uIHN5bmNOb2RlSW50byhwYXJlbnQsIGFmdGVyLCBkb20pIHtcbiAgICBsZXQgbmV4dCA9IGFmdGVyID8gYWZ0ZXIubmV4dFNpYmxpbmcgOiBwYXJlbnQuZmlyc3RDaGlsZDtcbiAgICBpZiAoZG9tLnBhcmVudE5vZGUgPT0gcGFyZW50KVxuICAgICAgICB3aGlsZSAobmV4dCAhPSBkb20pXG4gICAgICAgICAgICBuZXh0ID0gcm0obmV4dCk7XG4gICAgZWxzZVxuICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGRvbSwgbmV4dCk7XG59XG5jbGFzcyBDaGlsZEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoY2hpbGRyZW4sIHBvcywgaSkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLmkgPSBpO1xuICAgICAgICB0aGlzLm9mZiA9IDA7XG4gICAgfVxuICAgIGZpbmRQb3MocG9zLCBiaWFzID0gMSkge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAocG9zID4gdGhpcy5wb3MgfHwgcG9zID09IHRoaXMucG9zICYmXG4gICAgICAgICAgICAgICAgKGJpYXMgPiAwIHx8IHRoaXMuaSA9PSAwIHx8IHRoaXMuY2hpbGRyZW5bdGhpcy5pIC0gMV0uYnJlYWtBZnRlcikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZiA9IHBvcyAtIHRoaXMucG9zO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLmNoaWxkcmVuWy0tdGhpcy5pXTtcbiAgICAgICAgICAgIHRoaXMucG9zIC09IG5leHQubGVuZ3RoICsgbmV4dC5icmVha0FmdGVyO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBub25lJDIgPSBbXTtcbmNsYXNzIElubGluZVZpZXcgZXh0ZW5kcyBDb250ZW50VmlldyB7XG4gICAgLyoqXG4gICAgUmV0dXJuIHRydWUgd2hlbiB0aGlzIHZpZXcgaXMgZXF1aXZhbGVudCB0byBgb3RoZXJgIGFuZCBjYW4gdGFrZVxuICAgIG9uIGl0cyByb2xlLlxuICAgICovXG4gICAgYmVjb21lKF9vdGhlcikgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAvLyBXaGVuIHRoaXMgaXMgYSB6ZXJvLWxlbmd0aCB2aWV3IHdpdGggYSBzaWRlLCB0aGlzIHNob3VsZCByZXR1cm4gYVxuICAgIC8vIG5lZ2F0aXZlIG51bWJlciB0byBpbmRpY2F0ZSBpdCBpcyBiZWZvcmUgaXRzIHBvc2l0aW9uLCBvciBhXG4gICAgLy8gcG9zaXRpdmUgbnVtYmVyIHdoZW4gYWZ0ZXIgaXRzIHBvc2l0aW9uLlxuICAgIGdldFNpZGUoKSB7IHJldHVybiAwOyB9XG59XG5JbmxpbmVWaWV3LnByb3RvdHlwZS5jaGlsZHJlbiA9IG5vbmUkMjtcbmNvbnN0IE1heEpvaW5MZW4gPSAyNTY7XG5jbGFzcyBUZXh0VmlldyBleHRlbmRzIElubGluZVZpZXcge1xuICAgIGNvbnN0cnVjdG9yKHRleHQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMudGV4dC5sZW5ndGg7IH1cbiAgICBjcmVhdGVET00odGV4dERPTSkge1xuICAgICAgICB0aGlzLnNldERPTSh0ZXh0RE9NIHx8IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMudGV4dCkpO1xuICAgIH1cbiAgICBzeW5jKHRyYWNrKSB7XG4gICAgICAgIGlmICghdGhpcy5kb20pXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZURPTSgpO1xuICAgICAgICBpZiAodGhpcy5kb20ubm9kZVZhbHVlICE9IHRoaXMudGV4dCkge1xuICAgICAgICAgICAgaWYgKHRyYWNrICYmIHRyYWNrLm5vZGUgPT0gdGhpcy5kb20pXG4gICAgICAgICAgICAgICAgdHJhY2sud3JpdHRlbiA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmRvbS5ub2RlVmFsdWUgPSB0aGlzLnRleHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV1c2VET00oZG9tKSB7XG4gICAgICAgIGlmIChkb20ubm9kZVR5cGUgIT0gMylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5jcmVhdGVET00oZG9tKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIG1lcmdlKGZyb20sIHRvLCBzb3VyY2UpIHtcbiAgICAgICAgaWYgKHNvdXJjZSAmJiAoIShzb3VyY2UgaW5zdGFuY2VvZiBUZXh0VmlldykgfHwgdGhpcy5sZW5ndGggLSAodG8gLSBmcm9tKSArIHNvdXJjZS5sZW5ndGggPiBNYXhKb2luTGVuKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGhpcy50ZXh0LnNsaWNlKDAsIGZyb20pICsgKHNvdXJjZSA/IHNvdXJjZS50ZXh0IDogXCJcIikgKyB0aGlzLnRleHQuc2xpY2UodG8pO1xuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc2xpY2UoZnJvbSkge1xuICAgICAgICByZXR1cm4gbmV3IFRleHRWaWV3KHRoaXMudGV4dC5zbGljZShmcm9tKSk7XG4gICAgfVxuICAgIGxvY2FsUG9zRnJvbURPTShub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUgPT0gdGhpcy5kb20gPyBvZmZzZXQgOiBvZmZzZXQgPyB0aGlzLnRleHQubGVuZ3RoIDogMDtcbiAgICB9XG4gICAgZG9tQXRQb3MocG9zKSB7IHJldHVybiBuZXcgRE9NUG9zKHRoaXMuZG9tLCBwb3MpOyB9XG4gICAgZG9tQm91bmRzQXJvdW5kKF9mcm9tLCBfdG8sIG9mZnNldCkge1xuICAgICAgICByZXR1cm4geyBmcm9tOiBvZmZzZXQsIHRvOiBvZmZzZXQgKyB0aGlzLmxlbmd0aCwgc3RhcnRET006IHRoaXMuZG9tLCBlbmRET006IHRoaXMuZG9tLm5leHRTaWJsaW5nIH07XG4gICAgfVxuICAgIGNvb3Jkc0F0KHBvcywgc2lkZSkge1xuICAgICAgICByZXR1cm4gdGV4dENvb3Jkcyh0aGlzLmRvbSwgcG9zLCBzaWRlKTtcbiAgICB9XG59XG5jbGFzcyBNYXJrVmlldyBleHRlbmRzIElubGluZVZpZXcge1xuICAgIGNvbnN0cnVjdG9yKG1hcmssIGNoaWxkcmVuID0gW10sIGxlbmd0aCA9IDApIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tYXJrID0gbWFyaztcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgY2ggb2YgY2hpbGRyZW4pXG4gICAgICAgICAgICBjaC5zZXRQYXJlbnQodGhpcyk7XG4gICAgfVxuICAgIGNyZWF0ZURPTSgpIHtcbiAgICAgICAgbGV0IGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5tYXJrLnRhZ05hbWUpO1xuICAgICAgICBpZiAodGhpcy5tYXJrLmNsYXNzKVxuICAgICAgICAgICAgZG9tLmNsYXNzTmFtZSA9IHRoaXMubWFyay5jbGFzcztcbiAgICAgICAgaWYgKHRoaXMubWFyay5hdHRycylcbiAgICAgICAgICAgIGZvciAobGV0IG5hbWUgaW4gdGhpcy5tYXJrLmF0dHJzKVxuICAgICAgICAgICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUobmFtZSwgdGhpcy5tYXJrLmF0dHJzW25hbWVdKTtcbiAgICAgICAgdGhpcy5zZXRET00oZG9tKTtcbiAgICB9XG4gICAgc3luYyh0cmFjaykge1xuICAgICAgICBpZiAoIXRoaXMuZG9tKVxuICAgICAgICAgICAgdGhpcy5jcmVhdGVET00oKTtcbiAgICAgICAgc3VwZXIuc3luYyh0cmFjayk7XG4gICAgfVxuICAgIG1lcmdlKGZyb20sIHRvLCBzb3VyY2UsIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgICAgICBpZiAoc291cmNlICYmICghKHNvdXJjZSBpbnN0YW5jZW9mIE1hcmtWaWV3ICYmIHNvdXJjZS5tYXJrLmVxKHRoaXMubWFyaykpIHx8XG4gICAgICAgICAgICAoZnJvbSAmJiBvcGVuU3RhcnQgPD0gMCkgfHwgKHRvIDwgdGhpcy5sZW5ndGggJiYgb3BlbkVuZCA8PSAwKSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIG1lcmdlSW5saW5lQ2hpbGRyZW4odGhpcywgZnJvbSwgdG8sIHNvdXJjZSA/IHNvdXJjZS5jaGlsZHJlbiA6IG5vbmUkMiwgb3BlblN0YXJ0IC0gMSwgb3BlbkVuZCAtIDEpO1xuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc2xpY2UoZnJvbSkge1xuICAgICAgICByZXR1cm4gbmV3IE1hcmtWaWV3KHRoaXMubWFyaywgc2xpY2VJbmxpbmVDaGlsZHJlbih0aGlzLmNoaWxkcmVuLCBmcm9tKSwgdGhpcy5sZW5ndGggLSBmcm9tKTtcbiAgICB9XG4gICAgZG9tQXRQb3MocG9zKSB7XG4gICAgICAgIHJldHVybiBpbmxpbmVET01BdFBvcyh0aGlzLmRvbSwgdGhpcy5jaGlsZHJlbiwgcG9zKTtcbiAgICB9XG4gICAgY29vcmRzQXQocG9zLCBzaWRlKSB7XG4gICAgICAgIHJldHVybiBjb29yZHNJbkNoaWxkcmVuKHRoaXMsIHBvcywgc2lkZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdGV4dENvb3Jkcyh0ZXh0LCBwb3MsIHNpZGUpIHtcbiAgICBsZXQgbGVuZ3RoID0gdGV4dC5ub2RlVmFsdWUubGVuZ3RoO1xuICAgIGlmIChwb3MgPiBsZW5ndGgpXG4gICAgICAgIHBvcyA9IGxlbmd0aDtcbiAgICBsZXQgZnJvbSA9IHBvcywgdG8gPSBwb3MsIGZsYXR0ZW4gPSAwO1xuICAgIGlmIChwb3MgPT0gMCAmJiBzaWRlIDwgMCB8fCBwb3MgPT0gbGVuZ3RoICYmIHNpZGUgPj0gMCkge1xuICAgICAgICBpZiAoIShicm93c2VyLmNocm9tZSB8fCBicm93c2VyLmdlY2tvKSkgeyAvLyBUaGVzZSBicm93c2VycyByZWxpYWJseSByZXR1cm4gdmFsaWQgcmVjdGFuZ2xlcyBmb3IgZW1wdHkgcmFuZ2VzXG4gICAgICAgICAgICBpZiAocG9zKSB7XG4gICAgICAgICAgICAgICAgZnJvbS0tO1xuICAgICAgICAgICAgICAgIGZsYXR0ZW4gPSAxO1xuICAgICAgICAgICAgfSAvLyBGSVhNRSB0aGlzIGlzIHdyb25nIGluIFJUTCB0ZXh0XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0bysrO1xuICAgICAgICAgICAgICAgIGZsYXR0ZW4gPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHNpZGUgPCAwKVxuICAgICAgICAgICAgZnJvbS0tO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0bysrO1xuICAgIH1cbiAgICBsZXQgcmVjdHMgPSB0ZXh0UmFuZ2UodGV4dCwgZnJvbSwgdG8pLmdldENsaWVudFJlY3RzKCk7XG4gICAgaWYgKCFyZWN0cy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBSZWN0MDtcbiAgICBsZXQgcmVjdCA9IHJlY3RzWyhmbGF0dGVuID8gZmxhdHRlbiA8IDAgOiBzaWRlID49IDApID8gMCA6IHJlY3RzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChicm93c2VyLnNhZmFyaSAmJiAhZmxhdHRlbiAmJiByZWN0LndpZHRoID09IDApXG4gICAgICAgIHJlY3QgPSBBcnJheS5wcm90b3R5cGUuZmluZC5jYWxsKHJlY3RzLCByID0+IHIud2lkdGgpIHx8IHJlY3Q7XG4gICAgcmV0dXJuIGZsYXR0ZW4gPyBmbGF0dGVuUmVjdChyZWN0LCBmbGF0dGVuIDwgMCkgOiByZWN0O1xufVxuLy8gQWxzbyB1c2VkIGZvciBjb2xsYXBzZWQgcmFuZ2VzIHRoYXQgZG9uJ3QgaGF2ZSBhIHBsYWNlaG9sZGVyIHdpZGdldCFcbmNsYXNzIFdpZGdldFZpZXcgZXh0ZW5kcyBJbmxpbmVWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcih3aWRnZXQsIGxlbmd0aCwgc2lkZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLndpZGdldCA9IHdpZGdldDtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMuc2lkZSA9IHNpZGU7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUod2lkZ2V0LCBsZW5ndGgsIHNpZGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAod2lkZ2V0LmN1c3RvbVZpZXcgfHwgV2lkZ2V0Vmlldykod2lkZ2V0LCBsZW5ndGgsIHNpZGUpO1xuICAgIH1cbiAgICBzbGljZShmcm9tKSB7IHJldHVybiBXaWRnZXRWaWV3LmNyZWF0ZSh0aGlzLndpZGdldCwgdGhpcy5sZW5ndGggLSBmcm9tLCB0aGlzLnNpZGUpOyB9XG4gICAgc3luYygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRvbSB8fCAhdGhpcy53aWRnZXQudXBkYXRlRE9NKHRoaXMuZG9tKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRET00odGhpcy53aWRnZXQudG9ET00odGhpcy5lZGl0b3JWaWV3KSk7XG4gICAgICAgICAgICB0aGlzLmRvbS5jb250ZW50RWRpdGFibGUgPSBcImZhbHNlXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0U2lkZSgpIHsgcmV0dXJuIHRoaXMuc2lkZTsgfVxuICAgIG1lcmdlKGZyb20sIHRvLCBzb3VyY2UsIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgICAgICBpZiAoc291cmNlICYmICghKHNvdXJjZSBpbnN0YW5jZW9mIFdpZGdldFZpZXcpIHx8ICF0aGlzLndpZGdldC5jb21wYXJlKHNvdXJjZS53aWRnZXQpIHx8XG4gICAgICAgICAgICBmcm9tID4gMCAmJiBvcGVuU3RhcnQgPD0gMCB8fCB0byA8IHRoaXMubGVuZ3RoICYmIG9wZW5FbmQgPD0gMCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gZnJvbSArIChzb3VyY2UgPyBzb3VyY2UubGVuZ3RoIDogMCkgKyAodGhpcy5sZW5ndGggLSB0byk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBiZWNvbWUob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyLmxlbmd0aCA9PSB0aGlzLmxlbmd0aCAmJiBvdGhlciBpbnN0YW5jZW9mIFdpZGdldFZpZXcgJiYgb3RoZXIuc2lkZSA9PSB0aGlzLnNpZGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLndpZGdldC5jb25zdHJ1Y3RvciA9PSBvdGhlci53aWRnZXQuY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMud2lkZ2V0LmVxKG90aGVyLndpZGdldCkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFya0RpcnR5KHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMud2lkZ2V0ID0gb3RoZXIud2lkZ2V0O1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWdub3JlTXV0YXRpb24oKSB7IHJldHVybiB0cnVlOyB9XG4gICAgaWdub3JlRXZlbnQoZXZlbnQpIHsgcmV0dXJuIHRoaXMud2lkZ2V0Lmlnbm9yZUV2ZW50KGV2ZW50KTsgfVxuICAgIGdldCBvdmVycmlkZURPTVRleHQoKSB7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRleHQuVGV4dC5lbXB0eTtcbiAgICAgICAgbGV0IHRvcCA9IHRoaXM7XG4gICAgICAgIHdoaWxlICh0b3AucGFyZW50KVxuICAgICAgICAgICAgdG9wID0gdG9wLnBhcmVudDtcbiAgICAgICAgbGV0IHZpZXcgPSB0b3AuZWRpdG9yVmlldywgdGV4dCQxID0gdmlldyAmJiB2aWV3LnN0YXRlLmRvYywgc3RhcnQgPSB0aGlzLnBvc0F0U3RhcnQ7XG4gICAgICAgIHJldHVybiB0ZXh0JDEgPyB0ZXh0JDEuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgdGhpcy5sZW5ndGgpIDogdGV4dC5UZXh0LmVtcHR5O1xuICAgIH1cbiAgICBkb21BdFBvcyhwb3MpIHtcbiAgICAgICAgcmV0dXJuIHBvcyA9PSAwID8gRE9NUG9zLmJlZm9yZSh0aGlzLmRvbSkgOiBET01Qb3MuYWZ0ZXIodGhpcy5kb20sIHBvcyA9PSB0aGlzLmxlbmd0aCk7XG4gICAgfVxuICAgIGRvbUJvdW5kc0Fyb3VuZCgpIHsgcmV0dXJuIG51bGw7IH1cbiAgICBjb29yZHNBdChwb3MsIHNpZGUpIHtcbiAgICAgICAgbGV0IHJlY3RzID0gdGhpcy5kb20uZ2V0Q2xpZW50UmVjdHMoKSwgcmVjdCA9IG51bGw7XG4gICAgICAgIGlmICghcmVjdHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIFJlY3QwO1xuICAgICAgICBmb3IgKGxldCBpID0gcG9zID4gMCA/IHJlY3RzLmxlbmd0aCAtIDEgOiAwOzsgaSArPSAocG9zID4gMCA/IC0xIDogMSkpIHtcbiAgICAgICAgICAgIHJlY3QgPSByZWN0c1tpXTtcbiAgICAgICAgICAgIGlmIChwb3MgPiAwID8gaSA9PSAwIDogaSA9PSByZWN0cy5sZW5ndGggLSAxIHx8IHJlY3QudG9wIDwgcmVjdC5ib3R0b20pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChwb3MgPT0gMCAmJiBzaWRlID4gMCB8fCBwb3MgPT0gdGhpcy5sZW5ndGggJiYgc2lkZSA8PSAwKSA/IHJlY3QgOiBmbGF0dGVuUmVjdChyZWN0LCBwb3MgPT0gMCk7XG4gICAgfVxufVxuY2xhc3MgQ29tcG9zaXRpb25WaWV3IGV4dGVuZHMgV2lkZ2V0VmlldyB7XG4gICAgZG9tQXRQb3MocG9zKSB7IHJldHVybiBuZXcgRE9NUG9zKHRoaXMud2lkZ2V0LnRleHQsIHBvcyk7IH1cbiAgICBzeW5jKCkgeyBpZiAoIXRoaXMuZG9tKVxuICAgICAgICB0aGlzLnNldERPTSh0aGlzLndpZGdldC50b0RPTSgpKTsgfVxuICAgIGxvY2FsUG9zRnJvbURPTShub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuICFvZmZzZXQgPyAwIDogbm9kZS5ub2RlVHlwZSA9PSAzID8gTWF0aC5taW4ob2Zmc2V0LCB0aGlzLmxlbmd0aCkgOiB0aGlzLmxlbmd0aDtcbiAgICB9XG4gICAgaWdub3JlTXV0YXRpb24oKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGdldCBvdmVycmlkZURPTVRleHQoKSB7IHJldHVybiBudWxsOyB9XG4gICAgY29vcmRzQXQocG9zLCBzaWRlKSB7IHJldHVybiB0ZXh0Q29vcmRzKHRoaXMud2lkZ2V0LnRleHQsIHBvcywgc2lkZSk7IH1cbn1cbmZ1bmN0aW9uIG1lcmdlSW5saW5lQ2hpbGRyZW4ocGFyZW50LCBmcm9tLCB0bywgZWx0cywgb3BlblN0YXJ0LCBvcGVuRW5kKSB7XG4gICAgbGV0IGN1ciA9IHBhcmVudC5jaGlsZEN1cnNvcigpO1xuICAgIGxldCB7IGk6IHRvSSwgb2ZmOiB0b09mZiB9ID0gY3VyLmZpbmRQb3ModG8sIDEpO1xuICAgIGxldCB7IGk6IGZyb21JLCBvZmY6IGZyb21PZmYgfSA9IGN1ci5maW5kUG9zKGZyb20sIC0xKTtcbiAgICBsZXQgZExlbiA9IGZyb20gLSB0bztcbiAgICBmb3IgKGxldCB2aWV3IG9mIGVsdHMpXG4gICAgICAgIGRMZW4gKz0gdmlldy5sZW5ndGg7XG4gICAgcGFyZW50Lmxlbmd0aCArPSBkTGVuO1xuICAgIGxldCB7IGNoaWxkcmVuIH0gPSBwYXJlbnQ7XG4gICAgLy8gQm90aCBmcm9tIGFuZCB0byBwb2ludCBpbnRvIHRoZSBzYW1lIHRleHQgdmlld1xuICAgIGlmIChmcm9tSSA9PSB0b0kgJiYgZnJvbU9mZikge1xuICAgICAgICBsZXQgc3RhcnQgPSBjaGlsZHJlbltmcm9tSV07XG4gICAgICAgIC8vIE1heWJlIGp1c3QgdXBkYXRlIHRoYXQgdmlldyBhbmQgYmUgZG9uZVxuICAgICAgICBpZiAoZWx0cy5sZW5ndGggPT0gMSAmJiBzdGFydC5tZXJnZShmcm9tT2ZmLCB0b09mZiwgZWx0c1swXSwgb3BlblN0YXJ0LCBvcGVuRW5kKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGVsdHMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHN0YXJ0Lm1lcmdlKGZyb21PZmYsIHRvT2ZmLCBudWxsLCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSBzcGxpdCBpdCwgc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIHdvcnJ5IGFib3V0IGFsaWFzaW5nIGZyb250L2VuZCBhZnRlcndhcmRzXG4gICAgICAgIGxldCBhZnRlciA9IHN0YXJ0LnNsaWNlKHRvT2ZmKTtcbiAgICAgICAgaWYgKGFmdGVyLm1lcmdlKDAsIDAsIGVsdHNbZWx0cy5sZW5ndGggLSAxXSwgMCwgb3BlbkVuZCkpXG4gICAgICAgICAgICBlbHRzW2VsdHMubGVuZ3RoIC0gMV0gPSBhZnRlcjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZWx0cy5wdXNoKGFmdGVyKTtcbiAgICAgICAgdG9JKys7XG4gICAgICAgIG9wZW5FbmQgPSB0b09mZiA9IDA7XG4gICAgfVxuICAgIC8vIE1ha2Ugc3VyZSBzdGFydCBhbmQgZW5kIHBvc2l0aW9ucyBmYWxsIG9uIG5vZGUgYm91bmRhcmllc1xuICAgIC8vIChmcm9tT2ZmL3RvT2ZmIGFyZSBubyBsb25nZXIgdXNlZCBhZnRlciB0aGlzKSwgYW5kIHRoYXQgaWYgdGhlXG4gICAgLy8gc3RhcnQgb3IgZW5kIG9mIHRoZSBlbHRzIGNhbiBiZSBtZXJnZWQgd2l0aCBhZGphY2VudCBub2RlcyxcbiAgICAvLyB0aGlzIGlzIGRvbmVcbiAgICBpZiAodG9PZmYpIHtcbiAgICAgICAgbGV0IGVuZCA9IGNoaWxkcmVuW3RvSV07XG4gICAgICAgIGlmIChlbHRzLmxlbmd0aCAmJiBlbmQubWVyZ2UoMCwgdG9PZmYsIGVsdHNbZWx0cy5sZW5ndGggLSAxXSwgMCwgb3BlbkVuZCkpIHtcbiAgICAgICAgICAgIGVsdHMucG9wKCk7XG4gICAgICAgICAgICBvcGVuRW5kID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVuZC5tZXJnZSgwLCB0b09mZiwgbnVsbCwgMCwgMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodG9JIDwgY2hpbGRyZW4ubGVuZ3RoICYmIGVsdHMubGVuZ3RoICYmXG4gICAgICAgIGNoaWxkcmVuW3RvSV0ubWVyZ2UoMCwgMCwgZWx0c1tlbHRzLmxlbmd0aCAtIDFdLCAwLCBvcGVuRW5kKSkge1xuICAgICAgICBlbHRzLnBvcCgpO1xuICAgICAgICBvcGVuRW5kID0gMDtcbiAgICB9XG4gICAgaWYgKGZyb21PZmYpIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gY2hpbGRyZW5bZnJvbUldO1xuICAgICAgICBpZiAoZWx0cy5sZW5ndGggJiYgc3RhcnQubWVyZ2UoZnJvbU9mZiwgc3RhcnQubGVuZ3RoLCBlbHRzWzBdLCBvcGVuU3RhcnQsIDApKSB7XG4gICAgICAgICAgICBlbHRzLnNoaWZ0KCk7XG4gICAgICAgICAgICBvcGVuU3RhcnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnQubWVyZ2UoZnJvbU9mZiwgc3RhcnQubGVuZ3RoLCBudWxsLCAwLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBmcm9tSSsrO1xuICAgIH1cbiAgICBlbHNlIGlmIChmcm9tSSAmJiBlbHRzLmxlbmd0aCkge1xuICAgICAgICBsZXQgZW5kID0gY2hpbGRyZW5bZnJvbUkgLSAxXTtcbiAgICAgICAgaWYgKGVuZC5tZXJnZShlbmQubGVuZ3RoLCBlbmQubGVuZ3RoLCBlbHRzWzBdLCBvcGVuU3RhcnQsIDApKSB7XG4gICAgICAgICAgICBlbHRzLnNoaWZ0KCk7XG4gICAgICAgICAgICBvcGVuU3RhcnQgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRoZW4gdHJ5IHRvIG1lcmdlIGFueSBtZXJnZWFibGUgbm9kZXMgYXQgdGhlIHN0YXJ0IGFuZCBlbmQgb2ZcbiAgICAvLyB0aGUgY2hhbmdlZCByYW5nZVxuICAgIHdoaWxlIChmcm9tSSA8IHRvSSAmJiBlbHRzLmxlbmd0aCAmJiBjaGlsZHJlblt0b0kgLSAxXS5iZWNvbWUoZWx0c1tlbHRzLmxlbmd0aCAtIDFdKSkge1xuICAgICAgICBlbHRzLnBvcCgpO1xuICAgICAgICB0b0ktLTtcbiAgICAgICAgb3BlbkVuZCA9IDA7XG4gICAgfVxuICAgIHdoaWxlIChmcm9tSSA8IHRvSSAmJiBlbHRzLmxlbmd0aCAmJiBjaGlsZHJlbltmcm9tSV0uYmVjb21lKGVsdHNbMF0pKSB7XG4gICAgICAgIGVsdHMuc2hpZnQoKTtcbiAgICAgICAgZnJvbUkrKztcbiAgICAgICAgb3BlblN0YXJ0ID0gMDtcbiAgICB9XG4gICAgaWYgKCFlbHRzLmxlbmd0aCAmJiBmcm9tSSAmJiB0b0kgPCBjaGlsZHJlbi5sZW5ndGggJiYgb3BlblN0YXJ0ICYmIG9wZW5FbmQgJiZcbiAgICAgICAgY2hpbGRyZW5bdG9JXS5tZXJnZSgwLCAwLCBjaGlsZHJlbltmcm9tSSAtIDFdLCBvcGVuU3RhcnQsIG9wZW5FbmQpKVxuICAgICAgICBmcm9tSS0tO1xuICAgIC8vIEFuZCBpZiBhbnl0aGluZyByZW1haW5zLCBzcGxpY2UgdGhlIGNoaWxkIGFycmF5IHRvIGluc2VydCB0aGUgbmV3IGVsdHNcbiAgICBpZiAoZWx0cy5sZW5ndGggfHwgZnJvbUkgIT0gdG9JKVxuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkcmVuKGZyb21JLCB0b0ksIGVsdHMpO1xufVxuZnVuY3Rpb24gc2xpY2VJbmxpbmVDaGlsZHJlbihjaGlsZHJlbiwgZnJvbSkge1xuICAgIGxldCByZXN1bHQgPSBbXSwgb2ZmID0gMDtcbiAgICBmb3IgKGxldCBlbHQgb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGVuZCA9IG9mZiArIGVsdC5sZW5ndGg7XG4gICAgICAgIGlmIChlbmQgPiBmcm9tKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2gob2ZmIDwgZnJvbSA/IGVsdC5zbGljZShmcm9tIC0gb2ZmKSA6IGVsdCk7XG4gICAgICAgIG9mZiA9IGVuZDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGlubGluZURPTUF0UG9zKGRvbSwgY2hpbGRyZW4sIHBvcykge1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGxldCBvZmYgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGNoaWxkID0gY2hpbGRyZW5baV0sIGVuZCA9IG9mZiArIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgaWYgKGVuZCA9PSBvZmYgJiYgY2hpbGQuZ2V0U2lkZSgpIDw9IDApXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKHBvcyA+IG9mZiAmJiBwb3MgPCBlbmQgJiYgY2hpbGQuZG9tLnBhcmVudE5vZGUgPT0gZG9tKVxuICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmRvbUF0UG9zKHBvcyAtIG9mZik7XG4gICAgICAgIGlmIChwb3MgPD0gb2ZmKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIG9mZiA9IGVuZDtcbiAgICB9XG4gICAgZm9yICg7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgbGV0IGJlZm9yZSA9IGNoaWxkcmVuW2kgLSAxXS5kb207XG4gICAgICAgIGlmIChiZWZvcmUucGFyZW50Tm9kZSA9PSBkb20pXG4gICAgICAgICAgICByZXR1cm4gRE9NUG9zLmFmdGVyKGJlZm9yZSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRE9NUG9zKGRvbSwgMCk7XG59XG4vLyBBc3N1bWVzIGB2aWV3YCwgaWYgYSBtYXJrIHZpZXcsIGhhcyBwcmVjaXNlbHkgMSBjaGlsZC5cbmZ1bmN0aW9uIGpvaW5JbmxpbmVJbnRvKHBhcmVudCwgdmlldywgb3Blbikge1xuICAgIGxldCBsYXN0LCB7IGNoaWxkcmVuIH0gPSBwYXJlbnQ7XG4gICAgaWYgKG9wZW4gPiAwICYmIHZpZXcgaW5zdGFuY2VvZiBNYXJrVmlldyAmJiBjaGlsZHJlbi5sZW5ndGggJiZcbiAgICAgICAgKGxhc3QgPSBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXSkgaW5zdGFuY2VvZiBNYXJrVmlldyAmJiBsYXN0Lm1hcmsuZXEodmlldy5tYXJrKSkge1xuICAgICAgICBqb2luSW5saW5lSW50byhsYXN0LCB2aWV3LmNoaWxkcmVuWzBdLCBvcGVuIC0gMSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjaGlsZHJlbi5wdXNoKHZpZXcpO1xuICAgICAgICB2aWV3LnNldFBhcmVudChwYXJlbnQpO1xuICAgIH1cbiAgICBwYXJlbnQubGVuZ3RoICs9IHZpZXcubGVuZ3RoO1xufVxuZnVuY3Rpb24gY29vcmRzSW5DaGlsZHJlbih2aWV3LCBwb3MsIHNpZGUpIHtcbiAgICBmb3IgKGxldCBvZmYgPSAwLCBpID0gMDsgaSA8IHZpZXcuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGNoaWxkID0gdmlldy5jaGlsZHJlbltpXSwgZW5kID0gb2ZmICsgY2hpbGQubGVuZ3RoO1xuICAgICAgICBpZiAoZW5kID09IG9mZiAmJiBjaGlsZC5nZXRTaWRlKCkgPD0gMClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoc2lkZSA8PSAwIHx8IGVuZCA9PSB2aWV3Lmxlbmd0aCA/IGVuZCA+PSBwb3MgOiBlbmQgPiBwb3MpXG4gICAgICAgICAgICByZXR1cm4gY2hpbGQuY29vcmRzQXQocG9zIC0gb2ZmLCBzaWRlKTtcbiAgICAgICAgb2ZmID0gZW5kO1xuICAgIH1cbiAgICByZXR1cm4gKHZpZXcuZG9tLmxhc3RDaGlsZCB8fCB2aWV3LmRvbSkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG59XG5cbmZ1bmN0aW9uIGNvbWJpbmVBdHRycyhzb3VyY2UsIHRhcmdldCkge1xuICAgIGZvciAobGV0IG5hbWUgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChuYW1lID09IFwiY2xhc3NcIiAmJiB0YXJnZXQuY2xhc3MpXG4gICAgICAgICAgICB0YXJnZXQuY2xhc3MgKz0gXCIgXCIgKyBzb3VyY2UuY2xhc3M7XG4gICAgICAgIGVsc2UgaWYgKG5hbWUgPT0gXCJzdHlsZVwiICYmIHRhcmdldC5zdHlsZSlcbiAgICAgICAgICAgIHRhcmdldC5zdHlsZSArPSBcIjtcIiArIHNvdXJjZS5zdHlsZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGFyZ2V0W25hbWVdID0gc291cmNlW25hbWVdO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gYXR0cnNFcShhLCBiKSB7XG4gICAgaWYgKGEgPT0gYilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKCFhIHx8ICFiKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGtleXNBID0gT2JqZWN0LmtleXMoYSksIGtleXNCID0gT2JqZWN0LmtleXMoYik7XG4gICAgaWYgKGtleXNBLmxlbmd0aCAhPSBrZXlzQi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBrZXkgb2Yga2V5c0EpIHtcbiAgICAgICAgaWYgKGtleXNCLmluZGV4T2Yoa2V5KSA9PSAtMSB8fCBhW2tleV0gIT09IGJba2V5XSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiB1cGRhdGVBdHRycyhkb20sIHByZXYsIGF0dHJzKSB7XG4gICAgaWYgKHByZXYpXG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gcHJldilcbiAgICAgICAgICAgIGlmICghKGF0dHJzICYmIG5hbWUgaW4gYXR0cnMpKVxuICAgICAgICAgICAgICAgIGRvbS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgaWYgKGF0dHJzKVxuICAgICAgICBmb3IgKGxldCBuYW1lIGluIGF0dHJzKVxuICAgICAgICAgICAgaWYgKCEocHJldiAmJiBwcmV2W25hbWVdID09IGF0dHJzW25hbWVdKSlcbiAgICAgICAgICAgICAgICBkb20uc2V0QXR0cmlidXRlKG5hbWUsIGF0dHJzW25hbWVdKTtcbn1cblxuLyoqXG5XaWRnZXRzIGFkZGVkIHRvIHRoZSBjb250ZW50IGFyZSBkZXNjcmliZWQgYnkgc3ViY2xhc3NlcyBvZiB0aGlzXG5jbGFzcy4gVXNpbmcgYSBkZXNjcmlwdGlvbiBvYmplY3QgbGlrZSB0aGF0IG1ha2VzIGl0IHBvc3NpYmxlIHRvXG5kZWxheSBjcmVhdGluZyBvZiB0aGUgRE9NIHN0cnVjdHVyZSBmb3IgYSB3aWRnZXQgdW50aWwgaXQgaXNcbm5lZWRlZCwgYW5kIHRvIGF2b2lkIHJlZHJhd2luZyB3aWRnZXRzIGV2ZW4gd2hlbiB0aGUgZGVjb3JhdGlvbnNcbnRoYXQgZGVmaW5lIHRoZW0gYXJlIHJlY3JlYXRlZC5cbiovXG5jbGFzcyBXaWRnZXRUeXBlIHtcbiAgICAvKipcbiAgICBDb21wYXJlIHRoaXMgaW5zdGFuY2UgdG8gYW5vdGhlciBpbnN0YW5jZSBvZiB0aGUgc2FtZSB0eXBlLlxuICAgIChUeXBlU2NyaXB0IGNhbid0IGV4cHJlc3MgdGhpcywgYnV0IG9ubHkgaW5zdGFuY2VzIG9mIHRoZSBzYW1lXG4gICAgc3BlY2lmaWMgY2xhc3Mgd2lsbCBiZSBwYXNzZWQgdG8gdGhpcyBtZXRob2QuKSBUaGlzIGlzIHVzZWQgdG9cbiAgICBhdm9pZCByZWRyYXdpbmcgd2lkZ2V0cyB3aGVuIHRoZXkgYXJlIHJlcGxhY2VkIGJ5IGEgbmV3XG4gICAgZGVjb3JhdGlvbiBvZiB0aGUgc2FtZSB0eXBlLiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBqdXN0XG4gICAgcmV0dXJucyBgZmFsc2VgLCB3aGljaCB3aWxsIGNhdXNlIG5ldyBpbnN0YW5jZXMgb2YgdGhlIHdpZGdldCB0b1xuICAgIGFsd2F5cyBiZSByZWRyYXduLlxuICAgICovXG4gICAgZXEoX3dpZGdldCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAvKipcbiAgICBVcGRhdGUgYSBET00gZWxlbWVudCBjcmVhdGVkIGJ5IGEgd2lkZ2V0IG9mIHRoZSBzYW1lIHR5cGUgKGJ1dFxuICAgIGRpZmZlcmVudCwgbm9uLWBlcWAgY29udGVudCkgdG8gcmVmbGVjdCB0aGlzIHdpZGdldC4gTWF5IHJldHVyblxuICAgIHRydWUgdG8gaW5kaWNhdGUgdGhhdCBpdCBjb3VsZCB1cGRhdGUsIGZhbHNlIHRvIGluZGljYXRlIGl0XG4gICAgY291bGRuJ3QgKGluIHdoaWNoIGNhc2UgdGhlIHdpZGdldCB3aWxsIGJlIHJlZHJhd24pLiBUaGUgZGVmYXVsdFxuICAgIGltcGxlbWVudGF0aW9uIGp1c3QgcmV0dXJucyBmYWxzZS5cbiAgICAqL1xuICAgIHVwZGF0ZURPTShfZG9tKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29tcGFyZShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fCB0aGlzLmNvbnN0cnVjdG9yID09IG90aGVyLmNvbnN0cnVjdG9yICYmIHRoaXMuZXEob3RoZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgZXN0aW1hdGVkIGhlaWdodCB0aGlzIHdpZGdldCB3aWxsIGhhdmUsIHRvIGJlIHVzZWQgd2hlblxuICAgIGVzdGltYXRpbmcgdGhlIGhlaWdodCBvZiBjb250ZW50IHRoYXQgaGFzbid0IGJlZW4gZHJhd24uIE1heVxuICAgIHJldHVybiAtMSB0byBpbmRpY2F0ZSB5b3UgZG9uJ3Qga25vdy4gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb25cbiAgICByZXR1cm5zIC0xLlxuICAgICovXG4gICAgZ2V0IGVzdGltYXRlZEhlaWdodCgpIHsgcmV0dXJuIC0xOyB9XG4gICAgLyoqXG4gICAgQ2FuIGJlIHVzZWQgdG8gY29uZmlndXJlIHdoaWNoIGtpbmRzIG9mIGV2ZW50cyBpbnNpZGUgdGhlIHdpZGdldFxuICAgIHNob3VsZCBiZSBpZ25vcmVkIGJ5IHRoZSBlZGl0b3IuIFRoZSBkZWZhdWx0IGlzIHRvIGlnbm9yZSBhbGxcbiAgICBldmVudHMuXG4gICAgKi9cbiAgICBpZ25vcmVFdmVudChfZXZlbnQpIHsgcmV0dXJuIHRydWU7IH1cbiAgICAvKipcbiAgICAvIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGN1c3RvbVZpZXcoKSB7IHJldHVybiBudWxsOyB9XG59XG4vKipcblRoZSBkaWZmZXJlbnQgdHlwZXMgb2YgYmxvY2tzIHRoYXQgY2FuIG9jY3VyIGluIGFuIGVkaXRvciB2aWV3LlxuKi9cbmV4cG9ydHMuQmxvY2tUeXBlID0gdm9pZCAwO1xuKGZ1bmN0aW9uIChCbG9ja1R5cGUpIHtcbiAgICAvKipcbiAgICBBIGxpbmUgb2YgdGV4dC5cbiAgICAqL1xuICAgIEJsb2NrVHlwZVtCbG9ja1R5cGVbXCJUZXh0XCJdID0gMF0gPSBcIlRleHRcIjtcbiAgICAvKipcbiAgICBBIGJsb2NrIHdpZGdldCBhc3NvY2lhdGVkIHdpdGggdGhlIHBvc2l0aW9uIGFmdGVyIGl0LlxuICAgICovXG4gICAgQmxvY2tUeXBlW0Jsb2NrVHlwZVtcIldpZGdldEJlZm9yZVwiXSA9IDFdID0gXCJXaWRnZXRCZWZvcmVcIjtcbiAgICAvKipcbiAgICBBIGJsb2NrIHdpZGdldCBhc3NvY2lhdGVkIHdpdGggdGhlIHBvc2l0aW9uIGJlZm9yZSBpdC5cbiAgICAqL1xuICAgIEJsb2NrVHlwZVtCbG9ja1R5cGVbXCJXaWRnZXRBZnRlclwiXSA9IDJdID0gXCJXaWRnZXRBZnRlclwiO1xuICAgIC8qKlxuICAgIEEgYmxvY2sgd2lkZ2V0IFtyZXBsYWNpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5EZWNvcmF0aW9uXnJlcGxhY2UpIGEgcmFuZ2Ugb2YgY29udGVudC5cbiAgICAqL1xuICAgIEJsb2NrVHlwZVtCbG9ja1R5cGVbXCJXaWRnZXRSYW5nZVwiXSA9IDNdID0gXCJXaWRnZXRSYW5nZVwiO1xufSkoZXhwb3J0cy5CbG9ja1R5cGUgfHwgKGV4cG9ydHMuQmxvY2tUeXBlID0ge30pKTtcbi8qKlxuQSBkZWNvcmF0aW9uIHByb3ZpZGVzIGluZm9ybWF0aW9uIG9uIGhvdyB0byBkcmF3IG9yIHN0eWxlIGEgcGllY2Vcbm9mIGNvbnRlbnQuIFlvdSdsbCB1c3VhbGx5IHVzZSBpdCB3cmFwcGVkIGluIGFcbltgUmFuZ2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3Jhbmdlc2V0LlJhbmdlKSwgd2hpY2ggYWRkcyBhIHN0YXJ0IGFuZCBlbmQgcG9zaXRpb24uXG4qL1xuY2xhc3MgRGVjb3JhdGlvbiBleHRlbmRzIHJhbmdlc2V0LlJhbmdlVmFsdWUge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGFydFNpZGUsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZW5kU2lkZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB3aWRnZXQsIFxuICAgIC8qKlxuICAgIFRoZSBjb25maWcgb2JqZWN0IHVzZWQgdG8gY3JlYXRlIHRoaXMgZGVjb3JhdGlvbi4gWW91IGNhblxuICAgIGluY2x1ZGUgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIGluIHRoZXJlIHRvIHN0b3JlIG1ldGFkYXRhIGFib3V0XG4gICAgeW91ciBkZWNvcmF0aW9uLlxuICAgICovXG4gICAgc3BlYykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnN0YXJ0U2lkZSA9IHN0YXJ0U2lkZTtcbiAgICAgICAgdGhpcy5lbmRTaWRlID0gZW5kU2lkZTtcbiAgICAgICAgdGhpcy53aWRnZXQgPSB3aWRnZXQ7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGhlaWdodFJlbGV2YW50KCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBtYXJrIGRlY29yYXRpb24sIHdoaWNoIGluZmx1ZW5jZXMgdGhlIHN0eWxpbmcgb2YgdGhlXG4gICAgY29udGVudCBpbiBpdHMgcmFuZ2UuIE5lc3RlZCBtYXJrIGRlY29yYXRpb25zIHdpbGwgY2F1c2UgbmVzdGVkXG4gICAgRE9NIGVsZW1lbnRzIHRvIGJlIGNyZWF0ZWQuIE5lc3Rpbmcgb3JkZXIgaXMgZGV0ZXJtaW5lZCBieVxuICAgIHByZWNlZGVuY2Ugb2YgdGhlIFtmYWNldF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdeZGVjb3JhdGlvbnMpIG9yXG4gICAgKGJlbG93IHRoZSBmYWNldC1wcm92aWRlZCBkZWNvcmF0aW9ucykgW3ZpZXdcbiAgICBwbHVnaW5dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5QbHVnaW5TcGVjLmRlY29yYXRpb25zKS4gU3VjaCBlbGVtZW50cyBhcmUgc3BsaXRcbiAgICBvbiBsaW5lIGJvdW5kYXJpZXMgYW5kIG9uIHRoZSBib3VuZGFyaWVzIG9mIGhpZ2hlci1wcmVjZWRlbmNlXG4gICAgZGVjb3JhdGlvbnMuXG4gICAgKi9cbiAgICBzdGF0aWMgbWFyayhzcGVjKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWFya0RlY29yYXRpb24oc3BlYyk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHdpZGdldCBkZWNvcmF0aW9uLCB3aGljaCBhZGRzIGFuIGVsZW1lbnQgYXQgdGhlIGdpdmVuXG4gICAgcG9zaXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgd2lkZ2V0KHNwZWMpIHtcbiAgICAgICAgbGV0IHNpZGUgPSBzcGVjLnNpZGUgfHwgMDtcbiAgICAgICAgaWYgKHNwZWMuYmxvY2spXG4gICAgICAgICAgICBzaWRlICs9ICgyMDAwMDAwMDAgLyogQmlnQmxvY2sgKi8gKyAxKSAqIChzaWRlID4gMCA/IDEgOiAtMSk7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnREZWNvcmF0aW9uKHNwZWMsIHNpZGUsIHNpZGUsICEhc3BlYy5ibG9jaywgc3BlYy53aWRnZXQgfHwgbnVsbCwgZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSByZXBsYWNlIGRlY29yYXRpb24gd2hpY2ggcmVwbGFjZXMgdGhlIGdpdmVuIHJhbmdlIHdpdGhcbiAgICBhIHdpZGdldCwgb3Igc2ltcGx5IGhpZGVzIGl0LlxuICAgICovXG4gICAgc3RhdGljIHJlcGxhY2Uoc3BlYykge1xuICAgICAgICBsZXQgYmxvY2sgPSAhIXNwZWMuYmxvY2s7XG4gICAgICAgIGxldCB7IHN0YXJ0LCBlbmQgfSA9IGdldEluY2x1c2l2ZShzcGVjKTtcbiAgICAgICAgbGV0IHN0YXJ0U2lkZSA9IGJsb2NrID8gLTIwMDAwMDAwMCAvKiBCaWdCbG9jayAqLyAqIChzdGFydCA/IDIgOiAxKSA6IDEwMDAwMDAwMCAvKiBCaWdJbmxpbmUgKi8gKiAoc3RhcnQgPyAtMSA6IDEpO1xuICAgICAgICBsZXQgZW5kU2lkZSA9IGJsb2NrID8gMjAwMDAwMDAwIC8qIEJpZ0Jsb2NrICovICogKGVuZCA/IDIgOiAxKSA6IDEwMDAwMDAwMCAvKiBCaWdJbmxpbmUgKi8gKiAoZW5kID8gMSA6IC0xKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludERlY29yYXRpb24oc3BlYywgc3RhcnRTaWRlLCBlbmRTaWRlLCBibG9jaywgc3BlYy53aWRnZXQgfHwgbnVsbCwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGxpbmUgZGVjb3JhdGlvbiwgd2hpY2ggY2FuIGFkZCBET00gYXR0cmlidXRlcyB0byB0aGVcbiAgICBsaW5lIHN0YXJ0aW5nIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBsaW5lKHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lRGVjb3JhdGlvbihzcGVjKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQnVpbGQgYSBbYERlY29yYXRpb25TZXRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRGVjb3JhdGlvblNldCkgZnJvbSB0aGUgZ2l2ZW5cbiAgICBkZWNvcmF0ZWQgcmFuZ2Ugb3IgcmFuZ2VzLiBJZiB0aGUgcmFuZ2VzIGFyZW4ndCBhbHJlYWR5IHNvcnRlZCxcbiAgICBwYXNzIGB0cnVlYCBmb3IgYHNvcnRgIHRvIG1ha2UgdGhlIGxpYnJhcnkgc29ydCB0aGVtIGZvciB5b3UuXG4gICAgKi9cbiAgICBzdGF0aWMgc2V0KG9mLCBzb3J0ID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlc2V0LlJhbmdlU2V0Lm9mKG9mLCBzb3J0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBoYXNIZWlnaHQoKSB7IHJldHVybiB0aGlzLndpZGdldCA/IHRoaXMud2lkZ2V0LmVzdGltYXRlZEhlaWdodCA+IC0xIDogZmFsc2U7IH1cbn1cbi8qKlxuVGhlIGVtcHR5IHNldCBvZiBkZWNvcmF0aW9ucy5cbiovXG5EZWNvcmF0aW9uLm5vbmUgPSByYW5nZXNldC5SYW5nZVNldC5lbXB0eTtcbmNsYXNzIE1hcmtEZWNvcmF0aW9uIGV4dGVuZHMgRGVjb3JhdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICBsZXQgeyBzdGFydCwgZW5kIH0gPSBnZXRJbmNsdXNpdmUoc3BlYyk7XG4gICAgICAgIHN1cGVyKDEwMDAwMDAwMCAvKiBCaWdJbmxpbmUgKi8gKiAoc3RhcnQgPyAtMSA6IDEpLCAxMDAwMDAwMDAgLyogQmlnSW5saW5lICovICogKGVuZCA/IDEgOiAtMSksIG51bGwsIHNwZWMpO1xuICAgICAgICB0aGlzLnRhZ05hbWUgPSBzcGVjLnRhZ05hbWUgfHwgXCJzcGFuXCI7XG4gICAgICAgIHRoaXMuY2xhc3MgPSBzcGVjLmNsYXNzIHx8IFwiXCI7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBzcGVjLmF0dHJpYnV0ZXMgfHwgbnVsbDtcbiAgICB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHxcbiAgICAgICAgICAgIG90aGVyIGluc3RhbmNlb2YgTWFya0RlY29yYXRpb24gJiZcbiAgICAgICAgICAgICAgICB0aGlzLnRhZ05hbWUgPT0gb3RoZXIudGFnTmFtZSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuY2xhc3MgPT0gb3RoZXIuY2xhc3MgJiZcbiAgICAgICAgICAgICAgICBhdHRyc0VxKHRoaXMuYXR0cnMsIG90aGVyLmF0dHJzKTtcbiAgICB9XG4gICAgcmFuZ2UoZnJvbSwgdG8gPSBmcm9tKSB7XG4gICAgICAgIGlmIChmcm9tID49IHRvKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJNYXJrIGRlY29yYXRpb25zIG1heSBub3QgYmUgZW1wdHlcIik7XG4gICAgICAgIHJldHVybiBzdXBlci5yYW5nZShmcm9tLCB0byk7XG4gICAgfVxufVxuTWFya0RlY29yYXRpb24ucHJvdG90eXBlLnBvaW50ID0gZmFsc2U7XG5jbGFzcyBMaW5lRGVjb3JhdGlvbiBleHRlbmRzIERlY29yYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICAgICAgc3VwZXIoLTEwMDAwMDAwMCAvKiBCaWdJbmxpbmUgKi8sIC0xMDAwMDAwMDAgLyogQmlnSW5saW5lICovLCBudWxsLCBzcGVjKTtcbiAgICB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgTGluZURlY29yYXRpb24gJiYgYXR0cnNFcSh0aGlzLnNwZWMuYXR0cmlidXRlcywgb3RoZXIuc3BlYy5hdHRyaWJ1dGVzKTtcbiAgICB9XG4gICAgcmFuZ2UoZnJvbSwgdG8gPSBmcm9tKSB7XG4gICAgICAgIGlmICh0byAhPSBmcm9tKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJMaW5lIGRlY29yYXRpb24gcmFuZ2VzIG11c3QgYmUgemVyby1sZW5ndGhcIik7XG4gICAgICAgIHJldHVybiBzdXBlci5yYW5nZShmcm9tLCB0byk7XG4gICAgfVxufVxuTGluZURlY29yYXRpb24ucHJvdG90eXBlLm1hcE1vZGUgPSBzdGF0ZS5NYXBNb2RlLlRyYWNrQmVmb3JlO1xuTGluZURlY29yYXRpb24ucHJvdG90eXBlLnBvaW50ID0gdHJ1ZTtcbmNsYXNzIFBvaW50RGVjb3JhdGlvbiBleHRlbmRzIERlY29yYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHNwZWMsIHN0YXJ0U2lkZSwgZW5kU2lkZSwgYmxvY2ssIHdpZGdldCwgaXNSZXBsYWNlKSB7XG4gICAgICAgIHN1cGVyKHN0YXJ0U2lkZSwgZW5kU2lkZSwgd2lkZ2V0LCBzcGVjKTtcbiAgICAgICAgdGhpcy5ibG9jayA9IGJsb2NrO1xuICAgICAgICB0aGlzLmlzUmVwbGFjZSA9IGlzUmVwbGFjZTtcbiAgICAgICAgdGhpcy5tYXBNb2RlID0gIWJsb2NrID8gc3RhdGUuTWFwTW9kZS5UcmFja0RlbCA6IHN0YXJ0U2lkZSA8IDAgPyBzdGF0ZS5NYXBNb2RlLlRyYWNrQmVmb3JlIDogc3RhdGUuTWFwTW9kZS5UcmFja0FmdGVyO1xuICAgIH1cbiAgICAvLyBPbmx5IHJlbGV2YW50IHdoZW4gdGhpcy5ibG9jayA9PSB0cnVlXG4gICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0U2lkZSA8IHRoaXMuZW5kU2lkZSA/IGV4cG9ydHMuQmxvY2tUeXBlLldpZGdldFJhbmdlXG4gICAgICAgICAgICA6IHRoaXMuc3RhcnRTaWRlIDwgMCA/IGV4cG9ydHMuQmxvY2tUeXBlLldpZGdldEJlZm9yZSA6IGV4cG9ydHMuQmxvY2tUeXBlLldpZGdldEFmdGVyO1xuICAgIH1cbiAgICBnZXQgaGVpZ2h0UmVsZXZhbnQoKSB7IHJldHVybiB0aGlzLmJsb2NrIHx8ICEhdGhpcy53aWRnZXQgJiYgdGhpcy53aWRnZXQuZXN0aW1hdGVkSGVpZ2h0ID49IDU7IH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBQb2ludERlY29yYXRpb24gJiZcbiAgICAgICAgICAgIHdpZGdldHNFcSh0aGlzLndpZGdldCwgb3RoZXIud2lkZ2V0KSAmJlxuICAgICAgICAgICAgdGhpcy5ibG9jayA9PSBvdGhlci5ibG9jayAmJlxuICAgICAgICAgICAgdGhpcy5zdGFydFNpZGUgPT0gb3RoZXIuc3RhcnRTaWRlICYmIHRoaXMuZW5kU2lkZSA9PSBvdGhlci5lbmRTaWRlO1xuICAgIH1cbiAgICByYW5nZShmcm9tLCB0byA9IGZyb20pIHtcbiAgICAgICAgaWYgKHRoaXMuaXNSZXBsYWNlICYmIChmcm9tID4gdG8gfHwgKGZyb20gPT0gdG8gJiYgdGhpcy5zdGFydFNpZGUgPiAwICYmIHRoaXMuZW5kU2lkZSA8IDApKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCByYW5nZSBmb3IgcmVwbGFjZW1lbnQgZGVjb3JhdGlvblwiKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzUmVwbGFjZSAmJiB0byAhPSBmcm9tKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJXaWRnZXQgZGVjb3JhdGlvbnMgY2FuIG9ubHkgaGF2ZSB6ZXJvLWxlbmd0aCByYW5nZXNcIik7XG4gICAgICAgIHJldHVybiBzdXBlci5yYW5nZShmcm9tLCB0byk7XG4gICAgfVxufVxuUG9pbnREZWNvcmF0aW9uLnByb3RvdHlwZS5wb2ludCA9IHRydWU7XG5mdW5jdGlvbiBnZXRJbmNsdXNpdmUoc3BlYykge1xuICAgIGxldCB7IGluY2x1c2l2ZVN0YXJ0OiBzdGFydCwgaW5jbHVzaXZlRW5kOiBlbmQgfSA9IHNwZWM7XG4gICAgaWYgKHN0YXJ0ID09IG51bGwpXG4gICAgICAgIHN0YXJ0ID0gc3BlYy5pbmNsdXNpdmU7XG4gICAgaWYgKGVuZCA9PSBudWxsKVxuICAgICAgICBlbmQgPSBzcGVjLmluY2x1c2l2ZTtcbiAgICByZXR1cm4geyBzdGFydDogc3RhcnQgfHwgZmFsc2UsIGVuZDogZW5kIHx8IGZhbHNlIH07XG59XG5mdW5jdGlvbiB3aWRnZXRzRXEoYSwgYikge1xuICAgIHJldHVybiBhID09IGIgfHwgISEoYSAmJiBiICYmIGEuY29tcGFyZShiKSk7XG59XG5mdW5jdGlvbiBhZGRSYW5nZShmcm9tLCB0bywgcmFuZ2VzLCBtYXJnaW4gPSAwKSB7XG4gICAgbGV0IGxhc3QgPSByYW5nZXMubGVuZ3RoIC0gMTtcbiAgICBpZiAobGFzdCA+PSAwICYmIHJhbmdlc1tsYXN0XSArIG1hcmdpbiA+IGZyb20pXG4gICAgICAgIHJhbmdlc1tsYXN0XSA9IE1hdGgubWF4KHJhbmdlc1tsYXN0XSwgdG8pO1xuICAgIGVsc2VcbiAgICAgICAgcmFuZ2VzLnB1c2goZnJvbSwgdG8pO1xufVxuXG5jbGFzcyBMaW5lVmlldyBleHRlbmRzIENvbnRlbnRWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMucHJldkF0dHJzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmF0dHJzID0gbnVsbDtcbiAgICAgICAgdGhpcy5icmVha0FmdGVyID0gMDtcbiAgICB9XG4gICAgLy8gQ29uc3VtZXMgc291cmNlXG4gICAgbWVyZ2UoZnJvbSwgdG8sIHNvdXJjZSwgdGFrZURlY28sIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoIShzb3VyY2UgaW5zdGFuY2VvZiBMaW5lVmlldykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmRvbSlcbiAgICAgICAgICAgICAgICBzb3VyY2UudHJhbnNmZXJET00odGhpcyk7IC8vIFJldXNlIHNvdXJjZS5kb20gd2hlbiBhcHByb3ByaWF0ZVxuICAgICAgICB9XG4gICAgICAgIGlmICh0YWtlRGVjbylcbiAgICAgICAgICAgIHRoaXMuc2V0RGVjbyhzb3VyY2UgPyBzb3VyY2UuYXR0cnMgOiBudWxsKTtcbiAgICAgICAgbWVyZ2VJbmxpbmVDaGlsZHJlbih0aGlzLCBmcm9tLCB0bywgc291cmNlID8gc291cmNlLmNoaWxkcmVuIDogbm9uZSQxLCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc3BsaXQoYXQpIHtcbiAgICAgICAgbGV0IGVuZCA9IG5ldyBMaW5lVmlldztcbiAgICAgICAgZW5kLmJyZWFrQWZ0ZXIgPSB0aGlzLmJyZWFrQWZ0ZXI7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGVuZDtcbiAgICAgICAgbGV0IHsgaSwgb2ZmIH0gPSB0aGlzLmNoaWxkUG9zKGF0KTtcbiAgICAgICAgaWYgKG9mZikge1xuICAgICAgICAgICAgZW5kLmFwcGVuZCh0aGlzLmNoaWxkcmVuW2ldLnNsaWNlKG9mZiksIDApO1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS5tZXJnZShvZmYsIHRoaXMuY2hpbGRyZW5baV0ubGVuZ3RoLCBudWxsLCAwLCAwKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBqID0gaTsgaiA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICBlbmQuYXBwZW5kKHRoaXMuY2hpbGRyZW5bal0sIDApO1xuICAgICAgICB3aGlsZSAoaSA+IDAgJiYgdGhpcy5jaGlsZHJlbltpIC0gMV0ubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baSAtIDFdLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGlsZHJlbi5sZW5ndGggPSBpO1xuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGF0O1xuICAgICAgICByZXR1cm4gZW5kO1xuICAgIH1cbiAgICB0cmFuc2ZlckRPTShvdGhlcikge1xuICAgICAgICBpZiAoIXRoaXMuZG9tKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBvdGhlci5zZXRET00odGhpcy5kb20pO1xuICAgICAgICBvdGhlci5wcmV2QXR0cnMgPSB0aGlzLnByZXZBdHRycyA9PT0gdW5kZWZpbmVkID8gdGhpcy5hdHRycyA6IHRoaXMucHJldkF0dHJzO1xuICAgICAgICB0aGlzLnByZXZBdHRycyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5kb20gPSBudWxsO1xuICAgIH1cbiAgICBzZXREZWNvKGF0dHJzKSB7XG4gICAgICAgIGlmICghYXR0cnNFcSh0aGlzLmF0dHJzLCBhdHRycykpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJldkF0dHJzID0gdGhpcy5hdHRycztcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIE9ubHkgY2FsbGVkIHdoZW4gYnVpbGRpbmcgYSBsaW5lIHZpZXcgaW4gQ29udGVudEJ1aWxkZXJcbiAgICBhcHBlbmQoY2hpbGQsIG9wZW5TdGFydCkge1xuICAgICAgICBqb2luSW5saW5lSW50byh0aGlzLCBjaGlsZCwgb3BlblN0YXJ0KTtcbiAgICB9XG4gICAgLy8gT25seSBjYWxsZWQgd2hlbiBidWlsZGluZyBhIGxpbmUgdmlldyBpbiBDb250ZW50QnVpbGRlclxuICAgIGFkZExpbmVEZWNvKGRlY28pIHtcbiAgICAgICAgbGV0IGF0dHJzID0gZGVjby5zcGVjLmF0dHJpYnV0ZXM7XG4gICAgICAgIGlmIChhdHRycylcbiAgICAgICAgICAgIHRoaXMuYXR0cnMgPSBjb21iaW5lQXR0cnMoYXR0cnMsIHRoaXMuYXR0cnMgfHwge30pO1xuICAgIH1cbiAgICBkb21BdFBvcyhwb3MpIHtcbiAgICAgICAgcmV0dXJuIGlubGluZURPTUF0UG9zKHRoaXMuZG9tLCB0aGlzLmNoaWxkcmVuLCBwb3MpO1xuICAgIH1cbiAgICBzeW5jKHRyYWNrKSB7XG4gICAgICAgIGlmICghdGhpcy5kb20pIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RE9NKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuICAgICAgICAgICAgdGhpcy5kb20uY2xhc3NOYW1lID0gXCJjbS1saW5lXCI7XG4gICAgICAgICAgICB0aGlzLnByZXZBdHRycyA9IHRoaXMuYXR0cnMgPyBudWxsIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByZXZBdHRycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB1cGRhdGVBdHRycyh0aGlzLmRvbSwgdGhpcy5wcmV2QXR0cnMsIHRoaXMuYXR0cnMpO1xuICAgICAgICAgICAgdGhpcy5kb20uY2xhc3NMaXN0LmFkZChcImNtLWxpbmVcIik7XG4gICAgICAgICAgICB0aGlzLnByZXZBdHRycyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5zeW5jKHRyYWNrKTtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmRvbS5sYXN0Q2hpbGQ7XG4gICAgICAgIGlmICghbGFzdCB8fCAobGFzdC5ub2RlTmFtZSAhPSBcIkJSXCIgJiYgKENvbnRlbnRWaWV3LmdldChsYXN0KSBpbnN0YW5jZW9mIFdpZGdldFZpZXcpKSkge1xuICAgICAgICAgICAgbGV0IGhhY2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiQlJcIik7XG4gICAgICAgICAgICBoYWNrLmNtSWdub3JlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKGhhY2spO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1lYXN1cmVUZXh0U2l6ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09IDAgfHwgdGhpcy5sZW5ndGggPiAyMClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgdG90YWxXaWR0aCA9IDA7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmICghKGNoaWxkIGluc3RhbmNlb2YgVGV4dFZpZXcpKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgbGV0IHJlY3RzID0gY2xpZW50UmVjdHNGb3IoY2hpbGQuZG9tKTtcbiAgICAgICAgICAgIGlmIChyZWN0cy5sZW5ndGggIT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHRvdGFsV2lkdGggKz0gcmVjdHNbMF0ud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbGluZUhlaWdodDogdGhpcy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0LCBjaGFyV2lkdGg6IHRvdGFsV2lkdGggLyB0aGlzLmxlbmd0aCB9O1xuICAgIH1cbiAgICBjb29yZHNBdChwb3MsIHNpZGUpIHtcbiAgICAgICAgcmV0dXJuIGNvb3Jkc0luQ2hpbGRyZW4odGhpcywgcG9zLCBzaWRlKTtcbiAgICB9XG4gICAgbWF0Y2goX290aGVyKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGdldCB0eXBlKCkgeyByZXR1cm4gZXhwb3J0cy5CbG9ja1R5cGUuVGV4dDsgfVxuICAgIHN0YXRpYyBmaW5kKGRvY1ZpZXcsIHBvcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgb2ZmID0gMDs7IGkrKykge1xuICAgICAgICAgICAgbGV0IGJsb2NrID0gZG9jVmlldy5jaGlsZHJlbltpXSwgZW5kID0gb2ZmICsgYmxvY2subGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGVuZCA+PSBwb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2sgaW5zdGFuY2VvZiBMaW5lVmlldylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJsb2NrO1xuICAgICAgICAgICAgICAgIGlmIChibG9jay5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2ZmID0gZW5kICsgYmxvY2suYnJlYWtBZnRlcjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNvbnN0IG5vbmUkMSA9IFtdO1xuY2xhc3MgQmxvY2tXaWRnZXRWaWV3IGV4dGVuZHMgQ29udGVudFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKHdpZGdldCwgbGVuZ3RoLCB0eXBlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMud2lkZ2V0ID0gd2lkZ2V0O1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5icmVha0FmdGVyID0gMDtcbiAgICB9XG4gICAgbWVyZ2UoZnJvbSwgdG8sIHNvdXJjZSwgX3Rha2VEZWNvLCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICAgICAgaWYgKHNvdXJjZSAmJiAoIShzb3VyY2UgaW5zdGFuY2VvZiBCbG9ja1dpZGdldFZpZXcpIHx8ICF0aGlzLndpZGdldC5jb21wYXJlKHNvdXJjZS53aWRnZXQpIHx8XG4gICAgICAgICAgICBmcm9tID4gMCAmJiBvcGVuU3RhcnQgPD0gMCB8fCB0byA8IHRoaXMubGVuZ3RoICYmIG9wZW5FbmQgPD0gMCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gZnJvbSArIChzb3VyY2UgPyBzb3VyY2UubGVuZ3RoIDogMCkgKyAodGhpcy5sZW5ndGggLSB0byk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBkb21BdFBvcyhwb3MpIHtcbiAgICAgICAgcmV0dXJuIHBvcyA9PSAwID8gRE9NUG9zLmJlZm9yZSh0aGlzLmRvbSkgOiBET01Qb3MuYWZ0ZXIodGhpcy5kb20sIHBvcyA9PSB0aGlzLmxlbmd0aCk7XG4gICAgfVxuICAgIHNwbGl0KGF0KSB7XG4gICAgICAgIGxldCBsZW4gPSB0aGlzLmxlbmd0aCAtIGF0O1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGF0O1xuICAgICAgICByZXR1cm4gbmV3IEJsb2NrV2lkZ2V0Vmlldyh0aGlzLndpZGdldCwgbGVuLCB0aGlzLnR5cGUpO1xuICAgIH1cbiAgICBnZXQgY2hpbGRyZW4oKSB7IHJldHVybiBub25lJDE7IH1cbiAgICBzeW5jKCkge1xuICAgICAgICBpZiAoIXRoaXMuZG9tIHx8ICF0aGlzLndpZGdldC51cGRhdGVET00odGhpcy5kb20pKSB7XG4gICAgICAgICAgICB0aGlzLnNldERPTSh0aGlzLndpZGdldC50b0RPTSh0aGlzLmVkaXRvclZpZXcpKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmNvbnRlbnRFZGl0YWJsZSA9IFwiZmFsc2VcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgb3ZlcnJpZGVET01UZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC52aWV3LnN0YXRlLmRvYy5zbGljZSh0aGlzLnBvc0F0U3RhcnQsIHRoaXMucG9zQXRFbmQpIDogc3RhdGUuVGV4dC5lbXB0eTtcbiAgICB9XG4gICAgZG9tQm91bmRzQXJvdW5kKCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIG1hdGNoKG90aGVyKSB7XG4gICAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIEJsb2NrV2lkZ2V0VmlldyAmJiBvdGhlci50eXBlID09IHRoaXMudHlwZSAmJlxuICAgICAgICAgICAgb3RoZXIud2lkZ2V0LmNvbnN0cnVjdG9yID09IHRoaXMud2lkZ2V0LmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBpZiAoIW90aGVyLndpZGdldC5lcSh0aGlzLndpZGdldCkpXG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrRGlydHkodHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLndpZGdldCA9IG90aGVyLndpZGdldDtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5icmVha0FmdGVyID0gb3RoZXIuYnJlYWtBZnRlcjtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWdub3JlTXV0YXRpb24oKSB7IHJldHVybiB0cnVlOyB9XG4gICAgaWdub3JlRXZlbnQoZXZlbnQpIHsgcmV0dXJuIHRoaXMud2lkZ2V0Lmlnbm9yZUV2ZW50KGV2ZW50KTsgfVxufVxuXG5jbGFzcyBDb250ZW50QnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IoZG9jLCBwb3MsIGVuZCkge1xuICAgICAgICB0aGlzLmRvYyA9IGRvYztcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuZW5kID0gZW5kO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBbXTtcbiAgICAgICAgdGhpcy5jdXJMaW5lID0gbnVsbDtcbiAgICAgICAgdGhpcy5icmVha0F0U3RhcnQgPSAwO1xuICAgICAgICB0aGlzLm9wZW5TdGFydCA9IC0xO1xuICAgICAgICB0aGlzLm9wZW5FbmQgPSAtMTtcbiAgICAgICAgdGhpcy50ZXh0ID0gXCJcIjtcbiAgICAgICAgdGhpcy50ZXh0T2ZmID0gMDtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBkb2MuaXRlcigpO1xuICAgICAgICB0aGlzLnNraXAgPSBwb3M7XG4gICAgfVxuICAgIHBvc0NvdmVyZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuYnJlYWtBdFN0YXJ0ICYmIHRoaXMuZG9jLmxpbmVBdCh0aGlzLnBvcykuZnJvbSAhPSB0aGlzLnBvcztcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmNvbnRlbnRbdGhpcy5jb250ZW50Lmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gIWxhc3QuYnJlYWtBZnRlciAmJiAhKGxhc3QgaW5zdGFuY2VvZiBCbG9ja1dpZGdldFZpZXcgJiYgbGFzdC50eXBlID09IGV4cG9ydHMuQmxvY2tUeXBlLldpZGdldEJlZm9yZSk7XG4gICAgfVxuICAgIGdldExpbmUoKSB7XG4gICAgICAgIGlmICghdGhpcy5jdXJMaW5lKVxuICAgICAgICAgICAgdGhpcy5jb250ZW50LnB1c2godGhpcy5jdXJMaW5lID0gbmV3IExpbmVWaWV3KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VyTGluZTtcbiAgICB9XG4gICAgYWRkV2lkZ2V0KHZpZXcpIHtcbiAgICAgICAgdGhpcy5jdXJMaW5lID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb250ZW50LnB1c2godmlldyk7XG4gICAgfVxuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBvc0NvdmVyZWQoKSlcbiAgICAgICAgICAgIHRoaXMuZ2V0TGluZSgpO1xuICAgIH1cbiAgICB3cmFwTWFya3ModmlldywgYWN0aXZlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBhY3RpdmUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgICB2aWV3ID0gbmV3IE1hcmtWaWV3KGFjdGl2ZVtpXSwgW3ZpZXddLCB2aWV3Lmxlbmd0aCk7XG4gICAgICAgIHJldHVybiB2aWV3O1xuICAgIH1cbiAgICBidWlsZFRleHQobGVuZ3RoLCBhY3RpdmUsIG9wZW5TdGFydCkge1xuICAgICAgICB3aGlsZSAobGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudGV4dE9mZiA9PSB0aGlzLnRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgdmFsdWUsIGxpbmVCcmVhaywgZG9uZSB9ID0gdGhpcy5jdXJzb3IubmV4dCh0aGlzLnNraXApO1xuICAgICAgICAgICAgICAgIHRoaXMuc2tpcCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJhbiBvdXQgb2YgdGV4dCBjb250ZW50IHdoZW4gZHJhd2luZyBpbmxpbmUgdmlld3NcIik7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmVCcmVhaykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucG9zQ292ZXJlZCgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRMaW5lKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRlbnQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZW50W3RoaXMuY29udGVudC5sZW5ndGggLSAxXS5icmVha0FmdGVyID0gMTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5icmVha0F0U3RhcnQgPSAxO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1ckxpbmUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0T2ZmID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdGFrZSA9IE1hdGgubWluKHRoaXMudGV4dC5sZW5ndGggLSB0aGlzLnRleHRPZmYsIGxlbmd0aCwgNTEyIC8qIENodW5rICovKTtcbiAgICAgICAgICAgIHRoaXMuZ2V0TGluZSgpLmFwcGVuZCh0aGlzLndyYXBNYXJrcyhuZXcgVGV4dFZpZXcodGhpcy50ZXh0LnNsaWNlKHRoaXMudGV4dE9mZiwgdGhpcy50ZXh0T2ZmICsgdGFrZSkpLCBhY3RpdmUpLCBvcGVuU3RhcnQpO1xuICAgICAgICAgICAgdGhpcy50ZXh0T2ZmICs9IHRha2U7XG4gICAgICAgICAgICBsZW5ndGggLT0gdGFrZTtcbiAgICAgICAgICAgIG9wZW5TdGFydCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3Bhbihmcm9tLCB0bywgYWN0aXZlLCBvcGVuU3RhcnQpIHtcbiAgICAgICAgdGhpcy5idWlsZFRleHQodG8gLSBmcm9tLCBhY3RpdmUsIG9wZW5TdGFydCk7XG4gICAgICAgIHRoaXMucG9zID0gdG87XG4gICAgICAgIGlmICh0aGlzLm9wZW5TdGFydCA8IDApXG4gICAgICAgICAgICB0aGlzLm9wZW5TdGFydCA9IG9wZW5TdGFydDtcbiAgICB9XG4gICAgcG9pbnQoZnJvbSwgdG8sIGRlY28sIGFjdGl2ZSwgb3BlblN0YXJ0KSB7XG4gICAgICAgIGxldCBsZW4gPSB0byAtIGZyb207XG4gICAgICAgIGlmIChkZWNvIGluc3RhbmNlb2YgUG9pbnREZWNvcmF0aW9uKSB7XG4gICAgICAgICAgICBpZiAoZGVjby5ibG9jaykge1xuICAgICAgICAgICAgICAgIGxldCB7IHR5cGUgfSA9IGRlY287XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT0gZXhwb3J0cy5CbG9ja1R5cGUuV2lkZ2V0QWZ0ZXIgJiYgIXRoaXMucG9zQ292ZXJlZCgpKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldExpbmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFdpZGdldChuZXcgQmxvY2tXaWRnZXRWaWV3KGRlY28ud2lkZ2V0IHx8IG5ldyBOdWxsV2lkZ2V0KFwiZGl2XCIpLCBsZW4sIHR5cGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCB3aWRnZXQgPSB0aGlzLndyYXBNYXJrcyhXaWRnZXRWaWV3LmNyZWF0ZShkZWNvLndpZGdldCB8fCBuZXcgTnVsbFdpZGdldChcInNwYW5cIiksIGxlbiwgZGVjby5zdGFydFNpZGUpLCBhY3RpdmUpO1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0TGluZSgpLmFwcGVuZCh3aWRnZXQsIG9wZW5TdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kb2MubGluZUF0KHRoaXMucG9zKS5mcm9tID09IHRoaXMucG9zKSB7IC8vIExpbmUgZGVjb3JhdGlvblxuICAgICAgICAgICAgdGhpcy5nZXRMaW5lKCkuYWRkTGluZURlY28oZGVjbyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgLy8gQWR2YW5jZSB0aGUgaXRlcmF0b3IgcGFzdCB0aGUgcmVwbGFjZWQgY29udGVudFxuICAgICAgICAgICAgaWYgKHRoaXMudGV4dE9mZiArIGxlbiA8PSB0aGlzLnRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0T2ZmICs9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2tpcCArPSBsZW4gLSAodGhpcy50ZXh0Lmxlbmd0aCAtIHRoaXMudGV4dE9mZik7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0ID0gXCJcIjtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRPZmYgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wb3MgPSB0bztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcGVuU3RhcnQgPCAwKVxuICAgICAgICAgICAgdGhpcy5vcGVuU3RhcnQgPSBvcGVuU3RhcnQ7XG4gICAgfVxuICAgIHN0YXRpYyBidWlsZCh0ZXh0LCBmcm9tLCB0bywgZGVjb3JhdGlvbnMpIHtcbiAgICAgICAgbGV0IGJ1aWxkZXIgPSBuZXcgQ29udGVudEJ1aWxkZXIodGV4dCwgZnJvbSwgdG8pO1xuICAgICAgICBidWlsZGVyLm9wZW5FbmQgPSByYW5nZXNldC5SYW5nZVNldC5zcGFucyhkZWNvcmF0aW9ucywgZnJvbSwgdG8sIGJ1aWxkZXIpO1xuICAgICAgICBpZiAoYnVpbGRlci5vcGVuU3RhcnQgPCAwKVxuICAgICAgICAgICAgYnVpbGRlci5vcGVuU3RhcnQgPSBidWlsZGVyLm9wZW5FbmQ7XG4gICAgICAgIGJ1aWxkZXIuZmluaXNoKCk7XG4gICAgICAgIHJldHVybiBidWlsZGVyO1xuICAgIH1cbn1cbmNsYXNzIE51bGxXaWRnZXQgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgICBjb25zdHJ1Y3Rvcih0YWcpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7IHJldHVybiBvdGhlci50YWcgPT0gdGhpcy50YWc7IH1cbiAgICB0b0RPTSgpIHsgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy50YWcpOyB9XG4gICAgdXBkYXRlRE9NKGVsdCkgeyByZXR1cm4gZWx0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT0gdGhpcy50YWc7IH1cbn1cblxuY29uc3Qgbm9uZSA9IFtdO1xuY29uc3QgY2xpY2tBZGRzU2VsZWN0aW9uUmFuZ2UgPSBzdGF0ZS5GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGRyYWdNb3Zlc1NlbGVjdGlvbiQxID0gc3RhdGUuRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBtb3VzZVNlbGVjdGlvblN0eWxlID0gc3RhdGUuRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBleGNlcHRpb25TaW5rID0gc3RhdGUuRmFjZXQuZGVmaW5lKCk7XG5jb25zdCB1cGRhdGVMaXN0ZW5lciA9IHN0YXRlLkZhY2V0LmRlZmluZSgpO1xuY29uc3QgaW5wdXRIYW5kbGVyID0gc3RhdGUuRmFjZXQuZGVmaW5lKCk7XG4vKipcbkxvZyBvciByZXBvcnQgYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbiBpbiBjbGllbnQgY29kZS4gU2hvdWxkXG5wcm9iYWJseSBvbmx5IGJlIHVzZWQgYnkgZXh0ZW5zaW9uIGNvZGUgdGhhdCBhbGxvd3MgY2xpZW50IGNvZGUgdG9cbnByb3ZpZGUgZnVuY3Rpb25zLCBhbmQgY2FsbHMgdGhvc2UgZnVuY3Rpb25zIGluIGEgY29udGV4dCB3aGVyZSBhblxuZXhjZXB0aW9uIGNhbid0IGJlIHByb3BhZ2F0ZWQgdG8gY2FsbGluZyBjb2RlIGluIGEgcmVhc29uYWJsZSB3YXlcbihmb3IgZXhhbXBsZSB3aGVuIGluIGFuIGV2ZW50IGhhbmRsZXIpLlxuXG5FaXRoZXIgY2FsbHMgYSBoYW5kbGVyIHJlZ2lzdGVyZWQgd2l0aFxuW2BFZGl0b3JWaWV3LmV4Y2VwdGlvblNpbmtgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld15leGNlcHRpb25TaW5rKSxcbmB3aW5kb3cub25lcnJvcmAsIGlmIGRlZmluZWQsIG9yIGBjb25zb2xlLmVycm9yYCAoaW4gd2hpY2ggY2FzZVxuaXQnbGwgcGFzcyBgY29udGV4dGAsIHdoZW4gZ2l2ZW4sIGFzIGZpcnN0IGFyZ3VtZW50KS5cbiovXG5mdW5jdGlvbiBsb2dFeGNlcHRpb24oc3RhdGUsIGV4Y2VwdGlvbiwgY29udGV4dCkge1xuICAgIGxldCBoYW5kbGVyID0gc3RhdGUuZmFjZXQoZXhjZXB0aW9uU2luayk7XG4gICAgaWYgKGhhbmRsZXIubGVuZ3RoKVxuICAgICAgICBoYW5kbGVyWzBdKGV4Y2VwdGlvbik7XG4gICAgZWxzZSBpZiAod2luZG93Lm9uZXJyb3IpXG4gICAgICAgIHdpbmRvdy5vbmVycm9yKFN0cmluZyhleGNlcHRpb24pLCBjb250ZXh0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZXhjZXB0aW9uKTtcbiAgICBlbHNlIGlmIChjb250ZXh0KVxuICAgICAgICBjb25zb2xlLmVycm9yKGNvbnRleHQgKyBcIjpcIiwgZXhjZXB0aW9uKTtcbiAgICBlbHNlXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXhjZXB0aW9uKTtcbn1cbmNvbnN0IGVkaXRhYmxlID0gc3RhdGUuRmFjZXQuZGVmaW5lKHsgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5sZW5ndGggPyB2YWx1ZXNbMF0gOiB0cnVlIH0pO1xuLyoqXG5Vc2VkIHRvIFtkZWNsYXJlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuUGx1Z2luU3BlYy5wcm92aWRlKSB3aGljaFxuW2ZpZWxkc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LlBsdWdpblZhbHVlKSBhIFt2aWV3IHBsdWdpbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LlZpZXdQbHVnaW4pXG5wcm92aWRlcy5cbiovXG5jbGFzcyBQbHVnaW5GaWVsZFByb3ZpZGVyIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZmllbGQsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0KSB7XG4gICAgICAgIHRoaXMuZmllbGQgPSBmaWVsZDtcbiAgICAgICAgdGhpcy5nZXQgPSBnZXQ7XG4gICAgfVxufVxuLyoqXG5QbHVnaW4gZmllbGRzIGFyZSBhIG1lY2hhbmlzbSBmb3IgYWxsb3dpbmcgcGx1Z2lucyB0byBwcm92aWRlXG52YWx1ZXMgdGhhdCBjYW4gYmUgcmV0cmlldmVkIHRocm91Z2ggdGhlXG5bYHBsdWdpbkZpZWxkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcucGx1Z2luRmllbGQpIHZpZXcgbWV0aG9kLlxuKi9cbmNsYXNzIFBsdWdpbkZpZWxkIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBbcHJvdmlkZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5QbHVnaW5GaWVsZFByb3ZpZGVyKSBmb3IgdGhpcyBmaWVsZCxcbiAgICB0byB1c2Ugd2l0aCBhIHBsdWdpbidzIFtwcm92aWRlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuUGx1Z2luU3BlYy5wcm92aWRlKVxuICAgIG9wdGlvbi5cbiAgICAqL1xuICAgIGZyb20oZ2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUGx1Z2luRmllbGRQcm92aWRlcih0aGlzLCBnZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBuZXcgcGx1Z2luIGZpZWxkLlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZSgpIHsgcmV0dXJuIG5ldyBQbHVnaW5GaWVsZCgpOyB9XG59XG4vKipcblRoaXMgZmllbGQgY2FuIGJlIHVzZWQgYnkgcGx1Z2lucyB0byBwcm92aWRlXG5bZGVjb3JhdGlvbnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5EZWNvcmF0aW9uKS5cblxuKipOb3RlKio6IEZvciByZWFzb25zIG9mIGRhdGEgZmxvdyAocGx1Z2lucyBhcmUgb25seSB1cGRhdGVkXG5hZnRlciB0aGUgdmlld3BvcnQgaXMgY29tcHV0ZWQpLCBkZWNvcmF0aW9ucyBwcm9kdWNlZCBieSBwbHVnaW5zXG5hcmUgX25vdF8gdGFrZW4gaW50byBhY2NvdW50IHdoZW4gcHJlZGljdGluZyB0aGUgdmVydGljYWwgbGF5b3V0XG5zdHJ1Y3R1cmUgb2YgdGhlIGVkaXRvci4gVGh1cywgdGhpbmdzIGxpa2UgbGFyZ2Ugd2lkZ2V0cyBvciBiaWdcbnJlcGxhY2VtZW50cyAoaS5lLiBjb2RlIGZvbGRpbmcpIHNob3VsZCBiZSBwcm92aWRlZCB0aHJvdWdoIHRoZVxuc3RhdGUtbGV2ZWwgW2BkZWNvcmF0aW9uc2AgZmFjZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XmRlY29yYXRpb25zKSxcbm5vdCB0aGlzIHBsdWdpbiBmaWVsZC4gU3BlY2lmaWNhbGx5LCByZXBsYWNpbmcgZGVjb3JhdGlvbnMgdGhhdFxuY3Jvc3MgbGluZSBib3VuZGFyaWVzIHdpbGwgYnJlYWsgaWYgcHJvdmlkZWQgdGhyb3VnaCBhIHBsdWdpbi5cbiovXG5QbHVnaW5GaWVsZC5kZWNvcmF0aW9ucyA9IFBsdWdpbkZpZWxkLmRlZmluZSgpO1xuLyoqXG5QbHVnaW5zIGNhbiBwcm92aWRlIGFkZGl0aW9uYWwgc2Nyb2xsIG1hcmdpbnMgKHNwYWNlIGFyb3VuZCB0aGVcbnNpZGVzIG9mIHRoZSBzY3JvbGxpbmcgZWxlbWVudCB0aGF0IHNob3VsZCBiZSBjb25zaWRlcmVkXG5pbnZpc2libGUpIHRocm91Z2ggdGhpcyBmaWVsZC4gVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW4gdGhlXG5wbHVnaW4gaW50cm9kdWNlcyBlbGVtZW50cyB0aGF0IGNvdmVyIHBhcnQgb2YgdGhhdCBlbGVtZW50IChmb3JcbmV4YW1wbGUgYSBob3Jpem9udGFsbHkgZml4ZWQgZ3V0dGVyKS5cbiovXG5QbHVnaW5GaWVsZC5zY3JvbGxNYXJnaW5zID0gUGx1Z2luRmllbGQuZGVmaW5lKCk7XG5sZXQgbmV4dFBsdWdpbklEID0gMDtcbmNvbnN0IHZpZXdQbHVnaW4gPSBzdGF0ZS5GYWNldC5kZWZpbmUoKTtcbi8qKlxuVmlldyBwbHVnaW5zIGFzc29jaWF0ZSBzdGF0ZWZ1bCB2YWx1ZXMgd2l0aCBhIHZpZXcuIFRoZXkgY2FuXG5pbmZsdWVuY2UgdGhlIHdheSB0aGUgY29udGVudCBpcyBkcmF3biwgYW5kIGFyZSBub3RpZmllZCBvZiB0aGluZ3NcbnRoYXQgaGFwcGVuIGluIHRoZSB2aWV3LlxuKi9cbmNsYXNzIFZpZXdQbHVnaW4ge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgaWQsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY3JlYXRlLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGZpZWxkcykge1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMuY3JlYXRlID0gY3JlYXRlO1xuICAgICAgICB0aGlzLmZpZWxkcyA9IGZpZWxkcztcbiAgICAgICAgdGhpcy5leHRlbnNpb24gPSB2aWV3UGx1Z2luLm9mKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBwbHVnaW4gZnJvbSBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyB0aGVcbiAgICBwbHVnaW4ncyB2YWx1ZSwgZ2l2ZW4gYW4gZWRpdG9yIHZpZXcuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKGNyZWF0ZSwgc3BlYykge1xuICAgICAgICBsZXQgeyBldmVudEhhbmRsZXJzLCBwcm92aWRlLCBkZWNvcmF0aW9ucyB9ID0gc3BlYyB8fCB7fTtcbiAgICAgICAgbGV0IGZpZWxkcyA9IFtdO1xuICAgICAgICBpZiAocHJvdmlkZSlcbiAgICAgICAgICAgIGZvciAobGV0IHByb3ZpZGVyIG9mIEFycmF5LmlzQXJyYXkocHJvdmlkZSkgPyBwcm92aWRlIDogW3Byb3ZpZGVdKVxuICAgICAgICAgICAgICAgIGZpZWxkcy5wdXNoKHByb3ZpZGVyKTtcbiAgICAgICAgaWYgKGV2ZW50SGFuZGxlcnMpXG4gICAgICAgICAgICBmaWVsZHMucHVzaChkb21FdmVudEhhbmRsZXJzLmZyb20oKHZhbHVlKSA9PiAoeyBwbHVnaW46IHZhbHVlLCBoYW5kbGVyczogZXZlbnRIYW5kbGVycyB9KSkpO1xuICAgICAgICBpZiAoZGVjb3JhdGlvbnMpXG4gICAgICAgICAgICBmaWVsZHMucHVzaChQbHVnaW5GaWVsZC5kZWNvcmF0aW9ucy5mcm9tKGRlY29yYXRpb25zKSk7XG4gICAgICAgIHJldHVybiBuZXcgVmlld1BsdWdpbihuZXh0UGx1Z2luSUQrKywgY3JlYXRlLCBmaWVsZHMpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBwbHVnaW4gZm9yIGEgY2xhc3Mgd2hvc2UgY29uc3RydWN0b3IgdGFrZXMgYSBzaW5nbGVcbiAgICBlZGl0b3IgdmlldyBhcyBhcmd1bWVudC5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tQ2xhc3MoY2xzLCBzcGVjKSB7XG4gICAgICAgIHJldHVybiBWaWV3UGx1Z2luLmRlZmluZSh2aWV3ID0+IG5ldyBjbHModmlldyksIHNwZWMpO1xuICAgIH1cbn1cbmNvbnN0IGRvbUV2ZW50SGFuZGxlcnMgPSBQbHVnaW5GaWVsZC5kZWZpbmUoKTtcbmNsYXNzIFBsdWdpbkluc3RhbmNlIHtcbiAgICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgICAgIC8vIFdoZW4gc3RhcnRpbmcgYW4gdXBkYXRlLCBhbGwgcGx1Z2lucyBoYXZlIHRoaXMgZmllbGQgc2V0IHRvIHRoZVxuICAgICAgICAvLyB1cGRhdGUgb2JqZWN0LCBpbmRpY2F0aW5nIHRoZXkgbmVlZCB0byBiZSB1cGRhdGVkLiBXaGVuIGZpbmlzaGVkXG4gICAgICAgIC8vIHVwZGF0aW5nLCBpdCBpcyBzZXQgdG8gYGZhbHNlYC4gUmV0cmlldmluZyBhIHBsdWdpbiB0aGF0IG5lZWRzIHRvXG4gICAgICAgIC8vIGJlIHVwZGF0ZWQgd2l0aCBgdmlldy5wbHVnaW5gIGZvcmNlcyBhbiBlYWdlciB1cGRhdGUuXG4gICAgICAgIHRoaXMubXVzdFVwZGF0ZSA9IG51bGw7XG4gICAgICAgIC8vIFRoaXMgaXMgbnVsbCB3aGVuIHRoZSBwbHVnaW4gaXMgaW5pdGlhbGx5IGNyZWF0ZWQsIGJ1dFxuICAgICAgICAvLyBpbml0aWFsaXplZCBvbiB0aGUgZmlyc3QgdXBkYXRlLlxuICAgICAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICB9XG4gICAgdGFrZUZpZWxkKHR5cGUsIHRhcmdldCkge1xuICAgICAgICBmb3IgKGxldCB7IGZpZWxkLCBnZXQgfSBvZiB0aGlzLnNwZWMuZmllbGRzKVxuICAgICAgICAgICAgaWYgKGZpZWxkID09IHR5cGUpXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2goZ2V0KHRoaXMudmFsdWUpKTtcbiAgICB9XG4gICAgdXBkYXRlKHZpZXcpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnNwZWMuY3JlYXRlKHZpZXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odmlldy5zdGF0ZSwgZSwgXCJDb2RlTWlycm9yIHBsdWdpbiBjcmFzaGVkXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBQbHVnaW5JbnN0YW5jZS5kdW1teTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm11c3RVcGRhdGUpIHtcbiAgICAgICAgICAgIGxldCB1cGRhdGUgPSB0aGlzLm11c3RVcGRhdGU7XG4gICAgICAgICAgICB0aGlzLm11c3RVcGRhdGUgPSBudWxsO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnZhbHVlLnVwZGF0ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZS51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgbG9nRXhjZXB0aW9uKHVwZGF0ZS5zdGF0ZSwgZSwgXCJDb2RlTWlycm9yIHBsdWdpbiBjcmFzaGVkXCIpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlLmRlc3Ryb3kpXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoXykgeyB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdWdpbkluc3RhbmNlLmR1bW15O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkZXN0cm95KHZpZXcpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoKF9hID0gdGhpcy52YWx1ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlc3Ryb3kpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZS5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih2aWV3LnN0YXRlLCBlLCBcIkNvZGVNaXJyb3IgcGx1Z2luIGNyYXNoZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5QbHVnaW5JbnN0YW5jZS5kdW1teSA9IG5ldyBQbHVnaW5JbnN0YW5jZShWaWV3UGx1Z2luLmRlZmluZSgoKSA9PiAoe30pKSk7XG5jb25zdCBlZGl0b3JBdHRyaWJ1dGVzID0gc3RhdGUuRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLnJlZHVjZSgoYSwgYikgPT4gY29tYmluZUF0dHJzKGIsIGEpLCB7fSlcbn0pO1xuY29uc3QgY29udGVudEF0dHJpYnV0ZXMgPSBzdGF0ZS5GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMucmVkdWNlKChhLCBiKSA9PiBjb21iaW5lQXR0cnMoYiwgYSksIHt9KVxufSk7XG4vLyBQcm92aWRlIGRlY29yYXRpb25zXG5jb25zdCBkZWNvcmF0aW9ucyA9IHN0YXRlLkZhY2V0LmRlZmluZSgpO1xuY29uc3Qgc3R5bGVNb2R1bGUgPSBzdGF0ZS5GYWNldC5kZWZpbmUoKTtcbmNsYXNzIENoYW5nZWRSYW5nZSB7XG4gICAgY29uc3RydWN0b3IoZnJvbUEsIHRvQSwgZnJvbUIsIHRvQikge1xuICAgICAgICB0aGlzLmZyb21BID0gZnJvbUE7XG4gICAgICAgIHRoaXMudG9BID0gdG9BO1xuICAgICAgICB0aGlzLmZyb21CID0gZnJvbUI7XG4gICAgICAgIHRoaXMudG9CID0gdG9CO1xuICAgIH1cbiAgICBqb2luKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlZFJhbmdlKE1hdGgubWluKHRoaXMuZnJvbUEsIG90aGVyLmZyb21BKSwgTWF0aC5tYXgodGhpcy50b0EsIG90aGVyLnRvQSksIE1hdGgubWluKHRoaXMuZnJvbUIsIG90aGVyLmZyb21CKSwgTWF0aC5tYXgodGhpcy50b0IsIG90aGVyLnRvQikpO1xuICAgIH1cbiAgICBhZGRUb1NldChzZXQpIHtcbiAgICAgICAgbGV0IGkgPSBzZXQubGVuZ3RoLCBtZSA9IHRoaXM7XG4gICAgICAgIGZvciAoOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgcmFuZ2UgPSBzZXRbaSAtIDFdO1xuICAgICAgICAgICAgaWYgKHJhbmdlLmZyb21BID4gbWUudG9BKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHJhbmdlLnRvQSA8IG1lLmZyb21BKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbWUgPSBtZS5qb2luKHJhbmdlKTtcbiAgICAgICAgICAgIHNldC5zcGxpY2UoaSAtIDEsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHNldC5zcGxpY2UoaSwgMCwgbWUpO1xuICAgICAgICByZXR1cm4gc2V0O1xuICAgIH1cbiAgICBzdGF0aWMgZXh0ZW5kV2l0aFJhbmdlcyhkaWZmLCByYW5nZXMpIHtcbiAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiBkaWZmO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGRJID0gMCwgckkgPSAwLCBwb3NBID0gMCwgcG9zQiA9IDA7OyBkSSsrKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGRJID09IGRpZmYubGVuZ3RoID8gbnVsbCA6IGRpZmZbZEldLCBvZmYgPSBwb3NBIC0gcG9zQjtcbiAgICAgICAgICAgIGxldCBlbmQgPSBuZXh0ID8gbmV4dC5mcm9tQiA6IDFlOTtcbiAgICAgICAgICAgIHdoaWxlIChySSA8IHJhbmdlcy5sZW5ndGggJiYgcmFuZ2VzW3JJXSA8IGVuZCkge1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gcmFuZ2VzW3JJXSwgdG8gPSByYW5nZXNbckkgKyAxXTtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbUIgPSBNYXRoLm1heChwb3NCLCBmcm9tKSwgdG9CID0gTWF0aC5taW4oZW5kLCB0byk7XG4gICAgICAgICAgICAgICAgaWYgKGZyb21CIDw9IHRvQilcbiAgICAgICAgICAgICAgICAgICAgbmV3IENoYW5nZWRSYW5nZShmcm9tQiArIG9mZiwgdG9CICsgb2ZmLCBmcm9tQiwgdG9CKS5hZGRUb1NldChyZXN1bHQpO1xuICAgICAgICAgICAgICAgIGlmICh0byA+IGVuZClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBySSArPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFuZXh0KVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICBuZXcgQ2hhbmdlZFJhbmdlKG5leHQuZnJvbUEsIG5leHQudG9BLCBuZXh0LmZyb21CLCBuZXh0LnRvQikuYWRkVG9TZXQocmVzdWx0KTtcbiAgICAgICAgICAgIHBvc0EgPSBuZXh0LnRvQTtcbiAgICAgICAgICAgIHBvc0IgPSBuZXh0LnRvQjtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuVmlldyBbcGx1Z2luc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LlZpZXdQbHVnaW4pIGFyZSBnaXZlbiBpbnN0YW5jZXMgb2YgdGhpc1xuY2xhc3MsIHdoaWNoIGRlc2NyaWJlIHdoYXQgaGFwcGVuZWQsIHdoZW5ldmVyIHRoZSB2aWV3IGlzIHVwZGF0ZWQuXG4qL1xuY2xhc3MgVmlld1VwZGF0ZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgZWRpdG9yIHZpZXcgdGhhdCB0aGUgdXBkYXRlIGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAgICAqL1xuICAgIHZpZXcsIFxuICAgIC8qKlxuICAgIFRoZSBuZXcgZWRpdG9yIHN0YXRlLlxuICAgICovXG4gICAgc3RhdGUkMSwgXG4gICAgLyoqXG4gICAgVGhlIHRyYW5zYWN0aW9ucyBpbnZvbHZlZCBpbiB0aGUgdXBkYXRlLiBNYXkgYmUgZW1wdHkuXG4gICAgKi9cbiAgICB0cmFuc2FjdGlvbnMgPSBub25lKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZSQxO1xuICAgICAgICB0aGlzLnRyYW5zYWN0aW9ucyA9IHRyYW5zYWN0aW9ucztcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmZsYWdzID0gMDtcbiAgICAgICAgdGhpcy5zdGFydFN0YXRlID0gdmlldy5zdGF0ZTtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gc3RhdGUuQ2hhbmdlU2V0LmVtcHR5KHRoaXMuc3RhcnRTdGF0ZS5kb2MubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgdHIgb2YgdHJhbnNhY3Rpb25zKVxuICAgICAgICAgICAgdGhpcy5jaGFuZ2VzID0gdGhpcy5jaGFuZ2VzLmNvbXBvc2UodHIuY2hhbmdlcyk7XG4gICAgICAgIGxldCBjaGFuZ2VkUmFuZ2VzID0gW107XG4gICAgICAgIHRoaXMuY2hhbmdlcy5pdGVyQ2hhbmdlZFJhbmdlcygoZnJvbUEsIHRvQSwgZnJvbUIsIHRvQikgPT4gY2hhbmdlZFJhbmdlcy5wdXNoKG5ldyBDaGFuZ2VkUmFuZ2UoZnJvbUEsIHRvQSwgZnJvbUIsIHRvQikpKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VkUmFuZ2VzID0gY2hhbmdlZFJhbmdlcztcbiAgICAgICAgbGV0IGZvY3VzID0gdmlldy5oYXNGb2N1cztcbiAgICAgICAgaWYgKGZvY3VzICE9IHZpZXcuaW5wdXRTdGF0ZS5ub3RpZmllZEZvY3VzZWQpIHtcbiAgICAgICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5ub3RpZmllZEZvY3VzZWQgPSBmb2N1cztcbiAgICAgICAgICAgIHRoaXMuZmxhZ3MgfD0gMSAvKiBGb2N1cyAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kb2NDaGFuZ2VkKVxuICAgICAgICAgICAgdGhpcy5mbGFncyB8PSAyIC8qIEhlaWdodCAqLztcbiAgICB9XG4gICAgLyoqXG4gICAgVGVsbHMgeW91IHdoZXRoZXIgdGhlIHZpZXdwb3J0IGNoYW5nZWQgaW4gdGhpcyB1cGRhdGUuXG4gICAgKi9cbiAgICBnZXQgdmlld3BvcnRDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiA0IC8qIFZpZXdwb3J0ICovKSA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIHRoZSBsaW5lIGhlaWdodCBpbiB0aGUgZWRpdG9yIGNoYW5nZWQgaW4gdGhpcyB1cGRhdGUuXG4gICAgKi9cbiAgICBnZXQgaGVpZ2h0Q2hhbmdlZCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmZsYWdzICYgMiAvKiBIZWlnaHQgKi8pID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0cnVlIHdoZW4gdGhlIGRvY3VtZW50IGNoYW5nZWQgb3IgdGhlIHNpemUgb2YgdGhlIGVkaXRvclxuICAgIG9yIHRoZSBsaW5lcyBvciBjaGFyYWN0ZXJzIHdpdGhpbiBpdCBoYXMgY2hhbmdlZC5cbiAgICAqL1xuICAgIGdldCBnZW9tZXRyeUNoYW5nZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY0NoYW5nZWQgfHwgKHRoaXMuZmxhZ3MgJiAoMTYgLyogR2VvbWV0cnkgKi8gfCAyIC8qIEhlaWdodCAqLykpID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgdXBkYXRlIGluZGljYXRlcyBhIGZvY3VzIGNoYW5nZS5cbiAgICAqL1xuICAgIGdldCBmb2N1c0NoYW5nZWQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIDEgLyogRm9jdXMgKi8pID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgV2hldGhlciB0aGUgZG9jdW1lbnQgY2hhbmdlZCBpbiB0aGlzIHVwZGF0ZS5cbiAgICAqL1xuICAgIGdldCBkb2NDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2FjdGlvbnMuc29tZSh0ciA9PiB0ci5kb2NDaGFuZ2VkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgV2hldGhlciB0aGUgc2VsZWN0aW9uIHdhcyBleHBsaWNpdGx5IHNldCBpbiB0aGlzIHVwZGF0ZS5cbiAgICAqL1xuICAgIGdldCBzZWxlY3Rpb25TZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9ucy5zb21lKHRyID0+IHRyLnNlbGVjdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGVtcHR5KCkgeyByZXR1cm4gdGhpcy5mbGFncyA9PSAwICYmIHRoaXMudHJhbnNhY3Rpb25zLmxlbmd0aCA9PSAwOyB9XG59XG5cbmNsYXNzIERvY1ZpZXcgZXh0ZW5kcyBDb250ZW50VmlldyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uRGVjbyA9IERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IFtdO1xuICAgICAgICAvLyBUcmFjayBhIG1pbmltdW0gd2lkdGggZm9yIHRoZSBlZGl0b3IuIFdoZW4gbWVhc3VyaW5nIHNpemVzIGluXG4gICAgICAgIC8vIGNoZWNrTGF5b3V0LCB0aGlzIGlzIHVwZGF0ZWQgdG8gcG9pbnQgYXQgdGhlIHdpZHRoIG9mIGEgZ2l2ZW5cbiAgICAgICAgLy8gZWxlbWVudCBhbmQgaXRzIGV4dGVudCBpbiB0aGUgZG9jdW1lbnQuIFdoZW4gYSBjaGFuZ2UgaGFwcGVucyBpblxuICAgICAgICAvLyB0aGF0IHJhbmdlLCB0aGVzZSBhcmUgcmVzZXQuIFRoYXQgd2F5LCBvbmNlIHdlJ3ZlIHNlZW4gYVxuICAgICAgICAvLyBsaW5lL2VsZW1lbnQgb2YgYSBnaXZlbiBsZW5ndGgsIHdlIGtlZXAgdGhlIGVkaXRvciB3aWRlIGVub3VnaCB0b1xuICAgICAgICAvLyBmaXQgYXQgbGVhc3QgdGhhdCBlbGVtZW50LCB1bnRpbCBpdCBpcyBjaGFuZ2VkLCBhdCB3aGljaCBwb2ludCB3ZVxuICAgICAgICAvLyBmb3JnZXQgaXQgYWdhaW4uXG4gICAgICAgIHRoaXMubWluV2lkdGggPSAwO1xuICAgICAgICB0aGlzLm1pbldpZHRoRnJvbSA9IDA7XG4gICAgICAgIHRoaXMubWluV2lkdGhUbyA9IDA7XG4gICAgICAgIC8vIFRyYWNrIHdoZXRoZXIgdGhlIERPTSBzZWxlY3Rpb24gd2FzIHNldCBpbiBhIGxvc3N5IHdheSwgc28gdGhhdFxuICAgICAgICAvLyB3ZSBkb24ndCBtZXNzIGl0IHVwIHdoZW4gcmVhZGluZyBpdCBiYWNrIGl0XG4gICAgICAgIHRoaXMuaW1wcmVjaXNlQW5jaG9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbXByZWNpc2VIZWFkID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZXRET00odmlldy5jb250ZW50RE9NKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtuZXcgTGluZVZpZXddO1xuICAgICAgICB0aGlzLmNoaWxkcmVuWzBdLnNldFBhcmVudCh0aGlzKTtcbiAgICAgICAgdGhpcy51cGRhdGVJbm5lcihbbmV3IENoYW5nZWRSYW5nZSgwLCAwLCAwLCB2aWV3LnN0YXRlLmRvYy5sZW5ndGgpXSwgdGhpcy51cGRhdGVEZWNvKCksIDApO1xuICAgIH1cbiAgICBnZXQgcm9vdCgpIHsgcmV0dXJuIHRoaXMudmlldy5yb290OyB9XG4gICAgZ2V0IGVkaXRvclZpZXcoKSB7IHJldHVybiB0aGlzLnZpZXc7IH1cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy52aWV3LnN0YXRlLmRvYy5sZW5ndGg7IH1cbiAgICAvLyBVcGRhdGUgdGhlIGRvY3VtZW50IHZpZXcgdG8gYSBnaXZlbiBzdGF0ZS4gc2Nyb2xsSW50b1ZpZXcgY2FuIGJlXG4gICAgLy8gdXNlZCBhcyBhIGhpbnQgdG8gY29tcHV0ZSBhIG5ldyB2aWV3cG9ydCB0aGF0IGluY2x1ZGVzIHRoYXRcbiAgICAvLyBwb3NpdGlvbiwgaWYgd2Uga25vdyB0aGUgZWRpdG9yIGlzIGdvaW5nIHRvIHNjcm9sbCB0aGF0IHBvc2l0aW9uXG4gICAgLy8gaW50byB2aWV3LlxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IGNoYW5nZWRSYW5nZXMgPSB1cGRhdGUuY2hhbmdlZFJhbmdlcztcbiAgICAgICAgaWYgKHRoaXMubWluV2lkdGggPiAwICYmIGNoYW5nZWRSYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIWNoYW5nZWRSYW5nZXMuZXZlcnkoKHsgZnJvbUEsIHRvQSB9KSA9PiB0b0EgPCB0aGlzLm1pbldpZHRoRnJvbSB8fCBmcm9tQSA+IHRoaXMubWluV2lkdGhUbykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1pbldpZHRoID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubWluV2lkdGhGcm9tID0gdXBkYXRlLmNoYW5nZXMubWFwUG9zKHRoaXMubWluV2lkdGhGcm9tLCAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1pbldpZHRoVG8gPSB1cGRhdGUuY2hhbmdlcy5tYXBQb3ModGhpcy5taW5XaWR0aFRvLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nIDwgMClcbiAgICAgICAgICAgIHRoaXMuY29tcG9zaXRpb25EZWNvID0gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICBlbHNlIGlmICh1cGRhdGUudHJhbnNhY3Rpb25zLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMuY29tcG9zaXRpb25EZWNvID0gY29tcHV0ZUNvbXBvc2l0aW9uRGVjbyh0aGlzLnZpZXcsIHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICAgICAgLy8gV2hlbiB0aGUgRE9NIG5vZGVzIGFyb3VuZCB0aGUgc2VsZWN0aW9uIGFyZSBtb3ZlZCB0byBhbm90aGVyXG4gICAgICAgIC8vIHBhcmVudCwgQ2hyb21lIHNvbWV0aW1lcyByZXBvcnRzIGEgZGlmZmVyZW50IHNlbGVjdGlvbiB0aHJvdWdoXG4gICAgICAgIC8vIGdldFNlbGVjdGlvbiB0aGFuIHRoZSBvbmUgdGhhdCBpdCBhY3R1YWxseSBzaG93cyB0byB0aGUgdXNlci5cbiAgICAgICAgLy8gVGhpcyBmb3JjZXMgYSBzZWxlY3Rpb24gdXBkYXRlIHdoZW4gbGluZXMgYXJlIGpvaW5lZCB0byB3b3JrXG4gICAgICAgIC8vIGFyb3VuZCB0aGF0LiBJc3N1ZSAjNTRcbiAgICAgICAgbGV0IGZvcmNlU2VsZWN0aW9uID0gKGJyb3dzZXIuaWUgfHwgYnJvd3Nlci5jaHJvbWUpICYmICF0aGlzLmNvbXBvc2l0aW9uRGVjby5zaXplICYmIHVwZGF0ZSAmJlxuICAgICAgICAgICAgdXBkYXRlLnN0YXRlLmRvYy5saW5lcyAhPSB1cGRhdGUuc3RhcnRTdGF0ZS5kb2MubGluZXM7XG4gICAgICAgIGxldCBwcmV2RGVjbyA9IHRoaXMuZGVjb3JhdGlvbnMsIGRlY28gPSB0aGlzLnVwZGF0ZURlY28oKTtcbiAgICAgICAgbGV0IGRlY29EaWZmID0gZmluZENoYW5nZWREZWNvKHByZXZEZWNvLCBkZWNvLCB1cGRhdGUuY2hhbmdlcyk7XG4gICAgICAgIGNoYW5nZWRSYW5nZXMgPSBDaGFuZ2VkUmFuZ2UuZXh0ZW5kV2l0aFJhbmdlcyhjaGFuZ2VkUmFuZ2VzLCBkZWNvRGlmZik7XG4gICAgICAgIGxldCBwb2ludGVyU2VsID0gdXBkYXRlLnRyYW5zYWN0aW9ucy5zb21lKHRyID0+IHRyLmFubm90YXRpb24oc3RhdGUuVHJhbnNhY3Rpb24udXNlckV2ZW50KSA9PSBcInBvaW50ZXJzZWxlY3Rpb25cIik7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5ID09IDAgLyogTm90ICovICYmIGNoYW5nZWRSYW5nZXMubGVuZ3RoID09IDAgJiZcbiAgICAgICAgICAgICEodXBkYXRlLmZsYWdzICYgKDQgLyogVmlld3BvcnQgKi8gfCA4IC8qIExpbmVHYXBzICovKSkgJiZcbiAgICAgICAgICAgIHVwZGF0ZS5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5mcm9tID49IHRoaXMudmlldy52aWV3cG9ydC5mcm9tICYmXG4gICAgICAgICAgICB1cGRhdGUuc3RhdGUuc2VsZWN0aW9uLm1haW4udG8gPD0gdGhpcy52aWV3LnZpZXdwb3J0LnRvKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGlvbihmb3JjZVNlbGVjdGlvbiwgcG9pbnRlclNlbCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUlubmVyKGNoYW5nZWRSYW5nZXMsIGRlY28sIHVwZGF0ZS5zdGFydFN0YXRlLmRvYy5sZW5ndGgsIGZvcmNlU2VsZWN0aW9uLCBwb2ludGVyU2VsKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFVzZWQgYm90aCBieSB1cGRhdGUgYW5kIGNoZWNrTGF5b3V0IGRvIHBlcmZvcm0gdGhlIGFjdHVhbCBET01cbiAgICAvLyB1cGRhdGVcbiAgICB1cGRhdGVJbm5lcihjaGFuZ2VzLCBkZWNvLCBvbGRMZW5ndGgsIGZvcmNlU2VsZWN0aW9uID0gZmFsc2UsIHBvaW50ZXJTZWwgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZUNoaWxkcmVuKGNoYW5nZXMsIGRlY28sIG9sZExlbmd0aCk7XG4gICAgICAgIHRoaXMudmlldy5vYnNlcnZlci5pZ25vcmUoKCkgPT4ge1xuICAgICAgICAgICAgLy8gTG9jayB0aGUgaGVpZ2h0IGR1cmluZyByZWRyYXdpbmcsIHNpbmNlIENocm9tZSBzb21ldGltZXNcbiAgICAgICAgICAgIC8vIG1lc3NlcyB3aXRoIHRoZSBzY3JvbGwgcG9zaXRpb24gZHVyaW5nIERPTSBtdXRhdGlvbiAodGhvdWdoXG4gICAgICAgICAgICAvLyBubyByZWxheW91dCBpcyB0cmlnZ2VyZWQgYW5kIEkgY2Fubm90IGltYWdpbmUgaG93IGl0IGNhblxuICAgICAgICAgICAgLy8gcmVjb21wdXRlIHRoZSBzY3JvbGwgcG9zaXRpb24gd2l0aG91dCBhIGxheW91dClcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLmhlaWdodCA9IHRoaXMudmlldy52aWV3U3RhdGUuZG9tSGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUubWluV2lkdGggPSB0aGlzLm1pbldpZHRoID8gdGhpcy5taW5XaWR0aCArIFwicHhcIiA6IFwiXCI7XG4gICAgICAgICAgICAvLyBDaHJvbWUgd2lsbCBzb21ldGltZXMsIHdoZW4gRE9NIG11dGF0aW9ucyBvY2N1ciBkaXJlY3RseVxuICAgICAgICAgICAgLy8gYXJvdW5kIHRoZSBzZWxlY3Rpb24sIGdldCBjb25mdXNlZCBhbmQgcmVwb3J0IGEgZGlmZmVyZW50XG4gICAgICAgICAgICAvLyBzZWxlY3Rpb24gZnJvbSB0aGUgb25lIGl0IGRpc3BsYXlzIChpc3N1ZSAjMjE4KS4gVGhpcyB0cmllc1xuICAgICAgICAgICAgLy8gdG8gZGV0ZWN0IHRoYXQgc2l0dWF0aW9uLlxuICAgICAgICAgICAgbGV0IHRyYWNrID0gYnJvd3Nlci5jaHJvbWUgPyB7IG5vZGU6IGdldFNlbGVjdGlvbih0aGlzLnZpZXcucm9vdCkuZm9jdXNOb2RlLCB3cml0dGVuOiBmYWxzZSB9IDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5zeW5jKHRyYWNrKTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSAwIC8qIE5vdCAqLztcbiAgICAgICAgICAgIGlmICh0cmFjayA9PT0gbnVsbCB8fCB0cmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHJhY2sud3JpdHRlbilcbiAgICAgICAgICAgICAgICBmb3JjZVNlbGVjdGlvbiA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGlvbihmb3JjZVNlbGVjdGlvbiwgcG9pbnRlclNlbCk7XG4gICAgICAgICAgICB0aGlzLmRvbS5zdHlsZS5oZWlnaHQgPSBcIlwiO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXBkYXRlQ2hpbGRyZW4oY2hhbmdlcywgZGVjbywgb2xkTGVuZ3RoKSB7XG4gICAgICAgIGxldCBjdXJzb3IgPSB0aGlzLmNoaWxkQ3Vyc29yKG9sZExlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSBjaGFuZ2VzLmxlbmd0aCAtIDE7OyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gaSA+PSAwID8gY2hhbmdlc1tpXSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoIW5leHQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsZXQgeyBmcm9tQSwgdG9BLCBmcm9tQiwgdG9CIH0gPSBuZXh0O1xuICAgICAgICAgICAgbGV0IHsgY29udGVudCwgYnJlYWtBdFN0YXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQgfSA9IENvbnRlbnRCdWlsZGVyLmJ1aWxkKHRoaXMudmlldy5zdGF0ZS5kb2MsIGZyb21CLCB0b0IsIGRlY28pO1xuICAgICAgICAgICAgbGV0IHsgaTogdG9JLCBvZmY6IHRvT2ZmIH0gPSBjdXJzb3IuZmluZFBvcyh0b0EsIDEpO1xuICAgICAgICAgICAgbGV0IHsgaTogZnJvbUksIG9mZjogZnJvbU9mZiB9ID0gY3Vyc29yLmZpbmRQb3MoZnJvbUEsIC0xKTtcbiAgICAgICAgICAgIHRoaXMucmVwbGFjZVJhbmdlKGZyb21JLCBmcm9tT2ZmLCB0b0ksIHRvT2ZmLCBjb250ZW50LCBicmVha0F0U3RhcnQsIG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVwbGFjZVJhbmdlKGZyb21JLCBmcm9tT2ZmLCB0b0ksIHRvT2ZmLCBjb250ZW50LCBicmVha0F0U3RhcnQsIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgICAgICBsZXQgYmVmb3JlID0gdGhpcy5jaGlsZHJlbltmcm9tSV0sIGxhc3QgPSBjb250ZW50Lmxlbmd0aCA/IGNvbnRlbnRbY29udGVudC5sZW5ndGggLSAxXSA6IG51bGw7XG4gICAgICAgIGxldCBicmVha0F0RW5kID0gbGFzdCA/IGxhc3QuYnJlYWtBZnRlciA6IGJyZWFrQXRTdGFydDtcbiAgICAgICAgLy8gQ2hhbmdlIHdpdGhpbiBhIHNpbmdsZSBsaW5lXG4gICAgICAgIGlmIChmcm9tSSA9PSB0b0kgJiYgIWJyZWFrQXRTdGFydCAmJiAhYnJlYWtBdEVuZCAmJiBjb250ZW50Lmxlbmd0aCA8IDIgJiZcbiAgICAgICAgICAgIGJlZm9yZS5tZXJnZShmcm9tT2ZmLCB0b09mZiwgY29udGVudC5sZW5ndGggPyBsYXN0IDogbnVsbCwgZnJvbU9mZiA9PSAwLCBvcGVuU3RhcnQsIG9wZW5FbmQpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgYWZ0ZXIgPSB0aGlzLmNoaWxkcmVuW3RvSV07XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgZW5kIG9mIHRoZSBsaW5lIGFmdGVyIHRoZSB1cGRhdGUgaXMgcHJlc2VydmVkIGluIGBhZnRlcmBcbiAgICAgICAgaWYgKHRvT2ZmIDwgYWZ0ZXIubGVuZ3RoIHx8IGFmdGVyLmNoaWxkcmVuLmxlbmd0aCAmJiBhZnRlci5jaGlsZHJlblthZnRlci5jaGlsZHJlbi5sZW5ndGggLSAxXS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgLy8gSWYgd2UncmUgc3BsaXR0aW5nIGEgbGluZSwgc2VwYXJhdGUgcGFydCBvZiB0aGUgc3RhcnQgbGluZSB0b1xuICAgICAgICAgICAgLy8gYXZvaWQgdGhhdCBiZWluZyBtYW5nbGVkIHdoZW4gdXBkYXRpbmcgdGhlIHN0YXJ0IGxpbmUuXG4gICAgICAgICAgICBpZiAoZnJvbUkgPT0gdG9JKSB7XG4gICAgICAgICAgICAgICAgYWZ0ZXIgPSBhZnRlci5zcGxpdCh0b09mZik7XG4gICAgICAgICAgICAgICAgdG9PZmYgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlIGVsZW1lbnQgYWZ0ZXIgdGhlIHJlcGxhY2VtZW50IHNob3VsZCBiZSBtZXJnZWQgd2l0aFxuICAgICAgICAgICAgLy8gdGhlIGxhc3QgcmVwbGFjaW5nIGVsZW1lbnQsIHVwZGF0ZSBgY29udGVudGBcbiAgICAgICAgICAgIGlmICghYnJlYWtBdEVuZCAmJiBsYXN0ICYmIGFmdGVyLm1lcmdlKDAsIHRvT2ZmLCBsYXN0LCB0cnVlLCAwLCBvcGVuRW5kKSkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRbY29udGVudC5sZW5ndGggLSAxXSA9IGFmdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBzdGFydCBvZiB0aGUgYWZ0ZXIgZWxlbWVudCwgaWYgbmVjZXNzYXJ5LCBhbmRcbiAgICAgICAgICAgICAgICAvLyBhZGQgaXQgdG8gYGNvbnRlbnRgLlxuICAgICAgICAgICAgICAgIGlmICh0b09mZiB8fCBhZnRlci5jaGlsZHJlbi5sZW5ndGggJiYgYWZ0ZXIuY2hpbGRyZW5bMF0ubGVuZ3RoID09IDApXG4gICAgICAgICAgICAgICAgICAgIGFmdGVyLm1lcmdlKDAsIHRvT2ZmLCBudWxsLCBmYWxzZSwgMCwgb3BlbkVuZCk7XG4gICAgICAgICAgICAgICAgY29udGVudC5wdXNoKGFmdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhZnRlci5icmVha0FmdGVyKSB7XG4gICAgICAgICAgICAvLyBUaGUgZWxlbWVudCBhdCBgdG9JYCBpcyBlbnRpcmVseSBjb3ZlcmVkIGJ5IHRoaXMgcmFuZ2UuXG4gICAgICAgICAgICAvLyBQcmVzZXJ2ZSBpdHMgbGluZSBicmVhaywgaWYgYW55LlxuICAgICAgICAgICAgaWYgKGxhc3QpXG4gICAgICAgICAgICAgICAgbGFzdC5icmVha0FmdGVyID0gMTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBicmVha0F0U3RhcnQgPSAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpbmNlIHdlJ3ZlIGhhbmRsZWQgdGhlIG5leHQgZWxlbWVudCBmcm9tIHRoZSBjdXJyZW50IGVsZW1lbnRzXG4gICAgICAgIC8vIG5vdywgbWFrZSBzdXJlIGB0b0lgIHBvaW50cyBhZnRlciB0aGF0LlxuICAgICAgICB0b0krKztcbiAgICAgICAgYmVmb3JlLmJyZWFrQWZ0ZXIgPSBicmVha0F0U3RhcnQ7XG4gICAgICAgIGlmIChmcm9tT2ZmID4gMCkge1xuICAgICAgICAgICAgaWYgKCFicmVha0F0U3RhcnQgJiYgY29udGVudC5sZW5ndGggJiYgYmVmb3JlLm1lcmdlKGZyb21PZmYsIGJlZm9yZS5sZW5ndGgsIGNvbnRlbnRbMF0sIGZhbHNlLCBvcGVuU3RhcnQsIDApKSB7XG4gICAgICAgICAgICAgICAgYmVmb3JlLmJyZWFrQWZ0ZXIgPSBjb250ZW50LnNoaWZ0KCkuYnJlYWtBZnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZyb21PZmYgPCBiZWZvcmUubGVuZ3RoIHx8IGJlZm9yZS5jaGlsZHJlbi5sZW5ndGggJiYgYmVmb3JlLmNoaWxkcmVuW2JlZm9yZS5jaGlsZHJlbi5sZW5ndGggLSAxXS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIGJlZm9yZS5tZXJnZShmcm9tT2ZmLCBiZWZvcmUubGVuZ3RoLCBudWxsLCBmYWxzZSwgb3BlblN0YXJ0LCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZyb21JKys7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHJ5IHRvIG1lcmdlIHdpZGdldHMgb24gdGhlIGJvdW5kYXJpZXMgb2YgdGhlIHJlcGxhY2VtZW50XG4gICAgICAgIHdoaWxlIChmcm9tSSA8IHRvSSAmJiBjb250ZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5bdG9JIC0gMV0ubWF0Y2goY29udGVudFtjb250ZW50Lmxlbmd0aCAtIDFdKSlcbiAgICAgICAgICAgICAgICB0b0ktLSwgY29udGVudC5wb3AoKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY2hpbGRyZW5bZnJvbUldLm1hdGNoKGNvbnRlbnRbMF0pKVxuICAgICAgICAgICAgICAgIGZyb21JKyssIGNvbnRlbnQuc2hpZnQoKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJvbUkgPCB0b0kgfHwgY29udGVudC5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLnJlcGxhY2VDaGlsZHJlbihmcm9tSSwgdG9JLCBjb250ZW50KTtcbiAgICB9XG4gICAgLy8gU3luYyB0aGUgRE9NIHNlbGVjdGlvbiB0byB0aGlzLnN0YXRlLnNlbGVjdGlvblxuICAgIHVwZGF0ZVNlbGVjdGlvbihmb3JjZSA9IGZhbHNlLCBmcm9tUG9pbnRlciA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghKGZyb21Qb2ludGVyIHx8IHRoaXMubWF5Q29udHJvbFNlbGVjdGlvbigpKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IG1haW4gPSB0aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgICAgIC8vIEZJWE1FIG5lZWQgdG8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHRoZSBzZWxlY3Rpb24gZmFsbHMgaW5zaWRlIGEgYmxvY2sgcmFuZ2VcbiAgICAgICAgbGV0IGFuY2hvciA9IHRoaXMuZG9tQXRQb3MobWFpbi5hbmNob3IpO1xuICAgICAgICBsZXQgaGVhZCA9IG1haW4uZW1wdHkgPyBhbmNob3IgOiB0aGlzLmRvbUF0UG9zKG1haW4uaGVhZCk7XG4gICAgICAgIGlmIChicm93c2VyLmdlY2tvICYmIG1haW4uZW1wdHkgJiYgYmV0d2VlblVuZWRpdGFibGUoYW5jaG9yKSkge1xuICAgICAgICAgICAgbGV0IGR1bW15ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcIik7XG4gICAgICAgICAgICB0aGlzLnZpZXcub2JzZXJ2ZXIuaWdub3JlKCgpID0+IGFuY2hvci5ub2RlLmluc2VydEJlZm9yZShkdW1teSwgYW5jaG9yLm5vZGUuY2hpbGROb2Rlc1thbmNob3Iub2Zmc2V0XSB8fCBudWxsKSk7XG4gICAgICAgICAgICBhbmNob3IgPSBoZWFkID0gbmV3IERPTVBvcyhkdW1teSwgMCk7XG4gICAgICAgICAgICBmb3JjZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRvbVNlbCA9IGdldFNlbGVjdGlvbih0aGlzLnJvb3QpO1xuICAgICAgICAvLyBJZiB0aGUgc2VsZWN0aW9uIGlzIGFscmVhZHkgaGVyZSwgb3IgaW4gYW4gZXF1aXZhbGVudCBwb3NpdGlvbiwgZG9uJ3QgdG91Y2ggaXRcbiAgICAgICAgaWYgKGZvcmNlIHx8ICFkb21TZWwuZm9jdXNOb2RlIHx8XG4gICAgICAgICAgICAoYnJvd3Nlci5nZWNrbyAmJiBtYWluLmVtcHR5ICYmIG5leHRUb1VuZWRpdGFibGUoZG9tU2VsLmZvY3VzTm9kZSwgZG9tU2VsLmZvY3VzT2Zmc2V0KSkgfHxcbiAgICAgICAgICAgICFpc0VxdWl2YWxlbnRQb3NpdGlvbihhbmNob3Iubm9kZSwgYW5jaG9yLm9mZnNldCwgZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQpIHx8XG4gICAgICAgICAgICAhaXNFcXVpdmFsZW50UG9zaXRpb24oaGVhZC5ub2RlLCBoZWFkLm9mZnNldCwgZG9tU2VsLmZvY3VzTm9kZSwgZG9tU2VsLmZvY3VzT2Zmc2V0KSkge1xuICAgICAgICAgICAgdGhpcy52aWV3Lm9ic2VydmVyLmlnbm9yZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG1haW4uZW1wdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV29yayBhcm91bmQgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTYxMjA3NlxuICAgICAgICAgICAgICAgICAgICBpZiAoYnJvd3Nlci5nZWNrbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5leHRUbyA9IG5leHRUb1VuZWRpdGFibGUoYW5jaG9yLm5vZGUsIGFuY2hvci5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRUbyAmJiBuZXh0VG8gIT0gKDEgLyogQmVmb3JlICovIHwgMiAvKiBBZnRlciAqLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGV4dCA9IG5lYXJieVRleHROb2RlKGFuY2hvci5ub2RlLCBhbmNob3Iub2Zmc2V0LCBuZXh0VG8gPT0gMSAvKiBCZWZvcmUgKi8gPyAxIDogLTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmNob3IgPSBuZXcgRE9NUG9zKHRleHQsIG5leHRUbyA9PSAxIC8qIEJlZm9yZSAqLyA/IDAgOiB0ZXh0Lm5vZGVWYWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRvbVNlbC5jb2xsYXBzZShhbmNob3Iubm9kZSwgYW5jaG9yLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYWluLmJpZGlMZXZlbCAhPSBudWxsICYmIGRvbVNlbC5jdXJzb3JCaWRpTGV2ZWwgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbVNlbC5jdXJzb3JCaWRpTGV2ZWwgPSBtYWluLmJpZGlMZXZlbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZG9tU2VsLmV4dGVuZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTZWxlY3Rpb24uZXh0ZW5kIGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBhbiAnaW52ZXJ0ZWQnIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyAob25lIHdoZXJlIHRoZSBmb2N1cyBpcyBiZWZvcmUgdGhlIGFuY2hvciksIGJ1dCBub3QgYWxsXG4gICAgICAgICAgICAgICAgICAgIC8vIGJyb3dzZXJzIHN1cHBvcnQgaXQgeWV0LlxuICAgICAgICAgICAgICAgICAgICBkb21TZWwuY29sbGFwc2UoYW5jaG9yLm5vZGUsIGFuY2hvci5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICBkb21TZWwuZXh0ZW5kKGhlYWQubm9kZSwgaGVhZC5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJpbWl0aXZlIChJRSkgd2F5XG4gICAgICAgICAgICAgICAgICAgIGxldCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYWluLmFuY2hvciA+IG1haW4uaGVhZClcbiAgICAgICAgICAgICAgICAgICAgICAgIFthbmNob3IsIGhlYWRdID0gW2hlYWQsIGFuY2hvcl07XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldEVuZChoZWFkLm5vZGUsIGhlYWQub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQoYW5jaG9yLm5vZGUsIGFuY2hvci5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICBkb21TZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgICAgICAgICAgICAgIGRvbVNlbC5hZGRSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbXByZWNpc2VBbmNob3IgPSBhbmNob3IucHJlY2lzZSA/IG51bGwgOiBuZXcgRE9NUG9zKGRvbVNlbC5hbmNob3JOb2RlLCBkb21TZWwuYW5jaG9yT2Zmc2V0KTtcbiAgICAgICAgdGhpcy5pbXByZWNpc2VIZWFkID0gaGVhZC5wcmVjaXNlID8gbnVsbCA6IG5ldyBET01Qb3MoZG9tU2VsLmZvY3VzTm9kZSwgZG9tU2VsLmZvY3VzT2Zmc2V0KTtcbiAgICB9XG4gICAgZW5mb3JjZUN1cnNvckFzc29jKCkge1xuICAgICAgICBsZXQgY3Vyc29yID0gdGhpcy52aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgICAgICBsZXQgc2VsID0gZ2V0U2VsZWN0aW9uKHRoaXMucm9vdCk7XG4gICAgICAgIGlmICghY3Vyc29yLmVtcHR5IHx8ICFjdXJzb3IuYXNzb2MgfHwgIXNlbC5tb2RpZnkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBsaW5lID0gTGluZVZpZXcuZmluZCh0aGlzLCBjdXJzb3IuaGVhZCk7IC8vIEZJWE1FIHByb3ZpZGUgdmlldy1saW5lLXJhbmdlIGZpbmRpbmcgaGVscGVyXG4gICAgICAgIGlmICghbGluZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGxpbmVTdGFydCA9IGxpbmUucG9zQXRTdGFydDtcbiAgICAgICAgaWYgKGN1cnNvci5oZWFkID09IGxpbmVTdGFydCB8fCBjdXJzb3IuaGVhZCA9PSBsaW5lU3RhcnQgKyBsaW5lLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGJlZm9yZSA9IHRoaXMuY29vcmRzQXQoY3Vyc29yLmhlYWQsIC0xKSwgYWZ0ZXIgPSB0aGlzLmNvb3Jkc0F0KGN1cnNvci5oZWFkLCAxKTtcbiAgICAgICAgaWYgKCFiZWZvcmUgfHwgIWFmdGVyIHx8IGJlZm9yZS5ib3R0b20gPiBhZnRlci50b3ApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBkb20gPSB0aGlzLmRvbUF0UG9zKGN1cnNvci5oZWFkICsgY3Vyc29yLmFzc29jKTtcbiAgICAgICAgc2VsLmNvbGxhcHNlKGRvbS5ub2RlLCBkb20ub2Zmc2V0KTtcbiAgICAgICAgc2VsLm1vZGlmeShcIm1vdmVcIiwgY3Vyc29yLmFzc29jIDwgMCA/IFwiZm9yd2FyZFwiIDogXCJiYWNrd2FyZFwiLCBcImxpbmVib3VuZGFyeVwiKTtcbiAgICB9XG4gICAgbWF5Q29udHJvbFNlbGVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5zdGF0ZS5mYWNldChlZGl0YWJsZSkgPyB0aGlzLnJvb3QuYWN0aXZlRWxlbWVudCA9PSB0aGlzLmRvbSA6IGhhc1NlbGVjdGlvbih0aGlzLmRvbSwgZ2V0U2VsZWN0aW9uKHRoaXMucm9vdCkpO1xuICAgIH1cbiAgICBuZWFyZXN0KGRvbSkge1xuICAgICAgICBmb3IgKGxldCBjdXIgPSBkb207IGN1cjspIHtcbiAgICAgICAgICAgIGxldCBkb21WaWV3ID0gQ29udGVudFZpZXcuZ2V0KGN1cik7XG4gICAgICAgICAgICBpZiAoZG9tVmlldyAmJiBkb21WaWV3LnJvb3RWaWV3ID09IHRoaXMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbVZpZXc7XG4gICAgICAgICAgICBjdXIgPSBjdXIucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcG9zRnJvbURPTShub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IHZpZXcgPSB0aGlzLm5lYXJlc3Qobm9kZSk7XG4gICAgICAgIGlmICghdmlldylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVHJ5aW5nIHRvIGZpbmQgcG9zaXRpb24gZm9yIGEgRE9NIHBvc2l0aW9uIG91dHNpZGUgb2YgdGhlIGRvY3VtZW50XCIpO1xuICAgICAgICByZXR1cm4gdmlldy5sb2NhbFBvc0Zyb21ET00obm9kZSwgb2Zmc2V0KSArIHZpZXcucG9zQXRTdGFydDtcbiAgICB9XG4gICAgZG9tQXRQb3MocG9zKSB7XG4gICAgICAgIGxldCB7IGksIG9mZiB9ID0gdGhpcy5jaGlsZEN1cnNvcigpLmZpbmRQb3MocG9zLCAtMSk7XG4gICAgICAgIGZvciAoOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxOykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChvZmYgPCBjaGlsZC5sZW5ndGggfHwgY2hpbGQgaW5zdGFuY2VvZiBMaW5lVmlldylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIG9mZiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5baV0uZG9tQXRQb3Mob2ZmKTtcbiAgICB9XG4gICAgY29vcmRzQXQocG9zLCBzaWRlKSB7XG4gICAgICAgIGZvciAobGV0IG9mZiA9IHRoaXMubGVuZ3RoLCBpID0gdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxOzsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBzdGFydCA9IG9mZiAtIGNoaWxkLmJyZWFrQWZ0ZXIgLSBjaGlsZC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAocG9zID4gc3RhcnQgfHwgcG9zID09IHN0YXJ0ICYmIChjaGlsZC50eXBlID09IGV4cG9ydHMuQmxvY2tUeXBlLlRleHQgfHwgIWkgfHwgdGhpcy5jaGlsZHJlbltpIC0gMV0uYnJlYWtBZnRlcikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmNvb3Jkc0F0KHBvcyAtIHN0YXJ0LCBzaWRlKTtcbiAgICAgICAgICAgIG9mZiA9IHN0YXJ0O1xuICAgICAgICB9XG4gICAgfVxuICAgIG1lYXN1cmVWaXNpYmxlTGluZUhlaWdodHMoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXSwgeyBmcm9tLCB0byB9ID0gdGhpcy52aWV3LnZpZXdTdGF0ZS52aWV3cG9ydDtcbiAgICAgICAgbGV0IG1pbldpZHRoID0gTWF0aC5tYXgodGhpcy52aWV3LnNjcm9sbERPTS5jbGllbnRXaWR0aCwgdGhpcy5taW5XaWR0aCkgKyAxO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwLCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IHBvcyArIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChlbmQgPiB0bylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmIChwb3MgPj0gZnJvbSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNoaWxkLmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIGxldCB3aWR0aCA9IGNoaWxkLmRvbS5zY3JvbGxXaWR0aDtcbiAgICAgICAgICAgICAgICBpZiAod2lkdGggPiBtaW5XaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1pbldpZHRoID0gbWluV2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5taW5XaWR0aEZyb20gPSBwb3M7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWluV2lkdGhUbyA9IGVuZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgPSBlbmQgKyBjaGlsZC5icmVha0FmdGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIG1lYXN1cmVUZXh0U2l6ZSgpIHtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgTGluZVZpZXcpIHtcbiAgICAgICAgICAgICAgICBsZXQgbWVhc3VyZSA9IGNoaWxkLm1lYXN1cmVUZXh0U2l6ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChtZWFzdXJlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVhc3VyZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBubyB3b3JrYWJsZSBsaW5lIGV4aXN0cywgZm9yY2UgYSBsYXlvdXQgb2YgYSBtZWFzdXJhYmxlIGVsZW1lbnRcbiAgICAgICAgbGV0IGR1bW15ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgbGluZUhlaWdodCwgY2hhcldpZHRoO1xuICAgICAgICBkdW1teS5jbGFzc05hbWUgPSBcImNtLWxpbmVcIjtcbiAgICAgICAgZHVtbXkudGV4dENvbnRlbnQgPSBcImFiYyBkZWYgZ2hpIGprbCBtbm8gcHFyIHN0dVwiO1xuICAgICAgICB0aGlzLnZpZXcub2JzZXJ2ZXIuaWdub3JlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKGR1bW15KTtcbiAgICAgICAgICAgIGxldCByZWN0ID0gY2xpZW50UmVjdHNGb3IoZHVtbXkuZmlyc3RDaGlsZClbMF07XG4gICAgICAgICAgICBsaW5lSGVpZ2h0ID0gZHVtbXkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICAgICAgICAgICAgY2hhcldpZHRoID0gcmVjdCA/IHJlY3Qud2lkdGggLyAyNyA6IDc7XG4gICAgICAgICAgICBkdW1teS5yZW1vdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IGxpbmVIZWlnaHQsIGNoYXJXaWR0aCB9O1xuICAgIH1cbiAgICBjaGlsZEN1cnNvcihwb3MgPSB0aGlzLmxlbmd0aCkge1xuICAgICAgICAvLyBNb3ZlIGJhY2sgdG8gc3RhcnQgb2YgbGFzdCBlbGVtZW50IHdoZW4gcG9zc2libGUsIHNvIHRoYXRcbiAgICAgICAgLy8gYENoaWxkQ3Vyc29yLmZpbmRQb3NgIGRvZXNuJ3QgaGF2ZSB0byBkZWFsIHdpdGggdGhlIGVkZ2UgY2FzZVxuICAgICAgICAvLyBvZiBiZWluZyBhZnRlciB0aGUgbGFzdCBlbGVtZW50LlxuICAgICAgICBsZXQgaSA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICBpZiAoaSlcbiAgICAgICAgICAgIHBvcyAtPSB0aGlzLmNoaWxkcmVuWy0taV0ubGVuZ3RoO1xuICAgICAgICByZXR1cm4gbmV3IENoaWxkQ3Vyc29yKHRoaXMuY2hpbGRyZW4sIHBvcywgaSk7XG4gICAgfVxuICAgIGNvbXB1dGVCbG9ja0dhcERlY28oKSB7XG4gICAgICAgIGxldCBkZWNvID0gW10sIHZzID0gdGhpcy52aWV3LnZpZXdTdGF0ZTtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMCwgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gaSA9PSB2cy52aWV3cG9ydHMubGVuZ3RoID8gbnVsbCA6IHZzLnZpZXdwb3J0c1tpXTtcbiAgICAgICAgICAgIGxldCBlbmQgPSBuZXh0ID8gbmV4dC5mcm9tIC0gMSA6IHRoaXMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGVuZCA+IHBvcykge1xuICAgICAgICAgICAgICAgIGxldCBoZWlnaHQgPSB2cy5saW5lQXQoZW5kLCAwKS5ib3R0b20gLSB2cy5saW5lQXQocG9zLCAwKS50b3A7XG4gICAgICAgICAgICAgICAgZGVjby5wdXNoKERlY29yYXRpb24ucmVwbGFjZSh7IHdpZGdldDogbmV3IEJsb2NrR2FwV2lkZ2V0KGhlaWdodCksIGJsb2NrOiB0cnVlLCBpbmNsdXNpdmU6IHRydWUgfSkucmFuZ2UocG9zLCBlbmQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbmV4dClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHBvcyA9IG5leHQudG8gKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uLnNldChkZWNvKTtcbiAgICB9XG4gICAgdXBkYXRlRGVjbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjb3JhdGlvbnMgPSBbXG4gICAgICAgICAgICB0aGlzLmNvbXB1dGVCbG9ja0dhcERlY28oKSxcbiAgICAgICAgICAgIHRoaXMudmlldy52aWV3U3RhdGUubGluZUdhcERlY28sXG4gICAgICAgICAgICB0aGlzLmNvbXBvc2l0aW9uRGVjbyxcbiAgICAgICAgICAgIC4uLnRoaXMudmlldy5zdGF0ZS5mYWNldChkZWNvcmF0aW9ucyksXG4gICAgICAgICAgICAuLi50aGlzLnZpZXcucGx1Z2luRmllbGQoUGx1Z2luRmllbGQuZGVjb3JhdGlvbnMpXG4gICAgICAgIF07XG4gICAgfVxuICAgIHNjcm9sbFBvc0ludG9WaWV3KHBvcywgc2lkZSkge1xuICAgICAgICBsZXQgcmVjdCA9IHRoaXMuY29vcmRzQXQocG9zLCBzaWRlKTtcbiAgICAgICAgaWYgKCFyZWN0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgbUxlZnQgPSAwLCBtUmlnaHQgPSAwLCBtVG9wID0gMCwgbUJvdHRvbSA9IDA7XG4gICAgICAgIGZvciAobGV0IG1hcmdpbnMgb2YgdGhpcy52aWV3LnBsdWdpbkZpZWxkKFBsdWdpbkZpZWxkLnNjcm9sbE1hcmdpbnMpKVxuICAgICAgICAgICAgaWYgKG1hcmdpbnMpIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20gfSA9IG1hcmdpbnM7XG4gICAgICAgICAgICAgICAgaWYgKGxlZnQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgbUxlZnQgPSBNYXRoLm1heChtTGVmdCwgbGVmdCk7XG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIG1SaWdodCA9IE1hdGgubWF4KG1SaWdodCwgcmlnaHQpO1xuICAgICAgICAgICAgICAgIGlmICh0b3AgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgbVRvcCA9IE1hdGgubWF4KG1Ub3AsIHRvcCk7XG4gICAgICAgICAgICAgICAgaWYgKGJvdHRvbSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBtQm90dG9tID0gTWF0aC5tYXgobUJvdHRvbSwgYm90dG9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgc2Nyb2xsUmVjdEludG9WaWV3KHRoaXMuZG9tLCB7XG4gICAgICAgICAgICBsZWZ0OiByZWN0LmxlZnQgLSBtTGVmdCwgdG9wOiByZWN0LnRvcCAtIG1Ub3AsXG4gICAgICAgICAgICByaWdodDogcmVjdC5yaWdodCArIG1SaWdodCwgYm90dG9tOiByZWN0LmJvdHRvbSArIG1Cb3R0b21cbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gYmV0d2VlblVuZWRpdGFibGUocG9zKSB7XG4gICAgcmV0dXJuIHBvcy5ub2RlLm5vZGVUeXBlID09IDEgJiYgcG9zLm5vZGUuZmlyc3RDaGlsZCAmJlxuICAgICAgICAocG9zLm9mZnNldCA9PSAwIHx8IHBvcy5ub2RlLmNoaWxkTm9kZXNbcG9zLm9mZnNldCAtIDFdLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpICYmXG4gICAgICAgIChwb3Mub2Zmc2V0IDwgcG9zLm5vZGUuY2hpbGROb2Rlcy5sZW5ndGggfHwgcG9zLm5vZGUuY2hpbGROb2Rlc1twb3Mub2Zmc2V0XS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKTtcbn1cbmNsYXNzIEJsb2NrR2FwV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3IoaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH1cbiAgICB0b0RPTSgpIHtcbiAgICAgICAgbGV0IGVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMudXBkYXRlRE9NKGVsdCk7XG4gICAgICAgIHJldHVybiBlbHQ7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7IHJldHVybiBvdGhlci5oZWlnaHQgPT0gdGhpcy5oZWlnaHQ7IH1cbiAgICB1cGRhdGVET00oZWx0KSB7XG4gICAgICAgIGVsdC5zdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodCArIFwicHhcIjtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGdldCBlc3RpbWF0ZWRIZWlnaHQoKSB7IHJldHVybiB0aGlzLmhlaWdodDsgfVxufVxuZnVuY3Rpb24gY29tcHV0ZUNvbXBvc2l0aW9uRGVjbyh2aWV3LCBjaGFuZ2VzKSB7XG4gICAgbGV0IHNlbCA9IGdldFNlbGVjdGlvbih2aWV3LnJvb3QpO1xuICAgIGxldCB0ZXh0Tm9kZSA9IHNlbC5mb2N1c05vZGUgJiYgbmVhcmJ5VGV4dE5vZGUoc2VsLmZvY3VzTm9kZSwgc2VsLmZvY3VzT2Zmc2V0LCAwKTtcbiAgICBpZiAoIXRleHROb2RlKVxuICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuICAgIGxldCBjVmlldyA9IHZpZXcuZG9jVmlldy5uZWFyZXN0KHRleHROb2RlKTtcbiAgICBsZXQgZnJvbSwgdG8sIHRvcE5vZGUgPSB0ZXh0Tm9kZTtcbiAgICBpZiAoY1ZpZXcgaW5zdGFuY2VvZiBJbmxpbmVWaWV3KSB7XG4gICAgICAgIHdoaWxlIChjVmlldy5wYXJlbnQgaW5zdGFuY2VvZiBJbmxpbmVWaWV3KVxuICAgICAgICAgICAgY1ZpZXcgPSBjVmlldy5wYXJlbnQ7XG4gICAgICAgIGZyb20gPSBjVmlldy5wb3NBdFN0YXJ0O1xuICAgICAgICB0byA9IGZyb20gKyBjVmlldy5sZW5ndGg7XG4gICAgICAgIHRvcE5vZGUgPSBjVmlldy5kb207XG4gICAgfVxuICAgIGVsc2UgaWYgKGNWaWV3IGluc3RhbmNlb2YgTGluZVZpZXcpIHtcbiAgICAgICAgd2hpbGUgKHRvcE5vZGUucGFyZW50Tm9kZSAhPSBjVmlldy5kb20pXG4gICAgICAgICAgICB0b3BOb2RlID0gdG9wTm9kZS5wYXJlbnROb2RlO1xuICAgICAgICBsZXQgcHJldiA9IHRvcE5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICB3aGlsZSAocHJldiAmJiAhQ29udGVudFZpZXcuZ2V0KHByZXYpKVxuICAgICAgICAgICAgcHJldiA9IHByZXYucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICBmcm9tID0gdG8gPSBwcmV2ID8gQ29udGVudFZpZXcuZ2V0KHByZXYpLnBvc0F0RW5kIDogY1ZpZXcucG9zQXRTdGFydDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgfVxuICAgIGxldCBuZXdGcm9tID0gY2hhbmdlcy5tYXBQb3MoZnJvbSwgMSksIG5ld1RvID0gTWF0aC5tYXgobmV3RnJvbSwgY2hhbmdlcy5tYXBQb3ModG8sIC0xKSk7XG4gICAgbGV0IHRleHQgPSB0ZXh0Tm9kZS5ub2RlVmFsdWUsIHsgc3RhdGUgfSA9IHZpZXc7XG4gICAgaWYgKG5ld1RvIC0gbmV3RnJvbSA8IHRleHQubGVuZ3RoKSB7XG4gICAgICAgIGlmIChzdGF0ZS5zbGljZURvYyhuZXdGcm9tLCBNYXRoLm1pbihzdGF0ZS5kb2MubGVuZ3RoLCBuZXdGcm9tICsgdGV4dC5sZW5ndGgpKSA9PSB0ZXh0KVxuICAgICAgICAgICAgbmV3VG8gPSBuZXdGcm9tICsgdGV4dC5sZW5ndGg7XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLnNsaWNlRG9jKE1hdGgubWF4KDAsIG5ld1RvIC0gdGV4dC5sZW5ndGgpLCBuZXdUbykgPT0gdGV4dClcbiAgICAgICAgICAgIG5ld0Zyb20gPSBuZXdUbyAtIHRleHQubGVuZ3RoO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdGF0ZS5zbGljZURvYyhuZXdGcm9tLCBuZXdUbykgIT0gdGV4dCkge1xuICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuICAgIH1cbiAgICByZXR1cm4gRGVjb3JhdGlvbi5zZXQoRGVjb3JhdGlvbi5yZXBsYWNlKHsgd2lkZ2V0OiBuZXcgQ29tcG9zaXRpb25XaWRnZXQodG9wTm9kZSwgdGV4dE5vZGUpIH0pLnJhbmdlKG5ld0Zyb20sIG5ld1RvKSk7XG59XG5jbGFzcyBDb21wb3NpdGlvbldpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKHRvcCwgdGV4dCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnRvcCA9IHRvcDtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIHRoaXMudG9wID09IG90aGVyLnRvcCAmJiB0aGlzLnRleHQgPT0gb3RoZXIudGV4dDsgfVxuICAgIHRvRE9NKCkgeyByZXR1cm4gdGhpcy50b3A7IH1cbiAgICBpZ25vcmVFdmVudCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZ2V0IGN1c3RvbVZpZXcoKSB7IHJldHVybiBDb21wb3NpdGlvblZpZXc7IH1cbn1cbmZ1bmN0aW9uIG5lYXJieVRleHROb2RlKG5vZGUsIG9mZnNldCwgc2lkZSkge1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMylcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxICYmIG9mZnNldCA+IDAgJiYgc2lkZSA8PSAwKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0KG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiBvZmZzZXQgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoICYmIHNpZGUgPj0gMCkge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gbmV4dFRvVW5lZGl0YWJsZShub2RlLCBvZmZzZXQpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSAhPSAxKVxuICAgICAgICByZXR1cm4gMDtcbiAgICByZXR1cm4gKG9mZnNldCAmJiBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV0uY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIiA/IDEgLyogQmVmb3JlICovIDogMCkgfFxuICAgICAgICAob2Zmc2V0IDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAmJiBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiID8gMiAvKiBBZnRlciAqLyA6IDApO1xufVxuY2xhc3MgRGVjb3JhdGlvbkNvbXBhcmF0b3IkMSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IFtdO1xuICAgIH1cbiAgICBjb21wYXJlUmFuZ2UoZnJvbSwgdG8pIHsgYWRkUmFuZ2UoZnJvbSwgdG8sIHRoaXMuY2hhbmdlcyk7IH1cbiAgICBjb21wYXJlUG9pbnQoZnJvbSwgdG8pIHsgYWRkUmFuZ2UoZnJvbSwgdG8sIHRoaXMuY2hhbmdlcyk7IH1cbn1cbmZ1bmN0aW9uIGZpbmRDaGFuZ2VkRGVjbyhhLCBiLCBkaWZmKSB7XG4gICAgbGV0IGNvbXAgPSBuZXcgRGVjb3JhdGlvbkNvbXBhcmF0b3IkMTtcbiAgICByYW5nZXNldC5SYW5nZVNldC5jb21wYXJlKGEsIGIsIGRpZmYsIGNvbXApO1xuICAgIHJldHVybiBjb21wLmNoYW5nZXM7XG59XG5cbi8qKlxuVXNlZCB0byBpbmRpY2F0ZSBbdGV4dCBkaXJlY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnRleHREaXJlY3Rpb24pLlxuKi9cbmV4cG9ydHMuRGlyZWN0aW9uID0gdm9pZCAwO1xuKGZ1bmN0aW9uIChEaXJlY3Rpb24pIHtcbiAgICAvLyAoVGhlc2UgYXJlIGNob3NlbiB0byBtYXRjaCB0aGUgYmFzZSBsZXZlbHMsIGluIGJpZGkgYWxnb3JpdGhtXG4gICAgLy8gdGVybXMsIG9mIHNwYW5zIGluIHRoYXQgZGlyZWN0aW9uLilcbiAgICAvKipcbiAgICBMZWZ0LXRvLXJpZ2h0LlxuICAgICovXG4gICAgRGlyZWN0aW9uW0RpcmVjdGlvbltcIkxUUlwiXSA9IDBdID0gXCJMVFJcIjtcbiAgICAvKipcbiAgICBSaWdodC10by1sZWZ0LlxuICAgICovXG4gICAgRGlyZWN0aW9uW0RpcmVjdGlvbltcIlJUTFwiXSA9IDFdID0gXCJSVExcIjtcbn0pKGV4cG9ydHMuRGlyZWN0aW9uIHx8IChleHBvcnRzLkRpcmVjdGlvbiA9IHt9KSk7XG5jb25zdCBMVFIgPSBleHBvcnRzLkRpcmVjdGlvbi5MVFIsIFJUTCA9IGV4cG9ydHMuRGlyZWN0aW9uLlJUTDtcbi8vIERlY29kZSBhIHN0cmluZyB3aXRoIGVhY2ggdHlwZSBlbmNvZGVkIGFzIGxvZzIodHlwZSlcbmZ1bmN0aW9uIGRlYyhzdHIpIHtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspXG4gICAgICAgIHJlc3VsdC5wdXNoKDEgPDwgK3N0cltpXSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIENoYXJhY3RlciB0eXBlcyBmb3IgY29kZXBvaW50cyAwIHRvIDB4ZjhcbmNvbnN0IExvd1R5cGVzID0gZGVjKFwiODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg2NjY4ODg4ODg3ODc4MzMzMzMzMzMzMzc4ODg4ODgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDg4ODg4ODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODc4NjY2Njg4ODgwODg4ODg2NjMzODA4ODgzMDg4ODg4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDhcIik7XG4vLyBDaGFyYWN0ZXIgdHlwZXMgZm9yIGNvZGVwb2ludHMgMHg2MDAgdG8gMHg2ZjlcbmNvbnN0IEFyYWJpY1R5cGVzID0gZGVjKFwiNDQ0NDQ0ODgyNjYyNzI4ODk5OTk5OTk5OTk5MjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyOTk5OTk5OTk5OTk5OTk5OTk5OTk5NDQ0NDQ0NDQ0NDY0NDIyMjgyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjk5OTk5OTk0OTk5OTk5OTIyOTk4OTk5OTIyMzMzMzMzMzMzM1wiKTtcbmNvbnN0IEJyYWNrZXRzID0gT2JqZWN0LmNyZWF0ZShudWxsKSwgQnJhY2tldFN0YWNrID0gW107XG4vLyBUaGVyZSdzIGEgbG90IG1vcmUgaW5cbi8vIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL1B1YmxpYy9VQ0QvbGF0ZXN0L3VjZC9CaWRpQnJhY2tldHMudHh0LFxuLy8gd2hpY2ggYXJlIGxlZnQgb3V0IHRvIGtlZXAgY29kZSBzaXplIGRvd24uXG5mb3IgKGxldCBwIG9mIFtcIigpXCIsIFwiW11cIiwgXCJ7fVwiXSkge1xuICAgIGxldCBsID0gcC5jaGFyQ29kZUF0KDApLCByID0gcC5jaGFyQ29kZUF0KDEpO1xuICAgIEJyYWNrZXRzW2xdID0gcjtcbiAgICBCcmFja2V0c1tyXSA9IC1sO1xufVxuZnVuY3Rpb24gY2hhclR5cGUoY2gpIHtcbiAgICByZXR1cm4gY2ggPD0gMHhmNyA/IExvd1R5cGVzW2NoXSA6XG4gICAgICAgIDB4NTkwIDw9IGNoICYmIGNoIDw9IDB4NWY0ID8gMiAvKiBSICovIDpcbiAgICAgICAgICAgIDB4NjAwIDw9IGNoICYmIGNoIDw9IDB4NmY5ID8gQXJhYmljVHlwZXNbY2ggLSAweDYwMF0gOlxuICAgICAgICAgICAgICAgIDB4NmVlIDw9IGNoICYmIGNoIDw9IDB4OGFjID8gNCAvKiBBTCAqLyA6XG4gICAgICAgICAgICAgICAgICAgIDB4MjAwMCA8PSBjaCAmJiBjaCA8PSAweDIwMGIgPyAyNTYgLyogTkkgKi8gOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2ggPT0gMHgyMDBjID8gMjU2IC8qIE5JICovIDogMSAvKiBMICovO1xufVxuY29uc3QgQmlkaVJFID0gL1tcXHUwNTkwLVxcdTA1ZjRcXHUwNjAwLVxcdTA2ZmZcXHUwNzAwLVxcdTA4YWNdLztcbi8qKlxuUmVwcmVzZW50cyBhIGNvbnRpZ3VvdXMgcmFuZ2Ugb2YgdGV4dCB0aGF0IGhhcyBhIHNpbmdsZSBkaXJlY3Rpb25cbihhcyBpbiBsZWZ0LXRvLXJpZ2h0IG9yIHJpZ2h0LXRvLWxlZnQpLlxuKi9cbmNsYXNzIEJpZGlTcGFuIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBvZiB0aGUgc3BhbiAocmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSBsaW5lKS5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgb2YgdGhlIHNwYW4uXG4gICAgKi9cbiAgICB0bywgXG4gICAgLyoqXG4gICAgVGhlIFtcImJpZGlcbiAgICBsZXZlbFwiXShodHRwczovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHI5LyNCYXNpY19EaXNwbGF5X0FsZ29yaXRobSlcbiAgICBvZiB0aGUgc3BhbiAoaW4gdGhpcyBjb250ZXh0LCAwIG1lYW5zXG4gICAgbGVmdC10by1yaWdodCwgMSBtZWFucyByaWdodC10by1sZWZ0LCAyIG1lYW5zIGxlZnQtdG8tcmlnaHRcbiAgICBudW1iZXIgaW5zaWRlIHJpZ2h0LXRvLWxlZnQgdGV4dCkuXG4gICAgKi9cbiAgICBsZXZlbCkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGRpcmVjdGlvbiBvZiB0aGlzIHNwYW4uXG4gICAgKi9cbiAgICBnZXQgZGlyKCkgeyByZXR1cm4gdGhpcy5sZXZlbCAlIDIgPyBSVEwgOiBMVFI7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNpZGUoZW5kLCBkaXIpIHsgcmV0dXJuICh0aGlzLmRpciA9PSBkaXIpID09IGVuZCA/IHRoaXMudG8gOiB0aGlzLmZyb207IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmaW5kKG9yZGVyLCBpbmRleCwgbGV2ZWwsIGFzc29jKSB7XG4gICAgICAgIGxldCBtYXliZSA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9yZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3BhbiA9IG9yZGVyW2ldO1xuICAgICAgICAgICAgaWYgKHNwYW4uZnJvbSA8PSBpbmRleCAmJiBzcGFuLnRvID49IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHNwYW4ubGV2ZWwgPT0gbGV2ZWwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gbXVsdGlwbGUgc3BhbnMgbWF0Y2gsIGlmIGFzc29jICE9IDAsIHRha2UgdGhlIG9uZSB0aGF0XG4gICAgICAgICAgICAgICAgLy8gY292ZXJzIHRoYXQgc2lkZSwgb3RoZXJ3aXNlIHRha2UgdGhlIG9uZSB3aXRoIHRoZSBtaW5pbXVtXG4gICAgICAgICAgICAgICAgLy8gbGV2ZWwuXG4gICAgICAgICAgICAgICAgaWYgKG1heWJlIDwgMCB8fCAoYXNzb2MgIT0gMCA/IChhc3NvYyA8IDAgPyBzcGFuLmZyb20gPCBpbmRleCA6IHNwYW4udG8gPiBpbmRleCkgOiBvcmRlclttYXliZV0ubGV2ZWwgPiBzcGFuLmxldmVsKSlcbiAgICAgICAgICAgICAgICAgICAgbWF5YmUgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtYXliZSA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKTtcbiAgICAgICAgcmV0dXJuIG1heWJlO1xuICAgIH1cbn1cbi8vIFJldXNlZCBhcnJheSBvZiBjaGFyYWN0ZXIgdHlwZXNcbmNvbnN0IHR5cGVzID0gW107XG5mdW5jdGlvbiBjb21wdXRlT3JkZXIobGluZSwgZGlyZWN0aW9uKSB7XG4gICAgbGV0IGxlbiA9IGxpbmUubGVuZ3RoLCBvdXRlclR5cGUgPSBkaXJlY3Rpb24gPT0gTFRSID8gMSAvKiBMICovIDogMiAvKiBSICovLCBvcHBvc2l0ZVR5cGUgPSBkaXJlY3Rpb24gPT0gTFRSID8gMiAvKiBSICovIDogMSAvKiBMICovO1xuICAgIGlmICghbGluZSB8fCBvdXRlclR5cGUgPT0gMSAvKiBMICovICYmICFCaWRpUkUudGVzdChsaW5lKSlcbiAgICAgICAgcmV0dXJuIHRyaXZpYWxPcmRlcihsZW4pO1xuICAgIC8vIFcxLiBFeGFtaW5lIGVhY2ggbm9uLXNwYWNpbmcgbWFyayAoTlNNKSBpbiB0aGUgbGV2ZWwgcnVuLCBhbmRcbiAgICAvLyBjaGFuZ2UgdGhlIHR5cGUgb2YgdGhlIE5TTSB0byB0aGUgdHlwZSBvZiB0aGUgcHJldmlvdXNcbiAgICAvLyBjaGFyYWN0ZXIuIElmIHRoZSBOU00gaXMgYXQgdGhlIHN0YXJ0IG9mIHRoZSBsZXZlbCBydW4sIGl0IHdpbGxcbiAgICAvLyBnZXQgdGhlIHR5cGUgb2Ygc29yLlxuICAgIC8vIFcyLiBTZWFyY2ggYmFja3dhcmRzIGZyb20gZWFjaCBpbnN0YW5jZSBvZiBhIEV1cm9wZWFuIG51bWJlclxuICAgIC8vIHVudGlsIHRoZSBmaXJzdCBzdHJvbmcgdHlwZSAoUiwgTCwgQUwsIG9yIHNvcikgaXMgZm91bmQuIElmIGFuXG4gICAgLy8gQUwgaXMgZm91bmQsIGNoYW5nZSB0aGUgdHlwZSBvZiB0aGUgRXVyb3BlYW4gbnVtYmVyIHRvIEFyYWJpY1xuICAgIC8vIG51bWJlci5cbiAgICAvLyBXMy4gQ2hhbmdlIGFsbCBBTHMgdG8gUi5cbiAgICAvLyAoTGVmdCBhZnRlciB0aGlzOiBMLCBSLCBFTiwgQU4sIEVULCBDUywgTkkpXG4gICAgZm9yIChsZXQgaSA9IDAsIHByZXYgPSBvdXRlclR5cGUsIHByZXZTdHJvbmcgPSBvdXRlclR5cGU7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBsZXQgdHlwZSA9IGNoYXJUeXBlKGxpbmUuY2hhckNvZGVBdChpKSk7XG4gICAgICAgIGlmICh0eXBlID09IDUxMiAvKiBOU00gKi8pXG4gICAgICAgICAgICB0eXBlID0gcHJldjtcbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PSA4IC8qIEVOICovICYmIHByZXZTdHJvbmcgPT0gNCAvKiBBTCAqLylcbiAgICAgICAgICAgIHR5cGUgPSAxNiAvKiBBTiAqLztcbiAgICAgICAgdHlwZXNbaV0gPSB0eXBlID09IDQgLyogQUwgKi8gPyAyIC8qIFIgKi8gOiB0eXBlO1xuICAgICAgICBpZiAodHlwZSAmIDcgLyogU3Ryb25nICovKVxuICAgICAgICAgICAgcHJldlN0cm9uZyA9IHR5cGU7XG4gICAgICAgIHByZXYgPSB0eXBlO1xuICAgIH1cbiAgICAvLyBXNS4gQSBzZXF1ZW5jZSBvZiBFdXJvcGVhbiB0ZXJtaW5hdG9ycyBhZGphY2VudCB0byBFdXJvcGVhblxuICAgIC8vIG51bWJlcnMgY2hhbmdlcyB0byBhbGwgRXVyb3BlYW4gbnVtYmVycy5cbiAgICAvLyBXNi4gT3RoZXJ3aXNlLCBzZXBhcmF0b3JzIGFuZCB0ZXJtaW5hdG9ycyBjaGFuZ2UgdG8gT3RoZXJcbiAgICAvLyBOZXV0cmFsLlxuICAgIC8vIFc3LiBTZWFyY2ggYmFja3dhcmRzIGZyb20gZWFjaCBpbnN0YW5jZSBvZiBhIEV1cm9wZWFuIG51bWJlclxuICAgIC8vIHVudGlsIHRoZSBmaXJzdCBzdHJvbmcgdHlwZSAoUiwgTCwgb3Igc29yKSBpcyBmb3VuZC4gSWYgYW4gTCBpc1xuICAgIC8vIGZvdW5kLCB0aGVuIGNoYW5nZSB0aGUgdHlwZSBvZiB0aGUgRXVyb3BlYW4gbnVtYmVyIHRvIEwuXG4gICAgLy8gKExlZnQgYWZ0ZXIgdGhpczogTCwgUiwgRU4rQU4sIE5JKVxuICAgIGZvciAobGV0IGkgPSAwLCBwcmV2ID0gb3V0ZXJUeXBlLCBwcmV2U3Ryb25nID0gb3V0ZXJUeXBlOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbGV0IHR5cGUgPSB0eXBlc1tpXTtcbiAgICAgICAgaWYgKHR5cGUgPT0gMTI4IC8qIENTICovKSB7XG4gICAgICAgICAgICBpZiAoaSA8IGxlbiAtIDEgJiYgcHJldiA9PSB0eXBlc1tpICsgMV0gJiYgKHByZXYgJiAyNCAvKiBOdW0gKi8pKVxuICAgICAgICAgICAgICAgIHR5cGUgPSB0eXBlc1tpXSA9IHByZXY7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdHlwZXNbaV0gPSAyNTYgLyogTkkgKi87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PSA2NCAvKiBFVCAqLykge1xuICAgICAgICAgICAgbGV0IGVuZCA9IGkgKyAxO1xuICAgICAgICAgICAgd2hpbGUgKGVuZCA8IGxlbiAmJiB0eXBlc1tlbmRdID09IDY0IC8qIEVUICovKVxuICAgICAgICAgICAgICAgIGVuZCsrO1xuICAgICAgICAgICAgbGV0IHJlcGxhY2UgPSAoaSAmJiBwcmV2ID09IDggLyogRU4gKi8pIHx8IChlbmQgPCBsZW4gJiYgdHlwZXNbZW5kXSA9PSA4IC8qIEVOICovKSA/IChwcmV2U3Ryb25nID09IDEgLyogTCAqLyA/IDEgLyogTCAqLyA6IDggLyogRU4gKi8pIDogMjU2IC8qIE5JICovO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGk7IGogPCBlbmQ7IGorKylcbiAgICAgICAgICAgICAgICB0eXBlc1tqXSA9IHJlcGxhY2U7XG4gICAgICAgICAgICBpID0gZW5kIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09IDggLyogRU4gKi8gJiYgcHJldlN0cm9uZyA9PSAxIC8qIEwgKi8pIHtcbiAgICAgICAgICAgIHR5cGVzW2ldID0gMSAvKiBMICovO1xuICAgICAgICB9XG4gICAgICAgIHByZXYgPSB0eXBlO1xuICAgICAgICBpZiAodHlwZSAmIDcgLyogU3Ryb25nICovKVxuICAgICAgICAgICAgcHJldlN0cm9uZyA9IHR5cGU7XG4gICAgfVxuICAgIC8vIE4wLiBQcm9jZXNzIGJyYWNrZXQgcGFpcnMgaW4gYW4gaXNvbGF0aW5nIHJ1biBzZXF1ZW5jZVxuICAgIC8vIHNlcXVlbnRpYWxseSBpbiB0aGUgbG9naWNhbCBvcmRlciBvZiB0aGUgdGV4dCBwb3NpdGlvbnMgb2YgdGhlXG4gICAgLy8gb3BlbmluZyBwYWlyZWQgYnJhY2tldHMgdXNpbmcgdGhlIGxvZ2ljIGdpdmVuIGJlbG93LiBXaXRoaW4gdGhpc1xuICAgIC8vIHNjb3BlLCBiaWRpcmVjdGlvbmFsIHR5cGVzIEVOIGFuZCBBTiBhcmUgdHJlYXRlZCBhcyBSLlxuICAgIGZvciAobGV0IGkgPSAwLCBzSSA9IDAsIGNvbnRleHQgPSAwLCBjaCwgYnIsIHR5cGU7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAvLyBLZWVwcyBbc3RhcnRJbmRleCwgdHlwZSwgc3Ryb25nU2Vlbl0gdHJpcGxlcyBmb3IgZWFjaCBvcGVuXG4gICAgICAgIC8vIGJyYWNrZXQgb24gQnJhY2tldFN0YWNrLlxuICAgICAgICBpZiAoYnIgPSBCcmFja2V0c1tjaCA9IGxpbmUuY2hhckNvZGVBdChpKV0pIHtcbiAgICAgICAgICAgIGlmIChiciA8IDApIHsgLy8gQ2xvc2luZyBicmFja2V0XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgc0ogPSBzSSAtIDM7IHNKID49IDA7IHNKIC09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEJyYWNrZXRTdGFja1tzSiArIDFdID09IC1icikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZsYWdzID0gQnJhY2tldFN0YWNrW3NKICsgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdHlwZSA9IChmbGFncyAmIDIgLyogRW1iZWRJbnNpZGUgKi8pID8gb3V0ZXJUeXBlIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhKGZsYWdzICYgNCAvKiBPcHBvc2l0ZUluc2lkZSAqLykgPyAwIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZsYWdzICYgMSAvKiBPcHBvc2l0ZUJlZm9yZSAqLykgPyBvcHBvc2l0ZVR5cGUgOiBvdXRlclR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlc1tpXSA9IHR5cGVzW0JyYWNrZXRTdGFja1tzSl1dID0gdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNJID0gc0o7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEJyYWNrZXRTdGFjay5sZW5ndGggPT0gMTg5IC8qIE1heERlcHRoICovKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBCcmFja2V0U3RhY2tbc0krK10gPSBpO1xuICAgICAgICAgICAgICAgIEJyYWNrZXRTdGFja1tzSSsrXSA9IGNoO1xuICAgICAgICAgICAgICAgIEJyYWNrZXRTdGFja1tzSSsrXSA9IGNvbnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHR5cGUgPSB0eXBlc1tpXSkgPT0gMiAvKiBSICovIHx8IHR5cGUgPT0gMSAvKiBMICovKSB7XG4gICAgICAgICAgICBsZXQgZW1iZWQgPSB0eXBlID09IG91dGVyVHlwZTtcbiAgICAgICAgICAgIGNvbnRleHQgPSBlbWJlZCA/IDAgOiAxIC8qIE9wcG9zaXRlQmVmb3JlICovO1xuICAgICAgICAgICAgZm9yIChsZXQgc0ogPSBzSSAtIDM7IHNKID49IDA7IHNKIC09IDMpIHtcbiAgICAgICAgICAgICAgICBsZXQgY3VyID0gQnJhY2tldFN0YWNrW3NKICsgMl07XG4gICAgICAgICAgICAgICAgaWYgKGN1ciAmIDIgLyogRW1iZWRJbnNpZGUgKi8pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmIChlbWJlZCkge1xuICAgICAgICAgICAgICAgICAgICBCcmFja2V0U3RhY2tbc0ogKyAyXSB8PSAyIC8qIEVtYmVkSW5zaWRlICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1ciAmIDQgLyogT3Bwb3NpdGVJbnNpZGUgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgQnJhY2tldFN0YWNrW3NKICsgMl0gfD0gNCAvKiBPcHBvc2l0ZUluc2lkZSAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTjEuIEEgc2VxdWVuY2Ugb2YgbmV1dHJhbHMgdGFrZXMgdGhlIGRpcmVjdGlvbiBvZiB0aGVcbiAgICAvLyBzdXJyb3VuZGluZyBzdHJvbmcgdGV4dCBpZiB0aGUgdGV4dCBvbiBib3RoIHNpZGVzIGhhcyB0aGUgc2FtZVxuICAgIC8vIGRpcmVjdGlvbi4gRXVyb3BlYW4gYW5kIEFyYWJpYyBudW1iZXJzIGFjdCBhcyBpZiB0aGV5IHdlcmUgUiBpblxuICAgIC8vIHRlcm1zIG9mIHRoZWlyIGluZmx1ZW5jZSBvbiBuZXV0cmFscy4gU3RhcnQtb2YtbGV2ZWwtcnVuIChzb3IpXG4gICAgLy8gYW5kIGVuZC1vZi1sZXZlbC1ydW4gKGVvcikgYXJlIHVzZWQgYXQgbGV2ZWwgcnVuIGJvdW5kYXJpZXMuXG4gICAgLy8gTjIuIEFueSByZW1haW5pbmcgbmV1dHJhbHMgdGFrZSB0aGUgZW1iZWRkaW5nIGRpcmVjdGlvbi5cbiAgICAvLyAoTGVmdCBhZnRlciB0aGlzOiBMLCBSLCBFTitBTilcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICh0eXBlc1tpXSA9PSAyNTYgLyogTkkgKi8pIHtcbiAgICAgICAgICAgIGxldCBlbmQgPSBpICsgMTtcbiAgICAgICAgICAgIHdoaWxlIChlbmQgPCBsZW4gJiYgdHlwZXNbZW5kXSA9PSAyNTYgLyogTkkgKi8pXG4gICAgICAgICAgICAgICAgZW5kKys7XG4gICAgICAgICAgICBsZXQgYmVmb3JlTCA9IChpID8gdHlwZXNbaSAtIDFdIDogb3V0ZXJUeXBlKSA9PSAxIC8qIEwgKi87XG4gICAgICAgICAgICBsZXQgYWZ0ZXJMID0gKGVuZCA8IGxlbiA/IHR5cGVzW2VuZF0gOiBvdXRlclR5cGUpID09IDEgLyogTCAqLztcbiAgICAgICAgICAgIGxldCByZXBsYWNlID0gYmVmb3JlTCA9PSBhZnRlckwgPyAoYmVmb3JlTCA/IDEgLyogTCAqLyA6IDIgLyogUiAqLykgOiBvdXRlclR5cGU7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gaTsgaiA8IGVuZDsgaisrKVxuICAgICAgICAgICAgICAgIHR5cGVzW2pdID0gcmVwbGFjZTtcbiAgICAgICAgICAgIGkgPSBlbmQgLSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEhlcmUgd2UgZGVwYXJ0IGZyb20gdGhlIGRvY3VtZW50ZWQgYWxnb3JpdGhtLCBpbiBvcmRlciB0byBhdm9pZFxuICAgIC8vIGJ1aWxkaW5nIHVwIGFuIGFjdHVhbCBsZXZlbHMgYXJyYXkuIFNpbmNlIHRoZXJlIGFyZSBvbmx5IHRocmVlXG4gICAgLy8gbGV2ZWxzICgwLCAxLCAyKSBpbiBhbiBpbXBsZW1lbnRhdGlvbiB0aGF0IGRvZXNuJ3QgdGFrZVxuICAgIC8vIGV4cGxpY2l0IGVtYmVkZGluZyBpbnRvIGFjY291bnQsIHdlIGNhbiBidWlsZCB1cCB0aGUgb3JkZXIgb25cbiAgICAvLyB0aGUgZmx5LCB3aXRob3V0IGZvbGxvd2luZyB0aGUgbGV2ZWwtYmFzZWQgYWxnb3JpdGhtLlxuICAgIGxldCBvcmRlciA9IFtdO1xuICAgIGlmIChvdXRlclR5cGUgPT0gMSAvKiBMICovKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gaSwgcnRsID0gdHlwZXNbaSsrXSAhPSAxIC8qIEwgKi87XG4gICAgICAgICAgICB3aGlsZSAoaSA8IGxlbiAmJiBydGwgPT0gKHR5cGVzW2ldICE9IDEgLyogTCAqLykpXG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgaWYgKHJ0bCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBpOyBqID4gc3RhcnQ7KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlbmQgPSBqLCBsID0gdHlwZXNbLS1qXSAhPSAyIC8qIFIgKi87XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChqID4gc3RhcnQgJiYgbCA9PSAodHlwZXNbaiAtIDFdICE9IDIgLyogUiAqLykpXG4gICAgICAgICAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICAgICAgICAgIG9yZGVyLnB1c2gobmV3IEJpZGlTcGFuKGosIGVuZCwgbCA/IDIgOiAxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3JkZXIucHVzaChuZXcgQmlkaVNwYW4oc3RhcnQsIGksIDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBpLCBydGwgPSB0eXBlc1tpKytdID09IDIgLyogUiAqLztcbiAgICAgICAgICAgIHdoaWxlIChpIDwgbGVuICYmIHJ0bCA9PSAodHlwZXNbaV0gPT0gMiAvKiBSICovKSlcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBvcmRlci5wdXNoKG5ldyBCaWRpU3BhbihzdGFydCwgaSwgcnRsID8gMSA6IDIpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3JkZXI7XG59XG5mdW5jdGlvbiB0cml2aWFsT3JkZXIobGVuZ3RoKSB7XG4gICAgcmV0dXJuIFtuZXcgQmlkaVNwYW4oMCwgbGVuZ3RoLCAwKV07XG59XG5sZXQgbW92ZWRPdmVyID0gXCJcIjtcbmZ1bmN0aW9uIG1vdmVWaXN1YWxseShsaW5lLCBvcmRlciwgZGlyLCBzdGFydCwgZm9yd2FyZCkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgc3RhcnRJbmRleCA9IHN0YXJ0LmhlYWQgLSBsaW5lLmZyb20sIHNwYW5JID0gLTE7XG4gICAgaWYgKHN0YXJ0SW5kZXggPT0gMCkge1xuICAgICAgICBpZiAoIWZvcndhcmQgfHwgIWxpbmUubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChvcmRlclswXS5sZXZlbCAhPSBkaXIpIHtcbiAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBvcmRlclswXS5zaWRlKGZhbHNlLCBkaXIpO1xuICAgICAgICAgICAgc3BhbkkgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0YXJ0SW5kZXggPT0gbGluZS5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGZvcndhcmQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGxhc3QgPSBvcmRlcltvcmRlci5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGxhc3QubGV2ZWwgIT0gZGlyKSB7XG4gICAgICAgICAgICBzdGFydEluZGV4ID0gbGFzdC5zaWRlKHRydWUsIGRpcik7XG4gICAgICAgICAgICBzcGFuSSA9IG9yZGVyLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNwYW5JIDwgMClcbiAgICAgICAgc3BhbkkgPSBCaWRpU3Bhbi5maW5kKG9yZGVyLCBzdGFydEluZGV4LCAoX2EgPSBzdGFydC5iaWRpTGV2ZWwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IC0xLCBzdGFydC5hc3NvYyk7XG4gICAgbGV0IHNwYW4gPSBvcmRlcltzcGFuSV07XG4gICAgLy8gRW5kIG9mIHNwYW4uIChCdXQgbm90IGVuZCBvZiBsaW5lLS10aGF0IHdhcyBjaGVja2VkIGZvciBhYm92ZS4pXG4gICAgaWYgKHN0YXJ0SW5kZXggPT0gc3Bhbi5zaWRlKGZvcndhcmQsIGRpcikpIHtcbiAgICAgICAgc3BhbiA9IG9yZGVyW3NwYW5JICs9IGZvcndhcmQgPyAxIDogLTFdO1xuICAgICAgICBzdGFydEluZGV4ID0gc3Bhbi5zaWRlKCFmb3J3YXJkLCBkaXIpO1xuICAgIH1cbiAgICBsZXQgaW5kZXhGb3J3YXJkID0gZm9yd2FyZCA9PSAoc3Bhbi5kaXIgPT0gZGlyKTtcbiAgICBsZXQgbmV4dEluZGV4ID0gdGV4dC5maW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgc3RhcnRJbmRleCwgaW5kZXhGb3J3YXJkKTtcbiAgICBtb3ZlZE92ZXIgPSBsaW5lLnRleHQuc2xpY2UoTWF0aC5taW4oc3RhcnRJbmRleCwgbmV4dEluZGV4KSwgTWF0aC5tYXgoc3RhcnRJbmRleCwgbmV4dEluZGV4KSk7XG4gICAgaWYgKG5leHRJbmRleCAhPSBzcGFuLnNpZGUoZm9yd2FyZCwgZGlyKSlcbiAgICAgICAgcmV0dXJuIHN0YXRlLkVkaXRvclNlbGVjdGlvbi5jdXJzb3IobmV4dEluZGV4ICsgbGluZS5mcm9tLCBpbmRleEZvcndhcmQgPyAtMSA6IDEsIHNwYW4ubGV2ZWwpO1xuICAgIGxldCBuZXh0U3BhbiA9IHNwYW5JID09IChmb3J3YXJkID8gb3JkZXIubGVuZ3RoIC0gMSA6IDApID8gbnVsbCA6IG9yZGVyW3NwYW5JICsgKGZvcndhcmQgPyAxIDogLTEpXTtcbiAgICBpZiAoIW5leHRTcGFuICYmIHNwYW4ubGV2ZWwgIT0gZGlyKVxuICAgICAgICByZXR1cm4gc3RhdGUuRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihmb3J3YXJkID8gbGluZS50byA6IGxpbmUuZnJvbSwgZm9yd2FyZCA/IC0xIDogMSwgZGlyKTtcbiAgICBpZiAobmV4dFNwYW4gJiYgbmV4dFNwYW4ubGV2ZWwgPCBzcGFuLmxldmVsKVxuICAgICAgICByZXR1cm4gc3RhdGUuRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihuZXh0U3Bhbi5zaWRlKCFmb3J3YXJkLCBkaXIpICsgbGluZS5mcm9tLCBmb3J3YXJkID8gMSA6IC0xLCBuZXh0U3Bhbi5sZXZlbCk7XG4gICAgcmV0dXJuIHN0YXRlLkVkaXRvclNlbGVjdGlvbi5jdXJzb3IobmV4dEluZGV4ICsgbGluZS5mcm9tLCBmb3J3YXJkID8gLTEgOiAxLCBzcGFuLmxldmVsKTtcbn1cblxuZnVuY3Rpb24gZ3JvdXBBdChzdGF0ZSQxLCBwb3MsIGJpYXMgPSAxKSB7XG4gICAgbGV0IGNhdGVnb3JpemUgPSBzdGF0ZSQxLmNoYXJDYXRlZ29yaXplcihwb3MpO1xuICAgIGxldCBsaW5lID0gc3RhdGUkMS5kb2MubGluZUF0KHBvcyksIGxpbmVQb3MgPSBwb3MgLSBsaW5lLmZyb207XG4gICAgaWYgKGxpbmUubGVuZ3RoID09IDApXG4gICAgICAgIHJldHVybiBzdGF0ZS5FZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcyk7XG4gICAgaWYgKGxpbmVQb3MgPT0gMClcbiAgICAgICAgYmlhcyA9IDE7XG4gICAgZWxzZSBpZiAobGluZVBvcyA9PSBsaW5lLmxlbmd0aClcbiAgICAgICAgYmlhcyA9IC0xO1xuICAgIGxldCBmcm9tID0gbGluZVBvcywgdG8gPSBsaW5lUG9zO1xuICAgIGlmIChiaWFzIDwgMClcbiAgICAgICAgZnJvbSA9IHRleHQuZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIGxpbmVQb3MsIGZhbHNlKTtcbiAgICBlbHNlXG4gICAgICAgIHRvID0gdGV4dC5maW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgbGluZVBvcyk7XG4gICAgbGV0IGNhdCA9IGNhdGVnb3JpemUobGluZS50ZXh0LnNsaWNlKGZyb20sIHRvKSk7XG4gICAgd2hpbGUgKGZyb20gPiAwKSB7XG4gICAgICAgIGxldCBwcmV2ID0gdGV4dC5maW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgZnJvbSwgZmFsc2UpO1xuICAgICAgICBpZiAoY2F0ZWdvcml6ZShsaW5lLnRleHQuc2xpY2UocHJldiwgZnJvbSkpICE9IGNhdClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBmcm9tID0gcHJldjtcbiAgICB9XG4gICAgd2hpbGUgKHRvIDwgbGluZS5sZW5ndGgpIHtcbiAgICAgICAgbGV0IG5leHQgPSB0ZXh0LmZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCB0byk7XG4gICAgICAgIGlmIChjYXRlZ29yaXplKGxpbmUudGV4dC5zbGljZSh0bywgbmV4dCkpICE9IGNhdClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB0byA9IG5leHQ7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS5FZGl0b3JTZWxlY3Rpb24ucmFuZ2UoZnJvbSArIGxpbmUuZnJvbSwgdG8gKyBsaW5lLmZyb20pO1xufVxuLy8gU2VhcmNoIHRoZSBET00gZm9yIHRoZSB7bm9kZSwgb2Zmc2V0fSBwb3NpdGlvbiBjbG9zZXN0IHRvIHRoZSBnaXZlblxuLy8gY29vcmRpbmF0ZXMuIFZlcnkgaW5lZmZpY2llbnQgYW5kIGNydWRlLCBidXQgY2FuIHVzdWFsbHkgYmUgYXZvaWRlZFxuLy8gYnkgY2FsbGluZyBjYXJldChQb3NpdGlvbnxSYW5nZSlGcm9tUG9pbnQgaW5zdGVhZC5cbi8vIEZJWE1FIGhvbGRpbmcgYXJyb3ctdXAvZG93biBhdCB0aGUgZW5kIG9mIHRoZSB2aWV3cG9ydCBpcyBhIHJhdGhlclxuLy8gY29tbW9uIHVzZSBjYXNlIHRoYXQgd2lsbCByZXBlYXRlZGx5IHRyaWdnZXIgdGhpcyBjb2RlLiBNYXliZVxuLy8gaW50cm9kdWNlIHNvbWUgZWxlbWVudCBvZiBiaW5hcnkgc2VhcmNoIGFmdGVyIGFsbD9cbmZ1bmN0aW9uIGdldGR4KHgsIHJlY3QpIHtcbiAgICByZXR1cm4gcmVjdC5sZWZ0ID4geCA/IHJlY3QubGVmdCAtIHggOiBNYXRoLm1heCgwLCB4IC0gcmVjdC5yaWdodCk7XG59XG5mdW5jdGlvbiBnZXRkeSh5LCByZWN0KSB7XG4gICAgcmV0dXJuIHJlY3QudG9wID4geSA/IHJlY3QudG9wIC0geSA6IE1hdGgubWF4KDAsIHkgLSByZWN0LmJvdHRvbSk7XG59XG5mdW5jdGlvbiB5T3ZlcmxhcChhLCBiKSB7XG4gICAgcmV0dXJuIGEudG9wIDwgYi5ib3R0b20gLSAxICYmIGEuYm90dG9tID4gYi50b3AgKyAxO1xufVxuZnVuY3Rpb24gdXBUb3AocmVjdCwgdG9wKSB7XG4gICAgcmV0dXJuIHRvcCA8IHJlY3QudG9wID8geyB0b3AsIGxlZnQ6IHJlY3QubGVmdCwgcmlnaHQ6IHJlY3QucmlnaHQsIGJvdHRvbTogcmVjdC5ib3R0b20gfSA6IHJlY3Q7XG59XG5mdW5jdGlvbiB1cEJvdChyZWN0LCBib3R0b20pIHtcbiAgICByZXR1cm4gYm90dG9tID4gcmVjdC5ib3R0b20gPyB7IHRvcDogcmVjdC50b3AsIGxlZnQ6IHJlY3QubGVmdCwgcmlnaHQ6IHJlY3QucmlnaHQsIGJvdHRvbSB9IDogcmVjdDtcbn1cbmZ1bmN0aW9uIGRvbVBvc0F0Q29vcmRzKHBhcmVudCwgeCwgeSkge1xuICAgIGxldCBjbG9zZXN0LCBjbG9zZXN0UmVjdCwgY2xvc2VzdFgsIGNsb3Nlc3RZO1xuICAgIGxldCBhYm92ZSwgYmVsb3csIGFib3ZlUmVjdCwgYmVsb3dSZWN0O1xuICAgIGZvciAobGV0IGNoaWxkID0gcGFyZW50LmZpcnN0Q2hpbGQ7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKSB7XG4gICAgICAgIGxldCByZWN0cyA9IGNsaWVudFJlY3RzRm9yKGNoaWxkKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJlY3QgPSByZWN0c1tpXTtcbiAgICAgICAgICAgIGlmIChjbG9zZXN0UmVjdCAmJiB5T3ZlcmxhcChjbG9zZXN0UmVjdCwgcmVjdCkpXG4gICAgICAgICAgICAgICAgcmVjdCA9IHVwVG9wKHVwQm90KHJlY3QsIGNsb3Nlc3RSZWN0LmJvdHRvbSksIGNsb3Nlc3RSZWN0LnRvcCk7XG4gICAgICAgICAgICBsZXQgZHggPSBnZXRkeCh4LCByZWN0KSwgZHkgPSBnZXRkeSh5LCByZWN0KTtcbiAgICAgICAgICAgIGlmIChkeCA9PSAwICYmIGR5ID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLm5vZGVUeXBlID09IDMgPyBkb21Qb3NJblRleHQoY2hpbGQsIHgsIHkpIDogZG9tUG9zQXRDb29yZHMoY2hpbGQsIHgsIHkpO1xuICAgICAgICAgICAgaWYgKCFjbG9zZXN0IHx8IGNsb3Nlc3RZID4gZHkgfHwgY2xvc2VzdFkgPT0gZHkgJiYgY2xvc2VzdFggPiBkeCkge1xuICAgICAgICAgICAgICAgIGNsb3Nlc3QgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICBjbG9zZXN0UmVjdCA9IHJlY3Q7XG4gICAgICAgICAgICAgICAgY2xvc2VzdFggPSBkeDtcbiAgICAgICAgICAgICAgICBjbG9zZXN0WSA9IGR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGR4ID09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoeSA+IHJlY3QuYm90dG9tICYmICghYWJvdmVSZWN0IHx8IGFib3ZlUmVjdC5ib3R0b20gPCByZWN0LmJvdHRvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWJvdmUgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgYWJvdmVSZWN0ID0gcmVjdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoeSA8IHJlY3QudG9wICYmICghYmVsb3dSZWN0IHx8IGJlbG93UmVjdC50b3AgPiByZWN0LnRvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVsb3cgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgYmVsb3dSZWN0ID0gcmVjdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhYm92ZVJlY3QgJiYgeU92ZXJsYXAoYWJvdmVSZWN0LCByZWN0KSkge1xuICAgICAgICAgICAgICAgIGFib3ZlUmVjdCA9IHVwQm90KGFib3ZlUmVjdCwgcmVjdC5ib3R0b20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmVsb3dSZWN0ICYmIHlPdmVybGFwKGJlbG93UmVjdCwgcmVjdCkpIHtcbiAgICAgICAgICAgICAgICBiZWxvd1JlY3QgPSB1cFRvcChiZWxvd1JlY3QsIHJlY3QudG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYWJvdmVSZWN0ICYmIGFib3ZlUmVjdC5ib3R0b20gPj0geSkge1xuICAgICAgICBjbG9zZXN0ID0gYWJvdmU7XG4gICAgICAgIGNsb3Nlc3RSZWN0ID0gYWJvdmVSZWN0O1xuICAgIH1cbiAgICBlbHNlIGlmIChiZWxvd1JlY3QgJiYgYmVsb3dSZWN0LnRvcCA8PSB5KSB7XG4gICAgICAgIGNsb3Nlc3QgPSBiZWxvdztcbiAgICAgICAgY2xvc2VzdFJlY3QgPSBiZWxvd1JlY3Q7XG4gICAgfVxuICAgIGlmICghY2xvc2VzdClcbiAgICAgICAgcmV0dXJuIHsgbm9kZTogcGFyZW50LCBvZmZzZXQ6IDAgfTtcbiAgICBsZXQgY2xpcFggPSBNYXRoLm1heChjbG9zZXN0UmVjdC5sZWZ0LCBNYXRoLm1pbihjbG9zZXN0UmVjdC5yaWdodCwgeCkpO1xuICAgIGlmIChjbG9zZXN0Lm5vZGVUeXBlID09IDMpXG4gICAgICAgIHJldHVybiBkb21Qb3NJblRleHQoY2xvc2VzdCwgY2xpcFgsIHkpO1xuICAgIGlmICghY2xvc2VzdFggJiYgY2xvc2VzdC5jb250ZW50RWRpdGFibGUgPT0gXCJ0cnVlXCIpXG4gICAgICAgIHJldHVybiBkb21Qb3NBdENvb3JkcyhjbG9zZXN0LCBjbGlwWCwgeSk7XG4gICAgbGV0IG9mZnNldCA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwocGFyZW50LmNoaWxkTm9kZXMsIGNsb3Nlc3QpICtcbiAgICAgICAgKHggPj0gKGNsb3Nlc3RSZWN0LmxlZnQgKyBjbG9zZXN0UmVjdC5yaWdodCkgLyAyID8gMSA6IDApO1xuICAgIHJldHVybiB7IG5vZGU6IHBhcmVudCwgb2Zmc2V0IH07XG59XG5mdW5jdGlvbiBkb21Qb3NJblRleHQobm9kZSwgeCwgeSkge1xuICAgIGxldCBsZW4gPSBub2RlLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgbGV0IGNsb3Nlc3RPZmZzZXQgPSAtMSwgY2xvc2VzdERZID0gMWU5LCBnZW5lcmFsU2lkZSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBsZXQgcmVjdHMgPSB0ZXh0UmFuZ2Uobm9kZSwgaSwgaSArIDEpLmdldENsaWVudFJlY3RzKCk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmVjdHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGxldCByZWN0ID0gcmVjdHNbal07XG4gICAgICAgICAgICBpZiAocmVjdC50b3AgPT0gcmVjdC5ib3R0b20pXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoIWdlbmVyYWxTaWRlKVxuICAgICAgICAgICAgICAgIGdlbmVyYWxTaWRlID0geCAtIHJlY3QubGVmdDtcbiAgICAgICAgICAgIGxldCBkeSA9IChyZWN0LnRvcCA+IHkgPyByZWN0LnRvcCAtIHkgOiB5IC0gcmVjdC5ib3R0b20pIC0gMTtcbiAgICAgICAgICAgIGlmIChyZWN0LmxlZnQgLSAxIDw9IHggJiYgcmVjdC5yaWdodCArIDEgPj0geCAmJiBkeSA8IGNsb3Nlc3REWSkge1xuICAgICAgICAgICAgICAgIGxldCByaWdodCA9IHggPj0gKHJlY3QubGVmdCArIHJlY3QucmlnaHQpIC8gMiwgYWZ0ZXIgPSByaWdodDtcbiAgICAgICAgICAgICAgICBpZiAoYnJvd3Nlci5jaHJvbWUgfHwgYnJvd3Nlci5nZWNrbykge1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgUlRMIG9uIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBnZXR0aW5nIGNsaWVudFxuICAgICAgICAgICAgICAgICAgICAvLyByZWN0cyBmb3IgZW1wdHkgcmFuZ2VzLlxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVjdEJlZm9yZSA9IHRleHRSYW5nZShub2RlLCBpKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY3RCZWZvcmUubGVmdCA9PSByZWN0LnJpZ2h0KVxuICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXIgPSAhcmlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkeSA8PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBub2RlLCBvZmZzZXQ6IGkgKyAoYWZ0ZXIgPyAxIDogMCkgfTtcbiAgICAgICAgICAgICAgICBjbG9zZXN0T2Zmc2V0ID0gaSArIChhZnRlciA/IDEgOiAwKTtcbiAgICAgICAgICAgICAgICBjbG9zZXN0RFkgPSBkeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBub2RlLCBvZmZzZXQ6IGNsb3Nlc3RPZmZzZXQgPiAtMSA/IGNsb3Nlc3RPZmZzZXQgOiBnZW5lcmFsU2lkZSA+IDAgPyBub2RlLm5vZGVWYWx1ZS5sZW5ndGggOiAwIH07XG59XG5mdW5jdGlvbiBwb3NBdENvb3Jkcyh2aWV3LCB7IHgsIHkgfSwgYmlhcyA9IC0xKSB7XG4gICAgbGV0IGNvbnRlbnQgPSB2aWV3LmNvbnRlbnRET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGJsb2NrO1xuICAgIGxldCBoYWxmTGluZSA9IHZpZXcuZGVmYXVsdExpbmVIZWlnaHQgLyAyO1xuICAgIGZvciAobGV0IGJvdW5jZWQgPSBmYWxzZTs7KSB7XG4gICAgICAgIGJsb2NrID0gdmlldy5ibG9ja0F0SGVpZ2h0KHksIGNvbnRlbnQudG9wKTtcbiAgICAgICAgaWYgKGJsb2NrLnRvcCA+IHkgfHwgYmxvY2suYm90dG9tIDwgeSkge1xuICAgICAgICAgICAgYmlhcyA9IGJsb2NrLnRvcCA+IHkgPyAtMSA6IDE7XG4gICAgICAgICAgICB5ID0gTWF0aC5taW4oYmxvY2suYm90dG9tIC0gaGFsZkxpbmUsIE1hdGgubWF4KGJsb2NrLnRvcCArIGhhbGZMaW5lLCB5KSk7XG4gICAgICAgICAgICBpZiAoYm91bmNlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYm91bmNlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJsb2NrLnR5cGUgPT0gZXhwb3J0cy5CbG9ja1R5cGUuVGV4dClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB5ID0gYmlhcyA+IDAgPyBibG9jay5ib3R0b20gKyBoYWxmTGluZSA6IGJsb2NrLnRvcCAtIGhhbGZMaW5lO1xuICAgIH1cbiAgICBsZXQgbGluZVN0YXJ0ID0gYmxvY2suZnJvbTtcbiAgICAvLyBJZiB0aGlzIGlzIG91dHNpZGUgb2YgdGhlIHJlbmRlcmVkIHZpZXdwb3J0LCB3ZSBjYW4ndCBkZXRlcm1pbmUgYSBwb3NpdGlvblxuICAgIGlmIChsaW5lU3RhcnQgPCB2aWV3LnZpZXdwb3J0LmZyb20pXG4gICAgICAgIHJldHVybiB2aWV3LnZpZXdwb3J0LmZyb20gPT0gMCA/IDAgOiBudWxsO1xuICAgIGlmIChsaW5lU3RhcnQgPiB2aWV3LnZpZXdwb3J0LnRvKVxuICAgICAgICByZXR1cm4gdmlldy52aWV3cG9ydC50byA9PSB2aWV3LnN0YXRlLmRvYy5sZW5ndGggPyB2aWV3LnN0YXRlLmRvYy5sZW5ndGggOiBudWxsO1xuICAgIC8vIENsaXAgeCB0byB0aGUgdmlld3BvcnQgc2lkZXNcbiAgICB4ID0gTWF0aC5tYXgoY29udGVudC5sZWZ0ICsgMSwgTWF0aC5taW4oY29udGVudC5yaWdodCAtIDEsIHgpKTtcbiAgICBsZXQgcm9vdCA9IHZpZXcucm9vdCwgZWxlbWVudCA9IHJvb3QuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcbiAgICAvLyBUaGVyZSdzIHZpc2libGUgZWRpdG9yIGNvbnRlbnQgdW5kZXIgdGhlIHBvaW50LCBzbyB3ZSBjYW4gdHJ5XG4gICAgLy8gdXNpbmcgY2FyZXQoUG9zaXRpb258UmFuZ2UpRnJvbVBvaW50IGFzIGEgc2hvcnRjdXRcbiAgICBsZXQgbm9kZSwgb2Zmc2V0ID0gLTE7XG4gICAgaWYgKGVsZW1lbnQgJiYgdmlldy5jb250ZW50RE9NLmNvbnRhaW5zKGVsZW1lbnQpICYmICEodmlldy5kb2NWaWV3Lm5lYXJlc3QoZWxlbWVudCkgaW5zdGFuY2VvZiBXaWRnZXRWaWV3KSkge1xuICAgICAgICBpZiAocm9vdC5jYXJldFBvc2l0aW9uRnJvbVBvaW50KSB7XG4gICAgICAgICAgICBsZXQgcG9zID0gcm9vdC5jYXJldFBvc2l0aW9uRnJvbVBvaW50KHgsIHkpO1xuICAgICAgICAgICAgaWYgKHBvcylcbiAgICAgICAgICAgICAgICAoeyBvZmZzZXROb2RlOiBub2RlLCBvZmZzZXQgfSA9IHBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocm9vdC5jYXJldFJhbmdlRnJvbVBvaW50KSB7XG4gICAgICAgICAgICBsZXQgcmFuZ2UgPSByb290LmNhcmV0UmFuZ2VGcm9tUG9pbnQoeCwgeSk7XG4gICAgICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAoeyBzdGFydENvbnRhaW5lcjogbm9kZSwgc3RhcnRPZmZzZXQ6IG9mZnNldCB9ID0gcmFuZ2UpO1xuICAgICAgICAgICAgICAgIGlmIChicm93c2VyLnNhZmFyaSAmJiBpc1N1c3BpY2lvdXNDYXJldFJlc3VsdChub2RlLCBvZmZzZXQsIHgpKVxuICAgICAgICAgICAgICAgICAgICBub2RlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIE5vIGx1Y2ssIGRvIG91ciBvd24gKHBvdGVudGlhbGx5IGV4cGVuc2l2ZSkgc2VhcmNoXG4gICAgaWYgKCFub2RlIHx8ICF2aWV3LmRvY1ZpZXcuZG9tLmNvbnRhaW5zKG5vZGUpKSB7XG4gICAgICAgIGxldCBsaW5lID0gTGluZVZpZXcuZmluZCh2aWV3LmRvY1ZpZXcsIGxpbmVTdGFydCk7XG4gICAgICAgICh7IG5vZGUsIG9mZnNldCB9ID0gZG9tUG9zQXRDb29yZHMobGluZS5kb20sIHgsIHkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKG5vZGUsIG9mZnNldCk7XG59XG4vLyBJbiBjYXNlIG9mIGEgaGlnaCBsaW5lIGhlaWdodCwgU2FmYXJpJ3MgY2FyZXRSYW5nZUZyb21Qb2ludCB0cmVhdHNcbi8vIHRoZSBzcGFjZSBiZXR3ZWVuIGxpbmVzIGFzIGJlbG9uZ2luZyB0byB0aGUgbGFzdCBjaGFyYWN0ZXIgb2YgdGhlXG4vLyBsaW5lIGJlZm9yZS4gVGhpcyBpcyB1c2VkIHRvIGRldGVjdCBzdWNoIGEgcmVzdWx0IHNvIHRoYXQgaXQgY2FuIGJlXG4vLyBpZ25vcmVkIChpc3N1ZSAjNDAxKS5cbmZ1bmN0aW9uIGlzU3VzcGljaW91c0NhcmV0UmVzdWx0KG5vZGUsIG9mZnNldCwgeCkge1xuICAgIGxldCBsZW47XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgIT0gMyB8fCBvZmZzZXQgIT0gKGxlbiA9IG5vZGUubm9kZVZhbHVlLmxlbmd0aCkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBuZXh0ID0gbm9kZS5uZXh0U2libGluZzsgbmV4dDsgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmcpXG4gICAgICAgIGlmIChuZXh0Lm5vZGVUeXBlICE9IDEgfHwgbmV4dC5ub2RlTmFtZSAhPSBcIkJSXCIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRleHRSYW5nZShub2RlLCBsZW4gLSAxLCBsZW4pLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgPiB4O1xufVxuZnVuY3Rpb24gbW92ZVRvTGluZUJvdW5kYXJ5KHZpZXcsIHN0YXJ0LCBmb3J3YXJkLCBpbmNsdWRlV3JhcCkge1xuICAgIGxldCBsaW5lID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KHN0YXJ0LmhlYWQpO1xuICAgIGxldCBjb29yZHMgPSAhaW5jbHVkZVdyYXAgfHwgIXZpZXcubGluZVdyYXBwaW5nID8gbnVsbFxuICAgICAgICA6IHZpZXcuY29vcmRzQXRQb3Moc3RhcnQuYXNzb2MgPCAwICYmIHN0YXJ0LmhlYWQgPiBsaW5lLmZyb20gPyBzdGFydC5oZWFkIC0gMSA6IHN0YXJ0LmhlYWQpO1xuICAgIGlmIChjb29yZHMpIHtcbiAgICAgICAgbGV0IGVkaXRvclJlY3QgPSB2aWV3LmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IHBvcyA9IHZpZXcucG9zQXRDb29yZHMoeyB4OiBmb3J3YXJkID09ICh2aWV3LnRleHREaXJlY3Rpb24gPT0gZXhwb3J0cy5EaXJlY3Rpb24uTFRSKSA/IGVkaXRvclJlY3QucmlnaHQgLSAxIDogZWRpdG9yUmVjdC5sZWZ0ICsgMSxcbiAgICAgICAgICAgIHk6IChjb29yZHMudG9wICsgY29vcmRzLmJvdHRvbSkgLyAyIH0pO1xuICAgICAgICBpZiAocG9zICE9IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gc3RhdGUuRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MsIGZvcndhcmQgPyAtMSA6IDEpO1xuICAgIH1cbiAgICBsZXQgbGluZVZpZXcgPSBMaW5lVmlldy5maW5kKHZpZXcuZG9jVmlldywgc3RhcnQuaGVhZCk7XG4gICAgbGV0IGVuZCA9IGxpbmVWaWV3ID8gKGZvcndhcmQgPyBsaW5lVmlldy5wb3NBdEVuZCA6IGxpbmVWaWV3LnBvc0F0U3RhcnQpIDogKGZvcndhcmQgPyBsaW5lLnRvIDogbGluZS5mcm9tKTtcbiAgICByZXR1cm4gc3RhdGUuRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihlbmQsIGZvcndhcmQgPyAtMSA6IDEpO1xufVxuZnVuY3Rpb24gbW92ZUJ5Q2hhcih2aWV3LCBzdGFydCwgZm9yd2FyZCwgYnkpIHtcbiAgICBsZXQgbGluZSA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChzdGFydC5oZWFkKSwgc3BhbnMgPSB2aWV3LmJpZGlTcGFucyhsaW5lKTtcbiAgICBmb3IgKGxldCBjdXIgPSBzdGFydCwgY2hlY2sgPSBudWxsOzspIHtcbiAgICAgICAgbGV0IG5leHQgPSBtb3ZlVmlzdWFsbHkobGluZSwgc3BhbnMsIHZpZXcudGV4dERpcmVjdGlvbiwgY3VyLCBmb3J3YXJkKSwgY2hhciA9IG1vdmVkT3ZlcjtcbiAgICAgICAgaWYgKCFuZXh0KSB7XG4gICAgICAgICAgICBpZiAobGluZS5udW1iZXIgPT0gKGZvcndhcmQgPyB2aWV3LnN0YXRlLmRvYy5saW5lcyA6IDEpKVxuICAgICAgICAgICAgICAgIHJldHVybiBjdXI7XG4gICAgICAgICAgICBjaGFyID0gXCJcXG5cIjtcbiAgICAgICAgICAgIGxpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lKGxpbmUubnVtYmVyICsgKGZvcndhcmQgPyAxIDogLTEpKTtcbiAgICAgICAgICAgIHNwYW5zID0gdmlldy5iaWRpU3BhbnMobGluZSk7XG4gICAgICAgICAgICBuZXh0ID0gc3RhdGUuRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihmb3J3YXJkID8gbGluZS5mcm9tIDogbGluZS50byk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjaGVjaykge1xuICAgICAgICAgICAgaWYgKCFieSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIGNoZWNrID0gYnkoY2hhcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWNoZWNrKGNoYXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VyO1xuICAgICAgICB9XG4gICAgICAgIGN1ciA9IG5leHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gYnlHcm91cCh2aWV3LCBwb3MsIHN0YXJ0KSB7XG4gICAgbGV0IGNhdGVnb3JpemUgPSB2aWV3LnN0YXRlLmNoYXJDYXRlZ29yaXplcihwb3MpO1xuICAgIGxldCBjYXQgPSBjYXRlZ29yaXplKHN0YXJ0KTtcbiAgICByZXR1cm4gKG5leHQpID0+IHtcbiAgICAgICAgbGV0IG5leHRDYXQgPSBjYXRlZ29yaXplKG5leHQpO1xuICAgICAgICBpZiAoY2F0ID09IHN0YXRlLkNoYXJDYXRlZ29yeS5TcGFjZSlcbiAgICAgICAgICAgIGNhdCA9IG5leHRDYXQ7XG4gICAgICAgIHJldHVybiBjYXQgPT0gbmV4dENhdDtcbiAgICB9O1xufVxuZnVuY3Rpb24gbW92ZVZlcnRpY2FsbHkodmlldywgc3RhcnQsIGZvcndhcmQsIGRpc3RhbmNlKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBzdGFydFBvcyA9IHN0YXJ0LmhlYWQsIGRpciA9IGZvcndhcmQgPyAxIDogLTE7XG4gICAgaWYgKHN0YXJ0UG9zID09IChmb3J3YXJkID8gdmlldy5zdGF0ZS5kb2MubGVuZ3RoIDogMCkpXG4gICAgICAgIHJldHVybiBzdGF0ZS5FZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHN0YXJ0UG9zKTtcbiAgICBsZXQgc3RhcnRDb29yZHMgPSB2aWV3LmNvb3Jkc0F0UG9zKHN0YXJ0UG9zKTtcbiAgICBpZiAoc3RhcnRDb29yZHMpIHtcbiAgICAgICAgbGV0IHJlY3QgPSB2aWV3LmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IGdvYWwgPSAoX2EgPSBzdGFydC5nb2FsQ29sdW1uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBzdGFydENvb3Jkcy5sZWZ0IC0gcmVjdC5sZWZ0O1xuICAgICAgICBsZXQgcmVzb2x2ZWRHb2FsID0gcmVjdC5sZWZ0ICsgZ29hbDtcbiAgICAgICAgbGV0IGRpc3QgPSBkaXN0YW5jZSAhPT0gbnVsbCAmJiBkaXN0YW5jZSAhPT0gdm9pZCAwID8gZGlzdGFuY2UgOiAodmlldy5kZWZhdWx0TGluZUhlaWdodCA+PiAxKTtcbiAgICAgICAgZm9yIChsZXQgc3RhcnRZID0gZGlyIDwgMCA/IHN0YXJ0Q29vcmRzLnRvcCA6IHN0YXJ0Q29vcmRzLmJvdHRvbSwgZXh0cmEgPSAwOyBleHRyYSA8IDUwOyBleHRyYSArPSAxMCkge1xuICAgICAgICAgICAgbGV0IHBvcyA9IHBvc0F0Q29vcmRzKHZpZXcsIHsgeDogcmVzb2x2ZWRHb2FsLCB5OiBzdGFydFkgKyAoZGlzdCArIGV4dHJhKSAqIGRpciB9LCBkaXIpO1xuICAgICAgICAgICAgaWYgKHBvcyA9PSBudWxsKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKHBvcyAhPSBzdGFydFBvcylcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUuRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBnb2FsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBPdXRzaWRlIG9mIHRoZSBkcmF3biB2aWV3cG9ydCwgdXNlIGEgY3J1ZGUgY29sdW1uLWJhc2VkIGFwcHJvYWNoXG4gICAgbGV0IHsgZG9jIH0gPSB2aWV3LnN0YXRlLCBsaW5lID0gZG9jLmxpbmVBdChzdGFydFBvcyksIHRhYlNpemUgPSB2aWV3LnN0YXRlLnRhYlNpemU7XG4gICAgbGV0IGdvYWwgPSBzdGFydC5nb2FsQ29sdW1uLCBnb2FsQ29sID0gMDtcbiAgICBpZiAoZ29hbCA9PSBudWxsKSB7XG4gICAgICAgIGZvciAoY29uc3QgaXRlciA9IGRvYy5pdGVyUmFuZ2UobGluZS5mcm9tLCBzdGFydFBvcyk7ICFpdGVyLm5leHQoKS5kb25lOylcbiAgICAgICAgICAgIGdvYWxDb2wgPSB0ZXh0LmNvdW50Q29sdW1uKGl0ZXIudmFsdWUsIGdvYWxDb2wsIHRhYlNpemUpO1xuICAgICAgICBnb2FsID0gZ29hbENvbCAqIHZpZXcuZGVmYXVsdENoYXJhY3RlcldpZHRoO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ29hbENvbCA9IE1hdGgucm91bmQoZ29hbCAvIHZpZXcuZGVmYXVsdENoYXJhY3RlcldpZHRoKTtcbiAgICB9XG4gICAgaWYgKGRpciA8IDAgJiYgbGluZS5mcm9tID09IDApXG4gICAgICAgIHJldHVybiBzdGF0ZS5FZGl0b3JTZWxlY3Rpb24uY3Vyc29yKDApO1xuICAgIGVsc2UgaWYgKGRpciA+IDAgJiYgbGluZS50byA9PSBkb2MubGVuZ3RoKVxuICAgICAgICByZXR1cm4gc3RhdGUuRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihsaW5lLnRvKTtcbiAgICBsZXQgb3RoZXJMaW5lID0gZG9jLmxpbmUobGluZS5udW1iZXIgKyBkaXIpO1xuICAgIGxldCByZXN1bHQgPSBvdGhlckxpbmUuZnJvbTtcbiAgICBsZXQgc2VlbiA9IDA7XG4gICAgZm9yIChjb25zdCBpdGVyID0gZG9jLml0ZXJSYW5nZShvdGhlckxpbmUuZnJvbSwgb3RoZXJMaW5lLnRvKTsgc2VlbiA+PSBnb2FsQ29sICYmICFpdGVyLm5leHQoKS5kb25lOykge1xuICAgICAgICBjb25zdCB7IG9mZnNldCwgbGVmdE92ZXIgfSA9IHRleHQuZmluZENvbHVtbihpdGVyLnZhbHVlLCBzZWVuLCBnb2FsQ29sLCB0YWJTaXplKTtcbiAgICAgICAgc2VlbiA9IGdvYWxDb2wgLSBsZWZ0T3ZlcjtcbiAgICAgICAgcmVzdWx0ICs9IG9mZnNldDtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlLkVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmVzdWx0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZ29hbCk7XG59XG5cbi8vIFRoaXMgd2lsbCBhbHNvIGJlIHdoZXJlIGRyYWdnaW5nIGluZm8gYW5kIHN1Y2ggZ29lc1xuY2xhc3MgSW5wdXRTdGF0ZSB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLmxhc3RLZXlDb2RlID0gMDtcbiAgICAgICAgdGhpcy5sYXN0S2V5VGltZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdElPU0VudGVyID0gMDtcbiAgICAgICAgdGhpcy5sYXN0SU9TQmFja3NwYWNlID0gMDtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uT3JpZ2luID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uVGltZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdEVzY1ByZXNzID0gMDtcbiAgICAgICAgdGhpcy5zY3JvbGxIYW5kbGVycyA9IFtdO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5jdXN0b21IYW5kbGVycyA9IFtdO1xuICAgICAgICAvLyAtMSBtZWFucyBub3QgaW4gYSBjb21wb3NpdGlvbi4gT3RoZXJ3aXNlLCB0aGlzIGNvdW50cyB0aGUgbnVtYmVyXG4gICAgICAgIC8vIG9mIGNoYW5nZXMgbWFkZSBkdXJpbmcgdGhlIGNvbXBvc2l0aW9uLiBUaGUgY291bnQgaXMgdXNlZCB0b1xuICAgICAgICAvLyBhdm9pZCB0cmVhdGluZyB0aGUgc3RhcnQgc3RhdGUgb2YgdGhlIGNvbXBvc2l0aW9uLCBiZWZvcmUgYW55XG4gICAgICAgIC8vIGNoYW5nZXMgaGF2ZSBiZWVuIG1hZGUsIGFzIHBhcnQgb2YgdGhlIGNvbXBvc2l0aW9uLlxuICAgICAgICB0aGlzLmNvbXBvc2luZyA9IC0xO1xuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uRW5kZWRBdCA9IDA7XG4gICAgICAgIHRoaXMubW91c2VTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICBmb3IgKGxldCB0eXBlIGluIGhhbmRsZXJzKSB7XG4gICAgICAgICAgICBsZXQgaGFuZGxlciA9IGhhbmRsZXJzW3R5cGVdO1xuICAgICAgICAgICAgdmlldy5jb250ZW50RE9NLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT0gXCJrZXlkb3duXCIgJiYgdGhpcy5rZXlkb3duKHZpZXcsIGV2ZW50KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICghZXZlbnRCZWxvbmdzVG9FZGl0b3IodmlldywgZXZlbnQpIHx8IHRoaXMuaWdub3JlRHVyaW5nQ29tcG9zaXRpb24oZXZlbnQpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubXVzdEZsdXNoT2JzZXJ2ZXIoZXZlbnQpKVxuICAgICAgICAgICAgICAgICAgICB2aWV3Lm9ic2VydmVyLmZvcmNlRmx1c2goKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ydW5DdXN0b21IYW5kbGVycyh0eXBlLCB2aWV3LCBldmVudCkpXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyKHZpZXcsIGV2ZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzLnB1c2godHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub3RpZmllZEZvY3VzZWQgPSB2aWV3Lmhhc0ZvY3VzO1xuICAgICAgICB0aGlzLmVuc3VyZUhhbmRsZXJzKHZpZXcpO1xuICAgIH1cbiAgICBzZXRTZWxlY3Rpb25PcmlnaW4ob3JpZ2luKSB7XG4gICAgICAgIHRoaXMubGFzdFNlbGVjdGlvbk9yaWdpbiA9IG9yaWdpbjtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uVGltZSA9IERhdGUubm93KCk7XG4gICAgfVxuICAgIGVuc3VyZUhhbmRsZXJzKHZpZXcpIHtcbiAgICAgICAgbGV0IGhhbmRsZXJzID0gdGhpcy5jdXN0b21IYW5kbGVycyA9IHZpZXcucGx1Z2luRmllbGQoZG9tRXZlbnRIYW5kbGVycyk7XG4gICAgICAgIGZvciAobGV0IHNldCBvZiBoYW5kbGVycykge1xuICAgICAgICAgICAgZm9yIChsZXQgdHlwZSBpbiBzZXQuaGFuZGxlcnMpXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVnaXN0ZXJlZEV2ZW50cy5pbmRleE9mKHR5cGUpIDwgMCAmJiB0eXBlICE9IFwic2Nyb2xsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzLnB1c2godHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcuY29udGVudERPTS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFldmVudEJlbG9uZ3NUb0VkaXRvcih2aWV3LCBldmVudCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucnVuQ3VzdG9tSGFuZGxlcnModHlwZSwgdmlldywgZXZlbnQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBydW5DdXN0b21IYW5kbGVycyh0eXBlLCB2aWV3LCBldmVudCkge1xuICAgICAgICBmb3IgKGxldCBzZXQgb2YgdGhpcy5jdXN0b21IYW5kbGVycykge1xuICAgICAgICAgICAgbGV0IGhhbmRsZXIgPSBzZXQuaGFuZGxlcnNbdHlwZV0sIGhhbmRsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlZCA9IGhhbmRsZXIuY2FsbChzZXQucGx1Z2luLCBldmVudCwgdmlldyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih2aWV3LnN0YXRlLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZWQgfHwgZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDaHJvbWUgZm9yIEFuZHJvaWQgb2Z0ZW4gYXBwbGllcyBhIGJ1bmNoIG9mIG5vbnNlbnNpY2FsXG4gICAgICAgICAgICAgICAgICAgIC8vIERPTSBjaGFuZ2VzIGFmdGVyIGFuIGVudGVyIHByZXNzLCBldmVuIHdoZW5cbiAgICAgICAgICAgICAgICAgICAgLy8gcHJldmVudERlZmF1bHQtZWQuIFRoaXMgdHJpZXMgdG8gaWdub3JlIHRob3NlLlxuICAgICAgICAgICAgICAgICAgICBpZiAoYnJvd3Nlci5hbmRyb2lkICYmIHR5cGUgPT0gXCJrZXlkb3duXCIgJiYgZXZlbnQua2V5Q29kZSA9PSAxMylcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcub2JzZXJ2ZXIuZmx1c2hTb29uKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJ1blNjcm9sbEhhbmRsZXJzKHZpZXcsIGV2ZW50KSB7XG4gICAgICAgIGZvciAobGV0IHNldCBvZiB0aGlzLmN1c3RvbUhhbmRsZXJzKSB7XG4gICAgICAgICAgICBsZXQgaGFuZGxlciA9IHNldC5oYW5kbGVycy5zY3JvbGw7XG4gICAgICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIuY2FsbChzZXQucGx1Z2luLCBldmVudCwgdmlldyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih2aWV3LnN0YXRlLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAga2V5ZG93bih2aWV3LCBldmVudCkge1xuICAgICAgICAvLyBNdXN0IGFsd2F5cyBydW4sIGV2ZW4gaWYgYSBjdXN0b20gaGFuZGxlciBoYW5kbGVkIHRoZSBldmVudFxuICAgICAgICB0aGlzLmxhc3RLZXlDb2RlID0gZXZlbnQua2V5Q29kZTtcbiAgICAgICAgdGhpcy5sYXN0S2V5VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGlmICh0aGlzLnNjcmVlbktleUV2ZW50KHZpZXcsIGV2ZW50KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gUHJldmVudCB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZiBFbnRlciBvbiBpT1MgbWFrZXMgdGhlXG4gICAgICAgIC8vIHZpcnR1YWwga2V5Ym9hcmQgZ2V0IHN0dWNrIGluIHRoZSB3cm9uZyAobG93ZXJjYXNlKVxuICAgICAgICAvLyBzdGF0ZS4gU28gd2UgbGV0IGl0IGdvIHRocm91Z2gsIGFuZCB0aGVuLCBpblxuICAgICAgICAvLyBhcHBseURPTUNoYW5nZSwgbm90aWZ5IGtleSBoYW5kbGVycyBvZiBpdCBhbmQgcmVzZXQgdG9cbiAgICAgICAgLy8gdGhlIHN0YXRlIHRoZXkgcHJvZHVjZS5cbiAgICAgICAgaWYgKGJyb3dzZXIuaW9zICYmIChldmVudC5rZXlDb2RlID09IDEzIHx8IGV2ZW50LmtleUNvZGUgPT0gOCkgJiZcbiAgICAgICAgICAgICEoZXZlbnQuY3RybEtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQubWV0YUtleSkgJiYgIWV2ZW50LnN5bnRoZXRpYykge1xuICAgICAgICAgICAgdGhpc1tldmVudC5rZXlDb2RlID09IDEzID8gXCJsYXN0SU9TRW50ZXJcIiA6IFwibGFzdElPU0JhY2tzcGFjZVwiXSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlnbm9yZUR1cmluZ0NvbXBvc2l0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmICghL15rZXkvLnRlc3QoZXZlbnQudHlwZSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmNvbXBvc2luZyA+IDApXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vd3d3LnN0dW0uZGUvMjAxNi8wNi8yNC9oYW5kbGluZy1pbWUtZXZlbnRzLWluLWphdmFzY3JpcHQvLlxuICAgICAgICAvLyBPbiBzb21lIGlucHV0IG1ldGhvZCBlZGl0b3JzIChJTUVzKSwgdGhlIEVudGVyIGtleSBpcyB1c2VkIHRvXG4gICAgICAgIC8vIGNvbmZpcm0gY2hhcmFjdGVyIHNlbGVjdGlvbi4gT24gU2FmYXJpLCB3aGVuIEVudGVyIGlzIHByZXNzZWQsXG4gICAgICAgIC8vIGNvbXBvc2l0aW9uZW5kIGFuZCBrZXlkb3duIGV2ZW50cyBhcmUgc29tZXRpbWVzIGVtaXR0ZWQgaW4gdGhlXG4gICAgICAgIC8vIHdyb25nIG9yZGVyLiBUaGUga2V5IGV2ZW50IHNob3VsZCBzdGlsbCBiZSBpZ25vcmVkLCBldmVuIHdoZW5cbiAgICAgICAgLy8gaXQgaGFwcGVucyBhZnRlciB0aGUgY29tcG9zaXRpb25lbmQgZXZlbnQuXG4gICAgICAgIGlmIChicm93c2VyLnNhZmFyaSAmJiBldmVudC50aW1lU3RhbXAgLSB0aGlzLmNvbXBvc2l0aW9uRW5kZWRBdCA8IDUwMCkge1xuICAgICAgICAgICAgdGhpcy5jb21wb3NpdGlvbkVuZGVkQXQgPSAwO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzY3JlZW5LZXlFdmVudCh2aWV3LCBldmVudCkge1xuICAgICAgICBsZXQgcHJvdGVjdGVkVGFiID0gZXZlbnQua2V5Q29kZSA9PSA5ICYmIERhdGUubm93KCkgPCB0aGlzLmxhc3RFc2NQcmVzcyArIDIwMDA7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IDI3KVxuICAgICAgICAgICAgdGhpcy5sYXN0RXNjUHJlc3MgPSBEYXRlLm5vdygpO1xuICAgICAgICBlbHNlIGlmIChtb2RpZmllckNvZGVzLmluZGV4T2YoZXZlbnQua2V5Q29kZSkgPCAwKVxuICAgICAgICAgICAgdGhpcy5sYXN0RXNjUHJlc3MgPSAwO1xuICAgICAgICByZXR1cm4gcHJvdGVjdGVkVGFiO1xuICAgIH1cbiAgICBtdXN0Rmx1c2hPYnNlcnZlcihldmVudCkge1xuICAgICAgICByZXR1cm4gKGV2ZW50LnR5cGUgPT0gXCJrZXlkb3duXCIgJiYgZXZlbnQua2V5Q29kZSAhPSAyMjkpIHx8XG4gICAgICAgICAgICBldmVudC50eXBlID09IFwiY29tcG9zaXRpb25lbmRcIiAmJiAhYnJvd3Nlci5pb3M7XG4gICAgfVxuICAgIHN0YXJ0TW91c2VTZWxlY3Rpb24odmlldywgZXZlbnQsIHN0eWxlKSB7XG4gICAgICAgIGlmICh0aGlzLm1vdXNlU2VsZWN0aW9uKVxuICAgICAgICAgICAgdGhpcy5tb3VzZVNlbGVjdGlvbi5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMubW91c2VTZWxlY3Rpb24gPSBuZXcgTW91c2VTZWxlY3Rpb24odGhpcywgdmlldywgZXZlbnQsIHN0eWxlKTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodGhpcy5tb3VzZVNlbGVjdGlvbilcbiAgICAgICAgICAgIHRoaXMubW91c2VTZWxlY3Rpb24udXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgIHRoaXMubGFzdEtleUNvZGUgPSB0aGlzLmxhc3RTZWxlY3Rpb25UaW1lID0gMDtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMubW91c2VTZWxlY3Rpb24pXG4gICAgICAgICAgICB0aGlzLm1vdXNlU2VsZWN0aW9uLmRlc3Ryb3koKTtcbiAgICB9XG59XG4vLyBLZXkgY29kZXMgZm9yIG1vZGlmaWVyIGtleXNcbmNvbnN0IG1vZGlmaWVyQ29kZXMgPSBbMTYsIDE3LCAxOCwgMjAsIDkxLCA5MiwgMjI0LCAyMjVdO1xuY2xhc3MgTW91c2VTZWxlY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKGlucHV0U3RhdGUsIHZpZXcsIHN0YXJ0RXZlbnQsIHN0eWxlKSB7XG4gICAgICAgIHRoaXMuaW5wdXRTdGF0ZSA9IGlucHV0U3RhdGU7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuc3RhcnRFdmVudCA9IHN0YXJ0RXZlbnQ7XG4gICAgICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgICAgICAgbGV0IGRvYyA9IHZpZXcuY29udGVudERPTS5vd25lckRvY3VtZW50O1xuICAgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm1vdmUgPSB0aGlzLm1vdmUuYmluZCh0aGlzKSk7XG4gICAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLnVwID0gdGhpcy51cC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5leHRlbmQgPSBzdGFydEV2ZW50LnNoaWZ0S2V5O1xuICAgICAgICB0aGlzLm11bHRpcGxlID0gdmlldy5zdGF0ZS5mYWNldChzdGF0ZS5FZGl0b3JTdGF0ZS5hbGxvd011bHRpcGxlU2VsZWN0aW9ucykgJiYgYWRkc1NlbGVjdGlvblJhbmdlKHZpZXcsIHN0YXJ0RXZlbnQpO1xuICAgICAgICB0aGlzLmRyYWdNb3ZlID0gZHJhZ01vdmVzU2VsZWN0aW9uKHZpZXcsIHN0YXJ0RXZlbnQpO1xuICAgICAgICB0aGlzLmRyYWdnaW5nID0gaXNJblByaW1hcnlTZWxlY3Rpb24odmlldywgc3RhcnRFdmVudCkgPyBudWxsIDogZmFsc2U7XG4gICAgICAgIC8vIFdoZW4gY2xpY2tpbmcgb3V0c2lkZSBvZiB0aGUgc2VsZWN0aW9uLCBpbW1lZGlhdGVseSBhcHBseSB0aGVcbiAgICAgICAgLy8gZWZmZWN0IG9mIHN0YXJ0aW5nIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBzdGFydEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdChzdGFydEV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtb3ZlKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5idXR0b25zID09IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIGlmICh0aGlzLmRyYWdnaW5nICE9PSBmYWxzZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5zZWxlY3QoZXZlbnQpO1xuICAgIH1cbiAgICB1cChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZyA9PSBudWxsKVxuICAgICAgICAgICAgdGhpcy5zZWxlY3QodGhpcy5zdGFydEV2ZW50KTtcbiAgICAgICAgaWYgKCF0aGlzLmRyYWdnaW5nKVxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGxldCBkb2MgPSB0aGlzLnZpZXcuY29udGVudERPTS5vd25lckRvY3VtZW50O1xuICAgICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm1vdmUpO1xuICAgICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy51cCk7XG4gICAgICAgIHRoaXMuaW5wdXRTdGF0ZS5tb3VzZVNlbGVjdGlvbiA9IG51bGw7XG4gICAgfVxuICAgIHNlbGVjdChldmVudCkge1xuICAgICAgICBsZXQgc2VsZWN0aW9uID0gdGhpcy5zdHlsZS5nZXQoZXZlbnQsIHRoaXMuZXh0ZW5kLCB0aGlzLm11bHRpcGxlKTtcbiAgICAgICAgaWYgKCFzZWxlY3Rpb24uZXEodGhpcy52aWV3LnN0YXRlLnNlbGVjdGlvbikgfHwgc2VsZWN0aW9uLm1haW4uYXNzb2MgIT0gdGhpcy52aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLmFzc29jKVxuICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbnM6IHN0YXRlLlRyYW5zYWN0aW9uLnVzZXJFdmVudC5vZihcInBvaW50ZXJzZWxlY3Rpb25cIiksXG4gICAgICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGlmICh1cGRhdGUuZG9jQ2hhbmdlZCAmJiB0aGlzLmRyYWdnaW5nKVxuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRoaXMuZHJhZ2dpbmcubWFwKHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICAgICAgdGhpcy5zdHlsZS51cGRhdGUodXBkYXRlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRzU2VsZWN0aW9uUmFuZ2UodmlldywgZXZlbnQpIHtcbiAgICBsZXQgZmFjZXQgPSB2aWV3LnN0YXRlLmZhY2V0KGNsaWNrQWRkc1NlbGVjdGlvblJhbmdlKTtcbiAgICByZXR1cm4gZmFjZXQubGVuZ3RoID8gZmFjZXRbMF0oZXZlbnQpIDogYnJvd3Nlci5tYWMgPyBldmVudC5tZXRhS2V5IDogZXZlbnQuY3RybEtleTtcbn1cbmZ1bmN0aW9uIGRyYWdNb3Zlc1NlbGVjdGlvbih2aWV3LCBldmVudCkge1xuICAgIGxldCBmYWNldCA9IHZpZXcuc3RhdGUuZmFjZXQoZHJhZ01vdmVzU2VsZWN0aW9uJDEpO1xuICAgIHJldHVybiBmYWNldC5sZW5ndGggPyBmYWNldFswXShldmVudCkgOiBicm93c2VyLm1hYyA/ICFldmVudC5hbHRLZXkgOiAhZXZlbnQuY3RybEtleTtcbn1cbmZ1bmN0aW9uIGlzSW5QcmltYXJ5U2VsZWN0aW9uKHZpZXcsIGV2ZW50KSB7XG4gICAgbGV0IHsgbWFpbiB9ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKG1haW4uZW1wdHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAvLyBPbiBib3VuZGFyeSBjbGlja3MsIGNoZWNrIHdoZXRoZXIgdGhlIGNvb3JkaW5hdGVzIGFyZSBpbnNpZGUgdGhlXG4gICAgLy8gc2VsZWN0aW9uJ3MgY2xpZW50IHJlY3RhbmdsZXNcbiAgICBsZXQgc2VsID0gZ2V0U2VsZWN0aW9uKHZpZXcucm9vdCk7XG4gICAgaWYgKHNlbC5yYW5nZUNvdW50ID09IDApXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGxldCByZWN0cyA9IHNlbC5nZXRSYW5nZUF0KDApLmdldENsaWVudFJlY3RzKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgcmVjdCA9IHJlY3RzW2ldO1xuICAgICAgICBpZiAocmVjdC5sZWZ0IDw9IGV2ZW50LmNsaWVudFggJiYgcmVjdC5yaWdodCA+PSBldmVudC5jbGllbnRYICYmXG4gICAgICAgICAgICByZWN0LnRvcCA8PSBldmVudC5jbGllbnRZICYmIHJlY3QuYm90dG9tID49IGV2ZW50LmNsaWVudFkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZXZlbnRCZWxvbmdzVG9FZGl0b3IodmlldywgZXZlbnQpIHtcbiAgICBpZiAoIWV2ZW50LmJ1YmJsZXMpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgbm9kZSA9IGV2ZW50LnRhcmdldCwgY1ZpZXc7IG5vZGUgIT0gdmlldy5jb250ZW50RE9NOyBub2RlID0gbm9kZS5wYXJlbnROb2RlKVxuICAgICAgICBpZiAoIW5vZGUgfHwgbm9kZS5ub2RlVHlwZSA9PSAxMSB8fCAoKGNWaWV3ID0gQ29udGVudFZpZXcuZ2V0KG5vZGUpKSAmJiBjVmlldy5pZ25vcmVFdmVudChldmVudCkpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuY29uc3QgaGFuZGxlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLy8gVGhpcyBpcyB2ZXJ5IGNydWRlLCBidXQgdW5mb3J0dW5hdGVseSBib3RoIHRoZXNlIGJyb3dzZXJzIF9wcmV0ZW5kX1xuLy8gdGhhdCB0aGV5IGhhdmUgYSBjbGlwYm9hcmQgQVBJ4oCUYWxsIHRoZSBvYmplY3RzIGFuZCBtZXRob2RzIGFyZVxuLy8gdGhlcmUsIHRoZXkganVzdCBkb24ndCB3b3JrLCBhbmQgdGhleSBhcmUgaGFyZCB0byB0ZXN0LlxuY29uc3QgYnJva2VuQ2xpcGJvYXJkQVBJID0gKGJyb3dzZXIuaWUgJiYgYnJvd3Nlci5pZV92ZXJzaW9uIDwgMTUpIHx8XG4gICAgKGJyb3dzZXIuaW9zICYmIGJyb3dzZXIud2Via2l0X3ZlcnNpb24gPCA2MDQpO1xuZnVuY3Rpb24gY2FwdHVyZVBhc3RlKHZpZXcpIHtcbiAgICBsZXQgcGFyZW50ID0gdmlldy5kb20ucGFyZW50Tm9kZTtcbiAgICBpZiAoIXBhcmVudClcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCB0YXJnZXQgPSBwYXJlbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIpKTtcbiAgICB0YXJnZXQuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246IGZpeGVkOyBsZWZ0OiAtMTAwMDBweDsgdG9wOiAxMHB4XCI7XG4gICAgdGFyZ2V0LmZvY3VzKCk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZSgpO1xuICAgICAgICBkb1Bhc3RlKHZpZXcsIHRhcmdldC52YWx1ZSk7XG4gICAgfSwgNTApO1xufVxuZnVuY3Rpb24gZG9QYXN0ZSh2aWV3LCBpbnB1dCkge1xuICAgIGxldCB7IHN0YXRlOiBzdGF0ZSQxIH0gPSB2aWV3LCBjaGFuZ2VzLCBpID0gMSwgdGV4dCA9IHN0YXRlJDEudG9UZXh0KGlucHV0KTtcbiAgICBsZXQgYnlMaW5lID0gdGV4dC5saW5lcyA9PSBzdGF0ZSQxLnNlbGVjdGlvbi5yYW5nZXMubGVuZ3RoO1xuICAgIGxldCBsaW5ld2lzZSA9IGxhc3RMaW5ld2lzZUNvcHkgJiYgc3RhdGUkMS5zZWxlY3Rpb24ucmFuZ2VzLmV2ZXJ5KHIgPT4gci5lbXB0eSkgJiYgbGFzdExpbmV3aXNlQ29weSA9PSB0ZXh0LnRvU3RyaW5nKCk7XG4gICAgaWYgKGxpbmV3aXNlKSB7XG4gICAgICAgIGxldCBsYXN0TGluZSA9IC0xO1xuICAgICAgICBjaGFuZ2VzID0gc3RhdGUkMS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gc3RhdGUkMS5kb2MubGluZUF0KHJhbmdlLmZyb20pO1xuICAgICAgICAgICAgaWYgKGxpbmUuZnJvbSA9PSBsYXN0TGluZSlcbiAgICAgICAgICAgICAgICByZXR1cm4geyByYW5nZSB9O1xuICAgICAgICAgICAgbGFzdExpbmUgPSBsaW5lLmZyb207XG4gICAgICAgICAgICBsZXQgaW5zZXJ0ID0gc3RhdGUkMS50b1RleHQoKGJ5TGluZSA/IHRleHQubGluZShpKyspLnRleHQgOiBpbnB1dCkgKyBzdGF0ZSQxLmxpbmVCcmVhayk7XG4gICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGZyb206IGxpbmUuZnJvbSwgaW5zZXJ0IH0sXG4gICAgICAgICAgICAgICAgcmFuZ2U6IHN0YXRlLkVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuZnJvbSArIGluc2VydC5sZW5ndGgpIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChieUxpbmUpIHtcbiAgICAgICAgY2hhbmdlcyA9IHN0YXRlJDEuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHRleHQubGluZShpKyspO1xuICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBmcm9tOiByYW5nZS5mcm9tLCB0bzogcmFuZ2UudG8sIGluc2VydDogbGluZS50ZXh0IH0sXG4gICAgICAgICAgICAgICAgcmFuZ2U6IHN0YXRlLkVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuZnJvbSArIGxpbmUubGVuZ3RoKSB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNoYW5nZXMgPSBzdGF0ZSQxLnJlcGxhY2VTZWxlY3Rpb24odGV4dCk7XG4gICAgfVxuICAgIHZpZXcuZGlzcGF0Y2goY2hhbmdlcywge1xuICAgICAgICBhbm5vdGF0aW9uczogc3RhdGUuVHJhbnNhY3Rpb24udXNlckV2ZW50Lm9mKFwicGFzdGVcIiksXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlXG4gICAgfSk7XG59XG5oYW5kbGVycy5rZXlkb3duID0gKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgdmlldy5pbnB1dFN0YXRlLnNldFNlbGVjdGlvbk9yaWdpbihcImtleWJvYXJkc2VsZWN0aW9uXCIpO1xufTtcbmxldCBsYXN0VG91Y2ggPSAwO1xuZnVuY3Rpb24gbW91c2VMaWtlVG91Y2hFdmVudChlKSB7XG4gICAgcmV0dXJuIGUudG91Y2hlcy5sZW5ndGggPT0gMSAmJiBlLnRvdWNoZXNbMF0ucmFkaXVzWCA8PSAxICYmIGUudG91Y2hlc1swXS5yYWRpdXNZIDw9IDE7XG59XG5oYW5kbGVycy50b3VjaHN0YXJ0ID0gKHZpZXcsIGUpID0+IHtcbiAgICBpZiAoIW1vdXNlTGlrZVRvdWNoRXZlbnQoZSkpXG4gICAgICAgIGxhc3RUb3VjaCA9IERhdGUubm93KCk7XG4gICAgdmlldy5pbnB1dFN0YXRlLnNldFNlbGVjdGlvbk9yaWdpbihcInBvaW50ZXJzZWxlY3Rpb25cIik7XG59O1xuaGFuZGxlcnMudG91Y2htb3ZlID0gdmlldyA9PiB7XG4gICAgdmlldy5pbnB1dFN0YXRlLnNldFNlbGVjdGlvbk9yaWdpbihcInBvaW50ZXJzZWxlY3Rpb25cIik7XG59O1xuaGFuZGxlcnMubW91c2Vkb3duID0gKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgdmlldy5vYnNlcnZlci5mbHVzaCgpO1xuICAgIGlmIChsYXN0VG91Y2ggPiBEYXRlLm5vdygpIC0gMjAwMClcbiAgICAgICAgcmV0dXJuOyAvLyBJZ25vcmUgdG91Y2ggaW50ZXJhY3Rpb25cbiAgICBsZXQgc3R5bGUgPSBudWxsO1xuICAgIGZvciAobGV0IG1ha2VTdHlsZSBvZiB2aWV3LnN0YXRlLmZhY2V0KG1vdXNlU2VsZWN0aW9uU3R5bGUpKSB7XG4gICAgICAgIHN0eWxlID0gbWFrZVN0eWxlKHZpZXcsIGV2ZW50KTtcbiAgICAgICAgaWYgKHN0eWxlKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICghc3R5bGUgJiYgZXZlbnQuYnV0dG9uID09IDApXG4gICAgICAgIHN0eWxlID0gYmFzaWNNb3VzZVNlbGVjdGlvbih2aWV3LCBldmVudCk7XG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICAgIGlmICh2aWV3LnJvb3QuYWN0aXZlRWxlbWVudCAhPSB2aWV3LmNvbnRlbnRET00pXG4gICAgICAgICAgICB2aWV3Lm9ic2VydmVyLmlnbm9yZSgoKSA9PiBmb2N1c1ByZXZlbnRTY3JvbGwodmlldy5jb250ZW50RE9NKSk7XG4gICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5zdGFydE1vdXNlU2VsZWN0aW9uKHZpZXcsIGV2ZW50LCBzdHlsZSk7XG4gICAgfVxufTtcbmZ1bmN0aW9uIHJhbmdlRm9yQ2xpY2sodmlldywgcG9zLCBiaWFzLCB0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT0gMSkgeyAvLyBTaW5nbGUgY2xpY2tcbiAgICAgICAgcmV0dXJuIHN0YXRlLkVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zLCBiaWFzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PSAyKSB7IC8vIERvdWJsZSBjbGlja1xuICAgICAgICByZXR1cm4gZ3JvdXBBdCh2aWV3LnN0YXRlLCBwb3MsIGJpYXMpO1xuICAgIH1cbiAgICBlbHNlIHsgLy8gVHJpcGxlIGNsaWNrXG4gICAgICAgIGxldCB2aXN1YWwgPSBMaW5lVmlldy5maW5kKHZpZXcuZG9jVmlldywgcG9zKSwgbGluZSA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdCh2aXN1YWwgPyB2aXN1YWwucG9zQXRFbmQgOiBwb3MpO1xuICAgICAgICBsZXQgZnJvbSA9IHZpc3VhbCA/IHZpc3VhbC5wb3NBdFN0YXJ0IDogbGluZS5mcm9tLCB0byA9IHZpc3VhbCA/IHZpc3VhbC5wb3NBdEVuZCA6IGxpbmUudG87XG4gICAgICAgIGlmICh0byA8IHZpZXcuc3RhdGUuZG9jLmxlbmd0aCAmJiB0byA9PSBsaW5lLnRvKVxuICAgICAgICAgICAgdG8rKztcbiAgICAgICAgcmV0dXJuIHN0YXRlLkVkaXRvclNlbGVjdGlvbi5yYW5nZShmcm9tLCB0byk7XG4gICAgfVxufVxubGV0IGluc2lkZVkgPSAoeSwgcmVjdCkgPT4geSA+PSByZWN0LnRvcCAmJiB5IDw9IHJlY3QuYm90dG9tO1xubGV0IGluc2lkZSA9ICh4LCB5LCByZWN0KSA9PiBpbnNpZGVZKHksIHJlY3QpICYmIHggPj0gcmVjdC5sZWZ0ICYmIHggPD0gcmVjdC5yaWdodDtcbi8vIFRyeSB0byBkZXRlcm1pbmUsIGZvciB0aGUgZ2l2ZW4gY29vcmRpbmF0ZXMsIGFzc29jaWF0ZWQgd2l0aCB0aGVcbi8vIGdpdmVuIHBvc2l0aW9uLCB3aGV0aGVyIHRoZXkgYXJlIHJlbGF0ZWQgdG8gdGhlIGVsZW1lbnQgYmVmb3JlIG9yXG4vLyB0aGUgZWxlbWVudCBhZnRlciB0aGUgcG9zaXRpb24uXG5mdW5jdGlvbiBmaW5kUG9zaXRpb25TaWRlKHZpZXcsIHBvcywgeCwgeSkge1xuICAgIGxldCBsaW5lID0gTGluZVZpZXcuZmluZCh2aWV3LmRvY1ZpZXcsIHBvcyk7XG4gICAgaWYgKCFsaW5lKVxuICAgICAgICByZXR1cm4gMTtcbiAgICBsZXQgb2ZmID0gcG9zIC0gbGluZS5wb3NBdFN0YXJ0O1xuICAgIC8vIExpbmUgYm91bmRhcmllcyBwb2ludCBpbnRvIHRoZSBsaW5lXG4gICAgaWYgKG9mZiA9PSAwKVxuICAgICAgICByZXR1cm4gMTtcbiAgICBpZiAob2ZmID09IGxpbmUubGVuZ3RoKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgLy8gUG9zaXRpb25zIG9uIHRvcCBvZiBhbiBlbGVtZW50IHBvaW50IGF0IHRoYXQgZWxlbWVudFxuICAgIGxldCBiZWZvcmUgPSBsaW5lLmNvb3Jkc0F0KG9mZiwgLTEpO1xuICAgIGlmIChiZWZvcmUgJiYgaW5zaWRlKHgsIHksIGJlZm9yZSkpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICBsZXQgYWZ0ZXIgPSBsaW5lLmNvb3Jkc0F0KG9mZiwgMSk7XG4gICAgaWYgKGFmdGVyICYmIGluc2lkZSh4LCB5LCBhZnRlcikpXG4gICAgICAgIHJldHVybiAxO1xuICAgIC8vIFRoaXMgaXMgcHJvYmFibHkgYSBsaW5lIHdyYXAgcG9pbnQuIFBpY2sgYmVmb3JlIGlmIHRoZSBwb2ludCBpc1xuICAgIC8vIGJlc2lkZSBpdC5cbiAgICByZXR1cm4gYmVmb3JlICYmIGluc2lkZVkoeSwgYmVmb3JlKSA/IC0xIDogMTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5UG9zKHZpZXcsIGV2ZW50KSB7XG4gICAgbGV0IHBvcyA9IHZpZXcucG9zQXRDb29yZHMoeyB4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZIH0pO1xuICAgIGlmIChwb3MgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHsgcG9zLCBiaWFzOiBmaW5kUG9zaXRpb25TaWRlKHZpZXcsIHBvcywgZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSkgfTtcbn1cbmNvbnN0IEJhZE1vdXNlRGV0YWlsID0gYnJvd3Nlci5pZSAmJiBicm93c2VyLmllX3ZlcnNpb24gPD0gMTE7XG5sZXQgbGFzdE1vdXNlRG93biA9IG51bGwsIGxhc3RNb3VzZURvd25Db3VudCA9IDA7XG5mdW5jdGlvbiBnZXRDbGlja1R5cGUoZXZlbnQpIHtcbiAgICBpZiAoIUJhZE1vdXNlRGV0YWlsKVxuICAgICAgICByZXR1cm4gZXZlbnQuZGV0YWlsO1xuICAgIGxldCBsYXN0ID0gbGFzdE1vdXNlRG93bjtcbiAgICBsYXN0TW91c2VEb3duID0gZXZlbnQ7XG4gICAgcmV0dXJuIGxhc3RNb3VzZURvd25Db3VudCA9ICFsYXN0IHx8IChsYXN0LnRpbWVTdGFtcCA+IERhdGUubm93KCkgLSA0MDAgJiYgTWF0aC5hYnMobGFzdC5jbGllbnRYIC0gZXZlbnQuY2xpZW50WCkgPCAyICYmXG4gICAgICAgIE1hdGguYWJzKGxhc3QuY2xpZW50WSAtIGV2ZW50LmNsaWVudFkpIDwgMikgPyAobGFzdE1vdXNlRG93bkNvdW50ICsgMSkgJSAzIDogMTtcbn1cbmZ1bmN0aW9uIGJhc2ljTW91c2VTZWxlY3Rpb24odmlldywgZXZlbnQpIHtcbiAgICBsZXQgc3RhcnQgPSBxdWVyeVBvcyh2aWV3LCBldmVudCksIHR5cGUgPSBnZXRDbGlja1R5cGUoZXZlbnQpO1xuICAgIGxldCBzdGFydFNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGxldCBsYXN0ID0gc3RhcnQsIGxhc3RFdmVudCA9IGV2ZW50O1xuICAgIHJldHVybiB7XG4gICAgICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgICAgIGlmICh1cGRhdGUuY2hhbmdlcykge1xuICAgICAgICAgICAgICAgIGlmIChzdGFydClcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQucG9zID0gdXBkYXRlLmNoYW5nZXMubWFwUG9zKHN0YXJ0LnBvcyk7XG4gICAgICAgICAgICAgICAgc3RhcnRTZWwgPSBzdGFydFNlbC5tYXAodXBkYXRlLmNoYW5nZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXQoZXZlbnQsIGV4dGVuZCwgbXVsdGlwbGUpIHtcbiAgICAgICAgICAgIGxldCBjdXI7XG4gICAgICAgICAgICBpZiAoZXZlbnQuY2xpZW50WCA9PSBsYXN0RXZlbnQuY2xpZW50WCAmJiBldmVudC5jbGllbnRZID09IGxhc3RFdmVudC5jbGllbnRZKVxuICAgICAgICAgICAgICAgIGN1ciA9IGxhc3Q7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXIgPSBsYXN0ID0gcXVlcnlQb3ModmlldywgZXZlbnQpO1xuICAgICAgICAgICAgICAgIGxhc3RFdmVudCA9IGV2ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjdXIgfHwgIXN0YXJ0KVxuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydFNlbDtcbiAgICAgICAgICAgIGxldCByYW5nZSA9IHJhbmdlRm9yQ2xpY2sodmlldywgY3VyLnBvcywgY3VyLmJpYXMsIHR5cGUpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0LnBvcyAhPSBjdXIucG9zICYmICFleHRlbmQpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnRSYW5nZSA9IHJhbmdlRm9yQ2xpY2sodmlldywgc3RhcnQucG9zLCBzdGFydC5iaWFzLCB0eXBlKTtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IE1hdGgubWluKHN0YXJ0UmFuZ2UuZnJvbSwgcmFuZ2UuZnJvbSksIHRvID0gTWF0aC5tYXgoc3RhcnRSYW5nZS50bywgcmFuZ2UudG8pO1xuICAgICAgICAgICAgICAgIHJhbmdlID0gZnJvbSA8IHJhbmdlLmZyb20gPyBzdGF0ZS5FZGl0b3JTZWxlY3Rpb24ucmFuZ2UoZnJvbSwgdG8pIDogc3RhdGUuRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHRvLCBmcm9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHRlbmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0U2VsLnJlcGxhY2VSYW5nZShzdGFydFNlbC5tYWluLmV4dGVuZChyYW5nZS5mcm9tLCByYW5nZS50bykpO1xuICAgICAgICAgICAgZWxzZSBpZiAobXVsdGlwbGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0U2VsLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUuRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShbcmFuZ2VdKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5oYW5kbGVycy5kcmFnc3RhcnQgPSAodmlldywgZXZlbnQpID0+IHtcbiAgICBsZXQgeyBzZWxlY3Rpb246IHsgbWFpbiB9IH0gPSB2aWV3LnN0YXRlO1xuICAgIGxldCB7IG1vdXNlU2VsZWN0aW9uIH0gPSB2aWV3LmlucHV0U3RhdGU7XG4gICAgaWYgKG1vdXNlU2VsZWN0aW9uKVxuICAgICAgICBtb3VzZVNlbGVjdGlvbi5kcmFnZ2luZyA9IG1haW47XG4gICAgaWYgKGV2ZW50LmRhdGFUcmFuc2Zlcikge1xuICAgICAgICBldmVudC5kYXRhVHJhbnNmZXIuc2V0RGF0YShcIlRleHRcIiwgdmlldy5zdGF0ZS5zbGljZURvYyhtYWluLmZyb20sIG1haW4udG8pKTtcbiAgICAgICAgZXZlbnQuZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQgPSBcImNvcHlNb3ZlXCI7XG4gICAgfVxufTtcbmhhbmRsZXJzLmRyb3AgPSAodmlldywgZXZlbnQpID0+IHtcbiAgICBpZiAoIWV2ZW50LmRhdGFUcmFuc2ZlciB8fCAhdmlldy5zdGF0ZS5mYWNldChlZGl0YWJsZSkpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgZHJvcFBvcyA9IHZpZXcucG9zQXRDb29yZHMoeyB4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZIH0pO1xuICAgIGxldCB0ZXh0ID0gZXZlbnQuZGF0YVRyYW5zZmVyLmdldERhdGEoXCJUZXh0XCIpO1xuICAgIGlmIChkcm9wUG9zID09IG51bGwgfHwgIXRleHQpXG4gICAgICAgIHJldHVybjtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGxldCB7IG1vdXNlU2VsZWN0aW9uIH0gPSB2aWV3LmlucHV0U3RhdGU7XG4gICAgbGV0IGRlbCA9IG1vdXNlU2VsZWN0aW9uICYmIG1vdXNlU2VsZWN0aW9uLmRyYWdnaW5nICYmIG1vdXNlU2VsZWN0aW9uLmRyYWdNb3ZlID9cbiAgICAgICAgeyBmcm9tOiBtb3VzZVNlbGVjdGlvbi5kcmFnZ2luZy5mcm9tLCB0bzogbW91c2VTZWxlY3Rpb24uZHJhZ2dpbmcudG8gfSA6IG51bGw7XG4gICAgbGV0IGlucyA9IHsgZnJvbTogZHJvcFBvcywgaW5zZXJ0OiB0ZXh0IH07XG4gICAgbGV0IGNoYW5nZXMgPSB2aWV3LnN0YXRlLmNoYW5nZXMoZGVsID8gW2RlbCwgaW5zXSA6IGlucyk7XG4gICAgdmlldy5mb2N1cygpO1xuICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICBjaGFuZ2VzLFxuICAgICAgICBzZWxlY3Rpb246IHsgYW5jaG9yOiBjaGFuZ2VzLm1hcFBvcyhkcm9wUG9zLCAtMSksIGhlYWQ6IGNoYW5nZXMubWFwUG9zKGRyb3BQb3MsIDEpIH0sXG4gICAgICAgIGFubm90YXRpb25zOiBzdGF0ZS5UcmFuc2FjdGlvbi51c2VyRXZlbnQub2YoXCJkcm9wXCIpXG4gICAgfSk7XG59O1xuaGFuZGxlcnMucGFzdGUgPSAodmlldywgZXZlbnQpID0+IHtcbiAgICBpZiAoIXZpZXcuc3RhdGUuZmFjZXQoZWRpdGFibGUpKVxuICAgICAgICByZXR1cm47XG4gICAgdmlldy5vYnNlcnZlci5mbHVzaCgpO1xuICAgIGxldCBkYXRhID0gYnJva2VuQ2xpcGJvYXJkQVBJID8gbnVsbCA6IGV2ZW50LmNsaXBib2FyZERhdGE7XG4gICAgbGV0IHRleHQgPSBkYXRhICYmIGRhdGEuZ2V0RGF0YShcInRleHQvcGxhaW5cIik7XG4gICAgaWYgKHRleHQpIHtcbiAgICAgICAgZG9QYXN0ZSh2aWV3LCB0ZXh0KTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNhcHR1cmVQYXN0ZSh2aWV3KTtcbiAgICB9XG59O1xuZnVuY3Rpb24gY2FwdHVyZUNvcHkodmlldywgdGV4dCkge1xuICAgIC8vIFRoZSBleHRyYSB3cmFwcGVyIGlzIHNvbWVob3cgbmVjZXNzYXJ5IG9uIElFL0VkZ2UgdG8gcHJldmVudCB0aGVcbiAgICAvLyBjb250ZW50IGZyb20gYmVpbmcgbWFuZ2xlZCB3aGVuIGl0IGlzIHB1dCBvbnRvIHRoZSBjbGlwYm9hcmRcbiAgICBsZXQgcGFyZW50ID0gdmlldy5kb20ucGFyZW50Tm9kZTtcbiAgICBpZiAoIXBhcmVudClcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCB0YXJnZXQgPSBwYXJlbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIpKTtcbiAgICB0YXJnZXQuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246IGZpeGVkOyBsZWZ0OiAtMTAwMDBweDsgdG9wOiAxMHB4XCI7XG4gICAgdGFyZ2V0LnZhbHVlID0gdGV4dDtcbiAgICB0YXJnZXQuZm9jdXMoKTtcbiAgICB0YXJnZXQuc2VsZWN0aW9uRW5kID0gdGV4dC5sZW5ndGg7XG4gICAgdGFyZ2V0LnNlbGVjdGlvblN0YXJ0ID0gMDtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZSgpO1xuICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgfSwgNTApO1xufVxuZnVuY3Rpb24gY29waWVkUmFuZ2Uoc3RhdGUpIHtcbiAgICBsZXQgY29udGVudCA9IFtdLCByYW5nZXMgPSBbXSwgbGluZXdpc2UgPSBmYWxzZTtcbiAgICBmb3IgKGxldCByYW5nZSBvZiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKVxuICAgICAgICBpZiAoIXJhbmdlLmVtcHR5KSB7XG4gICAgICAgICAgICBjb250ZW50LnB1c2goc3RhdGUuc2xpY2VEb2MocmFuZ2UuZnJvbSwgcmFuZ2UudG8pKTtcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKHJhbmdlKTtcbiAgICAgICAgfVxuICAgIGlmICghY29udGVudC5sZW5ndGgpIHtcbiAgICAgICAgLy8gTm90aGluZyBzZWxlY3RlZCwgZG8gYSBsaW5lLXdpc2UgY29weVxuICAgICAgICBsZXQgdXB0byA9IC0xO1xuICAgICAgICBmb3IgKGxldCB7IGZyb20gfSBvZiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQoZnJvbSk7XG4gICAgICAgICAgICBpZiAobGluZS5udW1iZXIgPiB1cHRvKSB7XG4gICAgICAgICAgICAgICAgY29udGVudC5wdXNoKGxpbmUudGV4dCk7XG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goeyBmcm9tOiBsaW5lLmZyb20sIHRvOiBNYXRoLm1pbihzdGF0ZS5kb2MubGVuZ3RoLCBsaW5lLnRvICsgMSkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cHRvID0gbGluZS5udW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgbGluZXdpc2UgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4geyB0ZXh0OiBjb250ZW50LmpvaW4oc3RhdGUubGluZUJyZWFrKSwgcmFuZ2VzLCBsaW5ld2lzZSB9O1xufVxubGV0IGxhc3RMaW5ld2lzZUNvcHkgPSBudWxsO1xuaGFuZGxlcnMuY29weSA9IGhhbmRsZXJzLmN1dCA9ICh2aWV3LCBldmVudCkgPT4ge1xuICAgIGxldCB7IHRleHQsIHJhbmdlcywgbGluZXdpc2UgfSA9IGNvcGllZFJhbmdlKHZpZXcuc3RhdGUpO1xuICAgIGlmICghdGV4dClcbiAgICAgICAgcmV0dXJuO1xuICAgIGxhc3RMaW5ld2lzZUNvcHkgPSBsaW5ld2lzZSA/IHRleHQgOiBudWxsO1xuICAgIGxldCBkYXRhID0gYnJva2VuQ2xpcGJvYXJkQVBJID8gbnVsbCA6IGV2ZW50LmNsaXBib2FyZERhdGE7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZGF0YS5jbGVhckRhdGEoKTtcbiAgICAgICAgZGF0YS5zZXREYXRhKFwidGV4dC9wbGFpblwiLCB0ZXh0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNhcHR1cmVDb3B5KHZpZXcsIHRleHQpO1xuICAgIH1cbiAgICBpZiAoZXZlbnQudHlwZSA9PSBcImN1dFwiICYmIHZpZXcuc3RhdGUuZmFjZXQoZWRpdGFibGUpKVxuICAgICAgICB2aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIGNoYW5nZXM6IHJhbmdlcyxcbiAgICAgICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICAgICAgYW5ub3RhdGlvbnM6IHN0YXRlLlRyYW5zYWN0aW9uLnVzZXJFdmVudC5vZihcImN1dFwiKVxuICAgICAgICB9KTtcbn07XG5oYW5kbGVycy5mb2N1cyA9IGhhbmRsZXJzLmJsdXIgPSB2aWV3ID0+IHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHZpZXcuaGFzRm9jdXMgIT0gdmlldy5pbnB1dFN0YXRlLm5vdGlmaWVkRm9jdXNlZClcbiAgICAgICAgICAgIHZpZXcudXBkYXRlKFtdKTtcbiAgICB9LCAxMCk7XG59O1xuaGFuZGxlcnMuYmVmb3JlcHJpbnQgPSB2aWV3ID0+IHtcbiAgICB2aWV3LnZpZXdTdGF0ZS5wcmludGluZyA9IHRydWU7XG4gICAgdmlldy5yZXF1ZXN0TWVhc3VyZSgpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB2aWV3LnZpZXdTdGF0ZS5wcmludGluZyA9IGZhbHNlO1xuICAgICAgICB2aWV3LnJlcXVlc3RNZWFzdXJlKCk7XG4gICAgfSwgMjAwMCk7XG59O1xuZnVuY3Rpb24gZm9yY2VDbGVhckNvbXBvc2l0aW9uKHZpZXcpIHtcbiAgICBpZiAodmlldy5kb2NWaWV3LmNvbXBvc2l0aW9uRGVjby5zaXplKVxuICAgICAgICB2aWV3LnVwZGF0ZShbXSk7XG59XG5oYW5kbGVycy5jb21wb3NpdGlvbnN0YXJ0ID0gaGFuZGxlcnMuY29tcG9zaXRpb251cGRhdGUgPSB2aWV3ID0+IHtcbiAgICBpZiAodmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA8IDApIHtcbiAgICAgICAgaWYgKHZpZXcuZG9jVmlldy5jb21wb3NpdGlvbkRlY28uc2l6ZSkge1xuICAgICAgICAgICAgdmlldy5vYnNlcnZlci5mbHVzaCgpO1xuICAgICAgICAgICAgZm9yY2VDbGVhckNvbXBvc2l0aW9uKHZpZXcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZJWE1FIHBvc3NpYmx5IHNldCBhIHRpbWVvdXQgdG8gY2xlYXIgaXQgYWdhaW4gb24gQW5kcm9pZFxuICAgICAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nID0gMDtcbiAgICB9XG59O1xuaGFuZGxlcnMuY29tcG9zaXRpb25lbmQgPSB2aWV3ID0+IHtcbiAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nID0gLTE7XG4gICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRW5kZWRBdCA9IERhdGUubm93KCk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nIDwgMClcbiAgICAgICAgICAgIGZvcmNlQ2xlYXJDb21wb3NpdGlvbih2aWV3KTtcbiAgICB9LCA1MCk7XG59O1xuXG5jb25zdCB3cmFwcGluZ1doaXRlU3BhY2UgPSBbXCJwcmUtd3JhcFwiLCBcIm5vcm1hbFwiLCBcInByZS1saW5lXCJdO1xuY2xhc3MgSGVpZ2h0T3JhY2xlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5kb2MgPSB0ZXh0LlRleHQuZW1wdHk7XG4gICAgICAgIHRoaXMubGluZVdyYXBwaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGlyZWN0aW9uID0gZXhwb3J0cy5EaXJlY3Rpb24uTFRSO1xuICAgICAgICB0aGlzLmhlaWdodFNhbXBsZXMgPSB7fTtcbiAgICAgICAgdGhpcy5saW5lSGVpZ2h0ID0gMTQ7XG4gICAgICAgIHRoaXMuY2hhcldpZHRoID0gNztcbiAgICAgICAgdGhpcy5saW5lTGVuZ3RoID0gMzA7XG4gICAgICAgIC8vIFVzZWQgdG8gdHJhY2ssIGR1cmluZyB1cGRhdGVIZWlnaHQsIGlmIGFueSBhY3R1YWwgaGVpZ2h0cyBjaGFuZ2VkXG4gICAgICAgIHRoaXMuaGVpZ2h0Q2hhbmdlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBoZWlnaHRGb3JHYXAoZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IGxpbmVzID0gdGhpcy5kb2MubGluZUF0KHRvKS5udW1iZXIgLSB0aGlzLmRvYy5saW5lQXQoZnJvbSkubnVtYmVyICsgMTtcbiAgICAgICAgaWYgKHRoaXMubGluZVdyYXBwaW5nKVxuICAgICAgICAgICAgbGluZXMgKz0gTWF0aC5jZWlsKCgodG8gLSBmcm9tKSAtIChsaW5lcyAqIHRoaXMubGluZUxlbmd0aCAqIDAuNSkpIC8gdGhpcy5saW5lTGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGluZUhlaWdodCAqIGxpbmVzO1xuICAgIH1cbiAgICBoZWlnaHRGb3JMaW5lKGxlbmd0aCkge1xuICAgICAgICBpZiAoIXRoaXMubGluZVdyYXBwaW5nKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGluZUhlaWdodDtcbiAgICAgICAgbGV0IGxpbmVzID0gMSArIE1hdGgubWF4KDAsIE1hdGguY2VpbCgobGVuZ3RoIC0gdGhpcy5saW5lTGVuZ3RoKSAvICh0aGlzLmxpbmVMZW5ndGggLSA1KSkpO1xuICAgICAgICByZXR1cm4gbGluZXMgKiB0aGlzLmxpbmVIZWlnaHQ7XG4gICAgfVxuICAgIHNldERvYyhkb2MpIHsgdGhpcy5kb2MgPSBkb2M7IHJldHVybiB0aGlzOyB9XG4gICAgbXVzdFJlZnJlc2gobGluZUhlaWdodHMsIHdoaXRlU3BhY2UsIGRpcmVjdGlvbikge1xuICAgICAgICBsZXQgbmV3SGVpZ2h0ID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZUhlaWdodHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBoID0gbGluZUhlaWdodHNbaV07XG4gICAgICAgICAgICBpZiAoaCA8IDApIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghdGhpcy5oZWlnaHRTYW1wbGVzW01hdGguZmxvb3IoaCAqIDEwKV0pIHsgLy8gUm91bmQgdG8gLjEgcGl4ZWxzXG4gICAgICAgICAgICAgICAgbmV3SGVpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodFNhbXBsZXNbTWF0aC5mbG9vcihoICogMTApXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0hlaWdodCB8fCAod3JhcHBpbmdXaGl0ZVNwYWNlLmluZGV4T2Yod2hpdGVTcGFjZSkgPiAtMSkgIT0gdGhpcy5saW5lV3JhcHBpbmcgfHwgdGhpcy5kaXJlY3Rpb24gIT0gZGlyZWN0aW9uO1xuICAgIH1cbiAgICByZWZyZXNoKHdoaXRlU3BhY2UsIGRpcmVjdGlvbiwgbGluZUhlaWdodCwgY2hhcldpZHRoLCBsaW5lTGVuZ3RoLCBrbm93bkhlaWdodHMpIHtcbiAgICAgICAgbGV0IGxpbmVXcmFwcGluZyA9IHdyYXBwaW5nV2hpdGVTcGFjZS5pbmRleE9mKHdoaXRlU3BhY2UpID4gLTE7XG4gICAgICAgIGxldCBjaGFuZ2VkID0gTWF0aC5yb3VuZChsaW5lSGVpZ2h0KSAhPSBNYXRoLnJvdW5kKHRoaXMubGluZUhlaWdodCkgfHxcbiAgICAgICAgICAgIHRoaXMubGluZVdyYXBwaW5nICE9IGxpbmVXcmFwcGluZyB8fFxuICAgICAgICAgICAgdGhpcy5kaXJlY3Rpb24gIT0gZGlyZWN0aW9uO1xuICAgICAgICB0aGlzLmxpbmVXcmFwcGluZyA9IGxpbmVXcmFwcGluZztcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgICAgIHRoaXMubGluZUhlaWdodCA9IGxpbmVIZWlnaHQ7XG4gICAgICAgIHRoaXMuY2hhcldpZHRoID0gY2hhcldpZHRoO1xuICAgICAgICB0aGlzLmxpbmVMZW5ndGggPSBsaW5lTGVuZ3RoO1xuICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5oZWlnaHRTYW1wbGVzID0ge307XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtub3duSGVpZ2h0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBoID0ga25vd25IZWlnaHRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChoIDwgMClcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWlnaHRTYW1wbGVzW01hdGguZmxvb3IoaCAqIDEwKV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFuZ2VkO1xuICAgIH1cbn1cbi8vIFRoaXMgb2JqZWN0IGlzIHVzZWQgYnkgYHVwZGF0ZUhlaWdodGAgdG8gbWFrZSBET00gbWVhc3VyZW1lbnRzXG4vLyBhcnJpdmUgYXQgdGhlIHJpZ2h0IG5pZGVzLiBUaGUgYGhlaWdodHNgIGFycmF5IGlzIGEgc2VxdWVuY2Ugb2Zcbi8vIGJsb2NrIGhlaWdodHMsIHN0YXJ0aW5nIGZyb20gcG9zaXRpb24gYGZyb21gLlxuY2xhc3MgTWVhc3VyZWRIZWlnaHRzIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCBoZWlnaHRzKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMuaGVpZ2h0cyA9IGhlaWdodHM7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIH1cbiAgICBnZXQgbW9yZSgpIHsgcmV0dXJuIHRoaXMuaW5kZXggPCB0aGlzLmhlaWdodHMubGVuZ3RoOyB9XG59XG4vKipcblJlY29yZCB1c2VkIHRvIHJlcHJlc2VudCBpbmZvcm1hdGlvbiBhYm91dCBhIGJsb2NrLWxldmVsIGVsZW1lbnRcbmluIHRoZSBlZGl0b3Igdmlldy5cbiovXG5jbGFzcyBCbG9ja0luZm8ge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IG9mIHRoZSBlbGVtZW50IGluIHRoZSBkb2N1bWVudC5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBsZW5ndGggb2YgdGhlIGVsZW1lbnQuXG4gICAgKi9cbiAgICBsZW5ndGgsIFxuICAgIC8qKlxuICAgIFRoZSB0b3AgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnQuXG4gICAgKi9cbiAgICB0b3AsIFxuICAgIC8qKlxuICAgIEl0cyBoZWlnaHQuXG4gICAgKi9cbiAgICBoZWlnaHQsIFxuICAgIC8qKlxuICAgIFRoZSB0eXBlIG9mIGVsZW1lbnQgdGhpcyBpcy4gV2hlbiBxdWVyeWluZyBsaW5lcywgdGhpcyBtYXkgYmVcbiAgICBhbiBhcnJheSBvZiBhbGwgdGhlIGJsb2NrcyB0aGF0IG1ha2UgdXAgdGhlIGxpbmUuXG4gICAgKi9cbiAgICB0eXBlKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0aGlzLnRvcCA9IHRvcDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBlbmQgb2YgdGhlIGVsZW1lbnQgYXMgYSBkb2N1bWVudCBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGdldCB0bygpIHsgcmV0dXJuIHRoaXMuZnJvbSArIHRoaXMubGVuZ3RoOyB9XG4gICAgLyoqXG4gICAgVGhlIGJvdHRvbSBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudC5cbiAgICAqL1xuICAgIGdldCBib3R0b20oKSB7IHJldHVybiB0aGlzLnRvcCArIHRoaXMuaGVpZ2h0OyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBqb2luKG90aGVyKSB7XG4gICAgICAgIGxldCBkZXRhaWwgPSAoQXJyYXkuaXNBcnJheSh0aGlzLnR5cGUpID8gdGhpcy50eXBlIDogW3RoaXNdKVxuICAgICAgICAgICAgLmNvbmNhdChBcnJheS5pc0FycmF5KG90aGVyLnR5cGUpID8gb3RoZXIudHlwZSA6IFtvdGhlcl0pO1xuICAgICAgICByZXR1cm4gbmV3IEJsb2NrSW5mbyh0aGlzLmZyb20sIHRoaXMubGVuZ3RoICsgb3RoZXIubGVuZ3RoLCB0aGlzLnRvcCwgdGhpcy5oZWlnaHQgKyBvdGhlci5oZWlnaHQsIGRldGFpbCk7XG4gICAgfVxufVxudmFyIFF1ZXJ5VHlwZTtcbihmdW5jdGlvbiAoUXVlcnlUeXBlKSB7XG4gICAgUXVlcnlUeXBlW1F1ZXJ5VHlwZVtcIkJ5UG9zXCJdID0gMF0gPSBcIkJ5UG9zXCI7XG4gICAgUXVlcnlUeXBlW1F1ZXJ5VHlwZVtcIkJ5SGVpZ2h0XCJdID0gMV0gPSBcIkJ5SGVpZ2h0XCI7XG4gICAgUXVlcnlUeXBlW1F1ZXJ5VHlwZVtcIkJ5UG9zTm9IZWlnaHRcIl0gPSAyXSA9IFwiQnlQb3NOb0hlaWdodFwiO1xufSkoUXVlcnlUeXBlIHx8IChRdWVyeVR5cGUgPSB7fSkpO1xuY29uc3QgRXBzaWxvbiA9IDFlLTQ7XG5jbGFzcyBIZWlnaHRNYXAge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCwgLy8gVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGNvdmVyZWRcbiAgICBoZWlnaHQsIC8vIEhlaWdodCBvZiB0aGlzIHBhcnQgb2YgdGhlIGRvY3VtZW50XG4gICAgZmxhZ3MgPSAyIC8qIE91dGRhdGVkICovKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgIH1cbiAgICBnZXQgb3V0ZGF0ZWQoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDIgLyogT3V0ZGF0ZWQgKi8pID4gMDsgfVxuICAgIHNldCBvdXRkYXRlZCh2YWx1ZSkgeyB0aGlzLmZsYWdzID0gKHZhbHVlID8gMiAvKiBPdXRkYXRlZCAqLyA6IDApIHwgKHRoaXMuZmxhZ3MgJiB+MiAvKiBPdXRkYXRlZCAqLyk7IH1cbiAgICBzZXRIZWlnaHQob3JhY2xlLCBoZWlnaHQpIHtcbiAgICAgICAgaWYgKHRoaXMuaGVpZ2h0ICE9IGhlaWdodCkge1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuaGVpZ2h0IC0gaGVpZ2h0KSA+IEVwc2lsb24pXG4gICAgICAgICAgICAgICAgb3JhY2xlLmhlaWdodENoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQmFzZSBjYXNlIGlzIHRvIHJlcGxhY2UgYSBsZWFmIG5vZGUsIHdoaWNoIHNpbXBseSBidWlsZHMgYSB0cmVlXG4gICAgLy8gZnJvbSB0aGUgbmV3IG5vZGVzIGFuZCByZXR1cm5zIHRoYXQgKEhlaWdodE1hcEJyYW5jaCBhbmRcbiAgICAvLyBIZWlnaHRNYXBHYXAgb3ZlcnJpZGUgdGhpcyB0byBhY3R1YWxseSB1c2UgZnJvbS90bylcbiAgICByZXBsYWNlKF9mcm9tLCBfdG8sIG5vZGVzKSB7XG4gICAgICAgIHJldHVybiBIZWlnaHRNYXAub2Yobm9kZXMpO1xuICAgIH1cbiAgICAvLyBBZ2FpbiwgdGhlc2UgYXJlIGJhc2UgY2FzZXMsIGFuZCBhcmUgb3ZlcnJpZGRlbiBmb3IgYnJhbmNoIGFuZCBnYXAgbm9kZXMuXG4gICAgZGVjb21wb3NlTGVmdChfdG8sIHJlc3VsdCkgeyByZXN1bHQucHVzaCh0aGlzKTsgfVxuICAgIGRlY29tcG9zZVJpZ2h0KF9mcm9tLCByZXN1bHQpIHsgcmVzdWx0LnB1c2godGhpcyk7IH1cbiAgICBhcHBseUNoYW5nZXMoZGVjb3JhdGlvbnMsIG9sZERvYywgb3JhY2xlLCBjaGFuZ2VzKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSBjaGFuZ2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgeyBmcm9tQSwgdG9BLCBmcm9tQiwgdG9CIH0gPSBjaGFuZ2VzW2ldO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gbWUubGluZUF0KGZyb21BLCBRdWVyeVR5cGUuQnlQb3NOb0hlaWdodCwgb2xkRG9jLCAwLCAwKTtcbiAgICAgICAgICAgIGxldCBlbmQgPSBzdGFydC50byA+PSB0b0EgPyBzdGFydCA6IG1lLmxpbmVBdCh0b0EsIFF1ZXJ5VHlwZS5CeVBvc05vSGVpZ2h0LCBvbGREb2MsIDAsIDApO1xuICAgICAgICAgICAgdG9CICs9IGVuZC50byAtIHRvQTtcbiAgICAgICAgICAgIHRvQSA9IGVuZC50bztcbiAgICAgICAgICAgIHdoaWxlIChpID4gMCAmJiBzdGFydC5mcm9tIDw9IGNoYW5nZXNbaSAtIDFdLnRvQSkge1xuICAgICAgICAgICAgICAgIGZyb21BID0gY2hhbmdlc1tpIC0gMV0uZnJvbUE7XG4gICAgICAgICAgICAgICAgZnJvbUIgPSBjaGFuZ2VzW2kgLSAxXS5mcm9tQjtcbiAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgaWYgKGZyb21BIDwgc3RhcnQuZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBtZS5saW5lQXQoZnJvbUEsIFF1ZXJ5VHlwZS5CeVBvc05vSGVpZ2h0LCBvbGREb2MsIDAsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnJvbUIgKz0gc3RhcnQuZnJvbSAtIGZyb21BO1xuICAgICAgICAgICAgZnJvbUEgPSBzdGFydC5mcm9tO1xuICAgICAgICAgICAgbGV0IG5vZGVzID0gTm9kZUJ1aWxkZXIuYnVpbGQob3JhY2xlLCBkZWNvcmF0aW9ucywgZnJvbUIsIHRvQik7XG4gICAgICAgICAgICBtZSA9IG1lLnJlcGxhY2UoZnJvbUEsIHRvQSwgbm9kZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZS51cGRhdGVIZWlnaHQob3JhY2xlLCAwKTtcbiAgICB9XG4gICAgc3RhdGljIGVtcHR5KCkgeyByZXR1cm4gbmV3IEhlaWdodE1hcFRleHQoMCwgMCk7IH1cbiAgICAvLyBub2RlcyB1c2VzIG51bGwgdmFsdWVzIHRvIGluZGljYXRlIHRoZSBwb3NpdGlvbiBvZiBsaW5lIGJyZWFrcy5cbiAgICAvLyBUaGVyZSBhcmUgbmV2ZXIgbGluZSBicmVha3MgYXQgdGhlIHN0YXJ0IG9yIGVuZCBvZiB0aGUgYXJyYXksIG9yXG4gICAgLy8gdHdvIGxpbmUgYnJlYWtzIG5leHQgdG8gZWFjaCBvdGhlciwgYW5kIHRoZSBhcnJheSBpc24ndCBhbGxvd2VkXG4gICAgLy8gdG8gYmUgZW1wdHkgKHNhbWUgcmVzdHJpY3Rpb25zIGFzIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBidWlsZGVyKS5cbiAgICBzdGF0aWMgb2Yobm9kZXMpIHtcbiAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCA9PSAxKVxuICAgICAgICAgICAgcmV0dXJuIG5vZGVzWzBdO1xuICAgICAgICBsZXQgaSA9IDAsIGogPSBub2Rlcy5sZW5ndGgsIGJlZm9yZSA9IDAsIGFmdGVyID0gMDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKGkgPT0gaikge1xuICAgICAgICAgICAgICAgIGlmIChiZWZvcmUgPiBhZnRlciAqIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNwbGl0ID0gbm9kZXNbaSAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3BsaXQuYnJlYWspXG4gICAgICAgICAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoLS1pLCAxLCBzcGxpdC5sZWZ0LCBudWxsLCBzcGxpdC5yaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZSgtLWksIDEsIHNwbGl0LmxlZnQsIHNwbGl0LnJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgaiArPSAxICsgc3BsaXQuYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZSAtPSBzcGxpdC5zaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhZnRlciA+IGJlZm9yZSAqIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNwbGl0ID0gbm9kZXNbal07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGxpdC5icmVhaylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZShqLCAxLCBzcGxpdC5sZWZ0LCBudWxsLCBzcGxpdC5yaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZShqLCAxLCBzcGxpdC5sZWZ0LCBzcGxpdC5yaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGogKz0gMiArIHNwbGl0LmJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBhZnRlciAtPSBzcGxpdC5zaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmVmb3JlIDwgYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IG5vZGVzW2krK107XG4gICAgICAgICAgICAgICAgaWYgKG5leHQpXG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZSArPSBuZXh0LnNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IG5vZGVzWy0tal07XG4gICAgICAgICAgICAgICAgaWYgKG5leHQpXG4gICAgICAgICAgICAgICAgICAgIGFmdGVyICs9IG5leHQuc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgYnJrID0gMDtcbiAgICAgICAgaWYgKG5vZGVzW2kgLSAxXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBicmsgPSAxO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGVzW2ldID09IG51bGwpIHtcbiAgICAgICAgICAgIGJyayA9IDE7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBIZWlnaHRNYXBCcmFuY2goSGVpZ2h0TWFwLm9mKG5vZGVzLnNsaWNlKDAsIGkpKSwgYnJrLCBIZWlnaHRNYXAub2Yobm9kZXMuc2xpY2UoaikpKTtcbiAgICB9XG59XG5IZWlnaHRNYXAucHJvdG90eXBlLnNpemUgPSAxO1xuY2xhc3MgSGVpZ2h0TWFwQmxvY2sgZXh0ZW5kcyBIZWlnaHRNYXAge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCwgaGVpZ2h0LCB0eXBlKSB7XG4gICAgICAgIHN1cGVyKGxlbmd0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB9XG4gICAgYmxvY2tBdChfaGVpZ2h0LCBfZG9jLCB0b3AsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gbmV3IEJsb2NrSW5mbyhvZmZzZXQsIHRoaXMubGVuZ3RoLCB0b3AsIHRoaXMuaGVpZ2h0LCB0aGlzLnR5cGUpO1xuICAgIH1cbiAgICBsaW5lQXQoX3ZhbHVlLCBfdHlwZSwgZG9jLCB0b3AsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ibG9ja0F0KDAsIGRvYywgdG9wLCBvZmZzZXQpO1xuICAgIH1cbiAgICBmb3JFYWNoTGluZShfZnJvbSwgX3RvLCBkb2MsIHRvcCwgb2Zmc2V0LCBmKSB7XG4gICAgICAgIGYodGhpcy5ibG9ja0F0KDAsIGRvYywgdG9wLCBvZmZzZXQpKTtcbiAgICB9XG4gICAgdXBkYXRlSGVpZ2h0KG9yYWNsZSwgb2Zmc2V0ID0gMCwgX2ZvcmNlID0gZmFsc2UsIG1lYXN1cmVkKSB7XG4gICAgICAgIGlmIChtZWFzdXJlZCAmJiBtZWFzdXJlZC5mcm9tIDw9IG9mZnNldCAmJiBtZWFzdXJlZC5tb3JlKVxuICAgICAgICAgICAgdGhpcy5zZXRIZWlnaHQob3JhY2xlLCBtZWFzdXJlZC5oZWlnaHRzW21lYXN1cmVkLmluZGV4KytdKTtcbiAgICAgICAgdGhpcy5vdXRkYXRlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiBgYmxvY2soJHt0aGlzLmxlbmd0aH0pYDsgfVxufVxuY2xhc3MgSGVpZ2h0TWFwVGV4dCBleHRlbmRzIEhlaWdodE1hcEJsb2NrIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgsIGhlaWdodCkge1xuICAgICAgICBzdXBlcihsZW5ndGgsIGhlaWdodCwgZXhwb3J0cy5CbG9ja1R5cGUuVGV4dCk7XG4gICAgICAgIHRoaXMuY29sbGFwc2VkID0gMDsgLy8gQW1vdW50IG9mIGNvbGxhcHNlZCBjb250ZW50IGluIHRoZSBsaW5lXG4gICAgICAgIHRoaXMud2lkZ2V0SGVpZ2h0ID0gMDsgLy8gTWF4aW11bSBpbmxpbmUgd2lkZ2V0IGhlaWdodFxuICAgIH1cbiAgICByZXBsYWNlKF9mcm9tLCBfdG8sIG5vZGVzKSB7XG4gICAgICAgIGxldCBub2RlID0gbm9kZXNbMF07XG4gICAgICAgIGlmIChub2Rlcy5sZW5ndGggPT0gMSAmJiAobm9kZSBpbnN0YW5jZW9mIEhlaWdodE1hcFRleHQgfHwgbm9kZSBpbnN0YW5jZW9mIEhlaWdodE1hcEdhcCAmJiAobm9kZS5mbGFncyAmIDQgLyogU2luZ2xlTGluZSAqLykpICYmXG4gICAgICAgICAgICBNYXRoLmFicyh0aGlzLmxlbmd0aCAtIG5vZGUubGVuZ3RoKSA8IDEwKSB7XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEhlaWdodE1hcEdhcClcbiAgICAgICAgICAgICAgICBub2RlID0gbmV3IEhlaWdodE1hcFRleHQobm9kZS5sZW5ndGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBub2RlLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKCF0aGlzLm91dGRhdGVkKVxuICAgICAgICAgICAgICAgIG5vZGUub3V0ZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIEhlaWdodE1hcC5vZihub2Rlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlSGVpZ2h0KG9yYWNsZSwgb2Zmc2V0ID0gMCwgZm9yY2UgPSBmYWxzZSwgbWVhc3VyZWQpIHtcbiAgICAgICAgaWYgKG1lYXN1cmVkICYmIG1lYXN1cmVkLmZyb20gPD0gb2Zmc2V0ICYmIG1lYXN1cmVkLm1vcmUpXG4gICAgICAgICAgICB0aGlzLnNldEhlaWdodChvcmFjbGUsIG1lYXN1cmVkLmhlaWdodHNbbWVhc3VyZWQuaW5kZXgrK10pO1xuICAgICAgICBlbHNlIGlmIChmb3JjZSB8fCB0aGlzLm91dGRhdGVkKVxuICAgICAgICAgICAgdGhpcy5zZXRIZWlnaHQob3JhY2xlLCBNYXRoLm1heCh0aGlzLndpZGdldEhlaWdodCwgb3JhY2xlLmhlaWdodEZvckxpbmUodGhpcy5sZW5ndGggLSB0aGlzLmNvbGxhcHNlZCkpKTtcbiAgICAgICAgdGhpcy5vdXRkYXRlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgbGluZSgke3RoaXMubGVuZ3RofSR7dGhpcy5jb2xsYXBzZWQgPyAtdGhpcy5jb2xsYXBzZWQgOiBcIlwifSR7dGhpcy53aWRnZXRIZWlnaHQgPyBcIjpcIiArIHRoaXMud2lkZ2V0SGVpZ2h0IDogXCJcIn0pYDtcbiAgICB9XG59XG5jbGFzcyBIZWlnaHRNYXBHYXAgZXh0ZW5kcyBIZWlnaHRNYXAge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCkgeyBzdXBlcihsZW5ndGgsIDApOyB9XG4gICAgbGluZXMoZG9jLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IGZpcnN0TGluZSA9IGRvYy5saW5lQXQob2Zmc2V0KS5udW1iZXIsIGxhc3RMaW5lID0gZG9jLmxpbmVBdChvZmZzZXQgKyB0aGlzLmxlbmd0aCkubnVtYmVyO1xuICAgICAgICByZXR1cm4geyBmaXJzdExpbmUsIGxhc3RMaW5lLCBsaW5lSGVpZ2h0OiB0aGlzLmhlaWdodCAvIChsYXN0TGluZSAtIGZpcnN0TGluZSArIDEpIH07XG4gICAgfVxuICAgIGJsb2NrQXQoaGVpZ2h0LCBkb2MsIHRvcCwgb2Zmc2V0KSB7XG4gICAgICAgIGxldCB7IGZpcnN0TGluZSwgbGFzdExpbmUsIGxpbmVIZWlnaHQgfSA9IHRoaXMubGluZXMoZG9jLCBvZmZzZXQpO1xuICAgICAgICBsZXQgbGluZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKGxhc3RMaW5lIC0gZmlyc3RMaW5lLCBNYXRoLmZsb29yKChoZWlnaHQgLSB0b3ApIC8gbGluZUhlaWdodCkpKTtcbiAgICAgICAgbGV0IHsgZnJvbSwgbGVuZ3RoIH0gPSBkb2MubGluZShmaXJzdExpbmUgKyBsaW5lKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9ja0luZm8oZnJvbSwgbGVuZ3RoLCB0b3AgKyBsaW5lSGVpZ2h0ICogbGluZSwgbGluZUhlaWdodCwgZXhwb3J0cy5CbG9ja1R5cGUuVGV4dCk7XG4gICAgfVxuICAgIGxpbmVBdCh2YWx1ZSwgdHlwZSwgZG9jLCB0b3AsIG9mZnNldCkge1xuICAgICAgICBpZiAodHlwZSA9PSBRdWVyeVR5cGUuQnlIZWlnaHQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ibG9ja0F0KHZhbHVlLCBkb2MsIHRvcCwgb2Zmc2V0KTtcbiAgICAgICAgaWYgKHR5cGUgPT0gUXVlcnlUeXBlLkJ5UG9zTm9IZWlnaHQpIHtcbiAgICAgICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSBkb2MubGluZUF0KHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmxvY2tJbmZvKGZyb20sIHRvIC0gZnJvbSwgMCwgMCwgZXhwb3J0cy5CbG9ja1R5cGUuVGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgZmlyc3RMaW5lLCBsaW5lSGVpZ2h0IH0gPSB0aGlzLmxpbmVzKGRvYywgb2Zmc2V0KTtcbiAgICAgICAgbGV0IHsgZnJvbSwgbGVuZ3RoLCBudW1iZXIgfSA9IGRvYy5saW5lQXQodmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IEJsb2NrSW5mbyhmcm9tLCBsZW5ndGgsIHRvcCArIGxpbmVIZWlnaHQgKiAobnVtYmVyIC0gZmlyc3RMaW5lKSwgbGluZUhlaWdodCwgZXhwb3J0cy5CbG9ja1R5cGUuVGV4dCk7XG4gICAgfVxuICAgIGZvckVhY2hMaW5lKGZyb20sIHRvLCBkb2MsIHRvcCwgb2Zmc2V0LCBmKSB7XG4gICAgICAgIGxldCB7IGZpcnN0TGluZSwgbGluZUhlaWdodCB9ID0gdGhpcy5saW5lcyhkb2MsIG9mZnNldCk7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IE1hdGgubWF4KGZyb20sIG9mZnNldCksIGVuZCA9IE1hdGgubWluKG9mZnNldCArIHRoaXMubGVuZ3RoLCB0byk7IHBvcyA8PSBlbmQ7KSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IGRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgICAgIGlmIChwb3MgPT0gZnJvbSlcbiAgICAgICAgICAgICAgICB0b3AgKz0gbGluZUhlaWdodCAqIChsaW5lLm51bWJlciAtIGZpcnN0TGluZSk7XG4gICAgICAgICAgICBmKG5ldyBCbG9ja0luZm8obGluZS5mcm9tLCBsaW5lLmxlbmd0aCwgdG9wLCBsaW5lSGVpZ2h0LCBleHBvcnRzLkJsb2NrVHlwZS5UZXh0KSk7XG4gICAgICAgICAgICB0b3AgKz0gbGluZUhlaWdodDtcbiAgICAgICAgICAgIHBvcyA9IGxpbmUudG8gKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcGxhY2UoZnJvbSwgdG8sIG5vZGVzKSB7XG4gICAgICAgIGxldCBhZnRlciA9IHRoaXMubGVuZ3RoIC0gdG87XG4gICAgICAgIGlmIChhZnRlciA+IDApIHtcbiAgICAgICAgICAgIGxldCBsYXN0ID0gbm9kZXNbbm9kZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAobGFzdCBpbnN0YW5jZW9mIEhlaWdodE1hcEdhcClcbiAgICAgICAgICAgICAgICBub2Rlc1tub2Rlcy5sZW5ndGggLSAxXSA9IG5ldyBIZWlnaHRNYXBHYXAobGFzdC5sZW5ndGggKyBhZnRlcik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaChudWxsLCBuZXcgSGVpZ2h0TWFwR2FwKGFmdGVyIC0gMSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcm9tID4gMCkge1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gbm9kZXNbMF07XG4gICAgICAgICAgICBpZiAoZmlyc3QgaW5zdGFuY2VvZiBIZWlnaHRNYXBHYXApXG4gICAgICAgICAgICAgICAgbm9kZXNbMF0gPSBuZXcgSGVpZ2h0TWFwR2FwKGZyb20gKyBmaXJzdC5sZW5ndGgpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG5vZGVzLnVuc2hpZnQobmV3IEhlaWdodE1hcEdhcChmcm9tIC0gMSksIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBIZWlnaHRNYXAub2Yobm9kZXMpO1xuICAgIH1cbiAgICBkZWNvbXBvc2VMZWZ0KHRvLCByZXN1bHQpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobmV3IEhlaWdodE1hcEdhcCh0byAtIDEpLCBudWxsKTtcbiAgICB9XG4gICAgZGVjb21wb3NlUmlnaHQoZnJvbSwgcmVzdWx0KSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG51bGwsIG5ldyBIZWlnaHRNYXBHYXAodGhpcy5sZW5ndGggLSBmcm9tIC0gMSkpO1xuICAgIH1cbiAgICB1cGRhdGVIZWlnaHQob3JhY2xlLCBvZmZzZXQgPSAwLCBmb3JjZSA9IGZhbHNlLCBtZWFzdXJlZCkge1xuICAgICAgICBsZXQgZW5kID0gb2Zmc2V0ICsgdGhpcy5sZW5ndGg7XG4gICAgICAgIGlmIChtZWFzdXJlZCAmJiBtZWFzdXJlZC5mcm9tIDw9IG9mZnNldCArIHRoaXMubGVuZ3RoICYmIG1lYXN1cmVkLm1vcmUpIHtcbiAgICAgICAgICAgIC8vIEZpbGwgaW4gcGFydCBvZiB0aGlzIGdhcCB3aXRoIG1lYXN1cmVkIGxpbmVzLiBXZSBrbm93IHRoZXJlXG4gICAgICAgICAgICAvLyBjYW4ndCBiZSB3aWRnZXRzIG9yIGNvbGxhcHNlZCByYW5nZXMgaW4gdGhvc2UgbGluZXMsIGJlY2F1c2VcbiAgICAgICAgICAgIC8vIHRoZXkgd291bGQgYWxyZWFkeSBoYXZlIGJlZW4gYWRkZWQgdG8gdGhlIGhlaWdodG1hcCAoZ2Fwc1xuICAgICAgICAgICAgLy8gb25seSBjb250YWluIHBsYWluIHRleHQpLlxuICAgICAgICAgICAgbGV0IG5vZGVzID0gW10sIHBvcyA9IE1hdGgubWF4KG9mZnNldCwgbWVhc3VyZWQuZnJvbSk7XG4gICAgICAgICAgICBpZiAobWVhc3VyZWQuZnJvbSA+IG9mZnNldClcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG5ldyBIZWlnaHRNYXBHYXAobWVhc3VyZWQuZnJvbSAtIG9mZnNldCAtIDEpLnVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCkpO1xuICAgICAgICAgICAgd2hpbGUgKHBvcyA8PSBlbmQgJiYgbWVhc3VyZWQubW9yZSkge1xuICAgICAgICAgICAgICAgIGxldCBsZW4gPSBvcmFjbGUuZG9jLmxpbmVBdChwb3MpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobm9kZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgIGxldCBsaW5lID0gbmV3IEhlaWdodE1hcFRleHQobGVuLCBtZWFzdXJlZC5oZWlnaHRzW21lYXN1cmVkLmluZGV4KytdKTtcbiAgICAgICAgICAgICAgICBsaW5lLm91dGRhdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaChsaW5lKTtcbiAgICAgICAgICAgICAgICBwb3MgKz0gbGVuICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3MgPD0gZW5kKVxuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2gobnVsbCwgbmV3IEhlaWdodE1hcEdhcChlbmQgLSBwb3MpLnVwZGF0ZUhlaWdodChvcmFjbGUsIHBvcykpO1xuICAgICAgICAgICAgb3JhY2xlLmhlaWdodENoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIEhlaWdodE1hcC5vZihub2Rlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZm9yY2UgfHwgdGhpcy5vdXRkYXRlZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRIZWlnaHQob3JhY2xlLCBvcmFjbGUuaGVpZ2h0Rm9yR2FwKG9mZnNldCwgb2Zmc2V0ICsgdGhpcy5sZW5ndGgpKTtcbiAgICAgICAgICAgIHRoaXMub3V0ZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiBgZ2FwKCR7dGhpcy5sZW5ndGh9KWA7IH1cbn1cbmNsYXNzIEhlaWdodE1hcEJyYW5jaCBleHRlbmRzIEhlaWdodE1hcCB7XG4gICAgY29uc3RydWN0b3IobGVmdCwgYnJrLCByaWdodCkge1xuICAgICAgICBzdXBlcihsZWZ0Lmxlbmd0aCArIGJyayArIHJpZ2h0Lmxlbmd0aCwgbGVmdC5oZWlnaHQgKyByaWdodC5oZWlnaHQsIGJyayB8IChsZWZ0Lm91dGRhdGVkIHx8IHJpZ2h0Lm91dGRhdGVkID8gMiAvKiBPdXRkYXRlZCAqLyA6IDApKTtcbiAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgICAgICB0aGlzLnNpemUgPSBsZWZ0LnNpemUgKyByaWdodC5zaXplO1xuICAgIH1cbiAgICBnZXQgYnJlYWsoKSB7IHJldHVybiB0aGlzLmZsYWdzICYgMSAvKiBCcmVhayAqLzsgfVxuICAgIGJsb2NrQXQoaGVpZ2h0LCBkb2MsIHRvcCwgb2Zmc2V0KSB7XG4gICAgICAgIGxldCBtaWQgPSB0b3AgKyB0aGlzLmxlZnQuaGVpZ2h0O1xuICAgICAgICByZXR1cm4gaGVpZ2h0IDwgbWlkIHx8IHRoaXMucmlnaHQuaGVpZ2h0ID09IDAgPyB0aGlzLmxlZnQuYmxvY2tBdChoZWlnaHQsIGRvYywgdG9wLCBvZmZzZXQpXG4gICAgICAgICAgICA6IHRoaXMucmlnaHQuYmxvY2tBdChoZWlnaHQsIGRvYywgbWlkLCBvZmZzZXQgKyB0aGlzLmxlZnQubGVuZ3RoICsgdGhpcy5icmVhayk7XG4gICAgfVxuICAgIGxpbmVBdCh2YWx1ZSwgdHlwZSwgZG9jLCB0b3AsIG9mZnNldCkge1xuICAgICAgICBsZXQgcmlnaHRUb3AgPSB0b3AgKyB0aGlzLmxlZnQuaGVpZ2h0LCByaWdodE9mZnNldCA9IG9mZnNldCArIHRoaXMubGVmdC5sZW5ndGggKyB0aGlzLmJyZWFrO1xuICAgICAgICBsZXQgbGVmdCA9IHR5cGUgPT0gUXVlcnlUeXBlLkJ5SGVpZ2h0ID8gdmFsdWUgPCByaWdodFRvcCB8fCB0aGlzLnJpZ2h0LmhlaWdodCA9PSAwIDogdmFsdWUgPCByaWdodE9mZnNldDtcbiAgICAgICAgbGV0IGJhc2UgPSBsZWZ0ID8gdGhpcy5sZWZ0LmxpbmVBdCh2YWx1ZSwgdHlwZSwgZG9jLCB0b3AsIG9mZnNldClcbiAgICAgICAgICAgIDogdGhpcy5yaWdodC5saW5lQXQodmFsdWUsIHR5cGUsIGRvYywgcmlnaHRUb3AsIHJpZ2h0T2Zmc2V0KTtcbiAgICAgICAgaWYgKHRoaXMuYnJlYWsgfHwgKGxlZnQgPyBiYXNlLnRvIDwgcmlnaHRPZmZzZXQgOiBiYXNlLmZyb20gPiByaWdodE9mZnNldCkpXG4gICAgICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgICAgbGV0IHN1YlF1ZXJ5ID0gdHlwZSA9PSBRdWVyeVR5cGUuQnlQb3NOb0hlaWdodCA/IFF1ZXJ5VHlwZS5CeVBvc05vSGVpZ2h0IDogUXVlcnlUeXBlLkJ5UG9zO1xuICAgICAgICBpZiAobGVmdClcbiAgICAgICAgICAgIHJldHVybiBiYXNlLmpvaW4odGhpcy5yaWdodC5saW5lQXQocmlnaHRPZmZzZXQsIHN1YlF1ZXJ5LCBkb2MsIHJpZ2h0VG9wLCByaWdodE9mZnNldCkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZWZ0LmxpbmVBdChyaWdodE9mZnNldCwgc3ViUXVlcnksIGRvYywgdG9wLCBvZmZzZXQpLmpvaW4oYmFzZSk7XG4gICAgfVxuICAgIGZvckVhY2hMaW5lKGZyb20sIHRvLCBkb2MsIHRvcCwgb2Zmc2V0LCBmKSB7XG4gICAgICAgIGxldCByaWdodFRvcCA9IHRvcCArIHRoaXMubGVmdC5oZWlnaHQsIHJpZ2h0T2Zmc2V0ID0gb2Zmc2V0ICsgdGhpcy5sZWZ0Lmxlbmd0aCArIHRoaXMuYnJlYWs7XG4gICAgICAgIGlmICh0aGlzLmJyZWFrKSB7XG4gICAgICAgICAgICBpZiAoZnJvbSA8IHJpZ2h0T2Zmc2V0KVxuICAgICAgICAgICAgICAgIHRoaXMubGVmdC5mb3JFYWNoTGluZShmcm9tLCB0bywgZG9jLCB0b3AsIG9mZnNldCwgZik7XG4gICAgICAgICAgICBpZiAodG8gPj0gcmlnaHRPZmZzZXQpXG4gICAgICAgICAgICAgICAgdGhpcy5yaWdodC5mb3JFYWNoTGluZShmcm9tLCB0bywgZG9jLCByaWdodFRvcCwgcmlnaHRPZmZzZXQsIGYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG1pZCA9IHRoaXMubGluZUF0KHJpZ2h0T2Zmc2V0LCBRdWVyeVR5cGUuQnlQb3MsIGRvYywgdG9wLCBvZmZzZXQpO1xuICAgICAgICAgICAgaWYgKGZyb20gPCBtaWQuZnJvbSlcbiAgICAgICAgICAgICAgICB0aGlzLmxlZnQuZm9yRWFjaExpbmUoZnJvbSwgbWlkLmZyb20gLSAxLCBkb2MsIHRvcCwgb2Zmc2V0LCBmKTtcbiAgICAgICAgICAgIGlmIChtaWQudG8gPj0gZnJvbSAmJiBtaWQuZnJvbSA8PSB0bylcbiAgICAgICAgICAgICAgICBmKG1pZCk7XG4gICAgICAgICAgICBpZiAodG8gPiBtaWQudG8pXG4gICAgICAgICAgICAgICAgdGhpcy5yaWdodC5mb3JFYWNoTGluZShtaWQudG8gKyAxLCB0bywgZG9jLCByaWdodFRvcCwgcmlnaHRPZmZzZXQsIGYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcGxhY2UoZnJvbSwgdG8sIG5vZGVzKSB7XG4gICAgICAgIGxldCByaWdodFN0YXJ0ID0gdGhpcy5sZWZ0Lmxlbmd0aCArIHRoaXMuYnJlYWs7XG4gICAgICAgIGlmICh0byA8IHJpZ2h0U3RhcnQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iYWxhbmNlZCh0aGlzLmxlZnQucmVwbGFjZShmcm9tLCB0bywgbm9kZXMpLCB0aGlzLnJpZ2h0KTtcbiAgICAgICAgaWYgKGZyb20gPiB0aGlzLmxlZnQubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFsYW5jZWQodGhpcy5sZWZ0LCB0aGlzLnJpZ2h0LnJlcGxhY2UoZnJvbSAtIHJpZ2h0U3RhcnQsIHRvIC0gcmlnaHRTdGFydCwgbm9kZXMpKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAoZnJvbSA+IDApXG4gICAgICAgICAgICB0aGlzLmRlY29tcG9zZUxlZnQoZnJvbSwgcmVzdWx0KTtcbiAgICAgICAgbGV0IGxlZnQgPSByZXN1bHQubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBub2RlIG9mIG5vZGVzKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2gobm9kZSk7XG4gICAgICAgIGlmIChmcm9tID4gMClcbiAgICAgICAgICAgIG1lcmdlR2FwcyhyZXN1bHQsIGxlZnQgLSAxKTtcbiAgICAgICAgaWYgKHRvIDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCByaWdodCA9IHJlc3VsdC5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLmRlY29tcG9zZVJpZ2h0KHRvLCByZXN1bHQpO1xuICAgICAgICAgICAgbWVyZ2VHYXBzKHJlc3VsdCwgcmlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBIZWlnaHRNYXAub2YocmVzdWx0KTtcbiAgICB9XG4gICAgZGVjb21wb3NlTGVmdCh0bywgcmVzdWx0KSB7XG4gICAgICAgIGxldCBsZWZ0ID0gdGhpcy5sZWZ0Lmxlbmd0aDtcbiAgICAgICAgaWYgKHRvIDw9IGxlZnQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZWZ0LmRlY29tcG9zZUxlZnQodG8sIHJlc3VsdCk7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRoaXMubGVmdCk7XG4gICAgICAgIGlmICh0aGlzLmJyZWFrKSB7XG4gICAgICAgICAgICBsZWZ0Kys7XG4gICAgICAgICAgICBpZiAodG8gPj0gbGVmdClcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG8gPiBsZWZ0KVxuICAgICAgICAgICAgdGhpcy5yaWdodC5kZWNvbXBvc2VMZWZ0KHRvIC0gbGVmdCwgcmVzdWx0KTtcbiAgICB9XG4gICAgZGVjb21wb3NlUmlnaHQoZnJvbSwgcmVzdWx0KSB7XG4gICAgICAgIGxldCBsZWZ0ID0gdGhpcy5sZWZ0Lmxlbmd0aCwgcmlnaHQgPSBsZWZ0ICsgdGhpcy5icmVhaztcbiAgICAgICAgaWYgKGZyb20gPj0gcmlnaHQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yaWdodC5kZWNvbXBvc2VSaWdodChmcm9tIC0gcmlnaHQsIHJlc3VsdCk7XG4gICAgICAgIGlmIChmcm9tIDwgbGVmdClcbiAgICAgICAgICAgIHRoaXMubGVmdC5kZWNvbXBvc2VSaWdodChmcm9tLCByZXN1bHQpO1xuICAgICAgICBpZiAodGhpcy5icmVhayAmJiBmcm9tIDwgcmlnaHQpXG4gICAgICAgICAgICByZXN1bHQucHVzaChudWxsKTtcbiAgICAgICAgcmVzdWx0LnB1c2godGhpcy5yaWdodCk7XG4gICAgfVxuICAgIGJhbGFuY2VkKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChsZWZ0LnNpemUgPiAyICogcmlnaHQuc2l6ZSB8fCByaWdodC5zaXplID4gMiAqIGxlZnQuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiBIZWlnaHRNYXAub2YodGhpcy5icmVhayA/IFtsZWZ0LCBudWxsLCByaWdodF0gOiBbbGVmdCwgcmlnaHRdKTtcbiAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgICAgICB0aGlzLmhlaWdodCA9IGxlZnQuaGVpZ2h0ICsgcmlnaHQuaGVpZ2h0O1xuICAgICAgICB0aGlzLm91dGRhdGVkID0gbGVmdC5vdXRkYXRlZCB8fCByaWdodC5vdXRkYXRlZDtcbiAgICAgICAgdGhpcy5zaXplID0gbGVmdC5zaXplICsgcmlnaHQuc2l6ZTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZWZ0Lmxlbmd0aCArIHRoaXMuYnJlYWsgKyByaWdodC5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB1cGRhdGVIZWlnaHQob3JhY2xlLCBvZmZzZXQgPSAwLCBmb3JjZSA9IGZhbHNlLCBtZWFzdXJlZCkge1xuICAgICAgICBsZXQgeyBsZWZ0LCByaWdodCB9ID0gdGhpcywgcmlnaHRTdGFydCA9IG9mZnNldCArIGxlZnQubGVuZ3RoICsgdGhpcy5icmVhaywgcmViYWxhbmNlID0gbnVsbDtcbiAgICAgICAgaWYgKG1lYXN1cmVkICYmIG1lYXN1cmVkLmZyb20gPD0gb2Zmc2V0ICsgbGVmdC5sZW5ndGggJiYgbWVhc3VyZWQubW9yZSlcbiAgICAgICAgICAgIHJlYmFsYW5jZSA9IGxlZnQgPSBsZWZ0LnVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCwgZm9yY2UsIG1lYXN1cmVkKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGVmdC51cGRhdGVIZWlnaHQob3JhY2xlLCBvZmZzZXQsIGZvcmNlKTtcbiAgICAgICAgaWYgKG1lYXN1cmVkICYmIG1lYXN1cmVkLmZyb20gPD0gcmlnaHRTdGFydCArIHJpZ2h0Lmxlbmd0aCAmJiBtZWFzdXJlZC5tb3JlKVxuICAgICAgICAgICAgcmViYWxhbmNlID0gcmlnaHQgPSByaWdodC51cGRhdGVIZWlnaHQob3JhY2xlLCByaWdodFN0YXJ0LCBmb3JjZSwgbWVhc3VyZWQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByaWdodC51cGRhdGVIZWlnaHQob3JhY2xlLCByaWdodFN0YXJ0LCBmb3JjZSk7XG4gICAgICAgIGlmIChyZWJhbGFuY2UpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iYWxhbmNlZChsZWZ0LCByaWdodCk7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5sZWZ0LmhlaWdodCArIHRoaXMucmlnaHQuaGVpZ2h0O1xuICAgICAgICB0aGlzLm91dGRhdGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIHRoaXMubGVmdCArICh0aGlzLmJyZWFrID8gXCIgXCIgOiBcIi1cIikgKyB0aGlzLnJpZ2h0OyB9XG59XG5mdW5jdGlvbiBtZXJnZUdhcHMobm9kZXMsIGFyb3VuZCkge1xuICAgIGxldCBiZWZvcmUsIGFmdGVyO1xuICAgIGlmIChub2Rlc1thcm91bmRdID09IG51bGwgJiZcbiAgICAgICAgKGJlZm9yZSA9IG5vZGVzW2Fyb3VuZCAtIDFdKSBpbnN0YW5jZW9mIEhlaWdodE1hcEdhcCAmJlxuICAgICAgICAoYWZ0ZXIgPSBub2Rlc1thcm91bmQgKyAxXSkgaW5zdGFuY2VvZiBIZWlnaHRNYXBHYXApXG4gICAgICAgIG5vZGVzLnNwbGljZShhcm91bmQgLSAxLCAzLCBuZXcgSGVpZ2h0TWFwR2FwKGJlZm9yZS5sZW5ndGggKyAxICsgYWZ0ZXIubGVuZ3RoKSk7XG59XG5jb25zdCByZWxldmFudFdpZGdldEhlaWdodCA9IDU7XG5jbGFzcyBOb2RlQnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IocG9zLCBvcmFjbGUpIHtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMub3JhY2xlID0gb3JhY2xlO1xuICAgICAgICB0aGlzLm5vZGVzID0gW107XG4gICAgICAgIHRoaXMubGluZVN0YXJ0ID0gLTE7XG4gICAgICAgIHRoaXMubGluZUVuZCA9IC0xO1xuICAgICAgICB0aGlzLmNvdmVyaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy53cml0dGVuVG8gPSBwb3M7XG4gICAgfVxuICAgIGdldCBpc0NvdmVyZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvdmVyaW5nICYmIHRoaXMubm9kZXNbdGhpcy5ub2Rlcy5sZW5ndGggLSAxXSA9PSB0aGlzLmNvdmVyaW5nO1xuICAgIH1cbiAgICBzcGFuKF9mcm9tLCB0bykge1xuICAgICAgICBpZiAodGhpcy5saW5lU3RhcnQgPiAtMSkge1xuICAgICAgICAgICAgbGV0IGVuZCA9IE1hdGgubWluKHRvLCB0aGlzLmxpbmVFbmQpLCBsYXN0ID0gdGhpcy5ub2Rlc1t0aGlzLm5vZGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKGxhc3QgaW5zdGFuY2VvZiBIZWlnaHRNYXBUZXh0KVxuICAgICAgICAgICAgICAgIGxhc3QubGVuZ3RoICs9IGVuZCAtIHRoaXMucG9zO1xuICAgICAgICAgICAgZWxzZSBpZiAoZW5kID4gdGhpcy5wb3MgfHwgIXRoaXMuaXNDb3ZlcmVkKVxuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaChuZXcgSGVpZ2h0TWFwVGV4dChlbmQgLSB0aGlzLnBvcywgLTEpKTtcbiAgICAgICAgICAgIHRoaXMud3JpdHRlblRvID0gZW5kO1xuICAgICAgICAgICAgaWYgKHRvID4gZW5kKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdHRlblRvKys7XG4gICAgICAgICAgICAgICAgdGhpcy5saW5lU3RhcnQgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvcyA9IHRvO1xuICAgIH1cbiAgICBwb2ludChmcm9tLCB0bywgZGVjbykge1xuICAgICAgICBpZiAoZnJvbSA8IHRvIHx8IGRlY28uaGVpZ2h0UmVsZXZhbnQpIHtcbiAgICAgICAgICAgIGxldCBoZWlnaHQgPSBkZWNvLndpZGdldCA/IE1hdGgubWF4KDAsIGRlY28ud2lkZ2V0LmVzdGltYXRlZEhlaWdodCkgOiAwO1xuICAgICAgICAgICAgbGV0IGxlbiA9IHRvIC0gZnJvbTtcbiAgICAgICAgICAgIGlmIChkZWNvLmJsb2NrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRCbG9jayhuZXcgSGVpZ2h0TWFwQmxvY2sobGVuLCBoZWlnaHQsIGRlY28udHlwZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGVuIHx8IGhlaWdodCA+PSByZWxldmFudFdpZGdldEhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkTGluZURlY28oaGVpZ2h0LCBsZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRvID4gZnJvbSkge1xuICAgICAgICAgICAgdGhpcy5zcGFuKGZyb20sIHRvKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5saW5lRW5kID4gLTEgJiYgdGhpcy5saW5lRW5kIDwgdGhpcy5wb3MpXG4gICAgICAgICAgICB0aGlzLmxpbmVFbmQgPSB0aGlzLm9yYWNsZS5kb2MubGluZUF0KHRoaXMucG9zKS50bztcbiAgICB9XG4gICAgZW50ZXJMaW5lKCkge1xuICAgICAgICBpZiAodGhpcy5saW5lU3RhcnQgPiAtMSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHRoaXMub3JhY2xlLmRvYy5saW5lQXQodGhpcy5wb3MpO1xuICAgICAgICB0aGlzLmxpbmVTdGFydCA9IGZyb207XG4gICAgICAgIHRoaXMubGluZUVuZCA9IHRvO1xuICAgICAgICBpZiAodGhpcy53cml0dGVuVG8gPCBmcm9tKSB7XG4gICAgICAgICAgICBpZiAodGhpcy53cml0dGVuVG8gPCBmcm9tIC0gMSB8fCB0aGlzLm5vZGVzW3RoaXMubm9kZXMubGVuZ3RoIC0gMV0gPT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2godGhpcy5ibGFua0NvbnRlbnQodGhpcy53cml0dGVuVG8sIGZyb20gLSAxKSk7XG4gICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2gobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucG9zID4gZnJvbSlcbiAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaChuZXcgSGVpZ2h0TWFwVGV4dCh0aGlzLnBvcyAtIGZyb20sIC0xKSk7XG4gICAgICAgIHRoaXMud3JpdHRlblRvID0gdGhpcy5wb3M7XG4gICAgfVxuICAgIGJsYW5rQ29udGVudChmcm9tLCB0bykge1xuICAgICAgICBsZXQgZ2FwID0gbmV3IEhlaWdodE1hcEdhcCh0byAtIGZyb20pO1xuICAgICAgICBpZiAodGhpcy5vcmFjbGUuZG9jLmxpbmVBdChmcm9tKS50byA9PSB0bylcbiAgICAgICAgICAgIGdhcC5mbGFncyB8PSA0IC8qIFNpbmdsZUxpbmUgKi87XG4gICAgICAgIHJldHVybiBnYXA7XG4gICAgfVxuICAgIGVuc3VyZUxpbmUoKSB7XG4gICAgICAgIHRoaXMuZW50ZXJMaW5lKCk7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5ub2Rlcy5sZW5ndGggPyB0aGlzLm5vZGVzW3RoaXMubm9kZXMubGVuZ3RoIC0gMV0gOiBudWxsO1xuICAgICAgICBpZiAobGFzdCBpbnN0YW5jZW9mIEhlaWdodE1hcFRleHQpXG4gICAgICAgICAgICByZXR1cm4gbGFzdDtcbiAgICAgICAgbGV0IGxpbmUgPSBuZXcgSGVpZ2h0TWFwVGV4dCgwLCAtMSk7XG4gICAgICAgIHRoaXMubm9kZXMucHVzaChsaW5lKTtcbiAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfVxuICAgIGFkZEJsb2NrKGJsb2NrKSB7XG4gICAgICAgIHRoaXMuZW50ZXJMaW5lKCk7XG4gICAgICAgIGlmIChibG9jay50eXBlID09IGV4cG9ydHMuQmxvY2tUeXBlLldpZGdldEFmdGVyICYmICF0aGlzLmlzQ292ZXJlZClcbiAgICAgICAgICAgIHRoaXMuZW5zdXJlTGluZSgpO1xuICAgICAgICB0aGlzLm5vZGVzLnB1c2goYmxvY2spO1xuICAgICAgICB0aGlzLndyaXR0ZW5UbyA9IHRoaXMucG9zID0gdGhpcy5wb3MgKyBibG9jay5sZW5ndGg7XG4gICAgICAgIGlmIChibG9jay50eXBlICE9IGV4cG9ydHMuQmxvY2tUeXBlLldpZGdldEJlZm9yZSlcbiAgICAgICAgICAgIHRoaXMuY292ZXJpbmcgPSBibG9jaztcbiAgICB9XG4gICAgYWRkTGluZURlY28oaGVpZ2h0LCBsZW5ndGgpIHtcbiAgICAgICAgbGV0IGxpbmUgPSB0aGlzLmVuc3VyZUxpbmUoKTtcbiAgICAgICAgbGluZS5sZW5ndGggKz0gbGVuZ3RoO1xuICAgICAgICBsaW5lLmNvbGxhcHNlZCArPSBsZW5ndGg7XG4gICAgICAgIGxpbmUud2lkZ2V0SGVpZ2h0ID0gTWF0aC5tYXgobGluZS53aWRnZXRIZWlnaHQsIGhlaWdodCk7XG4gICAgICAgIHRoaXMud3JpdHRlblRvID0gdGhpcy5wb3MgPSB0aGlzLnBvcyArIGxlbmd0aDtcbiAgICB9XG4gICAgZmluaXNoKGZyb20pIHtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLm5vZGVzLmxlbmd0aCA9PSAwID8gbnVsbCA6IHRoaXMubm9kZXNbdGhpcy5ub2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKHRoaXMubGluZVN0YXJ0ID4gLTEgJiYgIShsYXN0IGluc3RhbmNlb2YgSGVpZ2h0TWFwVGV4dCkgJiYgIXRoaXMuaXNDb3ZlcmVkKVxuICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG5ldyBIZWlnaHRNYXBUZXh0KDAsIC0xKSk7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMud3JpdHRlblRvIDwgdGhpcy5wb3MgfHwgbGFzdCA9PSBudWxsKVxuICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKHRoaXMuYmxhbmtDb250ZW50KHRoaXMud3JpdHRlblRvLCB0aGlzLnBvcykpO1xuICAgICAgICBsZXQgcG9zID0gZnJvbTtcbiAgICAgICAgZm9yIChsZXQgbm9kZSBvZiB0aGlzLm5vZGVzKSB7XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEhlaWdodE1hcFRleHQpXG4gICAgICAgICAgICAgICAgbm9kZS51cGRhdGVIZWlnaHQodGhpcy5vcmFjbGUsIHBvcyk7XG4gICAgICAgICAgICBwb3MgKz0gbm9kZSA/IG5vZGUubGVuZ3RoIDogMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlcztcbiAgICB9XG4gICAgLy8gQWx3YXlzIGNhbGxlZCB3aXRoIGEgcmVnaW9uIHRoYXQgb24gYm90aCBzaWRlcyBlaXRoZXIgc3RyZXRjaGVzXG4gICAgLy8gdG8gYSBsaW5lIGJyZWFrIG9yIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50LlxuICAgIC8vIFRoZSByZXR1cm5lZCBhcnJheSB1c2VzIG51bGwgdG8gaW5kaWNhdGUgbGluZSBicmVha3MsIGJ1dCBuZXZlclxuICAgIC8vIHN0YXJ0cyBvciBlbmRzIGluIGEgbGluZSBicmVhaywgb3IgaGFzIG11bHRpcGxlIGxpbmUgYnJlYWtzIG5leHRcbiAgICAvLyB0byBlYWNoIG90aGVyLlxuICAgIHN0YXRpYyBidWlsZChvcmFjbGUsIGRlY29yYXRpb25zLCBmcm9tLCB0bykge1xuICAgICAgICBsZXQgYnVpbGRlciA9IG5ldyBOb2RlQnVpbGRlcihmcm9tLCBvcmFjbGUpO1xuICAgICAgICByYW5nZXNldC5SYW5nZVNldC5zcGFucyhkZWNvcmF0aW9ucywgZnJvbSwgdG8sIGJ1aWxkZXIsIDApO1xuICAgICAgICByZXR1cm4gYnVpbGRlci5maW5pc2goZnJvbSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaGVpZ2h0UmVsZXZhbnREZWNvQ2hhbmdlcyhhLCBiLCBkaWZmKSB7XG4gICAgbGV0IGNvbXAgPSBuZXcgRGVjb3JhdGlvbkNvbXBhcmF0b3I7XG4gICAgcmFuZ2VzZXQuUmFuZ2VTZXQuY29tcGFyZShhLCBiLCBkaWZmLCBjb21wLCAwKTtcbiAgICByZXR1cm4gY29tcC5jaGFuZ2VzO1xufVxuY2xhc3MgRGVjb3JhdGlvbkNvbXBhcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBbXTtcbiAgICB9XG4gICAgY29tcGFyZVJhbmdlKCkgeyB9XG4gICAgY29tcGFyZVBvaW50KGZyb20sIHRvLCBhLCBiKSB7XG4gICAgICAgIGlmIChmcm9tIDwgdG8gfHwgYSAmJiBhLmhlaWdodFJlbGV2YW50IHx8IGIgJiYgYi5oZWlnaHRSZWxldmFudClcbiAgICAgICAgICAgIGFkZFJhbmdlKGZyb20sIHRvLCB0aGlzLmNoYW5nZXMsIDUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdmlzaWJsZVBpeGVsUmFuZ2UoZG9tLCBwYWRkaW5nVG9wKSB7XG4gICAgbGV0IHJlY3QgPSBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IGxlZnQgPSBNYXRoLm1heCgwLCByZWN0LmxlZnQpLCByaWdodCA9IE1hdGgubWluKGlubmVyV2lkdGgsIHJlY3QucmlnaHQpO1xuICAgIGxldCB0b3AgPSBNYXRoLm1heCgwLCByZWN0LnRvcCksIGJvdHRvbSA9IE1hdGgubWluKGlubmVySGVpZ2h0LCByZWN0LmJvdHRvbSk7XG4gICAgZm9yIChsZXQgcGFyZW50ID0gZG9tLnBhcmVudE5vZGU7IHBhcmVudDspIHsgLy8gKENhc3QgdG8gYW55IGJlY2F1c2UgVHlwZVNjcmlwdCBpcyB1c2VsZXNzIHdpdGggTm9kZSB0eXBlcylcbiAgICAgICAgaWYgKHBhcmVudC5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICBpZiAoKHBhcmVudC5zY3JvbGxIZWlnaHQgPiBwYXJlbnQuY2xpZW50SGVpZ2h0IHx8IHBhcmVudC5zY3JvbGxXaWR0aCA+IHBhcmVudC5jbGllbnRXaWR0aCkgJiZcbiAgICAgICAgICAgICAgICB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnQpLm92ZXJmbG93ICE9IFwidmlzaWJsZVwiKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmVudFJlY3QgPSBwYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgbGVmdCA9IE1hdGgubWF4KGxlZnQsIHBhcmVudFJlY3QubGVmdCk7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSBNYXRoLm1pbihyaWdodCwgcGFyZW50UmVjdC5yaWdodCk7XG4gICAgICAgICAgICAgICAgdG9wID0gTWF0aC5tYXgodG9wLCBwYXJlbnRSZWN0LnRvcCk7XG4gICAgICAgICAgICAgICAgYm90dG9tID0gTWF0aC5taW4oYm90dG9tLCBwYXJlbnRSZWN0LmJvdHRvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJlbnQubm9kZVR5cGUgPT0gMTEpIHsgLy8gU2hhZG93IHJvb3RcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5ob3N0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgbGVmdDogbGVmdCAtIHJlY3QubGVmdCwgcmlnaHQ6IHJpZ2h0IC0gcmVjdC5sZWZ0LFxuICAgICAgICB0b3A6IHRvcCAtIChyZWN0LnRvcCArIHBhZGRpbmdUb3ApLCBib3R0b206IGJvdHRvbSAtIChyZWN0LnRvcCArIHBhZGRpbmdUb3ApIH07XG59XG4vLyBMaW5lIGdhcHMgYXJlIHBsYWNlaG9sZGVyIHdpZGdldHMgdXNlZCB0byBoaWRlIHBpZWNlcyBvZiBvdmVybG9uZ1xuLy8gbGluZXMgd2l0aGluIHRoZSB2aWV3cG9ydCwgYXMgYSBrbHVkZ2UgdG8ga2VlcCB0aGUgZWRpdG9yXG4vLyByZXNwb25zaXZlIHdoZW4gYSByaWRpY3Vsb3VzbHkgbG9uZyBsaW5lIGlzIGxvYWRlZCBpbnRvIGl0LlxuY2xhc3MgTGluZUdhcCB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8sIHNpemUpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgIH1cbiAgICBzdGF0aWMgc2FtZShhLCBiKSB7XG4gICAgICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgZ0EgPSBhW2ldLCBnQiA9IGJbaV07XG4gICAgICAgICAgICBpZiAoZ0EuZnJvbSAhPSBnQi5mcm9tIHx8IGdBLnRvICE9IGdCLnRvIHx8IGdBLnNpemUgIT0gZ0Iuc2l6ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGRyYXcod3JhcHBpbmcpIHtcbiAgICAgICAgcmV0dXJuIERlY29yYXRpb24ucmVwbGFjZSh7IHdpZGdldDogbmV3IExpbmVHYXBXaWRnZXQodGhpcy5zaXplLCB3cmFwcGluZykgfSkucmFuZ2UodGhpcy5mcm9tLCB0aGlzLnRvKTtcbiAgICB9XG59XG5jbGFzcyBMaW5lR2FwV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3Ioc2l6ZSwgdmVydGljYWwpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICAgICAgdGhpcy52ZXJ0aWNhbCA9IHZlcnRpY2FsO1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gb3RoZXIuc2l6ZSA9PSB0aGlzLnNpemUgJiYgb3RoZXIudmVydGljYWwgPT0gdGhpcy52ZXJ0aWNhbDsgfVxuICAgIHRvRE9NKCkge1xuICAgICAgICBsZXQgZWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgaWYgKHRoaXMudmVydGljYWwpIHtcbiAgICAgICAgICAgIGVsdC5zdHlsZS5oZWlnaHQgPSB0aGlzLnNpemUgKyBcInB4XCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbHQuc3R5bGUud2lkdGggPSB0aGlzLnNpemUgKyBcInB4XCI7XG4gICAgICAgICAgICBlbHQuc3R5bGUuaGVpZ2h0ID0gXCIycHhcIjtcbiAgICAgICAgICAgIGVsdC5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWx0O1xuICAgIH1cbiAgICBnZXQgZXN0aW1hdGVkSGVpZ2h0KCkgeyByZXR1cm4gdGhpcy52ZXJ0aWNhbCA/IHRoaXMuc2l6ZSA6IC0xOyB9XG59XG5jbGFzcyBWaWV3U3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKHN0YXRlKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgLy8gVGhlc2UgYXJlIGNvbnRlbnRET00tbG9jYWwgY29vcmRpbmF0ZXNcbiAgICAgICAgdGhpcy5waXhlbFZpZXdwb3J0ID0geyBsZWZ0OiAwLCByaWdodDogd2luZG93LmlubmVyV2lkdGgsIHRvcDogMCwgYm90dG9tOiAwIH07XG4gICAgICAgIHRoaXMuaW5WaWV3ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wYWRkaW5nVG9wID0gMDtcbiAgICAgICAgdGhpcy5wYWRkaW5nQm90dG9tID0gMDtcbiAgICAgICAgdGhpcy5jb250ZW50V2lkdGggPSAwO1xuICAgICAgICB0aGlzLmhlaWdodE9yYWNsZSA9IG5ldyBIZWlnaHRPcmFjbGU7XG4gICAgICAgIC8vIFNlZSBWUC5NYXhET01IZWlnaHRcbiAgICAgICAgdGhpcy5zY2FsZXIgPSBJZFNjYWxlcjtcbiAgICAgICAgdGhpcy5zY3JvbGxUbyA9IG51bGw7XG4gICAgICAgIC8vIEJyaWVmbHkgc2V0IHRvIHRydWUgd2hlbiBwcmludGluZywgdG8gZGlzYWJsZSB2aWV3cG9ydCBsaW1pdGluZ1xuICAgICAgICB0aGlzLnByaW50aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMudmlzaWJsZVJhbmdlcyA9IFtdO1xuICAgICAgICAvLyBDdXJzb3IgJ2Fzc29jJyBpcyBvbmx5IHNpZ25pZmljYW50IHdoZW4gdGhlIGN1cnNvciBpcyBvbiBhIGxpbmVcbiAgICAgICAgLy8gd3JhcCBwb2ludCwgd2hlcmUgaXQgbXVzdCBzdGljayB0byB0aGUgY2hhcmFjdGVyIHRoYXQgaXQgaXNcbiAgICAgICAgLy8gYXNzb2NpYXRlZCB3aXRoLiBTaW5jZSBicm93c2VycyBkb24ndCBwcm92aWRlIGEgcmVhc29uYWJsZVxuICAgICAgICAvLyBpbnRlcmZhY2UgdG8gc2V0IG9yIHF1ZXJ5IHRoaXMsIHdoZW4gYSBzZWxlY3Rpb24gaXMgc2V0IHRoYXRcbiAgICAgICAgLy8gbWlnaHQgY2F1c2UgdGhpcyB0byBiZSBzaWduZmljYW50LCB0aGlzIGZsYWcgaXMgc2V0LiBUaGUgbmV4dFxuICAgICAgICAvLyBtZWFzdXJlIHBoYXNlIHdpbGwgY2hlY2sgd2hldGhlciB0aGUgY3Vyc29yIGlzIG9uIGEgbGluZS13cmFwcGluZ1xuICAgICAgICAvLyBib3VuZGFyeSBhbmQsIGlmIHNvLCByZXNldCBpdCB0byBtYWtlIHN1cmUgaXQgaXMgcG9zaXRpb25lZCBpblxuICAgICAgICAvLyB0aGUgcmlnaHQgcGxhY2UuXG4gICAgICAgIHRoaXMubXVzdEVuZm9yY2VDdXJzb3JBc3NvYyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhlaWdodE1hcCA9IEhlaWdodE1hcC5lbXB0eSgpLmFwcGx5Q2hhbmdlcyhzdGF0ZS5mYWNldChkZWNvcmF0aW9ucyksIHRleHQuVGV4dC5lbXB0eSwgdGhpcy5oZWlnaHRPcmFjbGUuc2V0RG9jKHN0YXRlLmRvYyksIFtuZXcgQ2hhbmdlZFJhbmdlKDAsIDAsIDAsIHN0YXRlLmRvYy5sZW5ndGgpXSk7XG4gICAgICAgIHRoaXMudmlld3BvcnQgPSB0aGlzLmdldFZpZXdwb3J0KDAsIG51bGwpO1xuICAgICAgICB0aGlzLnVwZGF0ZUZvclZpZXdwb3J0KCk7XG4gICAgICAgIHRoaXMubGluZUdhcHMgPSB0aGlzLmVuc3VyZUxpbmVHYXBzKFtdKTtcbiAgICAgICAgdGhpcy5saW5lR2FwRGVjbyA9IERlY29yYXRpb24uc2V0KHRoaXMubGluZUdhcHMubWFwKGdhcCA9PiBnYXAuZHJhdyhmYWxzZSkpKTtcbiAgICAgICAgdGhpcy5jb21wdXRlVmlzaWJsZVJhbmdlcygpO1xuICAgIH1cbiAgICB1cGRhdGVGb3JWaWV3cG9ydCgpIHtcbiAgICAgICAgbGV0IHZpZXdwb3J0cyA9IFt0aGlzLnZpZXdwb3J0XSwgeyBtYWluIH0gPSB0aGlzLnN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gMTsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcG9zID0gaSA/IG1haW4uaGVhZCA6IG1haW4uYW5jaG9yO1xuICAgICAgICAgICAgaWYgKCF2aWV3cG9ydHMuc29tZSgoeyBmcm9tLCB0byB9KSA9PiBwb3MgPj0gZnJvbSAmJiBwb3MgPD0gdG8pKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHRoaXMubGluZUF0KHBvcywgMCk7XG4gICAgICAgICAgICAgICAgdmlld3BvcnRzLnB1c2gobmV3IFZpZXdwb3J0KGZyb20sIHRvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aWV3cG9ydHMgPSB2aWV3cG9ydHMuc29ydCgoYSwgYikgPT4gYS5mcm9tIC0gYi5mcm9tKTtcbiAgICAgICAgdGhpcy5zY2FsZXIgPSB0aGlzLmhlaWdodE1hcC5oZWlnaHQgPD0gNzAwMDAwMCAvKiBNYXhET01IZWlnaHQgKi8gPyBJZFNjYWxlciA6XG4gICAgICAgICAgICBuZXcgQmlnU2NhbGVyKHRoaXMuaGVpZ2h0T3JhY2xlLmRvYywgdGhpcy5oZWlnaHRNYXAsIHRoaXMudmlld3BvcnRzKTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSwgc2Nyb2xsVG8gPSBudWxsKSB7XG4gICAgICAgIGxldCBwcmV2ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHVwZGF0ZS5zdGF0ZTtcbiAgICAgICAgbGV0IG5ld0RlY28gPSB0aGlzLnN0YXRlLmZhY2V0KGRlY29yYXRpb25zKTtcbiAgICAgICAgbGV0IGNvbnRlbnRDaGFuZ2VzID0gdXBkYXRlLmNoYW5nZWRSYW5nZXM7XG4gICAgICAgIGxldCBoZWlnaHRDaGFuZ2VzID0gQ2hhbmdlZFJhbmdlLmV4dGVuZFdpdGhSYW5nZXMoY29udGVudENoYW5nZXMsIGhlaWdodFJlbGV2YW50RGVjb0NoYW5nZXModXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQoZGVjb3JhdGlvbnMpLCBuZXdEZWNvLCB1cGRhdGUgPyB1cGRhdGUuY2hhbmdlcyA6IHN0YXRlLkNoYW5nZVNldC5lbXB0eSh0aGlzLnN0YXRlLmRvYy5sZW5ndGgpKSk7XG4gICAgICAgIGxldCBwcmV2SGVpZ2h0ID0gdGhpcy5oZWlnaHRNYXAuaGVpZ2h0O1xuICAgICAgICB0aGlzLmhlaWdodE1hcCA9IHRoaXMuaGVpZ2h0TWFwLmFwcGx5Q2hhbmdlcyhuZXdEZWNvLCBwcmV2LmRvYywgdGhpcy5oZWlnaHRPcmFjbGUuc2V0RG9jKHRoaXMuc3RhdGUuZG9jKSwgaGVpZ2h0Q2hhbmdlcyk7XG4gICAgICAgIGlmICh0aGlzLmhlaWdodE1hcC5oZWlnaHQgIT0gcHJldkhlaWdodClcbiAgICAgICAgICAgIHVwZGF0ZS5mbGFncyB8PSAyIC8qIEhlaWdodCAqLztcbiAgICAgICAgbGV0IHZpZXdwb3J0ID0gaGVpZ2h0Q2hhbmdlcy5sZW5ndGggPyB0aGlzLm1hcFZpZXdwb3J0KHRoaXMudmlld3BvcnQsIHVwZGF0ZS5jaGFuZ2VzKSA6IHRoaXMudmlld3BvcnQ7XG4gICAgICAgIGlmIChzY3JvbGxUbyAmJiAoc2Nyb2xsVG8uaGVhZCA8IHZpZXdwb3J0LmZyb20gfHwgc2Nyb2xsVG8uaGVhZCA+IHZpZXdwb3J0LnRvKSB8fCAhdGhpcy52aWV3cG9ydElzQXBwcm9wcmlhdGUodmlld3BvcnQpKVxuICAgICAgICAgICAgdmlld3BvcnQgPSB0aGlzLmdldFZpZXdwb3J0KDAsIHNjcm9sbFRvKTtcbiAgICAgICAgaWYgKCF2aWV3cG9ydC5lcSh0aGlzLnZpZXdwb3J0KSkge1xuICAgICAgICAgICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgICAgICAgICAgdXBkYXRlLmZsYWdzIHw9IDQgLyogVmlld3BvcnQgKi87XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVGb3JWaWV3cG9ydCgpO1xuICAgICAgICBpZiAodGhpcy5saW5lR2Fwcy5sZW5ndGggfHwgdGhpcy52aWV3cG9ydC50byAtIHRoaXMudmlld3BvcnQuZnJvbSA+IDE1MDAwIC8qIE1pblZpZXdQb3J0ICovKVxuICAgICAgICAgICAgdXBkYXRlLmZsYWdzIHw9IHRoaXMudXBkYXRlTGluZUdhcHModGhpcy5lbnN1cmVMaW5lR2Fwcyh0aGlzLm1hcExpbmVHYXBzKHRoaXMubGluZUdhcHMsIHVwZGF0ZS5jaGFuZ2VzKSkpO1xuICAgICAgICB0aGlzLmNvbXB1dGVWaXNpYmxlUmFuZ2VzKCk7XG4gICAgICAgIGlmIChzY3JvbGxUbylcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG8gPSBzY3JvbGxUbztcbiAgICAgICAgaWYgKCF0aGlzLm11c3RFbmZvcmNlQ3Vyc29yQXNzb2MgJiYgdXBkYXRlLnNlbGVjdGlvblNldCAmJiB1cGRhdGUudmlldy5saW5lV3JhcHBpbmcgJiZcbiAgICAgICAgICAgIHVwZGF0ZS5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5lbXB0eSAmJiB1cGRhdGUuc3RhdGUuc2VsZWN0aW9uLm1haW4uYXNzb2MpXG4gICAgICAgICAgICB0aGlzLm11c3RFbmZvcmNlQ3Vyc29yQXNzb2MgPSB0cnVlO1xuICAgIH1cbiAgICBtZWFzdXJlKGRvY1ZpZXcsIHJlcGVhdGVkKSB7XG4gICAgICAgIGxldCBkb20gPSBkb2NWaWV3LmRvbSwgd2hpdGVTcGFjZSA9IFwiXCIsIGRpcmVjdGlvbiA9IGV4cG9ydHMuRGlyZWN0aW9uLkxUUjtcbiAgICAgICAgaWYgKCFyZXBlYXRlZCkge1xuICAgICAgICAgICAgLy8gVmVydGljYWwgcGFkZGluZ1xuICAgICAgICAgICAgbGV0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9tKTtcbiAgICAgICAgICAgIHdoaXRlU3BhY2UgPSBzdHlsZS53aGl0ZVNwYWNlLCBkaXJlY3Rpb24gPSAoc3R5bGUuZGlyZWN0aW9uID09IFwicnRsXCIgPyBleHBvcnRzLkRpcmVjdGlvbi5SVEwgOiBleHBvcnRzLkRpcmVjdGlvbi5MVFIpO1xuICAgICAgICAgICAgdGhpcy5wYWRkaW5nVG9wID0gcGFyc2VJbnQoc3R5bGUucGFkZGluZ1RvcCkgfHwgMDtcbiAgICAgICAgICAgIHRoaXMucGFkZGluZ0JvdHRvbSA9IHBhcnNlSW50KHN0eWxlLnBhZGRpbmdCb3R0b20pIHx8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGl4ZWwgdmlld3BvcnRcbiAgICAgICAgbGV0IHBpeGVsVmlld3BvcnQgPSB0aGlzLnByaW50aW5nID8geyB0b3A6IC0xZTgsIGJvdHRvbTogMWU4LCBsZWZ0OiAtMWU4LCByaWdodDogMWU4IH0gOiB2aXNpYmxlUGl4ZWxSYW5nZShkb20sIHRoaXMucGFkZGluZ1RvcCk7XG4gICAgICAgIGxldCBkVG9wID0gcGl4ZWxWaWV3cG9ydC50b3AgLSB0aGlzLnBpeGVsVmlld3BvcnQudG9wLCBkQm90dG9tID0gcGl4ZWxWaWV3cG9ydC5ib3R0b20gLSB0aGlzLnBpeGVsVmlld3BvcnQuYm90dG9tO1xuICAgICAgICB0aGlzLnBpeGVsVmlld3BvcnQgPSBwaXhlbFZpZXdwb3J0O1xuICAgICAgICB0aGlzLmluVmlldyA9IHRoaXMucGl4ZWxWaWV3cG9ydC5ib3R0b20gPiB0aGlzLnBpeGVsVmlld3BvcnQudG9wICYmIHRoaXMucGl4ZWxWaWV3cG9ydC5yaWdodCA+IHRoaXMucGl4ZWxWaWV3cG9ydC5sZWZ0O1xuICAgICAgICBpZiAoIXRoaXMuaW5WaWV3KVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGxldCBsaW5lSGVpZ2h0cyA9IGRvY1ZpZXcubWVhc3VyZVZpc2libGVMaW5lSGVpZ2h0cygpO1xuICAgICAgICBsZXQgcmVmcmVzaCA9IGZhbHNlLCBiaWFzID0gMCwgcmVzdWx0ID0gMCwgb3JhY2xlID0gdGhpcy5oZWlnaHRPcmFjbGU7XG4gICAgICAgIGlmICghcmVwZWF0ZWQpIHtcbiAgICAgICAgICAgIGxldCBjb250ZW50V2lkdGggPSBkb2NWaWV3LmRvbS5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgIGlmIChvcmFjbGUubXVzdFJlZnJlc2gobGluZUhlaWdodHMsIHdoaXRlU3BhY2UsIGRpcmVjdGlvbikgfHxcbiAgICAgICAgICAgICAgICBvcmFjbGUubGluZVdyYXBwaW5nICYmIE1hdGguYWJzKGNvbnRlbnRXaWR0aCAtIHRoaXMuY29udGVudFdpZHRoKSA+IG9yYWNsZS5jaGFyV2lkdGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBsaW5lSGVpZ2h0LCBjaGFyV2lkdGggfSA9IGRvY1ZpZXcubWVhc3VyZVRleHRTaXplKCk7XG4gICAgICAgICAgICAgICAgcmVmcmVzaCA9IG9yYWNsZS5yZWZyZXNoKHdoaXRlU3BhY2UsIGRpcmVjdGlvbiwgbGluZUhlaWdodCwgY2hhcldpZHRoLCBjb250ZW50V2lkdGggLyBjaGFyV2lkdGgsIGxpbmVIZWlnaHRzKTtcbiAgICAgICAgICAgICAgICBpZiAocmVmcmVzaCkge1xuICAgICAgICAgICAgICAgICAgICBkb2NWaWV3Lm1pbldpZHRoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0IHw9IDE2IC8qIEdlb21ldHJ5ICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRlbnRXaWR0aCAhPSBjb250ZW50V2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRXaWR0aCA9IGNvbnRlbnRXaWR0aDtcbiAgICAgICAgICAgICAgICByZXN1bHQgfD0gMTYgLyogR2VvbWV0cnkgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZFRvcCA+IDAgJiYgZEJvdHRvbSA+IDApXG4gICAgICAgICAgICAgICAgYmlhcyA9IE1hdGgubWF4KGRUb3AsIGRCb3R0b20pO1xuICAgICAgICAgICAgZWxzZSBpZiAoZFRvcCA8IDAgJiYgZEJvdHRvbSA8IDApXG4gICAgICAgICAgICAgICAgYmlhcyA9IE1hdGgubWluKGRUb3AsIGRCb3R0b20pO1xuICAgICAgICB9XG4gICAgICAgIG9yYWNsZS5oZWlnaHRDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGVpZ2h0TWFwID0gdGhpcy5oZWlnaHRNYXAudXBkYXRlSGVpZ2h0KG9yYWNsZSwgMCwgcmVmcmVzaCwgbmV3IE1lYXN1cmVkSGVpZ2h0cyh0aGlzLnZpZXdwb3J0LmZyb20sIGxpbmVIZWlnaHRzKSk7XG4gICAgICAgIGlmIChvcmFjbGUuaGVpZ2h0Q2hhbmdlZClcbiAgICAgICAgICAgIHJlc3VsdCB8PSAyIC8qIEhlaWdodCAqLztcbiAgICAgICAgaWYgKCF0aGlzLnZpZXdwb3J0SXNBcHByb3ByaWF0ZSh0aGlzLnZpZXdwb3J0LCBiaWFzKSB8fFxuICAgICAgICAgICAgdGhpcy5zY3JvbGxUbyAmJiAodGhpcy5zY3JvbGxUby5oZWFkIDwgdGhpcy52aWV3cG9ydC5mcm9tIHx8IHRoaXMuc2Nyb2xsVG8uaGVhZCA+IHRoaXMudmlld3BvcnQudG8pKSB7XG4gICAgICAgICAgICBsZXQgbmV3VlAgPSB0aGlzLmdldFZpZXdwb3J0KGJpYXMsIHRoaXMuc2Nyb2xsVG8pO1xuICAgICAgICAgICAgaWYgKG5ld1ZQLmZyb20gIT0gdGhpcy52aWV3cG9ydC5mcm9tIHx8IG5ld1ZQLnRvICE9IHRoaXMudmlld3BvcnQudG8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdwb3J0ID0gbmV3VlA7XG4gICAgICAgICAgICAgICAgcmVzdWx0IHw9IDQgLyogVmlld3BvcnQgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVGb3JWaWV3cG9ydCgpO1xuICAgICAgICBpZiAodGhpcy5saW5lR2Fwcy5sZW5ndGggfHwgdGhpcy52aWV3cG9ydC50byAtIHRoaXMudmlld3BvcnQuZnJvbSA+IDE1MDAwIC8qIE1pblZpZXdQb3J0ICovKVxuICAgICAgICAgICAgcmVzdWx0IHw9IHRoaXMudXBkYXRlTGluZUdhcHModGhpcy5lbnN1cmVMaW5lR2FwcyhyZWZyZXNoID8gW10gOiB0aGlzLmxpbmVHYXBzKSk7XG4gICAgICAgIHRoaXMuY29tcHV0ZVZpc2libGVSYW5nZXMoKTtcbiAgICAgICAgaWYgKHRoaXMubXVzdEVuZm9yY2VDdXJzb3JBc3NvYykge1xuICAgICAgICAgICAgdGhpcy5tdXN0RW5mb3JjZUN1cnNvckFzc29jID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGRvbmUgaW4gdGhlIHJlYWQgc3RhZ2UsIGJlY2F1c2UgbW92aW5nIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgICAgIC8vIHRvIGEgbGluZSBlbmQgaXMgZ29pbmcgdG8gdHJpZ2dlciBhIGxheW91dCBhbnl3YXksIHNvIGl0XG4gICAgICAgICAgICAvLyBjYW4ndCBiZSBhIHB1cmUgd3JpdGUuIEl0IHNob3VsZCBiZSByYXJlIHRoYXQgaXQgZG9lcyBhbnlcbiAgICAgICAgICAgIC8vIHdyaXRpbmcuXG4gICAgICAgICAgICBkb2NWaWV3LmVuZm9yY2VDdXJzb3JBc3NvYygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGdldCB2aXNpYmxlVG9wKCkgeyByZXR1cm4gdGhpcy5zY2FsZXIuZnJvbURPTSh0aGlzLnBpeGVsVmlld3BvcnQudG9wLCAwKTsgfVxuICAgIGdldCB2aXNpYmxlQm90dG9tKCkgeyByZXR1cm4gdGhpcy5zY2FsZXIuZnJvbURPTSh0aGlzLnBpeGVsVmlld3BvcnQuYm90dG9tLCAwKTsgfVxuICAgIGdldFZpZXdwb3J0KGJpYXMsIHNjcm9sbFRvKSB7XG4gICAgICAgIC8vIFRoaXMgd2lsbCBkaXZpZGUgVlAuTWFyZ2luIGJldHdlZW4gdGhlIHRvcCBhbmQgdGhlXG4gICAgICAgIC8vIGJvdHRvbSwgZGVwZW5kaW5nIG9uIHRoZSBiaWFzICh0aGUgY2hhbmdlIGluIHZpZXdwb3J0IHBvc2l0aW9uXG4gICAgICAgIC8vIHNpbmNlIHRoZSBsYXN0IHVwZGF0ZSkuIEl0J2xsIGhvbGQgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICAgIGxldCBtYXJnaW5Ub3AgPSAwLjUgLSBNYXRoLm1heCgtMC41LCBNYXRoLm1pbigwLjUsIGJpYXMgLyAxMDAwIC8qIE1hcmdpbiAqLyAvIDIpKTtcbiAgICAgICAgbGV0IG1hcCA9IHRoaXMuaGVpZ2h0TWFwLCBkb2MgPSB0aGlzLnN0YXRlLmRvYywgeyB2aXNpYmxlVG9wLCB2aXNpYmxlQm90dG9tIH0gPSB0aGlzO1xuICAgICAgICBsZXQgdmlld3BvcnQgPSBuZXcgVmlld3BvcnQobWFwLmxpbmVBdCh2aXNpYmxlVG9wIC0gbWFyZ2luVG9wICogMTAwMCAvKiBNYXJnaW4gKi8sIFF1ZXJ5VHlwZS5CeUhlaWdodCwgZG9jLCAwLCAwKS5mcm9tLCBtYXAubGluZUF0KHZpc2libGVCb3R0b20gKyAoMSAtIG1hcmdpblRvcCkgKiAxMDAwIC8qIE1hcmdpbiAqLywgUXVlcnlUeXBlLkJ5SGVpZ2h0LCBkb2MsIDAsIDApLnRvKTtcbiAgICAgICAgLy8gSWYgc2Nyb2xsVG8gaXMgZ2l2ZW4sIG1ha2Ugc3VyZSB0aGUgdmlld3BvcnQgaW5jbHVkZXMgdGhhdCBwb3NpdGlvblxuICAgICAgICBpZiAoc2Nyb2xsVG8pIHtcbiAgICAgICAgICAgIGlmIChzY3JvbGxUby5oZWFkIDwgdmlld3BvcnQuZnJvbSkge1xuICAgICAgICAgICAgICAgIGxldCB7IHRvcDogbmV3VG9wIH0gPSBtYXAubGluZUF0KHNjcm9sbFRvLmhlYWQsIFF1ZXJ5VHlwZS5CeVBvcywgZG9jLCAwLCAwKTtcbiAgICAgICAgICAgICAgICB2aWV3cG9ydCA9IG5ldyBWaWV3cG9ydChtYXAubGluZUF0KG5ld1RvcCAtIDEwMDAgLyogTWFyZ2luICovIC8gMiwgUXVlcnlUeXBlLkJ5SGVpZ2h0LCBkb2MsIDAsIDApLmZyb20sIG1hcC5saW5lQXQobmV3VG9wICsgKHZpc2libGVCb3R0b20gLSB2aXNpYmxlVG9wKSArIDEwMDAgLyogTWFyZ2luICovIC8gMiwgUXVlcnlUeXBlLkJ5SGVpZ2h0LCBkb2MsIDAsIDApLnRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNjcm9sbFRvLmhlYWQgPiB2aWV3cG9ydC50bykge1xuICAgICAgICAgICAgICAgIGxldCB7IGJvdHRvbTogbmV3Qm90dG9tIH0gPSBtYXAubGluZUF0KHNjcm9sbFRvLmhlYWQsIFF1ZXJ5VHlwZS5CeVBvcywgZG9jLCAwLCAwKTtcbiAgICAgICAgICAgICAgICB2aWV3cG9ydCA9IG5ldyBWaWV3cG9ydChtYXAubGluZUF0KG5ld0JvdHRvbSAtICh2aXNpYmxlQm90dG9tIC0gdmlzaWJsZVRvcCkgLSAxMDAwIC8qIE1hcmdpbiAqLyAvIDIsIFF1ZXJ5VHlwZS5CeUhlaWdodCwgZG9jLCAwLCAwKS5mcm9tLCBtYXAubGluZUF0KG5ld0JvdHRvbSArIDEwMDAgLyogTWFyZ2luICovIC8gMiwgUXVlcnlUeXBlLkJ5SGVpZ2h0LCBkb2MsIDAsIDApLnRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmlld3BvcnQ7XG4gICAgfVxuICAgIG1hcFZpZXdwb3J0KHZpZXdwb3J0LCBjaGFuZ2VzKSB7XG4gICAgICAgIGxldCBmcm9tID0gY2hhbmdlcy5tYXBQb3Modmlld3BvcnQuZnJvbSwgLTEpLCB0byA9IGNoYW5nZXMubWFwUG9zKHZpZXdwb3J0LnRvLCAxKTtcbiAgICAgICAgcmV0dXJuIG5ldyBWaWV3cG9ydCh0aGlzLmhlaWdodE1hcC5saW5lQXQoZnJvbSwgUXVlcnlUeXBlLkJ5UG9zLCB0aGlzLnN0YXRlLmRvYywgMCwgMCkuZnJvbSwgdGhpcy5oZWlnaHRNYXAubGluZUF0KHRvLCBRdWVyeVR5cGUuQnlQb3MsIHRoaXMuc3RhdGUuZG9jLCAwLCAwKS50byk7XG4gICAgfVxuICAgIC8vIENoZWNrcyBpZiBhIGdpdmVuIHZpZXdwb3J0IGNvdmVycyB0aGUgdmlzaWJsZSBwYXJ0IG9mIHRoZVxuICAgIC8vIGRvY3VtZW50IGFuZCBub3QgdG9vIG11Y2ggYmV5b25kIHRoYXQuXG4gICAgdmlld3BvcnRJc0FwcHJvcHJpYXRlKHsgZnJvbSwgdG8gfSwgYmlhcyA9IDApIHtcbiAgICAgICAgbGV0IHsgdG9wIH0gPSB0aGlzLmhlaWdodE1hcC5saW5lQXQoZnJvbSwgUXVlcnlUeXBlLkJ5UG9zLCB0aGlzLnN0YXRlLmRvYywgMCwgMCk7XG4gICAgICAgIGxldCB7IGJvdHRvbSB9ID0gdGhpcy5oZWlnaHRNYXAubGluZUF0KHRvLCBRdWVyeVR5cGUuQnlQb3MsIHRoaXMuc3RhdGUuZG9jLCAwLCAwKTtcbiAgICAgICAgbGV0IHsgdmlzaWJsZVRvcCwgdmlzaWJsZUJvdHRvbSB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIChmcm9tID09IDAgfHwgdG9wIDw9IHZpc2libGVUb3AgLSBNYXRoLm1heCgxMCAvKiBNaW5Db3Zlck1hcmdpbiAqLywgTWF0aC5taW4oLWJpYXMsIDI1MCAvKiBNYXhDb3Zlck1hcmdpbiAqLykpKSAmJlxuICAgICAgICAgICAgKHRvID09IHRoaXMuc3RhdGUuZG9jLmxlbmd0aCB8fFxuICAgICAgICAgICAgICAgIGJvdHRvbSA+PSB2aXNpYmxlQm90dG9tICsgTWF0aC5tYXgoMTAgLyogTWluQ292ZXJNYXJnaW4gKi8sIE1hdGgubWluKGJpYXMsIDI1MCAvKiBNYXhDb3Zlck1hcmdpbiAqLykpKSAmJlxuICAgICAgICAgICAgKHRvcCA+IHZpc2libGVUb3AgLSAyICogMTAwMCAvKiBNYXJnaW4gKi8gJiYgYm90dG9tIDwgdmlzaWJsZUJvdHRvbSArIDIgKiAxMDAwIC8qIE1hcmdpbiAqLyk7XG4gICAgfVxuICAgIG1hcExpbmVHYXBzKGdhcHMsIGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKCFnYXBzLmxlbmd0aCB8fCBjaGFuZ2VzLmVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIGdhcHM7XG4gICAgICAgIGxldCBtYXBwZWQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZ2FwIG9mIGdhcHMpXG4gICAgICAgICAgICBpZiAoIWNoYW5nZXMudG91Y2hlc1JhbmdlKGdhcC5mcm9tLCBnYXAudG8pKVxuICAgICAgICAgICAgICAgIG1hcHBlZC5wdXNoKG5ldyBMaW5lR2FwKGNoYW5nZXMubWFwUG9zKGdhcC5mcm9tKSwgY2hhbmdlcy5tYXBQb3MoZ2FwLnRvKSwgZ2FwLnNpemUpKTtcbiAgICAgICAgcmV0dXJuIG1hcHBlZDtcbiAgICB9XG4gICAgLy8gQ29tcHV0ZXMgcG9zaXRpb25zIGluIHRoZSB2aWV3cG9ydCB3aGVyZSB0aGUgc3RhcnQgb3IgZW5kIG9mIGFcbiAgICAvLyBsaW5lIHNob3VsZCBiZSBoaWRkZW4sIHRyeWluZyB0byByZXVzZSBleGlzdGluZyBsaW5lIGdhcHMgd2hlblxuICAgIC8vIGFwcHJvcHJpYXRlIHRvIGF2b2lkIHVubmVjY2VzYXJ5IHJlZHJhd3MuXG4gICAgLy8gVXNlcyBjcnVkZSBjaGFyYWN0ZXItY291bnRpbmcgZm9yIHRoZSBwb3NpdGlvbmluZyBhbmQgc2l6aW5nLFxuICAgIC8vIHNpbmNlIGFjdHVhbCBET00gY29vcmRpbmF0ZXMgYXJlbid0IGFsd2F5cyBhdmFpbGFibGUgYW5kXG4gICAgLy8gcHJlZGljdGFibGUuIFJlbGllcyBvbiBnZW5lcm91cyBtYXJnaW5zIChzZWUgTEcuTWFyZ2luKSB0byBoaWRlXG4gICAgLy8gdGhlIGFydGlmYWN0cyB0aGlzIG1pZ2h0IHByb2R1Y2UgZnJvbSB0aGUgdXNlci5cbiAgICBlbnN1cmVMaW5lR2FwcyhjdXJyZW50KSB7XG4gICAgICAgIGxldCBnYXBzID0gW107XG4gICAgICAgIC8vIFRoaXMgd29uJ3Qgd29yayBhdCBhbGwgaW4gcHJlZG9taW5hbnRseSByaWdodC10by1sZWZ0IHRleHQuXG4gICAgICAgIGlmICh0aGlzLmhlaWdodE9yYWNsZS5kaXJlY3Rpb24gIT0gZXhwb3J0cy5EaXJlY3Rpb24uTFRSKVxuICAgICAgICAgICAgcmV0dXJuIGdhcHM7XG4gICAgICAgIHRoaXMuaGVpZ2h0TWFwLmZvckVhY2hMaW5lKHRoaXMudmlld3BvcnQuZnJvbSwgdGhpcy52aWV3cG9ydC50bywgdGhpcy5zdGF0ZS5kb2MsIDAsIDAsIGxpbmUgPT4ge1xuICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoIDwgMTAwMDAgLyogTWFyZ2luICovKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCBzdHJ1Y3R1cmUgPSBsaW5lU3RydWN0dXJlKGxpbmUuZnJvbSwgbGluZS50bywgdGhpcy5zdGF0ZSk7XG4gICAgICAgICAgICBpZiAoc3RydWN0dXJlLnRvdGFsIDwgMTAwMDAgLyogTWFyZ2luICovKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCB2aWV3RnJvbSwgdmlld1RvO1xuICAgICAgICAgICAgaWYgKHRoaXMuaGVpZ2h0T3JhY2xlLmxpbmVXcmFwcGluZykge1xuICAgICAgICAgICAgICAgIGlmIChsaW5lLmZyb20gIT0gdGhpcy52aWV3cG9ydC5mcm9tKVxuICAgICAgICAgICAgICAgICAgICB2aWV3RnJvbSA9IGxpbmUuZnJvbTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHZpZXdGcm9tID0gZmluZFBvc2l0aW9uKHN0cnVjdHVyZSwgKHRoaXMudmlzaWJsZVRvcCAtIGxpbmUudG9wKSAvIGxpbmUuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBpZiAobGluZS50byAhPSB0aGlzLnZpZXdwb3J0LnRvKVxuICAgICAgICAgICAgICAgICAgICB2aWV3VG8gPSBsaW5lLnRvO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdmlld1RvID0gZmluZFBvc2l0aW9uKHN0cnVjdHVyZSwgKHRoaXMudmlzaWJsZUJvdHRvbSAtIGxpbmUudG9wKSAvIGxpbmUuaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCB0b3RhbFdpZHRoID0gc3RydWN0dXJlLnRvdGFsICogdGhpcy5oZWlnaHRPcmFjbGUuY2hhcldpZHRoO1xuICAgICAgICAgICAgICAgIHZpZXdGcm9tID0gZmluZFBvc2l0aW9uKHN0cnVjdHVyZSwgdGhpcy5waXhlbFZpZXdwb3J0LmxlZnQgLyB0b3RhbFdpZHRoKTtcbiAgICAgICAgICAgICAgICB2aWV3VG8gPSBmaW5kUG9zaXRpb24oc3RydWN0dXJlLCB0aGlzLnBpeGVsVmlld3BvcnQucmlnaHQgLyB0b3RhbFdpZHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzZWwgPSB0aGlzLnN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBnYXAgZG9lc24ndCBjb3ZlciBhIHNlbGVjdGlvbiBlbmRcbiAgICAgICAgICAgIGlmIChzZWwuZnJvbSA8PSB2aWV3RnJvbSAmJiBzZWwudG8gPj0gbGluZS5mcm9tKVxuICAgICAgICAgICAgICAgIHZpZXdGcm9tID0gc2VsLmZyb207XG4gICAgICAgICAgICBpZiAoc2VsLmZyb20gPD0gbGluZS50byAmJiBzZWwudG8gPj0gdmlld1RvKVxuICAgICAgICAgICAgICAgIHZpZXdUbyA9IHNlbC50bztcbiAgICAgICAgICAgIGxldCBnYXBUbyA9IHZpZXdGcm9tIC0gMTAwMDAgLyogTWFyZ2luICovLCBnYXBGcm9tID0gdmlld1RvICsgMTAwMDAgLyogTWFyZ2luICovO1xuICAgICAgICAgICAgaWYgKGdhcFRvID4gbGluZS5mcm9tICsgNTAwMCAvKiBIYWxmTWFyZ2luICovKVxuICAgICAgICAgICAgICAgIGdhcHMucHVzaChmaW5kKGN1cnJlbnQsIGdhcCA9PiBnYXAuZnJvbSA9PSBsaW5lLmZyb20gJiYgZ2FwLnRvID4gZ2FwVG8gLSA1MDAwIC8qIEhhbGZNYXJnaW4gKi8gJiYgZ2FwLnRvIDwgZ2FwVG8gKyA1MDAwIC8qIEhhbGZNYXJnaW4gKi8pIHx8XG4gICAgICAgICAgICAgICAgICAgIG5ldyBMaW5lR2FwKGxpbmUuZnJvbSwgZ2FwVG8sIHRoaXMuZ2FwU2l6ZShsaW5lLCBnYXBUbywgdHJ1ZSwgc3RydWN0dXJlKSkpO1xuICAgICAgICAgICAgaWYgKGdhcEZyb20gPCBsaW5lLnRvIC0gNTAwMCAvKiBIYWxmTWFyZ2luICovKVxuICAgICAgICAgICAgICAgIGdhcHMucHVzaChmaW5kKGN1cnJlbnQsIGdhcCA9PiBnYXAudG8gPT0gbGluZS50byAmJiBnYXAuZnJvbSA+IGdhcEZyb20gLSA1MDAwIC8qIEhhbGZNYXJnaW4gKi8gJiZcbiAgICAgICAgICAgICAgICAgICAgZ2FwLmZyb20gPCBnYXBGcm9tICsgNTAwMCAvKiBIYWxmTWFyZ2luICovKSB8fFxuICAgICAgICAgICAgICAgICAgICBuZXcgTGluZUdhcChnYXBGcm9tLCBsaW5lLnRvLCB0aGlzLmdhcFNpemUobGluZSwgZ2FwRnJvbSwgZmFsc2UsIHN0cnVjdHVyZSkpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBnYXBzO1xuICAgIH1cbiAgICBnYXBTaXplKGxpbmUsIHBvcywgc3RhcnQsIHN0cnVjdHVyZSkge1xuICAgICAgICBpZiAodGhpcy5oZWlnaHRPcmFjbGUubGluZVdyYXBwaW5nKSB7XG4gICAgICAgICAgICBsZXQgaGVpZ2h0ID0gbGluZS5oZWlnaHQgKiBmaW5kRnJhY3Rpb24oc3RydWN0dXJlLCBwb3MpO1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0ID8gaGVpZ2h0IDogbGluZS5oZWlnaHQgLSBoZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgcmF0aW8gPSBmaW5kRnJhY3Rpb24oc3RydWN0dXJlLCBwb3MpO1xuICAgICAgICAgICAgcmV0dXJuIHN0cnVjdHVyZS50b3RhbCAqIHRoaXMuaGVpZ2h0T3JhY2xlLmNoYXJXaWR0aCAqIChzdGFydCA/IHJhdGlvIDogMSAtIHJhdGlvKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVMaW5lR2FwcyhnYXBzKSB7XG4gICAgICAgIGlmICghTGluZUdhcC5zYW1lKGdhcHMsIHRoaXMubGluZUdhcHMpKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmVHYXBzID0gZ2FwcztcbiAgICAgICAgICAgIHRoaXMubGluZUdhcERlY28gPSBEZWNvcmF0aW9uLnNldChnYXBzLm1hcChnYXAgPT4gZ2FwLmRyYXcodGhpcy5oZWlnaHRPcmFjbGUubGluZVdyYXBwaW5nKSkpO1xuICAgICAgICAgICAgcmV0dXJuIDggLyogTGluZUdhcHMgKi87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNvbXB1dGVWaXNpYmxlUmFuZ2VzKCkge1xuICAgICAgICBsZXQgZGVjbyA9IHRoaXMuc3RhdGUuZmFjZXQoZGVjb3JhdGlvbnMpO1xuICAgICAgICBpZiAodGhpcy5saW5lR2Fwcy5sZW5ndGgpXG4gICAgICAgICAgICBkZWNvID0gZGVjby5jb25jYXQodGhpcy5saW5lR2FwRGVjbyk7XG4gICAgICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICAgICAgcmFuZ2VzZXQuUmFuZ2VTZXQuc3BhbnMoZGVjbywgdGhpcy52aWV3cG9ydC5mcm9tLCB0aGlzLnZpZXdwb3J0LnRvLCB7XG4gICAgICAgICAgICBzcGFuKGZyb20sIHRvKSB7IHJhbmdlcy5wdXNoKHsgZnJvbSwgdG8gfSk7IH0sXG4gICAgICAgICAgICBwb2ludCgpIHsgfVxuICAgICAgICB9LCAyMCk7XG4gICAgICAgIHRoaXMudmlzaWJsZVJhbmdlcyA9IHJhbmdlcztcbiAgICB9XG4gICAgbGluZUF0KHBvcywgZWRpdG9yVG9wKSB7XG4gICAgICAgIGVkaXRvclRvcCArPSB0aGlzLnBhZGRpbmdUb3A7XG4gICAgICAgIHJldHVybiBzY2FsZUJsb2NrKHRoaXMuaGVpZ2h0TWFwLmxpbmVBdChwb3MsIFF1ZXJ5VHlwZS5CeVBvcywgdGhpcy5zdGF0ZS5kb2MsIGVkaXRvclRvcCwgMCksIHRoaXMuc2NhbGVyLCBlZGl0b3JUb3ApO1xuICAgIH1cbiAgICBsaW5lQXRIZWlnaHQoaGVpZ2h0LCBlZGl0b3JUb3ApIHtcbiAgICAgICAgZWRpdG9yVG9wICs9IHRoaXMucGFkZGluZ1RvcDtcbiAgICAgICAgcmV0dXJuIHNjYWxlQmxvY2sodGhpcy5oZWlnaHRNYXAubGluZUF0KHRoaXMuc2NhbGVyLmZyb21ET00oaGVpZ2h0LCBlZGl0b3JUb3ApLCBRdWVyeVR5cGUuQnlIZWlnaHQsIHRoaXMuc3RhdGUuZG9jLCBlZGl0b3JUb3AsIDApLCB0aGlzLnNjYWxlciwgZWRpdG9yVG9wKTtcbiAgICB9XG4gICAgYmxvY2tBdEhlaWdodChoZWlnaHQsIGVkaXRvclRvcCkge1xuICAgICAgICBlZGl0b3JUb3AgKz0gdGhpcy5wYWRkaW5nVG9wO1xuICAgICAgICByZXR1cm4gc2NhbGVCbG9jayh0aGlzLmhlaWdodE1hcC5ibG9ja0F0KHRoaXMuc2NhbGVyLmZyb21ET00oaGVpZ2h0LCBlZGl0b3JUb3ApLCB0aGlzLnN0YXRlLmRvYywgZWRpdG9yVG9wLCAwKSwgdGhpcy5zY2FsZXIsIGVkaXRvclRvcCk7XG4gICAgfVxuICAgIGZvckVhY2hMaW5lKGZyb20sIHRvLCBmLCBlZGl0b3JUb3ApIHtcbiAgICAgICAgZWRpdG9yVG9wICs9IHRoaXMucGFkZGluZ1RvcDtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0TWFwLmZvckVhY2hMaW5lKGZyb20sIHRvLCB0aGlzLnN0YXRlLmRvYywgZWRpdG9yVG9wLCAwLCB0aGlzLnNjYWxlci5zY2FsZSA9PSAxID8gZiA6IGIgPT4gZihzY2FsZUJsb2NrKGIsIHRoaXMuc2NhbGVyLCBlZGl0b3JUb3ApKSk7XG4gICAgfVxuICAgIGdldCBjb250ZW50SGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb21IZWlnaHQgKyB0aGlzLnBhZGRpbmdUb3AgKyB0aGlzLnBhZGRpbmdCb3R0b207XG4gICAgfVxuICAgIGdldCBkb21IZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjYWxlci50b0RPTSh0aGlzLmhlaWdodE1hcC5oZWlnaHQsIHRoaXMucGFkZGluZ1RvcCk7XG4gICAgfVxufVxuLyoqXG5JbmRpY2F0ZXMgdGhlIHJhbmdlIG9mIHRoZSBkb2N1bWVudCB0aGF0IGlzIGluIHRoZSB2aXNpYmxlXG52aWV3cG9ydC5cbiovXG5jbGFzcyBWaWV3cG9ydCB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbiAgICBlcShiKSB7IHJldHVybiB0aGlzLmZyb20gPT0gYi5mcm9tICYmIHRoaXMudG8gPT0gYi50bzsgfVxufVxuZnVuY3Rpb24gbGluZVN0cnVjdHVyZShmcm9tLCB0bywgc3RhdGUpIHtcbiAgICBsZXQgcmFuZ2VzID0gW10sIHBvcyA9IGZyb20sIHRvdGFsID0gMDtcbiAgICByYW5nZXNldC5SYW5nZVNldC5zcGFucyhzdGF0ZS5mYWNldChkZWNvcmF0aW9ucyksIGZyb20sIHRvLCB7XG4gICAgICAgIHNwYW4oKSB7IH0sXG4gICAgICAgIHBvaW50KGZyb20sIHRvKSB7XG4gICAgICAgICAgICBpZiAoZnJvbSA+IHBvcykge1xuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKHsgZnJvbTogcG9zLCB0bzogZnJvbSB9KTtcbiAgICAgICAgICAgICAgICB0b3RhbCArPSBmcm9tIC0gcG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zID0gdG87XG4gICAgICAgIH1cbiAgICB9LCAyMCk7IC8vIFdlJ3JlIG9ubHkgaW50ZXJlc3RlZCBpbiBjb2xsYXBzZWQgcmFuZ2VzIG9mIGEgc2lnbmlmaWNhbnQgc2l6ZVxuICAgIGlmIChwb3MgPCB0bykge1xuICAgICAgICByYW5nZXMucHVzaCh7IGZyb206IHBvcywgdG8gfSk7XG4gICAgICAgIHRvdGFsICs9IHRvIC0gcG9zO1xuICAgIH1cbiAgICByZXR1cm4geyB0b3RhbCwgcmFuZ2VzIH07XG59XG5mdW5jdGlvbiBmaW5kUG9zaXRpb24oeyB0b3RhbCwgcmFuZ2VzIH0sIHJhdGlvKSB7XG4gICAgaWYgKHJhdGlvIDw9IDApXG4gICAgICAgIHJldHVybiByYW5nZXNbMF0uZnJvbTtcbiAgICBpZiAocmF0aW8gPj0gMSlcbiAgICAgICAgcmV0dXJuIHJhbmdlc1tyYW5nZXMubGVuZ3RoIC0gMV0udG87XG4gICAgbGV0IGRpc3QgPSBNYXRoLmZsb29yKHRvdGFsICogcmF0aW8pO1xuICAgIGZvciAobGV0IGkgPSAwOzsgaSsrKSB7XG4gICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSByYW5nZXNbaV0sIHNpemUgPSB0byAtIGZyb207XG4gICAgICAgIGlmIChkaXN0IDw9IHNpemUpXG4gICAgICAgICAgICByZXR1cm4gZnJvbSArIGRpc3Q7XG4gICAgICAgIGRpc3QgLT0gc2l6ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kRnJhY3Rpb24oc3RydWN0dXJlLCBwb3MpIHtcbiAgICBsZXQgY291bnRlZCA9IDA7XG4gICAgZm9yIChsZXQgeyBmcm9tLCB0byB9IG9mIHN0cnVjdHVyZS5yYW5nZXMpIHtcbiAgICAgICAgaWYgKHBvcyA8PSB0bykge1xuICAgICAgICAgICAgY291bnRlZCArPSBwb3MgLSBmcm9tO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY291bnRlZCArPSB0byAtIGZyb207XG4gICAgfVxuICAgIHJldHVybiBjb3VudGVkIC8gc3RydWN0dXJlLnRvdGFsO1xufVxuZnVuY3Rpb24gZmluZChhcnJheSwgZikge1xuICAgIGZvciAobGV0IHZhbCBvZiBhcnJheSlcbiAgICAgICAgaWYgKGYodmFsKSlcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbi8vIERvbid0IHNjYWxlIHdoZW4gdGhlIGRvY3VtZW50IGhlaWdodCBpcyB3aXRoaW4gdGhlIHJhbmdlIG9mIHdoYXRcbi8vIHRoZSBET00gY2FuIGhhbmRsZS5cbmNvbnN0IElkU2NhbGVyID0ge1xuICAgIHRvRE9NKG4pIHsgcmV0dXJuIG47IH0sXG4gICAgZnJvbURPTShuKSB7IHJldHVybiBuOyB9LFxuICAgIHNjYWxlOiAxXG59O1xuLy8gV2hlbiB0aGUgaGVpZ2h0IGlzIHRvbyBiaWcgKD4gVlAuTWF4RE9NSGVpZ2h0KSwgc2NhbGUgZG93biB0aGVcbi8vIHJlZ2lvbnMgb3V0c2lkZSB0aGUgdmlld3BvcnRzIHNvIHRoYXQgdGhlIHRvdGFsIGhlaWdodCBpc1xuLy8gVlAuTWF4RE9NSGVpZ2h0LlxuY2xhc3MgQmlnU2NhbGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihkb2MsIGhlaWdodE1hcCwgdmlld3BvcnRzKSB7XG4gICAgICAgIGxldCB2cEhlaWdodCA9IDAsIGJhc2UgPSAwLCBkb21CYXNlID0gMDtcbiAgICAgICAgdGhpcy52aWV3cG9ydHMgPSB2aWV3cG9ydHMubWFwKCh7IGZyb20sIHRvIH0pID0+IHtcbiAgICAgICAgICAgIGxldCB0b3AgPSBoZWlnaHRNYXAubGluZUF0KGZyb20sIFF1ZXJ5VHlwZS5CeVBvcywgZG9jLCAwLCAwKS50b3A7XG4gICAgICAgICAgICBsZXQgYm90dG9tID0gaGVpZ2h0TWFwLmxpbmVBdCh0bywgUXVlcnlUeXBlLkJ5UG9zLCBkb2MsIDAsIDApLmJvdHRvbTtcbiAgICAgICAgICAgIHZwSGVpZ2h0ICs9IGJvdHRvbSAtIHRvcDtcbiAgICAgICAgICAgIHJldHVybiB7IGZyb20sIHRvLCB0b3AsIGJvdHRvbSwgZG9tVG9wOiAwLCBkb21Cb3R0b206IDAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2NhbGUgPSAoNzAwMDAwMCAvKiBNYXhET01IZWlnaHQgKi8gLSB2cEhlaWdodCkgLyAoaGVpZ2h0TWFwLmhlaWdodCAtIHZwSGVpZ2h0KTtcbiAgICAgICAgZm9yIChsZXQgb2JqIG9mIHRoaXMudmlld3BvcnRzKSB7XG4gICAgICAgICAgICBvYmouZG9tVG9wID0gZG9tQmFzZSArIChvYmoudG9wIC0gYmFzZSkgKiB0aGlzLnNjYWxlO1xuICAgICAgICAgICAgZG9tQmFzZSA9IG9iai5kb21Cb3R0b20gPSBvYmouZG9tVG9wICsgKG9iai5ib3R0b20gLSBvYmoudG9wKTtcbiAgICAgICAgICAgIGJhc2UgPSBvYmouYm90dG9tO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvRE9NKG4sIHRvcCkge1xuICAgICAgICBuIC09IHRvcDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGJhc2UgPSAwLCBkb21CYXNlID0gMDs7IGkrKykge1xuICAgICAgICAgICAgbGV0IHZwID0gaSA8IHRoaXMudmlld3BvcnRzLmxlbmd0aCA/IHRoaXMudmlld3BvcnRzW2ldIDogbnVsbDtcbiAgICAgICAgICAgIGlmICghdnAgfHwgbiA8IHZwLnRvcClcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9tQmFzZSArIChuIC0gYmFzZSkgKiB0aGlzLnNjYWxlICsgdG9wO1xuICAgICAgICAgICAgaWYgKG4gPD0gdnAuYm90dG9tKVxuICAgICAgICAgICAgICAgIHJldHVybiB2cC5kb21Ub3AgKyAobiAtIHZwLnRvcCkgKyB0b3A7XG4gICAgICAgICAgICBiYXNlID0gdnAuYm90dG9tO1xuICAgICAgICAgICAgZG9tQmFzZSA9IHZwLmRvbUJvdHRvbTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmcm9tRE9NKG4sIHRvcCkge1xuICAgICAgICBuIC09IHRvcDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGJhc2UgPSAwLCBkb21CYXNlID0gMDs7IGkrKykge1xuICAgICAgICAgICAgbGV0IHZwID0gaSA8IHRoaXMudmlld3BvcnRzLmxlbmd0aCA/IHRoaXMudmlld3BvcnRzW2ldIDogbnVsbDtcbiAgICAgICAgICAgIGlmICghdnAgfHwgbiA8IHZwLmRvbVRvcClcbiAgICAgICAgICAgICAgICByZXR1cm4gYmFzZSArIChuIC0gZG9tQmFzZSkgLyB0aGlzLnNjYWxlICsgdG9wO1xuICAgICAgICAgICAgaWYgKG4gPD0gdnAuZG9tQm90dG9tKVxuICAgICAgICAgICAgICAgIHJldHVybiB2cC50b3AgKyAobiAtIHZwLmRvbVRvcCkgKyB0b3A7XG4gICAgICAgICAgICBiYXNlID0gdnAuYm90dG9tO1xuICAgICAgICAgICAgZG9tQmFzZSA9IHZwLmRvbUJvdHRvbTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHNjYWxlQmxvY2soYmxvY2ssIHNjYWxlciwgdG9wKSB7XG4gICAgaWYgKHNjYWxlci5zY2FsZSA9PSAxKVxuICAgICAgICByZXR1cm4gYmxvY2s7XG4gICAgbGV0IGJUb3AgPSBzY2FsZXIudG9ET00oYmxvY2sudG9wLCB0b3ApLCBiQm90dG9tID0gc2NhbGVyLnRvRE9NKGJsb2NrLmJvdHRvbSwgdG9wKTtcbiAgICByZXR1cm4gbmV3IEJsb2NrSW5mbyhibG9jay5mcm9tLCBibG9jay5sZW5ndGgsIGJUb3AsIGJCb3R0b20gLSBiVG9wLCBBcnJheS5pc0FycmF5KGJsb2NrLnR5cGUpID8gYmxvY2sudHlwZS5tYXAoYiA9PiBzY2FsZUJsb2NrKGIsIHNjYWxlciwgdG9wKSkgOiBibG9jay50eXBlKTtcbn1cblxuY29uc3QgdGhlbWUgPSBzdGF0ZS5GYWNldC5kZWZpbmUoeyBjb21iaW5lOiBzdHJzID0+IHN0cnMuam9pbihcIiBcIikgfSk7XG5jb25zdCBkYXJrVGhlbWUgPSBzdGF0ZS5GYWNldC5kZWZpbmUoeyBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLmluZGV4T2YodHJ1ZSkgPiAtMSB9KTtcbmNvbnN0IGJhc2VUaGVtZUlEID0gc3R5bGVNb2QuU3R5bGVNb2R1bGUubmV3TmFtZSgpLCBiYXNlTGlnaHRJRCA9IHN0eWxlTW9kLlN0eWxlTW9kdWxlLm5ld05hbWUoKSwgYmFzZURhcmtJRCA9IHN0eWxlTW9kLlN0eWxlTW9kdWxlLm5ld05hbWUoKTtcbmNvbnN0IGxpZ2h0RGFya0lEcyA9IHsgXCImbGlnaHRcIjogXCIuXCIgKyBiYXNlTGlnaHRJRCwgXCImZGFya1wiOiBcIi5cIiArIGJhc2VEYXJrSUQgfTtcbmZ1bmN0aW9uIGJ1aWxkVGhlbWUobWFpbiwgc3BlYywgc2NvcGVzKSB7XG4gICAgcmV0dXJuIG5ldyBzdHlsZU1vZC5TdHlsZU1vZHVsZShzcGVjLCB7XG4gICAgICAgIGZpbmlzaChzZWwpIHtcbiAgICAgICAgICAgIHJldHVybiAvJi8udGVzdChzZWwpID8gc2VsLnJlcGxhY2UoLyZcXHcqLywgbSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG0gPT0gXCImXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWluO1xuICAgICAgICAgICAgICAgIGlmICghc2NvcGVzIHx8ICFzY29wZXNbbV0pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBVbnN1cHBvcnRlZCBzZWxlY3RvcjogJHttfWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBzY29wZXNbbV07XG4gICAgICAgICAgICB9KSA6IG1haW4gKyBcIiBcIiArIHNlbDtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuY29uc3QgYmFzZVRoZW1lID0gYnVpbGRUaGVtZShcIi5cIiArIGJhc2VUaGVtZUlELCB7XG4gICAgXCImXCI6IHtcbiAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmUgIWltcG9ydGFudFwiLFxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICBcIiYuY20tZm9jdXNlZFwiOiB7XG4gICAgICAgICAgICAvLyBQcm92aWRlIGEgc2ltcGxlIGRlZmF1bHQgb3V0bGluZSB0byBtYWtlIHN1cmUgYSBmb2N1c2VkXG4gICAgICAgICAgICAvLyBlZGl0b3IgaXMgdmlzdWFsbHkgZGlzdGluY3QuIENhbid0IGxlYXZlIHRoZSBkZWZhdWx0IGJlaGF2aW9yXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd2lsbCBhcHBseSB0byB0aGUgY29udGVudCBlbGVtZW50LCB3aGljaCBpc1xuICAgICAgICAgICAgLy8gaW5zaWRlIHRoZSBzY3JvbGxhYmxlIGNvbnRhaW5lciBhbmQgZG9lc24ndCBpbmNsdWRlIHRoZVxuICAgICAgICAgICAgLy8gZ3V0dGVycy4gV2UgYWxzbyBjYW4ndCB1c2UgYW4gJ2F1dG8nIG91dGxpbmUsIHNpbmNlIHRob3NlXG4gICAgICAgICAgICAvLyBhcmUsIGZvciBzb21lIHJlYXNvbiwgZHJhd24gYmVoaW5kIHRoZSBlbGVtZW50IGNvbnRlbnQsIHdoaWNoXG4gICAgICAgICAgICAvLyB3aWxsIGNhdXNlIHRoaW5ncyBsaWtlIHRoZSBhY3RpdmUgbGluZSBiYWNrZ3JvdW5kIHRvIGNvdmVyXG4gICAgICAgICAgICAvLyB0aGUgb3V0bGluZSAoIzI5NykuXG4gICAgICAgICAgICBvdXRsaW5lOiBcIjFweCBkb3R0ZWQgIzIxMjEyMVwiXG4gICAgICAgIH0sXG4gICAgICAgIGRpc3BsYXk6IFwiZmxleCAhaW1wb3J0YW50XCIsXG4gICAgICAgIGZsZXhEaXJlY3Rpb246IFwiY29sdW1uXCJcbiAgICB9LFxuICAgIFwiLmNtLXNjcm9sbGVyXCI6IHtcbiAgICAgICAgZGlzcGxheTogXCJmbGV4ICFpbXBvcnRhbnRcIixcbiAgICAgICAgYWxpZ25JdGVtczogXCJmbGV4LXN0YXJ0ICFpbXBvcnRhbnRcIixcbiAgICAgICAgZm9udEZhbWlseTogXCJtb25vc3BhY2VcIixcbiAgICAgICAgbGluZUhlaWdodDogMS40LFxuICAgICAgICBmbGV4R3JvdzogMixcbiAgICAgICAgb3ZlcmZsb3dYOiBcImF1dG9cIixcbiAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcbiAgICAgICAgekluZGV4OiAwXG4gICAgfSxcbiAgICBcIi5jbS1jb250ZW50XCI6IHtcbiAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICBmbGV4R3JvdzogMixcbiAgICAgICAgbWluSGVpZ2h0OiBcIjEwMCVcIixcbiAgICAgICAgZGlzcGxheTogXCJibG9ja1wiLFxuICAgICAgICB3aGl0ZVNwYWNlOiBcInByZVwiLFxuICAgICAgICB3b3JkV3JhcDogXCJub3JtYWxcIixcbiAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcbiAgICAgICAgcGFkZGluZzogXCI0cHggMFwiLFxuICAgICAgICBvdXRsaW5lOiBcIm5vbmVcIlxuICAgIH0sXG4gICAgXCIuY20tbGluZVdyYXBwaW5nXCI6IHtcbiAgICAgICAgd2hpdGVTcGFjZTogXCJwcmUtd3JhcFwiLFxuICAgICAgICBvdmVyZmxvd1dyYXA6IFwiYW55d2hlcmVcIlxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLWNvbnRlbnRcIjogeyBjYXJldENvbG9yOiBcImJsYWNrXCIgfSxcbiAgICBcIiZkYXJrIC5jbS1jb250ZW50XCI6IHsgY2FyZXRDb2xvcjogXCJ3aGl0ZVwiIH0sXG4gICAgXCIuY20tbGluZVwiOiB7XG4gICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIixcbiAgICAgICAgcGFkZGluZzogXCIwIDJweCAwIDRweFwiXG4gICAgfSxcbiAgICBcIi5jbS1zZWxlY3Rpb25MYXllclwiOiB7XG4gICAgICAgIHpJbmRleDogLTEsXG4gICAgICAgIGNvbnRhaW46IFwic2l6ZSBzdHlsZVwiXG4gICAgfSxcbiAgICBcIi5jbS1zZWxlY3Rpb25CYWNrZ3JvdW5kXCI6IHtcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1zZWxlY3Rpb25CYWNrZ3JvdW5kXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZDogXCIjZDlkOWQ5XCJcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLXNlbGVjdGlvbkJhY2tncm91bmRcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBcIiMyMjJcIlxuICAgIH0sXG4gICAgXCImbGlnaHQuY20tZm9jdXNlZCAuY20tc2VsZWN0aW9uQmFja2dyb3VuZFwiOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IFwiI2Q3ZDRmMFwiXG4gICAgfSxcbiAgICBcIiZkYXJrLmNtLWZvY3VzZWQgLmNtLXNlbGVjdGlvbkJhY2tncm91bmRcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBcIiMyMzNcIlxuICAgIH0sXG4gICAgXCIuY20tY3Vyc29yTGF5ZXJcIjoge1xuICAgICAgICB6SW5kZXg6IDEwMCxcbiAgICAgICAgY29udGFpbjogXCJzaXplIHN0eWxlXCIsXG4gICAgICAgIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiXG4gICAgfSxcbiAgICBcIiYuY20tZm9jdXNlZCAuY20tY3Vyc29yTGF5ZXJcIjoge1xuICAgICAgICBhbmltYXRpb246IFwic3RlcHMoMSkgY20tYmxpbmsgMS4ycyBpbmZpbml0ZVwiXG4gICAgfSxcbiAgICAvLyBUd28gYW5pbWF0aW9ucyBkZWZpbmVkIHNvIHRoYXQgd2UgY2FuIHN3aXRjaCBiZXR3ZWVuIHRoZW0gdG9cbiAgICAvLyByZXN0YXJ0IHRoZSBhbmltYXRpb24gd2l0aG91dCBmb3JjaW5nIGFub3RoZXIgc3R5bGVcbiAgICAvLyByZWNvbXB1dGF0aW9uLlxuICAgIFwiQGtleWZyYW1lcyBjbS1ibGlua1wiOiB7IFwiMCVcIjoge30sIFwiNTAlXCI6IHsgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiB9LCBcIjEwMCVcIjoge30gfSxcbiAgICBcIkBrZXlmcmFtZXMgY20tYmxpbmsyXCI6IHsgXCIwJVwiOiB7fSwgXCI1MCVcIjogeyB2aXNpYmlsaXR5OiBcImhpZGRlblwiIH0sIFwiMTAwJVwiOiB7fSB9LFxuICAgIFwiLmNtLWN1cnNvclwiOiB7XG4gICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgIGJvcmRlckxlZnQ6IFwiMS4ycHggc29saWQgYmxhY2tcIixcbiAgICAgICAgbWFyZ2luTGVmdDogXCItMC42cHhcIixcbiAgICAgICAgcG9pbnRlckV2ZW50czogXCJub25lXCIsXG4gICAgICAgIGRpc3BsYXk6IFwibm9uZVwiXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS1jdXJzb3JcIjoge1xuICAgICAgICBib3JkZXJMZWZ0Q29sb3I6IFwiIzQ0NFwiXG4gICAgfSxcbiAgICBcIiYuY20tZm9jdXNlZCAuY20tY3Vyc29yXCI6IHtcbiAgICAgICAgZGlzcGxheTogXCJibG9ja1wiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tYWN0aXZlTGluZVwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjZjNmOWZmXCIgfSxcbiAgICBcIiZkYXJrIC5jbS1hY3RpdmVMaW5lXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiMyMjMwMzlcIiB9LFxuICAgIFwiJmxpZ2h0IC5jbS1zcGVjaWFsQ2hhclwiOiB7IGNvbG9yOiBcInJlZFwiIH0sXG4gICAgXCImZGFyayAuY20tc3BlY2lhbENoYXJcIjogeyBjb2xvcjogXCIjZjc4XCIgfSxcbiAgICBcIi5jbS10YWJcIjoge1xuICAgICAgICBkaXNwbGF5OiBcImlubGluZS1ibG9ja1wiLFxuICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJib3R0b21cIlxuICAgIH0sXG4gICAgXCIuY20tcGxhY2Vob2xkZXJcIjoge1xuICAgICAgICBjb2xvcjogXCIjODg4XCIsXG4gICAgICAgIGRpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCJcbiAgICB9LFxuICAgIFwiLmNtLWJ1dHRvblwiOiB7XG4gICAgICAgIHZlcnRpY2FsQWxpZ246IFwibWlkZGxlXCIsXG4gICAgICAgIGNvbG9yOiBcImluaGVyaXRcIixcbiAgICAgICAgZm9udFNpemU6IFwiNzAlXCIsXG4gICAgICAgIHBhZGRpbmc6IFwiLjJlbSAxZW1cIixcbiAgICAgICAgYm9yZGVyUmFkaXVzOiBcIjNweFwiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tYnV0dG9uXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZEltYWdlOiBcImxpbmVhci1ncmFkaWVudCgjZWZmMWY1LCAjZDlkOWRmKVwiLFxuICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkICM4ODhcIixcbiAgICAgICAgXCImOmFjdGl2ZVwiOiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IFwibGluZWFyLWdyYWRpZW50KCNiNGI0YjQsICNkMGQzZDYpXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCImZGFyayAuY20tYnV0dG9uXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZEltYWdlOiBcImxpbmVhci1ncmFkaWVudCgjMzkzOTM5LCAjMTExKVwiLFxuICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkICM4ODhcIixcbiAgICAgICAgXCImOmFjdGl2ZVwiOiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IFwibGluZWFyLWdyYWRpZW50KCMxMTEsICMzMzMpXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCIuY20tdGV4dGZpZWxkXCI6IHtcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJtaWRkbGVcIixcbiAgICAgICAgY29sb3I6IFwiaW5oZXJpdFwiLFxuICAgICAgICBmb250U2l6ZTogXCI3MCVcIixcbiAgICAgICAgYm9yZGVyOiBcIjFweCBzb2xpZCBzaWx2ZXJcIixcbiAgICAgICAgcGFkZGluZzogXCIuMmVtIC41ZW1cIlxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXRleHRmaWVsZFwiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJ3aGl0ZVwiXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS10ZXh0ZmllbGRcIjoge1xuICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkICM1NTVcIixcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcImluaGVyaXRcIlxuICAgIH1cbn0sIGxpZ2h0RGFya0lEcyk7XG5cbmNvbnN0IG9ic2VydmVPcHRpb25zID0ge1xuICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxuICAgIHN1YnRyZWU6IHRydWUsXG4gICAgY2hhcmFjdGVyRGF0YU9sZFZhbHVlOiB0cnVlXG59O1xuLy8gSUUxMSBoYXMgdmVyeSBicm9rZW4gbXV0YXRpb24gb2JzZXJ2ZXJzLCBzbyB3ZSBhbHNvIGxpc3RlbiB0b1xuLy8gRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkIHRoZXJlXG5jb25zdCB1c2VDaGFyRGF0YSA9IGJyb3dzZXIuaWUgJiYgYnJvd3Nlci5pZV92ZXJzaW9uIDw9IDExO1xuY2xhc3MgRE9NT2JzZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIG9uQ2hhbmdlLCBvblNjcm9sbENoYW5nZWQpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IG9uQ2hhbmdlO1xuICAgICAgICB0aGlzLm9uU2Nyb2xsQ2hhbmdlZCA9IG9uU2Nyb2xsQ2hhbmdlZDtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pZ25vcmVTZWxlY3Rpb24gPSBuZXcgRE9NU2VsZWN0aW9uO1xuICAgICAgICB0aGlzLmRlbGF5ZWRGbHVzaCA9IC0xO1xuICAgICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLmludGVyc2VjdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuaW50ZXJzZWN0aW5nID0gZmFsc2U7XG4gICAgICAgIC8vIFRpbWVvdXQgZm9yIHNjaGVkdWxpbmcgY2hlY2sgb2YgdGhlIHBhcmVudHMgdGhhdCBuZWVkIHNjcm9sbCBoYW5kbGVyc1xuICAgICAgICB0aGlzLnBhcmVudENoZWNrID0gLTE7XG4gICAgICAgIHRoaXMuZG9tID0gdmlldy5jb250ZW50RE9NO1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobXV0YXRpb25zID0+IHtcbiAgICAgICAgICAgIGZvciAobGV0IG11dCBvZiBtdXRhdGlvbnMpXG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKG11dCk7XG4gICAgICAgICAgICAvLyBJRTExIHdpbGwgc29tZXRpbWVzIChvbiB0eXBpbmcgb3ZlciBhIHNlbGVjdGlvbiBvclxuICAgICAgICAgICAgLy8gYmFja3NwYWNpbmcgb3V0IGEgc2luZ2xlIGNoYXJhY3RlciB0ZXh0IG5vZGUpIGNhbGwgdGhlXG4gICAgICAgICAgICAvLyBvYnNlcnZlciBjYWxsYmFjayBiZWZvcmUgYWN0dWFsbHkgdXBkYXRpbmcgdGhlIERPTS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBVbnJlbGF0ZWRseSwgaU9TIFNhZmFyaSB3aWxsLCB3aGVuIGVuZGluZyBhIGNvbXBvc2l0aW9uLFxuICAgICAgICAgICAgLy8gc29tZXRpbWVzIGZpcnN0IGNsZWFyIGl0LCBkZWxpdmVyIHRoZSBtdXRhdGlvbnMsIGFuZCB0aGVuXG4gICAgICAgICAgICAvLyByZWluc2VydCB0aGUgZmluaXNoZWQgdGV4dC4gQ29kZU1pcnJvcidzIGhhbmRsaW5nIG9mIHRoZVxuICAgICAgICAgICAgLy8gZGVsZXRpb24gd2lsbCBwcmV2ZW50IHRoZSByZWluc2VydGlvbiBmcm9tIGhhcHBlbmluZyxcbiAgICAgICAgICAgIC8vIGJyZWFraW5nIGNvbXBvc2l0aW9uLlxuICAgICAgICAgICAgaWYgKChicm93c2VyLmllICYmIGJyb3dzZXIuaWVfdmVyc2lvbiA8PSAxMSB8fCBicm93c2VyLmlvcyAmJiB2aWV3LmNvbXBvc2luZykgJiZcbiAgICAgICAgICAgICAgICBtdXRhdGlvbnMuc29tZShtID0+IG0udHlwZSA9PSBcImNoaWxkTGlzdFwiICYmIG0ucmVtb3ZlZE5vZGVzLmxlbmd0aCB8fFxuICAgICAgICAgICAgICAgICAgICBtLnR5cGUgPT0gXCJjaGFyYWN0ZXJEYXRhXCIgJiYgbS5vbGRWYWx1ZS5sZW5ndGggPiBtLnRhcmdldC5ub2RlVmFsdWUubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICB0aGlzLmZsdXNoU29vbigpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh1c2VDaGFyRGF0YSlcbiAgICAgICAgICAgIHRoaXMub25DaGFyRGF0YSA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucXVldWUucHVzaCh7IHRhcmdldDogZXZlbnQudGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImNoYXJhY3RlckRhdGFcIixcbiAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWU6IGV2ZW50LnByZXZWYWx1ZSB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmZsdXNoU29vbigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vblNlbGVjdGlvbkNoYW5nZSA9IHRoaXMub25TZWxlY3Rpb25DaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgICB0aGlzLm9uU2Nyb2xsID0gdGhpcy5vblNjcm9sbC5iaW5kKHRoaXMpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLm9uU2Nyb2xsKTtcbiAgICAgICAgaWYgKHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudENoZWNrIDwgMClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRDaGVjayA9IHNldFRpbWVvdXQodGhpcy5saXN0ZW5Gb3JTY3JvbGwuYmluZCh0aGlzKSwgMTAwMCk7XG4gICAgICAgICAgICAgICAgaWYgKGVudHJpZXNbZW50cmllcy5sZW5ndGggLSAxXS5pbnRlcnNlY3Rpb25SYXRpbyA+IDAgIT0gdGhpcy5pbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnRlcnNlY3RpbmcgPSAhdGhpcy5pbnRlcnNlY3Rpbmc7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmludGVyc2VjdGluZyAhPSB0aGlzLnZpZXcuaW5WaWV3KVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vblNjcm9sbENoYW5nZWQoZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb24ub2JzZXJ2ZSh0aGlzLmRvbSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saXN0ZW5Gb3JTY3JvbGwoKTtcbiAgICB9XG4gICAgb25TY3JvbGwoZSkge1xuICAgICAgICBpZiAodGhpcy5pbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgICAgICAgIHRoaXMub25TY3JvbGxDaGFuZ2VkKGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uU2VsZWN0aW9uQ2hhbmdlKGV2ZW50KSB7XG4gICAgICAgIGxldCB7IHZpZXcgfSA9IHRoaXMsIHNlbCA9IGdldFNlbGVjdGlvbih2aWV3LnJvb3QpO1xuICAgICAgICBpZiAodmlldy5zdGF0ZS5mYWNldChlZGl0YWJsZSkgPyB2aWV3LnJvb3QuYWN0aXZlRWxlbWVudCAhPSB0aGlzLmRvbSA6ICFoYXNTZWxlY3Rpb24odmlldy5kb20sIHNlbCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBjb250ZXh0ID0gc2VsLmFuY2hvck5vZGUgJiYgdmlldy5kb2NWaWV3Lm5lYXJlc3Qoc2VsLmFuY2hvck5vZGUpO1xuICAgICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0Lmlnbm9yZUV2ZW50KGV2ZW50KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gRGVsZXRpb25zIG9uIElFMTEgZmlyZSB0aGVpciBldmVudHMgaW4gdGhlIHdyb25nIG9yZGVyLCBnaXZpbmdcbiAgICAgICAgLy8gdXMgYSBzZWxlY3Rpb24gY2hhbmdlIGV2ZW50IGJlZm9yZSB0aGUgRE9NIGNoYW5nZXMgYXJlXG4gICAgICAgIC8vIHJlcG9ydGVkLlxuICAgICAgICAvLyAoU2VsZWN0aW9uLmlzQ29sbGFwc2VkIGlzbid0IHJlbGlhYmxlIG9uIElFKVxuICAgICAgICBpZiAoYnJvd3Nlci5pZSAmJiBicm93c2VyLmllX3ZlcnNpb24gPD0gMTEgJiYgIXZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uZW1wdHkgJiZcbiAgICAgICAgICAgIHNlbC5mb2N1c05vZGUgJiYgaXNFcXVpdmFsZW50UG9zaXRpb24oc2VsLmZvY3VzTm9kZSwgc2VsLmZvY3VzT2Zmc2V0LCBzZWwuYW5jaG9yTm9kZSwgc2VsLmFuY2hvck9mZnNldCkpXG4gICAgICAgICAgICB0aGlzLmZsdXNoU29vbigpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgfVxuICAgIGxpc3RlbkZvclNjcm9sbCgpIHtcbiAgICAgICAgdGhpcy5wYXJlbnRDaGVjayA9IC0xO1xuICAgICAgICBsZXQgaSA9IDAsIGNoYW5nZWQgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBkb20gPSB0aGlzLmRvbTsgZG9tOykge1xuICAgICAgICAgICAgaWYgKGRvbS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjaGFuZ2VkICYmIGkgPCB0aGlzLnNjcm9sbFRhcmdldHMubGVuZ3RoICYmIHRoaXMuc2Nyb2xsVGFyZ2V0c1tpXSA9PSBkb20pXG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghY2hhbmdlZClcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRoaXMuc2Nyb2xsVGFyZ2V0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlZClcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZC5wdXNoKGRvbSk7XG4gICAgICAgICAgICAgICAgZG9tID0gZG9tLnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkb20ubm9kZVR5cGUgPT0gMTEpIHsgLy8gU2hhZG93IHJvb3RcbiAgICAgICAgICAgICAgICBkb20gPSBkb20uaG9zdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpIDwgdGhpcy5zY3JvbGxUYXJnZXRzLmxlbmd0aCAmJiAhY2hhbmdlZClcbiAgICAgICAgICAgIGNoYW5nZWQgPSB0aGlzLnNjcm9sbFRhcmdldHMuc2xpY2UoMCwgaSk7XG4gICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBkb20gb2YgdGhpcy5zY3JvbGxUYXJnZXRzKVxuICAgICAgICAgICAgICAgIGRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMub25TY3JvbGwpO1xuICAgICAgICAgICAgZm9yIChsZXQgZG9tIG9mIHRoaXMuc2Nyb2xsVGFyZ2V0cyA9IGNoYW5nZWQpXG4gICAgICAgICAgICAgICAgZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5vblNjcm9sbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWdub3JlKGYpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSlcbiAgICAgICAgICAgIHJldHVybiBmKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgICAgIHJldHVybiBmKCk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5vYnNlcnZlci5vYnNlcnZlKHRoaXMuZG9tLCBvYnNlcnZlT3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZG9tLm93bmVyRG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNlbGVjdGlvbmNoYW5nZVwiLCB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlKTtcbiAgICAgICAgaWYgKHVzZUNoYXJEYXRhKVxuICAgICAgICAgICAgdGhpcy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNoYXJhY3RlckRhdGFNb2RpZmllZFwiLCB0aGlzLm9uQ2hhckRhdGEpO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB0aGlzLmRvbS5vd25lckRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdGhpcy5vblNlbGVjdGlvbkNoYW5nZSk7XG4gICAgICAgIGlmICh1c2VDaGFyRGF0YSlcbiAgICAgICAgICAgIHRoaXMuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWRcIiwgdGhpcy5vbkNoYXJEYXRhKTtcbiAgICB9XG4gICAgY2xlYXJTZWxlY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuaWdub3JlU2VsZWN0aW9uLnNldChnZXRTZWxlY3Rpb24odGhpcy52aWV3LnJvb3QpKTtcbiAgICB9XG4gICAgLy8gVGhyb3cgYXdheSBhbnkgcGVuZGluZyBjaGFuZ2VzXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIudGFrZVJlY29yZHMoKTtcbiAgICAgICAgdGhpcy5xdWV1ZS5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgfVxuICAgIGZsdXNoU29vbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVsYXllZEZsdXNoIDwgMClcbiAgICAgICAgICAgIHRoaXMuZGVsYXllZEZsdXNoID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4geyB0aGlzLmRlbGF5ZWRGbHVzaCA9IC0xOyB0aGlzLmZsdXNoKCk7IH0sIDIwKTtcbiAgICB9XG4gICAgZm9yY2VGbHVzaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVsYXllZEZsdXNoID49IDApIHtcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5kZWxheWVkRmx1c2gpO1xuICAgICAgICAgICAgdGhpcy5kZWxheWVkRmx1c2ggPSAtMTtcbiAgICAgICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBcHBseSBwZW5kaW5nIGNoYW5nZXMsIGlmIGFueVxuICAgIGZsdXNoKCkge1xuICAgICAgICBpZiAodGhpcy5kZWxheWVkRmx1c2ggPj0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHJlY29yZHMgPSB0aGlzLnF1ZXVlO1xuICAgICAgICBmb3IgKGxldCBtdXQgb2YgdGhpcy5vYnNlcnZlci50YWtlUmVjb3JkcygpKVxuICAgICAgICAgICAgcmVjb3Jkcy5wdXNoKG11dCk7XG4gICAgICAgIGlmIChyZWNvcmRzLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgICAgbGV0IHNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbih0aGlzLnZpZXcucm9vdCk7XG4gICAgICAgIGxldCBuZXdTZWwgPSAhdGhpcy5pZ25vcmVTZWxlY3Rpb24uZXEoc2VsZWN0aW9uKSAmJiBoYXNTZWxlY3Rpb24odGhpcy5kb20sIHNlbGVjdGlvbik7XG4gICAgICAgIGlmIChyZWNvcmRzLmxlbmd0aCA9PSAwICYmICFuZXdTZWwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBmcm9tID0gLTEsIHRvID0gLTEsIHR5cGVPdmVyID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IHJlY29yZCBvZiByZWNvcmRzKSB7XG4gICAgICAgICAgICBsZXQgcmFuZ2UgPSB0aGlzLnJlYWRNdXRhdGlvbihyZWNvcmQpO1xuICAgICAgICAgICAgaWYgKCFyYW5nZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChyYW5nZS50eXBlT3ZlcilcbiAgICAgICAgICAgICAgICB0eXBlT3ZlciA9IHRydWU7XG4gICAgICAgICAgICBpZiAoZnJvbSA9PSAtMSkge1xuICAgICAgICAgICAgICAgICh7IGZyb20sIHRvIH0gPSByYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmcm9tID0gTWF0aC5taW4ocmFuZ2UuZnJvbSwgZnJvbSk7XG4gICAgICAgICAgICAgICAgdG8gPSBNYXRoLm1heChyYW5nZS50bywgdG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBzdGFydFN0YXRlID0gdGhpcy52aWV3LnN0YXRlO1xuICAgICAgICBpZiAoZnJvbSA+IC0xIHx8IG5ld1NlbClcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2UoZnJvbSwgdG8sIHR5cGVPdmVyKTtcbiAgICAgICAgaWYgKHRoaXMudmlldy5zdGF0ZSA9PSBzdGFydFN0YXRlKSB7IC8vIFRoZSB2aWV3IHdhc24ndCB1cGRhdGVkXG4gICAgICAgICAgICBpZiAodGhpcy52aWV3LmRvY1ZpZXcuZGlydHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlnbm9yZSgoKSA9PiB0aGlzLnZpZXcuZG9jVmlldy5zeW5jKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMudmlldy5kb2NWaWV3LmRpcnR5ID0gMCAvKiBOb3QgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnZpZXcuZG9jVmlldy51cGRhdGVTZWxlY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgfVxuICAgIHJlYWRNdXRhdGlvbihyZWMpIHtcbiAgICAgICAgbGV0IGNWaWV3ID0gdGhpcy52aWV3LmRvY1ZpZXcubmVhcmVzdChyZWMudGFyZ2V0KTtcbiAgICAgICAgaWYgKCFjVmlldyB8fCBjVmlldy5pZ25vcmVNdXRhdGlvbihyZWMpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNWaWV3Lm1hcmtEaXJ0eSgpO1xuICAgICAgICBpZiAocmVjLnR5cGUgPT0gXCJjaGlsZExpc3RcIikge1xuICAgICAgICAgICAgbGV0IGNoaWxkQmVmb3JlID0gZmluZENoaWxkKGNWaWV3LCByZWMucHJldmlvdXNTaWJsaW5nIHx8IHJlYy50YXJnZXQucHJldmlvdXNTaWJsaW5nLCAtMSk7XG4gICAgICAgICAgICBsZXQgY2hpbGRBZnRlciA9IGZpbmRDaGlsZChjVmlldywgcmVjLm5leHRTaWJsaW5nIHx8IHJlYy50YXJnZXQubmV4dFNpYmxpbmcsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHsgZnJvbTogY2hpbGRCZWZvcmUgPyBjVmlldy5wb3NBZnRlcihjaGlsZEJlZm9yZSkgOiBjVmlldy5wb3NBdFN0YXJ0LFxuICAgICAgICAgICAgICAgIHRvOiBjaGlsZEFmdGVyID8gY1ZpZXcucG9zQmVmb3JlKGNoaWxkQWZ0ZXIpIDogY1ZpZXcucG9zQXRFbmQsIHR5cGVPdmVyOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBcImNoYXJhY3RlckRhdGFcIlxuICAgICAgICAgICAgcmV0dXJuIHsgZnJvbTogY1ZpZXcucG9zQXRTdGFydCwgdG86IGNWaWV3LnBvc0F0RW5kLCB0eXBlT3ZlcjogcmVjLnRhcmdldC5ub2RlVmFsdWUgPT0gcmVjLm9sZFZhbHVlIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIGlmICh0aGlzLmludGVyc2VjdGlvbilcbiAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgZm9yIChsZXQgZG9tIG9mIHRoaXMuc2Nyb2xsVGFyZ2V0cylcbiAgICAgICAgICAgIGRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMub25TY3JvbGwpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLm9uU2Nyb2xsKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucGFyZW50Q2hlY2spO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmRDaGlsZChjVmlldywgZG9tLCBkaXIpIHtcbiAgICB3aGlsZSAoZG9tKSB7XG4gICAgICAgIGxldCBjdXJWaWV3ID0gQ29udGVudFZpZXcuZ2V0KGRvbSk7XG4gICAgICAgIGlmIChjdXJWaWV3ICYmIGN1clZpZXcucGFyZW50ID09IGNWaWV3KVxuICAgICAgICAgICAgcmV0dXJuIGN1clZpZXc7XG4gICAgICAgIGxldCBwYXJlbnQgPSBkb20ucGFyZW50Tm9kZTtcbiAgICAgICAgZG9tID0gcGFyZW50ICE9IGNWaWV3LmRvbSA/IHBhcmVudCA6IGRpciA+IDAgPyBkb20ubmV4dFNpYmxpbmcgOiBkb20ucHJldmlvdXNTaWJsaW5nO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gYXBwbHlET01DaGFuZ2Uodmlldywgc3RhcnQsIGVuZCwgdHlwZU92ZXIpIHtcbiAgICBsZXQgY2hhbmdlLCBuZXdTZWw7XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4sIGJvdW5kcztcbiAgICBpZiAoc3RhcnQgPiAtMSAmJiAoYm91bmRzID0gdmlldy5kb2NWaWV3LmRvbUJvdW5kc0Fyb3VuZChzdGFydCwgZW5kLCAwKSkpIHtcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IGJvdW5kcztcbiAgICAgICAgbGV0IHNlbFBvaW50cyA9IHZpZXcuZG9jVmlldy5pbXByZWNpc2VIZWFkIHx8IHZpZXcuZG9jVmlldy5pbXByZWNpc2VBbmNob3IgPyBbXSA6IHNlbGVjdGlvblBvaW50cyh2aWV3LmNvbnRlbnRET00sIHZpZXcucm9vdCk7XG4gICAgICAgIGxldCByZWFkZXIgPSBuZXcgRE9NUmVhZGVyKHNlbFBvaW50cywgdmlldyk7XG4gICAgICAgIHJlYWRlci5yZWFkUmFuZ2UoYm91bmRzLnN0YXJ0RE9NLCBib3VuZHMuZW5kRE9NKTtcbiAgICAgICAgbmV3U2VsID0gc2VsZWN0aW9uRnJvbVBvaW50cyhzZWxQb2ludHMsIGZyb20pO1xuICAgICAgICBsZXQgcHJlZmVycmVkUG9zID0gc2VsLmZyb20sIHByZWZlcnJlZFNpZGUgPSBudWxsO1xuICAgICAgICAvLyBQcmVmZXIgYW5jaG9yaW5nIHRvIGVuZCB3aGVuIEJhY2tzcGFjZSBpcyBwcmVzc2VkIChvciwgb25cbiAgICAgICAgLy8gQW5kcm9pZCwgd2hlbiBzb21ldGhpbmcgd2FzIGRlbGV0ZWQpXG4gICAgICAgIGlmICh2aWV3LmlucHV0U3RhdGUubGFzdEtleUNvZGUgPT09IDggJiYgdmlldy5pbnB1dFN0YXRlLmxhc3RLZXlUaW1lID4gRGF0ZS5ub3coKSAtIDEwMCB8fFxuICAgICAgICAgICAgYnJvd3Nlci5hbmRyb2lkICYmIHJlYWRlci50ZXh0Lmxlbmd0aCA8IHRvIC0gZnJvbSkge1xuICAgICAgICAgICAgcHJlZmVycmVkUG9zID0gc2VsLnRvO1xuICAgICAgICAgICAgcHJlZmVycmVkU2lkZSA9IFwiZW5kXCI7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRpZmYgPSBmaW5kRGlmZih2aWV3LnN0YXRlLnNsaWNlRG9jKGZyb20sIHRvKSwgcmVhZGVyLnRleHQsIHByZWZlcnJlZFBvcyAtIGZyb20sIHByZWZlcnJlZFNpZGUpO1xuICAgICAgICBpZiAoZGlmZilcbiAgICAgICAgICAgIGNoYW5nZSA9IHsgZnJvbTogZnJvbSArIGRpZmYuZnJvbSwgdG86IGZyb20gKyBkaWZmLnRvQSxcbiAgICAgICAgICAgICAgICBpbnNlcnQ6IHZpZXcuc3RhdGUudG9UZXh0KHJlYWRlci50ZXh0LnNsaWNlKGRpZmYuZnJvbSwgZGlmZi50b0IpKSB9O1xuICAgIH1cbiAgICBlbHNlIGlmICh2aWV3Lmhhc0ZvY3VzIHx8ICF2aWV3LnN0YXRlLmZhY2V0KGVkaXRhYmxlKSkge1xuICAgICAgICBsZXQgZG9tU2VsID0gZ2V0U2VsZWN0aW9uKHZpZXcucm9vdCk7XG4gICAgICAgIGxldCB7IGltcHJlY2lzZUhlYWQ6IGlIZWFkLCBpbXByZWNpc2VBbmNob3I6IGlBbmNob3IgfSA9IHZpZXcuZG9jVmlldztcbiAgICAgICAgbGV0IGhlYWQgPSBpSGVhZCAmJiBpSGVhZC5ub2RlID09IGRvbVNlbC5mb2N1c05vZGUgJiYgaUhlYWQub2Zmc2V0ID09IGRvbVNlbC5mb2N1c09mZnNldCB8fFxuICAgICAgICAgICAgIWNvbnRhaW5zKHZpZXcuY29udGVudERPTSwgZG9tU2VsLmZvY3VzTm9kZSlcbiAgICAgICAgICAgID8gdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkXG4gICAgICAgICAgICA6IHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKGRvbVNlbC5mb2N1c05vZGUsIGRvbVNlbC5mb2N1c09mZnNldCk7XG4gICAgICAgIGxldCBhbmNob3IgPSBpQW5jaG9yICYmIGlBbmNob3Iubm9kZSA9PSBkb21TZWwuYW5jaG9yTm9kZSAmJiBpQW5jaG9yLm9mZnNldCA9PSBkb21TZWwuYW5jaG9yT2Zmc2V0IHx8XG4gICAgICAgICAgICAhY29udGFpbnModmlldy5jb250ZW50RE9NLCBkb21TZWwuYW5jaG9yTm9kZSlcbiAgICAgICAgICAgID8gdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5hbmNob3JcbiAgICAgICAgICAgIDogc2VsZWN0aW9uQ29sbGFwc2VkKGRvbVNlbCkgPyBoZWFkIDogdmlldy5kb2NWaWV3LnBvc0Zyb21ET00oZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQpO1xuICAgICAgICBpZiAoaGVhZCAhPSBzZWwuaGVhZCB8fCBhbmNob3IgIT0gc2VsLmFuY2hvcilcbiAgICAgICAgICAgIG5ld1NlbCA9IHN0YXRlLkVkaXRvclNlbGVjdGlvbi5zaW5nbGUoYW5jaG9yLCBoZWFkKTtcbiAgICB9XG4gICAgaWYgKCFjaGFuZ2UgJiYgIW5ld1NlbClcbiAgICAgICAgcmV0dXJuO1xuICAgIC8vIEhldXJpc3RpYyB0byBub3RpY2UgdHlwaW5nIG92ZXIgYSBzZWxlY3RlZCBjaGFyYWN0ZXJcbiAgICBpZiAoIWNoYW5nZSAmJiB0eXBlT3ZlciAmJiAhc2VsLmVtcHR5ICYmIG5ld1NlbCAmJiBuZXdTZWwubWFpbi5lbXB0eSlcbiAgICAgICAgY2hhbmdlID0geyBmcm9tOiBzZWwuZnJvbSwgdG86IHNlbC50bywgaW5zZXJ0OiB2aWV3LnN0YXRlLmRvYy5zbGljZShzZWwuZnJvbSwgc2VsLnRvKSB9O1xuICAgIGlmIChjaGFuZ2UpIHtcbiAgICAgICAgbGV0IHN0YXJ0U3RhdGUgPSB2aWV3LnN0YXRlO1xuICAgICAgICAvLyBBbmRyb2lkIGJyb3dzZXJzIGRvbid0IGZpcmUgcmVhc29uYWJsZSBrZXkgZXZlbnRzIGZvciBlbnRlcixcbiAgICAgICAgLy8gYmFja3NwYWNlLCBvciBkZWxldGUuIFNvIHRoaXMgZGV0ZWN0cyBjaGFuZ2VzIHRoYXQgbG9vayBsaWtlXG4gICAgICAgIC8vIHRoZXkncmUgY2F1c2VkIGJ5IHRob3NlIGtleXMsIGFuZCByZWludGVycHJldHMgdGhlbSBhcyBrZXlcbiAgICAgICAgLy8gZXZlbnRzLlxuICAgICAgICBpZiAoYnJvd3Nlci5hbmRyb2lkICYmXG4gICAgICAgICAgICAoKGNoYW5nZS5mcm9tID09IHNlbC5mcm9tICYmIGNoYW5nZS50byA9PSBzZWwudG8gJiZcbiAgICAgICAgICAgICAgICBjaGFuZ2UuaW5zZXJ0Lmxlbmd0aCA9PSAxICYmIGNoYW5nZS5pbnNlcnQubGluZXMgPT0gMiAmJlxuICAgICAgICAgICAgICAgIGRpc3BhdGNoS2V5KHZpZXcsIFwiRW50ZXJcIiwgMTMpKSB8fFxuICAgICAgICAgICAgICAgIChjaGFuZ2UuZnJvbSA9PSBzZWwuZnJvbSAtIDEgJiYgY2hhbmdlLnRvID09IHNlbC50byAmJiBjaGFuZ2UuaW5zZXJ0Lmxlbmd0aCA9PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoS2V5KHZpZXcsIFwiQmFja3NwYWNlXCIsIDgpKSB8fFxuICAgICAgICAgICAgICAgIChjaGFuZ2UuZnJvbSA9PSBzZWwuZnJvbSAmJiBjaGFuZ2UudG8gPT0gc2VsLnRvICsgMSAmJiBjaGFuZ2UuaW5zZXJ0Lmxlbmd0aCA9PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoS2V5KHZpZXcsIFwiRGVsZXRlXCIsIDQ2KSkpIHx8XG4gICAgICAgICAgICBicm93c2VyLmlvcyAmJlxuICAgICAgICAgICAgICAgICgodmlldy5pbnB1dFN0YXRlLmxhc3RJT1NFbnRlciA+IERhdGUubm93KCkgLSAyMjUgJiYgY2hhbmdlLmluc2VydC5saW5lcyA+IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hLZXkodmlldywgXCJFbnRlclwiLCAxMykpIHx8XG4gICAgICAgICAgICAgICAgICAgICh2aWV3LmlucHV0U3RhdGUubGFzdElPU0JhY2tzcGFjZSA+IERhdGUubm93KCkgLSAyMjUgJiYgIWNoYW5nZS5pbnNlcnQubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaEtleSh2aWV3LCBcIkJhY2tzcGFjZVwiLCA4KSkpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgdGV4dCA9IGNoYW5nZS5pbnNlcnQudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKHZpZXcuc3RhdGUuZmFjZXQoaW5wdXRIYW5kbGVyKS5zb21lKGggPT4gaCh2aWV3LCBjaGFuZ2UuZnJvbSwgY2hhbmdlLnRvLCB0ZXh0KSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nID49IDApXG4gICAgICAgICAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nKys7XG4gICAgICAgIGxldCB0cjtcbiAgICAgICAgaWYgKGNoYW5nZS5mcm9tID49IHNlbC5mcm9tICYmIGNoYW5nZS50byA8PSBzZWwudG8gJiYgY2hhbmdlLnRvIC0gY2hhbmdlLmZyb20gPj0gKHNlbC50byAtIHNlbC5mcm9tKSAvIDMgJiZcbiAgICAgICAgICAgICghbmV3U2VsIHx8IG5ld1NlbC5tYWluLmVtcHR5ICYmIG5ld1NlbC5tYWluLmZyb20gPT0gY2hhbmdlLmZyb20gKyBjaGFuZ2UuaW5zZXJ0Lmxlbmd0aCkpIHtcbiAgICAgICAgICAgIGxldCBiZWZvcmUgPSBzZWwuZnJvbSA8IGNoYW5nZS5mcm9tID8gc3RhcnRTdGF0ZS5zbGljZURvYyhzZWwuZnJvbSwgY2hhbmdlLmZyb20pIDogXCJcIjtcbiAgICAgICAgICAgIGxldCBhZnRlciA9IHNlbC50byA+IGNoYW5nZS50byA/IHN0YXJ0U3RhdGUuc2xpY2VEb2MoY2hhbmdlLnRvLCBzZWwudG8pIDogXCJcIjtcbiAgICAgICAgICAgIHRyID0gc3RhcnRTdGF0ZS5yZXBsYWNlU2VsZWN0aW9uKHZpZXcuc3RhdGUudG9UZXh0KGJlZm9yZSArIGNoYW5nZS5pbnNlcnQuc2xpY2VTdHJpbmcoMCwgdW5kZWZpbmVkLCB2aWV3LnN0YXRlLmxpbmVCcmVhaykgK1xuICAgICAgICAgICAgICAgIGFmdGVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgY2hhbmdlcyA9IHN0YXJ0U3RhdGUuY2hhbmdlcyhjaGFuZ2UpO1xuICAgICAgICAgICAgdHIgPSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlcyxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb246IG5ld1NlbCAmJiAhc3RhcnRTdGF0ZS5zZWxlY3Rpb24ubWFpbi5lcShuZXdTZWwubWFpbikgJiYgbmV3U2VsLm1haW4udG8gPD0gY2hhbmdlcy5uZXdMZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgPyBzdGFydFN0YXRlLnNlbGVjdGlvbi5yZXBsYWNlUmFuZ2UobmV3U2VsLm1haW4pIDogdW5kZWZpbmVkXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZpZXcuZGlzcGF0Y2godHIsIHsgc2Nyb2xsSW50b1ZpZXc6IHRydWUsIGFubm90YXRpb25zOiBzdGF0ZS5UcmFuc2FjdGlvbi51c2VyRXZlbnQub2YoXCJpbnB1dFwiKSB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAobmV3U2VsICYmICFuZXdTZWwubWFpbi5lcShzZWwpKSB7XG4gICAgICAgIGxldCBzY3JvbGxJbnRvVmlldyA9IGZhbHNlLCBhbm5vdGF0aW9ucztcbiAgICAgICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5sYXN0U2VsZWN0aW9uVGltZSA+IERhdGUubm93KCkgLSA1MCkge1xuICAgICAgICAgICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5sYXN0U2VsZWN0aW9uT3JpZ2luID09IFwia2V5Ym9hcmRzZWxlY3Rpb25cIilcbiAgICAgICAgICAgICAgICBzY3JvbGxJbnRvVmlldyA9IHRydWU7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbnMgPSBzdGF0ZS5UcmFuc2FjdGlvbi51c2VyRXZlbnQub2Yodmlldy5pbnB1dFN0YXRlLmxhc3RTZWxlY3Rpb25PcmlnaW4pO1xuICAgICAgICB9XG4gICAgICAgIHZpZXcuZGlzcGF0Y2goeyBzZWxlY3Rpb246IG5ld1NlbCwgc2Nyb2xsSW50b1ZpZXcsIGFubm90YXRpb25zIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmREaWZmKGEsIGIsIHByZWZlcnJlZFBvcywgcHJlZmVycmVkU2lkZSkge1xuICAgIGxldCBtaW5MZW4gPSBNYXRoLm1pbihhLmxlbmd0aCwgYi5sZW5ndGgpO1xuICAgIGxldCBmcm9tID0gMDtcbiAgICB3aGlsZSAoZnJvbSA8IG1pbkxlbiAmJiBhLmNoYXJDb2RlQXQoZnJvbSkgPT0gYi5jaGFyQ29kZUF0KGZyb20pKVxuICAgICAgICBmcm9tKys7XG4gICAgaWYgKGZyb20gPT0gbWluTGVuICYmIGEubGVuZ3RoID09IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgdG9BID0gYS5sZW5ndGgsIHRvQiA9IGIubGVuZ3RoO1xuICAgIHdoaWxlICh0b0EgPiAwICYmIHRvQiA+IDAgJiYgYS5jaGFyQ29kZUF0KHRvQSAtIDEpID09IGIuY2hhckNvZGVBdCh0b0IgLSAxKSkge1xuICAgICAgICB0b0EtLTtcbiAgICAgICAgdG9CLS07XG4gICAgfVxuICAgIGlmIChwcmVmZXJyZWRTaWRlID09IFwiZW5kXCIpIHtcbiAgICAgICAgbGV0IGFkanVzdCA9IE1hdGgubWF4KDAsIGZyb20gLSBNYXRoLm1pbih0b0EsIHRvQikpO1xuICAgICAgICBwcmVmZXJyZWRQb3MgLT0gdG9BICsgYWRqdXN0IC0gZnJvbTtcbiAgICB9XG4gICAgaWYgKHRvQSA8IGZyb20gJiYgYS5sZW5ndGggPCBiLmxlbmd0aCkge1xuICAgICAgICBsZXQgbW92ZSA9IHByZWZlcnJlZFBvcyA8PSBmcm9tICYmIHByZWZlcnJlZFBvcyA+PSB0b0EgPyBmcm9tIC0gcHJlZmVycmVkUG9zIDogMDtcbiAgICAgICAgZnJvbSAtPSBtb3ZlO1xuICAgICAgICB0b0IgPSBmcm9tICsgKHRvQiAtIHRvQSk7XG4gICAgICAgIHRvQSA9IGZyb207XG4gICAgfVxuICAgIGVsc2UgaWYgKHRvQiA8IGZyb20pIHtcbiAgICAgICAgbGV0IG1vdmUgPSBwcmVmZXJyZWRQb3MgPD0gZnJvbSAmJiBwcmVmZXJyZWRQb3MgPj0gdG9CID8gZnJvbSAtIHByZWZlcnJlZFBvcyA6IDA7XG4gICAgICAgIGZyb20gLT0gbW92ZTtcbiAgICAgICAgdG9BID0gZnJvbSArICh0b0EgLSB0b0IpO1xuICAgICAgICB0b0IgPSBmcm9tO1xuICAgIH1cbiAgICByZXR1cm4geyBmcm9tLCB0b0EsIHRvQiB9O1xufVxuY2xhc3MgRE9NUmVhZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihwb2ludHMsIHZpZXcpIHtcbiAgICAgICAgdGhpcy5wb2ludHMgPSBwb2ludHM7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMudGV4dCA9IFwiXCI7XG4gICAgICAgIHRoaXMubGluZUJyZWFrID0gdmlldy5zdGF0ZS5saW5lQnJlYWs7XG4gICAgfVxuICAgIHJlYWRSYW5nZShzdGFydCwgZW5kKSB7XG4gICAgICAgIGlmICghc3RhcnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBwYXJlbnQgPSBzdGFydC5wYXJlbnROb2RlO1xuICAgICAgICBmb3IgKGxldCBjdXIgPSBzdGFydDs7KSB7XG4gICAgICAgICAgICB0aGlzLmZpbmRQb2ludEJlZm9yZShwYXJlbnQsIGN1cik7XG4gICAgICAgICAgICB0aGlzLnJlYWROb2RlKGN1cik7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGN1ci5uZXh0U2libGluZztcbiAgICAgICAgICAgIGlmIChuZXh0ID09IGVuZClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCB2aWV3ID0gQ29udGVudFZpZXcuZ2V0KGN1ciksIG5leHRWaWV3ID0gQ29udGVudFZpZXcuZ2V0KG5leHQpO1xuICAgICAgICAgICAgaWYgKCh2aWV3ID8gdmlldy5icmVha0FmdGVyIDogaXNCbG9ja0VsZW1lbnQoY3VyKSkgfHxcbiAgICAgICAgICAgICAgICAoKG5leHRWaWV3ID8gbmV4dFZpZXcuYnJlYWtBZnRlciA6IGlzQmxvY2tFbGVtZW50KG5leHQpKSAmJiAhKGN1ci5ub2RlTmFtZSA9PSBcIkJSXCIgJiYgIWN1ci5jbUlnbm9yZSkpKVxuICAgICAgICAgICAgICAgIHRoaXMudGV4dCArPSB0aGlzLmxpbmVCcmVhaztcbiAgICAgICAgICAgIGN1ciA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maW5kUG9pbnRCZWZvcmUocGFyZW50LCBlbmQpO1xuICAgIH1cbiAgICByZWFkTm9kZShub2RlKSB7XG4gICAgICAgIGlmIChub2RlLmNtSWdub3JlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgdmlldyA9IENvbnRlbnRWaWV3LmdldChub2RlKTtcbiAgICAgICAgbGV0IGZyb21WaWV3ID0gdmlldyAmJiB2aWV3Lm92ZXJyaWRlRE9NVGV4dDtcbiAgICAgICAgbGV0IHRleHQ7XG4gICAgICAgIGlmIChmcm9tVmlldyAhPSBudWxsKVxuICAgICAgICAgICAgdGV4dCA9IGZyb21WaWV3LnNsaWNlU3RyaW5nKDAsIHVuZGVmaW5lZCwgdGhpcy5saW5lQnJlYWspO1xuICAgICAgICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICB0ZXh0ID0gbm9kZS5ub2RlVmFsdWU7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZU5hbWUgPT0gXCJCUlwiKVxuICAgICAgICAgICAgdGV4dCA9IG5vZGUubmV4dFNpYmxpbmcgPyB0aGlzLmxpbmVCcmVhayA6IFwiXCI7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgICAgIHRoaXMucmVhZFJhbmdlKG5vZGUuZmlyc3RDaGlsZCwgbnVsbCk7XG4gICAgICAgIGlmICh0ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZmluZFBvaW50SW4obm9kZSwgdGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy50ZXh0ICs9IHRleHQ7XG4gICAgICAgICAgICAvLyBDaHJvbWUgaW5zZXJ0cyB0d28gbmV3bGluZXMgd2hlbiBwcmVzc2luZyBzaGlmdC1lbnRlciBhdCB0aGVcbiAgICAgICAgICAgIC8vIGVuZCBvZiBhIGxpbmUuIFRoaXMgZHJvcHMgb25lIG9mIHRob3NlLlxuICAgICAgICAgICAgaWYgKGJyb3dzZXIuY2hyb21lICYmIHRoaXMudmlldy5pbnB1dFN0YXRlLmxhc3RLZXlDb2RlID09IDEzICYmICFub2RlLm5leHRTaWJsaW5nICYmIC9cXG5cXG4kLy50ZXN0KHRoaXMudGV4dCkpXG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0ID0gdGhpcy50ZXh0LnNsaWNlKDAsIC0xKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaW5kUG9pbnRCZWZvcmUobm9kZSwgbmV4dCkge1xuICAgICAgICBmb3IgKGxldCBwb2ludCBvZiB0aGlzLnBvaW50cylcbiAgICAgICAgICAgIGlmIChwb2ludC5ub2RlID09IG5vZGUgJiYgbm9kZS5jaGlsZE5vZGVzW3BvaW50Lm9mZnNldF0gPT0gbmV4dClcbiAgICAgICAgICAgICAgICBwb2ludC5wb3MgPSB0aGlzLnRleHQubGVuZ3RoO1xuICAgIH1cbiAgICBmaW5kUG9pbnRJbihub2RlLCBtYXhMZW4pIHtcbiAgICAgICAgZm9yIChsZXQgcG9pbnQgb2YgdGhpcy5wb2ludHMpXG4gICAgICAgICAgICBpZiAocG9pbnQubm9kZSA9PSBub2RlKVxuICAgICAgICAgICAgICAgIHBvaW50LnBvcyA9IHRoaXMudGV4dC5sZW5ndGggKyBNYXRoLm1pbihwb2ludC5vZmZzZXQsIG1heExlbik7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNCbG9ja0VsZW1lbnQobm9kZSkge1xuICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09IDEgJiYgL14oRElWfFB8TEl8VUx8T0x8QkxPQ0tRVU9URXxERHxEVHxIXFxkfFNFQ1RJT058UFJFKSQvLnRlc3Qobm9kZS5ub2RlTmFtZSk7XG59XG5jbGFzcyBET01Qb2ludCB7XG4gICAgY29uc3RydWN0b3Iobm9kZSwgb2Zmc2V0KSB7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLnBvcyA9IC0xO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNlbGVjdGlvblBvaW50cyhkb20sIHJvb3QpIHtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgaWYgKHJvb3QuYWN0aXZlRWxlbWVudCAhPSBkb20pXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgbGV0IHsgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0IH0gPSBnZXRTZWxlY3Rpb24ocm9vdCk7XG4gICAgaWYgKGFuY2hvck5vZGUpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobmV3IERPTVBvaW50KGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCkpO1xuICAgICAgICBpZiAoZm9jdXNOb2RlICE9IGFuY2hvck5vZGUgfHwgZm9jdXNPZmZzZXQgIT0gYW5jaG9yT2Zmc2V0KVxuICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IERPTVBvaW50KGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHNlbGVjdGlvbkZyb21Qb2ludHMocG9pbnRzLCBiYXNlKSB7XG4gICAgaWYgKHBvaW50cy5sZW5ndGggPT0gMClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGFuY2hvciA9IHBvaW50c1swXS5wb3MsIGhlYWQgPSBwb2ludHMubGVuZ3RoID09IDIgPyBwb2ludHNbMV0ucG9zIDogYW5jaG9yO1xuICAgIHJldHVybiBhbmNob3IgPiAtMSAmJiBoZWFkID4gLTEgPyBzdGF0ZS5FZGl0b3JTZWxlY3Rpb24uc2luZ2xlKGFuY2hvciArIGJhc2UsIGhlYWQgKyBiYXNlKSA6IG51bGw7XG59XG5mdW5jdGlvbiBkaXNwYXRjaEtleSh2aWV3LCBuYW1lLCBjb2RlKSB7XG4gICAgbGV0IG9wdGlvbnMgPSB7IGtleTogbmFtZSwgY29kZTogbmFtZSwga2V5Q29kZTogY29kZSwgd2hpY2g6IGNvZGUsIGNhbmNlbGFibGU6IHRydWUgfTtcbiAgICBsZXQgZG93biA9IG5ldyBLZXlib2FyZEV2ZW50KFwia2V5ZG93blwiLCBvcHRpb25zKTtcbiAgICBkb3duLnN5bnRoZXRpYyA9IHRydWU7XG4gICAgdmlldy5jb250ZW50RE9NLmRpc3BhdGNoRXZlbnQoZG93bik7XG4gICAgbGV0IHVwID0gbmV3IEtleWJvYXJkRXZlbnQoXCJrZXl1cFwiLCBvcHRpb25zKTtcbiAgICB1cC5zeW50aGV0aWMgPSB0cnVlO1xuICAgIHZpZXcuY29udGVudERPTS5kaXNwYXRjaEV2ZW50KHVwKTtcbiAgICByZXR1cm4gZG93bi5kZWZhdWx0UHJldmVudGVkIHx8IHVwLmRlZmF1bHRQcmV2ZW50ZWQ7XG59XG5cbi8vIFRoZSBlZGl0b3IncyB1cGRhdGUgc3RhdGUgbWFjaGluZSBsb29rcyBzb21ldGhpbmcgbGlrZSB0aGlzOlxuLy9cbi8vICAgICBJZGxlIOKGkiBVcGRhdGluZyDih4YgSWRsZSAodW5jaGVja2VkKSDihpIgTWVhc3VyaW5nIOKGkiBJZGxlXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4oaRICAgICAg4oaTXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVXBkYXRpbmcgKG1lYXN1cmUpXG4vL1xuLy8gVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiAnSWRsZScgYW5kICdJZGxlICh1bmNoZWNrZWQpJyBsaWVzIGluXG4vLyB3aGV0aGVyIGEgbGF5b3V0IGNoZWNrIGhhcyBiZWVuIHNjaGVkdWxlZC4gQSByZWd1bGFyIHVwZGF0ZSB0aHJvdWdoXG4vLyB0aGUgYHVwZGF0ZWAgbWV0aG9kIHVwZGF0ZXMgdGhlIERPTSBpbiBhIHdyaXRlLW9ubHkgZmFzaGlvbiwgYW5kXG4vLyByZWxpZXMgb24gYSBjaGVjayAoc2NoZWR1bGVkIHdpdGggYHJlcXVlc3RBbmltYXRpb25GcmFtZWApIHRvIG1ha2Vcbi8vIHN1cmUgZXZlcnl0aGluZyBpcyB3aGVyZSBpdCBzaG91bGQgYmUgYW5kIHRoZSB2aWV3cG9ydCBjb3ZlcnMgdGhlXG4vLyB2aXNpYmxlIGNvZGUuIFRoYXQgY2hlY2sgY29udGludWVzIHRvIG1lYXN1cmUgYW5kIHRoZW4gb3B0aW9uYWxseVxuLy8gdXBkYXRlIHVudGlsIGl0IHJlYWNoZXMgYSBjb2hlcmVudCBzdGF0ZS5cbi8qKlxuQW4gZWRpdG9yIHZpZXcgcmVwcmVzZW50cyB0aGUgZWRpdG9yJ3MgdXNlciBpbnRlcmZhY2UuIEl0IGhvbGRzXG50aGUgZWRpdGFibGUgRE9NIHN1cmZhY2UsIGFuZCBwb3NzaWJseSBvdGhlciBlbGVtZW50cyBzdWNoIGFzIHRoZVxubGluZSBudW1iZXIgZ3V0dGVyLiBJdCBoYW5kbGVzIGV2ZW50cyBhbmQgZGlzcGF0Y2hlcyBzdGF0ZVxudHJhbnNhY3Rpb25zIGZvciBlZGl0aW5nIGFjdGlvbnMuXG4qL1xuY2xhc3MgRWRpdG9yVmlldyB7XG4gICAgLyoqXG4gICAgQ29uc3RydWN0IGEgbmV3IHZpZXcuIFlvdSdsbCB1c3VhbGx5IHdhbnQgdG8gcHV0IGB2aWV3LmRvbWAgaW50b1xuICAgIHlvdXIgZG9jdW1lbnQgYWZ0ZXIgY3JlYXRpbmcgYSB2aWV3LCBzbyB0aGF0IHRoZSB1c2VyIGNhbiBzZWVcbiAgICBpdC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEluaXRpYWxpemF0aW9uIG9wdGlvbnMuXG4gICAgKi9cbiAgICBjb25maWcgPSB7fSkge1xuICAgICAgICB0aGlzLnBsdWdpbnMgPSBbXTtcbiAgICAgICAgdGhpcy5lZGl0b3JBdHRycyA9IHt9O1xuICAgICAgICB0aGlzLmNvbnRlbnRBdHRycyA9IHt9O1xuICAgICAgICB0aGlzLmJpZGlDYWNoZSA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAyIC8qIFVwZGF0aW5nICovO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubWVhc3VyZVNjaGVkdWxlZCA9IC0xO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubWVhc3VyZVJlcXVlc3RzID0gW107XG4gICAgICAgIHRoaXMuY29udGVudERPTSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuc2Nyb2xsRE9NID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5zY3JvbGxET00udGFiSW5kZXggPSAtMTtcbiAgICAgICAgdGhpcy5zY3JvbGxET00uY2xhc3NOYW1lID0gXCJjbS1zY3JvbGxlclwiO1xuICAgICAgICB0aGlzLnNjcm9sbERPTS5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRET00pO1xuICAgICAgICB0aGlzLmFubm91bmNlRE9NID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5hbm5vdW5jZURPTS5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogLTEwMDAwcHhcIjtcbiAgICAgICAgdGhpcy5hbm5vdW5jZURPTS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxpdmVcIiwgXCJwb2xpdGVcIik7XG4gICAgICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQodGhpcy5hbm5vdW5jZURPTSk7XG4gICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKHRoaXMuc2Nyb2xsRE9NKTtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2ggPSBjb25maWcuZGlzcGF0Y2ggfHwgKCh0cikgPT4gdGhpcy51cGRhdGUoW3RyXSkpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoID0gdGhpcy5kaXNwYXRjaC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJvb3QgPSAoY29uZmlnLnJvb3QgfHwgZG9jdW1lbnQpO1xuICAgICAgICB0aGlzLnZpZXdTdGF0ZSA9IG5ldyBWaWV3U3RhdGUoY29uZmlnLnN0YXRlIHx8IHN0YXRlLkVkaXRvclN0YXRlLmNyZWF0ZSgpKTtcbiAgICAgICAgdGhpcy5wbHVnaW5zID0gdGhpcy5zdGF0ZS5mYWNldCh2aWV3UGx1Z2luKS5tYXAoc3BlYyA9PiBuZXcgUGx1Z2luSW5zdGFuY2Uoc3BlYykudXBkYXRlKHRoaXMpKTtcbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IG5ldyBET01PYnNlcnZlcih0aGlzLCAoZnJvbSwgdG8sIHR5cGVPdmVyKSA9PiB7XG4gICAgICAgICAgICBhcHBseURPTUNoYW5nZSh0aGlzLCBmcm9tLCB0bywgdHlwZU92ZXIpO1xuICAgICAgICB9LCBldmVudCA9PiB7XG4gICAgICAgICAgICB0aGlzLmlucHV0U3RhdGUucnVuU2Nyb2xsSGFuZGxlcnModGhpcywgZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5tZWFzdXJlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmlucHV0U3RhdGUgPSBuZXcgSW5wdXRTdGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5kb2NWaWV3ID0gbmV3IERvY1ZpZXcodGhpcyk7XG4gICAgICAgIHRoaXMubW91bnRTdHlsZXMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVBdHRycygpO1xuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMCAvKiBJZGxlICovO1xuICAgICAgICBlbnN1cmVHbG9iYWxIYW5kbGVyKCk7XG4gICAgICAgIHRoaXMucmVxdWVzdE1lYXN1cmUoKTtcbiAgICAgICAgaWYgKGNvbmZpZy5wYXJlbnQpXG4gICAgICAgICAgICBjb25maWcucGFyZW50LmFwcGVuZENoaWxkKHRoaXMuZG9tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGN1cnJlbnQgZWRpdG9yIHN0YXRlLlxuICAgICovXG4gICAgZ2V0IHN0YXRlKCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUuc3RhdGU7IH1cbiAgICAvKipcbiAgICBUbyBiZSBhYmxlIHRvIGRpc3BsYXkgbGFyZ2UgZG9jdW1lbnRzIHdpdGhvdXQgY29uc3VtaW5nIHRvbyBtdWNoXG4gICAgbWVtb3J5IG9yIG92ZXJsb2FkaW5nIHRoZSBicm93c2VyLCBDb2RlTWlycm9yIG9ubHkgZHJhd3MgdGhlXG4gICAgY29kZSB0aGF0IGlzIHZpc2libGUgKHBsdXMgYSBtYXJnaW4gYXJvdW5kIGl0KSB0byB0aGUgRE9NLiBUaGlzXG4gICAgcHJvcGVydHkgdGVsbHMgeW91IHRoZSBleHRlbnQgb2YgdGhlIGN1cnJlbnQgZHJhd24gdmlld3BvcnQsIGluXG4gICAgZG9jdW1lbnQgcG9zaXRpb25zLlxuICAgICovXG4gICAgZ2V0IHZpZXdwb3J0KCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUudmlld3BvcnQ7IH1cbiAgICAvKipcbiAgICBXaGVuIHRoZXJlIGFyZSwgZm9yIGV4YW1wbGUsIGxhcmdlIGNvbGxhcHNlZCByYW5nZXMgaW4gdGhlXG4gICAgdmlld3BvcnQsIGl0cyBzaXplIGNhbiBiZSBhIGxvdCBiaWdnZXIgdGhhbiB0aGUgYWN0dWFsIHZpc2libGVcbiAgICBjb250ZW50LiBUaHVzLCBpZiB5b3UgYXJlIGRvaW5nIHNvbWV0aGluZyBsaWtlIHN0eWxpbmcgdGhlXG4gICAgY29udGVudCBpbiB0aGUgdmlld3BvcnQsIGl0IGlzIHByZWZlcmFibGUgdG8gb25seSBkbyBzbyBmb3JcbiAgICB0aGVzZSByYW5nZXMsIHdoaWNoIGFyZSB0aGUgc3Vic2V0IG9mIHRoZSB2aWV3cG9ydCB0aGF0IGlzXG4gICAgYWN0dWFsbHkgZHJhd24uXG4gICAgKi9cbiAgICBnZXQgdmlzaWJsZVJhbmdlcygpIHsgcmV0dXJuIHRoaXMudmlld1N0YXRlLnZpc2libGVSYW5nZXM7IH1cbiAgICAvKipcbiAgICBSZXR1cm5zIGZhbHNlIHdoZW4gdGhlIGVkaXRvciBpcyBlbnRpcmVseSBzY3JvbGxlZCBvdXQgb2Ygdmlld1xuICAgIG9yIG90aGVyd2lzZSBoaWRkZW4uXG4gICAgKi9cbiAgICBnZXQgaW5WaWV3KCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUuaW5WaWV3OyB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHVzZXIgaXMgY3VycmVudGx5IGNvbXBvc2luZyB0ZXh0IHZpYVxuICAgIFtJTUVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvTW96aWxsYS9JTUVfaGFuZGxpbmdfZ3VpZGUpLlxuICAgICovXG4gICAgZ2V0IGNvbXBvc2luZygpIHsgcmV0dXJuIHRoaXMuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPiAwOyB9XG4gICAgZGlzcGF0Y2goLi4uaW5wdXQpIHtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2goaW5wdXQubGVuZ3RoID09IDEgJiYgaW5wdXRbMF0gaW5zdGFuY2VvZiBzdGF0ZS5UcmFuc2FjdGlvbiA/IGlucHV0WzBdXG4gICAgICAgICAgICA6IHRoaXMuc3RhdGUudXBkYXRlKC4uLmlucHV0KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFVwZGF0ZSB0aGUgdmlldyBmb3IgdGhlIGdpdmVuIGFycmF5IG9mIHRyYW5zYWN0aW9ucy4gVGhpcyB3aWxsXG4gICAgdXBkYXRlIHRoZSB2aXNpYmxlIGRvY3VtZW50IGFuZCBzZWxlY3Rpb24gdG8gbWF0Y2ggdGhlIHN0YXRlXG4gICAgcHJvZHVjZWQgYnkgdGhlIHRyYW5zYWN0aW9ucywgYW5kIG5vdGlmeSB2aWV3IHBsdWdpbnMgb2YgdGhlXG4gICAgY2hhbmdlLiBZb3Ugc2hvdWxkIHVzdWFsbHkgY2FsbFxuICAgIFtgZGlzcGF0Y2hgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5kaXNwYXRjaCkgaW5zdGVhZCwgd2hpY2ggdXNlcyB0aGlzXG4gICAgYXMgYSBwcmltaXRpdmUuXG4gICAgKi9cbiAgICB1cGRhdGUodHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLnVwZGF0ZVN0YXRlICE9IDAgLyogSWRsZSAqLylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbGxzIHRvIEVkaXRvclZpZXcudXBkYXRlIGFyZSBub3QgYWxsb3dlZCB3aGlsZSBhbiB1cGRhdGUgaXMgaW4gcHJvZ3Jlc3NcIik7XG4gICAgICAgIGxldCByZWRyYXduID0gZmFsc2UsIHVwZGF0ZTtcbiAgICAgICAgbGV0IHN0YXRlJDEgPSB0aGlzLnN0YXRlO1xuICAgICAgICBmb3IgKGxldCB0ciBvZiB0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICh0ci5zdGFydFN0YXRlICE9IHN0YXRlJDEpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUcnlpbmcgdG8gdXBkYXRlIHN0YXRlIHdpdGggYSB0cmFuc2FjdGlvbiB0aGF0IGRvZXNuJ3Qgc3RhcnQgZnJvbSB0aGUgcHJldmlvdXMgc3RhdGUuXCIpO1xuICAgICAgICAgICAgc3RhdGUkMSA9IHRyLnN0YXRlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdoZW4gdGhlIHBocmFzZXMgY2hhbmdlLCByZWRyYXcgdGhlIGVkaXRvclxuICAgICAgICBpZiAoc3RhdGUkMS5mYWNldChzdGF0ZS5FZGl0b3JTdGF0ZS5waHJhc2VzKSAhPSB0aGlzLnN0YXRlLmZhY2V0KHN0YXRlLkVkaXRvclN0YXRlLnBocmFzZXMpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0U3RhdGUoc3RhdGUkMSk7XG4gICAgICAgIHVwZGF0ZSA9IG5ldyBWaWV3VXBkYXRlKHRoaXMsIHN0YXRlJDEsIHRyYW5zYWN0aW9ucyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMiAvKiBVcGRhdGluZyAqLztcbiAgICAgICAgICAgIGxldCBzY3JvbGxUbyA9IHRyYW5zYWN0aW9ucy5zb21lKHRyID0+IHRyLnNjcm9sbEludG9WaWV3KSA/IHN0YXRlJDEuc2VsZWN0aW9uLm1haW4gOiBudWxsO1xuICAgICAgICAgICAgdGhpcy52aWV3U3RhdGUudXBkYXRlKHVwZGF0ZSwgc2Nyb2xsVG8pO1xuICAgICAgICAgICAgdGhpcy5iaWRpQ2FjaGUgPSBDYWNoZWRPcmRlci51cGRhdGUodGhpcy5iaWRpQ2FjaGUsIHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICAgICAgICAgIGlmICghdXBkYXRlLmVtcHR5KVxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUGx1Z2lucyh1cGRhdGUpO1xuICAgICAgICAgICAgcmVkcmF3biA9IHRoaXMuZG9jVmlldy51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmZhY2V0KHN0eWxlTW9kdWxlKSAhPSB0aGlzLnN0eWxlTW9kdWxlcylcbiAgICAgICAgICAgICAgICB0aGlzLm1vdW50U3R5bGVzKCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUF0dHJzKCk7XG4gICAgICAgICAgICB0aGlzLnNob3dBbm5vdW5jZW1lbnRzKHRyYW5zYWN0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMCAvKiBJZGxlICovO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWRyYXduIHx8IHNjcm9sbFRvIHx8IHRoaXMudmlld1N0YXRlLm11c3RFbmZvcmNlQ3Vyc29yQXNzb2MpXG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RNZWFzdXJlKCk7XG4gICAgICAgIGlmICghdXBkYXRlLmVtcHR5KVxuICAgICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5zdGF0ZS5mYWNldCh1cGRhdGVMaXN0ZW5lcikpXG4gICAgICAgICAgICAgICAgbGlzdGVuZXIodXBkYXRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVzZXQgdGhlIHZpZXcgdG8gdGhlIGdpdmVuIHN0YXRlLiAoVGhpcyB3aWxsIGNhdXNlIHRoZSBlbnRpcmVcbiAgICBkb2N1bWVudCB0byBiZSByZWRyYXduIGFuZCBhbGwgdmlldyBwbHVnaW5zIHRvIGJlIHJlaW5pdGlhbGl6ZWQsXG4gICAgc28geW91IHNob3VsZCBwcm9iYWJseSBvbmx5IHVzZSBpdCB3aGVuIHRoZSBuZXcgc3RhdGUgaXNuJ3RcbiAgICBkZXJpdmVkIGZyb20gdGhlIG9sZCBzdGF0ZS4gT3RoZXJ3aXNlLCB1c2VcbiAgICBbYGRpc3BhdGNoYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuZGlzcGF0Y2gpIGluc3RlYWQuKVxuICAgICovXG4gICAgc2V0U3RhdGUobmV3U3RhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMudXBkYXRlU3RhdGUgIT0gMCAvKiBJZGxlICovKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbHMgdG8gRWRpdG9yVmlldy5zZXRTdGF0ZSBhcmUgbm90IGFsbG93ZWQgd2hpbGUgYW4gdXBkYXRlIGlzIGluIHByb2dyZXNzXCIpO1xuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMiAvKiBVcGRhdGluZyAqLztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAobGV0IHBsdWdpbiBvZiB0aGlzLnBsdWdpbnMpXG4gICAgICAgICAgICAgICAgcGx1Z2luLmRlc3Ryb3kodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnZpZXdTdGF0ZSA9IG5ldyBWaWV3U3RhdGUobmV3U3RhdGUpO1xuICAgICAgICAgICAgdGhpcy5wbHVnaW5zID0gbmV3U3RhdGUuZmFjZXQodmlld1BsdWdpbikubWFwKHNwZWMgPT4gbmV3IFBsdWdpbkluc3RhbmNlKHNwZWMpLnVwZGF0ZSh0aGlzKSk7XG4gICAgICAgICAgICB0aGlzLmRvY1ZpZXcgPSBuZXcgRG9jVmlldyh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRTdGF0ZS5lbnN1cmVIYW5kbGVycyh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMubW91bnRTdHlsZXMoKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQXR0cnMoKTtcbiAgICAgICAgICAgIHRoaXMuYmlkaUNhY2hlID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMCAvKiBJZGxlICovO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVxdWVzdE1lYXN1cmUoKTtcbiAgICB9XG4gICAgdXBkYXRlUGx1Z2lucyh1cGRhdGUpIHtcbiAgICAgICAgbGV0IHByZXZTcGVjcyA9IHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KHZpZXdQbHVnaW4pLCBzcGVjcyA9IHVwZGF0ZS5zdGF0ZS5mYWNldCh2aWV3UGx1Z2luKTtcbiAgICAgICAgaWYgKHByZXZTcGVjcyAhPSBzcGVjcykge1xuICAgICAgICAgICAgbGV0IG5ld1BsdWdpbnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IHNwZWMgb2Ygc3BlY3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBwcmV2U3BlY3MuaW5kZXhPZihzcGVjKTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1BsdWdpbnMucHVzaChuZXcgUGx1Z2luSW5zdGFuY2Uoc3BlYykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBsdWdpbiA9IHRoaXMucGx1Z2luc1tmb3VuZF07XG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbi5tdXN0VXBkYXRlID0gdXBkYXRlO1xuICAgICAgICAgICAgICAgICAgICBuZXdQbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBwbHVnaW4gb2YgdGhpcy5wbHVnaW5zKVxuICAgICAgICAgICAgICAgIGlmIChwbHVnaW4ubXVzdFVwZGF0ZSAhPSB1cGRhdGUpXG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbi5kZXN0cm95KHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5wbHVnaW5zID0gbmV3UGx1Z2lucztcbiAgICAgICAgICAgIHRoaXMuaW5wdXRTdGF0ZS5lbnN1cmVIYW5kbGVycyh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IHAgb2YgdGhpcy5wbHVnaW5zKVxuICAgICAgICAgICAgICAgIHAubXVzdFVwZGF0ZSA9IHVwZGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGx1Z2lucy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRoaXMucGx1Z2luc1tpXSA9IHRoaXMucGx1Z2luc1tpXS51cGRhdGUodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbWVhc3VyZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubWVhc3VyZVNjaGVkdWxlZCA+IC0xKVxuICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5tZWFzdXJlU2NoZWR1bGVkKTtcbiAgICAgICAgdGhpcy5tZWFzdXJlU2NoZWR1bGVkID0gLTE7IC8vIFByZXZlbnQgcmVxdWVzdE1lYXN1cmUgY2FsbHMgZnJvbSBzY2hlZHVsaW5nIGFub3RoZXIgYW5pbWF0aW9uIGZyYW1lXG4gICAgICAgIGxldCB1cGRhdGVkID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDEgLyogTWVhc3VyaW5nICovO1xuICAgICAgICAgICAgICAgIGxldCBjaGFuZ2VkID0gdGhpcy52aWV3U3RhdGUubWVhc3VyZSh0aGlzLmRvY1ZpZXcsIGkgPiAwKTtcbiAgICAgICAgICAgICAgICBsZXQgbWVhc3VyaW5nID0gdGhpcy5tZWFzdXJlUmVxdWVzdHM7XG4gICAgICAgICAgICAgICAgaWYgKCFjaGFuZ2VkICYmICFtZWFzdXJpbmcubGVuZ3RoICYmIHRoaXMudmlld1N0YXRlLnNjcm9sbFRvID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHRoaXMubWVhc3VyZVJlcXVlc3RzID0gW107XG4gICAgICAgICAgICAgICAgaWYgKGkgPiA1KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlZpZXdwb3J0IGZhaWxlZCB0byBzdGFiaWxpemVcIik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgbWVhc3VyZWQgPSBtZWFzdXJpbmcubWFwKG0gPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG0ucmVhZCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nRXhjZXB0aW9uKHRoaXMuc3RhdGUsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJhZE1lYXN1cmU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsZXQgdXBkYXRlID0gbmV3IFZpZXdVcGRhdGUodGhpcywgdGhpcy5zdGF0ZSk7XG4gICAgICAgICAgICAgICAgdXBkYXRlLmZsYWdzIHw9IGNoYW5nZWQ7XG4gICAgICAgICAgICAgICAgaWYgKCF1cGRhdGVkKVxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkID0gdXBkYXRlO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZC5mbGFncyB8PSBjaGFuZ2VkO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAyIC8qIFVwZGF0aW5nICovO1xuICAgICAgICAgICAgICAgIGlmICghdXBkYXRlLmVtcHR5KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVBsdWdpbnModXBkYXRlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUF0dHJzKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZWQpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jVmlldy51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lYXN1cmluZy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lYXN1cmVkW2ldICE9IEJhZE1lYXN1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVhc3VyaW5nW2ldLndyaXRlKG1lYXN1cmVkW2ldLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nRXhjZXB0aW9uKHRoaXMuc3RhdGUsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmlld1N0YXRlLnNjcm9sbFRvKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jVmlldy5zY3JvbGxQb3NJbnRvVmlldyh0aGlzLnZpZXdTdGF0ZS5zY3JvbGxUby5oZWFkLCB0aGlzLnZpZXdTdGF0ZS5zY3JvbGxUby5hc3NvYyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld1N0YXRlLnNjcm9sbFRvID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCEoY2hhbmdlZCAmIDQgLyogVmlld3BvcnQgKi8pICYmIHRoaXMubWVhc3VyZVJlcXVlc3RzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAwIC8qIElkbGUgKi87XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZWFzdXJlU2NoZWR1bGVkID0gLTE7XG4gICAgICAgIGlmICh1cGRhdGVkICYmICF1cGRhdGVkLmVtcHR5KVxuICAgICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5zdGF0ZS5mYWNldCh1cGRhdGVMaXN0ZW5lcikpXG4gICAgICAgICAgICAgICAgbGlzdGVuZXIodXBkYXRlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgQ1NTIGNsYXNzZXMgZm9yIHRoZSBjdXJyZW50bHkgYWN0aXZlIGVkaXRvciB0aGVtZXMuXG4gICAgKi9cbiAgICBnZXQgdGhlbWVDbGFzc2VzKCkge1xuICAgICAgICByZXR1cm4gYmFzZVRoZW1lSUQgKyBcIiBcIiArXG4gICAgICAgICAgICAodGhpcy5zdGF0ZS5mYWNldChkYXJrVGhlbWUpID8gYmFzZURhcmtJRCA6IGJhc2VMaWdodElEKSArIFwiIFwiICtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuZmFjZXQodGhlbWUpO1xuICAgIH1cbiAgICB1cGRhdGVBdHRycygpIHtcbiAgICAgICAgbGV0IGVkaXRvckF0dHJzID0gY29tYmluZUF0dHJzKHRoaXMuc3RhdGUuZmFjZXQoZWRpdG9yQXR0cmlidXRlcyksIHtcbiAgICAgICAgICAgIC8vIEZJWE1FIGRyb3AgY20td3JhcCBpbiBuZXh0IG1ham9yIHJlbGVhc2VcbiAgICAgICAgICAgIGNsYXNzOiBcImNtLWVkaXRvciBjbS13cmFwXCIgKyAodGhpcy5oYXNGb2N1cyA/IFwiIGNtLWZvY3VzZWQgXCIgOiBcIiBcIikgKyB0aGlzLnRoZW1lQ2xhc3Nlc1xuICAgICAgICB9KTtcbiAgICAgICAgdXBkYXRlQXR0cnModGhpcy5kb20sIHRoaXMuZWRpdG9yQXR0cnMsIGVkaXRvckF0dHJzKTtcbiAgICAgICAgdGhpcy5lZGl0b3JBdHRycyA9IGVkaXRvckF0dHJzO1xuICAgICAgICBsZXQgY29udGVudEF0dHJzID0gY29tYmluZUF0dHJzKHRoaXMuc3RhdGUuZmFjZXQoY29udGVudEF0dHJpYnV0ZXMpLCB7XG4gICAgICAgICAgICBzcGVsbGNoZWNrOiBcImZhbHNlXCIsXG4gICAgICAgICAgICBjb250ZW50ZWRpdGFibGU6IFN0cmluZyh0aGlzLnN0YXRlLmZhY2V0KGVkaXRhYmxlKSksXG4gICAgICAgICAgICBjbGFzczogXCJjbS1jb250ZW50XCIsXG4gICAgICAgICAgICBzdHlsZTogYCR7YnJvd3Nlci50YWJTaXplfTogJHt0aGlzLnN0YXRlLnRhYlNpemV9YCxcbiAgICAgICAgICAgIHJvbGU6IFwidGV4dGJveFwiLFxuICAgICAgICAgICAgXCJhcmlhLW11bHRpbGluZVwiOiBcInRydWVcIlxuICAgICAgICB9KTtcbiAgICAgICAgdXBkYXRlQXR0cnModGhpcy5jb250ZW50RE9NLCB0aGlzLmNvbnRlbnRBdHRycywgY29udGVudEF0dHJzKTtcbiAgICAgICAgdGhpcy5jb250ZW50QXR0cnMgPSBjb250ZW50QXR0cnM7XG4gICAgfVxuICAgIHNob3dBbm5vdW5jZW1lbnRzKHRycykge1xuICAgICAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCB0ciBvZiB0cnMpXG4gICAgICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cylcbiAgICAgICAgICAgICAgICBpZiAoZWZmZWN0LmlzKEVkaXRvclZpZXcuYW5ub3VuY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYW5ub3VuY2VET00udGV4dENvbnRlbnQgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGl2ID0gdGhpcy5hbm5vdW5jZURPTS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgICAgICAgICAgICAgICAgICAgZGl2LnRleHRDb250ZW50ID0gZWZmZWN0LnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICB9XG4gICAgbW91bnRTdHlsZXMoKSB7XG4gICAgICAgIHRoaXMuc3R5bGVNb2R1bGVzID0gdGhpcy5zdGF0ZS5mYWNldChzdHlsZU1vZHVsZSk7XG4gICAgICAgIHN0eWxlTW9kLlN0eWxlTW9kdWxlLm1vdW50KHRoaXMucm9vdCwgdGhpcy5zdHlsZU1vZHVsZXMuY29uY2F0KGJhc2VUaGVtZSkucmV2ZXJzZSgpKTtcbiAgICB9XG4gICAgcmVhZE1lYXN1cmVkKCkge1xuICAgICAgICBpZiAodGhpcy51cGRhdGVTdGF0ZSA9PSAyIC8qIFVwZGF0aW5nICovKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVhZGluZyB0aGUgZWRpdG9yIGxheW91dCBpc24ndCBhbGxvd2VkIGR1cmluZyBhbiB1cGRhdGVcIik7XG4gICAgICAgIGlmICh0aGlzLnVwZGF0ZVN0YXRlID09IDAgLyogSWRsZSAqLyAmJiB0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPiAtMSlcbiAgICAgICAgICAgIHRoaXMubWVhc3VyZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICBNYWtlIHN1cmUgcGx1Z2lucyBnZXQgYSBjaGFuY2UgdG8gbWVhc3VyZSB0aGUgRE9NIGxheW91dCBiZWZvcmVcbiAgICB0aGUgbmV4dCBmcmFtZS4gQ2FsbGluZyB0aGlzIGlzIHByZWZlcmFibGUgcmVhZGluZyBET00gbGF5b3V0XG4gICAgZGlyZWN0bHkgZnJvbSwgZm9yIGV4YW1wbGUsIGFuIGV2ZW50IGhhbmRsZXIsIGJlY2F1c2UgaXQnbGwgbWFrZVxuICAgIHN1cmUgbWVhc3VyaW5nIGFuZCBkcmF3aW5nIGRvbmUgYnkgb3RoZXIgY29tcG9uZW50cyBpc1xuICAgIHN5bmNocm9uaXplZCwgYXZvaWRpbmcgdW5uZWNlc3NhcnkgRE9NIGxheW91dCBjb21wdXRhdGlvbnMuXG4gICAgKi9cbiAgICByZXF1ZXN0TWVhc3VyZShyZXF1ZXN0KSB7XG4gICAgICAgIGlmICh0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPCAwKVxuICAgICAgICAgICAgdGhpcy5tZWFzdXJlU2NoZWR1bGVkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMubWVhc3VyZSgpKTtcbiAgICAgICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0LmtleSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tZWFzdXJlUmVxdWVzdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWVhc3VyZVJlcXVlc3RzW2ldLmtleSA9PT0gcmVxdWVzdC5rZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWVhc3VyZVJlcXVlc3RzW2ldID0gcmVxdWVzdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubWVhc3VyZVJlcXVlc3RzLnB1c2gocmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQ29sbGVjdCBhbGwgdmFsdWVzIHByb3ZpZGVkIGJ5IHRoZSBhY3RpdmUgcGx1Z2lucyBmb3IgYSBnaXZlblxuICAgIGZpZWxkLlxuICAgICovXG4gICAgcGx1Z2luRmllbGQoZmllbGQpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwbHVnaW4gb2YgdGhpcy5wbHVnaW5zKVxuICAgICAgICAgICAgcGx1Z2luLnVwZGF0ZSh0aGlzKS50YWtlRmllbGQoZmllbGQsIHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgdmFsdWUgb2YgYSBzcGVjaWZpYyBwbHVnaW4sIGlmIHByZXNlbnQuIE5vdGUgdGhhdFxuICAgIHBsdWdpbnMgdGhhdCBjcmFzaCBjYW4gYmUgZHJvcHBlZCBmcm9tIGEgdmlldywgc28gZXZlbiB3aGVuIHlvdVxuICAgIGtub3cgeW91IHJlZ2lzdGVyZWQgYSBnaXZlbiBwbHVnaW4sIGl0IGlzIHJlY29tbWVuZGVkIHRvIGNoZWNrXG4gICAgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGlzIG1ldGhvZC5cbiAgICAqL1xuICAgIHBsdWdpbihwbHVnaW4pIHtcbiAgICAgICAgZm9yIChsZXQgaW5zdCBvZiB0aGlzLnBsdWdpbnMpXG4gICAgICAgICAgICBpZiAoaW5zdC5zcGVjID09IHBsdWdpbilcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdC51cGRhdGUodGhpcykudmFsdWU7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBsaW5lIG9yIGJsb2NrIHdpZGdldCBhdCB0aGUgZ2l2ZW4gdmVydGljYWwgcG9zaXRpb24uXG4gICAgXG4gICAgQnkgZGVmYXVsdCwgdGhpcyBwb3NpdGlvbiBpcyBpbnRlcnByZXRlZCBhcyBhIHNjcmVlbiBwb3NpdGlvbixcbiAgICBtZWFuaW5nIGBkb2NUb3BgIGlzIHNldCB0byB0aGUgRE9NIHRvcCBwb3NpdGlvbiBvZiB0aGUgZWRpdG9yXG4gICAgY29udGVudCAoZm9yY2luZyBhIGxheW91dCkuIFlvdSBjYW4gcGFzcyBhIGRpZmZlcmVudCBgZG9jVG9wYFxuICAgIHZhbHVl4oCUZm9yIGV4YW1wbGUgMCB0byBpbnRlcnByZXQgYGhlaWdodGAgYXMgYSBkb2N1bWVudC1yZWxhdGl2ZVxuICAgIHBvc2l0aW9uLCBvciBhIHByZWNvbXB1dGVkIGRvY3VtZW50IHRvcFxuICAgIChgdmlldy5jb250ZW50RE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcGApIHRvIGxpbWl0IGxheW91dFxuICAgIHF1ZXJpZXMuXG4gICAgKi9cbiAgICBibG9ja0F0SGVpZ2h0KGhlaWdodCwgZG9jVG9wKSB7XG4gICAgICAgIHRoaXMucmVhZE1lYXN1cmVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdTdGF0ZS5ibG9ja0F0SGVpZ2h0KGhlaWdodCwgZW5zdXJlVG9wKGRvY1RvcCwgdGhpcy5jb250ZW50RE9NKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgaW5mb3JtYXRpb24gZm9yIHRoZSB2aXN1YWwgbGluZSAoc2VlXG4gICAgW2B2aXN1YWxMaW5lQXRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy52aXN1YWxMaW5lQXQpKSBhdCB0aGUgZ2l2ZW5cbiAgICB2ZXJ0aWNhbCBwb3NpdGlvbi4gVGhlIHJlc3VsdGluZyBibG9jayBpbmZvIG1pZ2h0IGhvbGQgYW5vdGhlclxuICAgIGFycmF5IG9mIGJsb2NrIGluZm8gc3RydWN0cyBpbiBpdHMgYHR5cGVgIGZpZWxkIGlmIHRoaXMgbGluZVxuICAgIGNvbnNpc3RzIG9mIG1vcmUgdGhhbiBvbmUgYmxvY2suXG4gICAgXG4gICAgRGVmYXVsdHMgdG8gdHJlYXRpbmcgYGhlaWdodGAgYXMgYSBzY3JlZW4gcG9zaXRpb24uIFNlZVxuICAgIFtgYmxvY2tBdEhlaWdodGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmJsb2NrQXRIZWlnaHQpIGZvciB0aGVcbiAgICBpbnRlcnByZXRhdGlvbiBvZiB0aGUgYGRvY1RvcGAgcGFyYW1ldGVyLlxuICAgICovXG4gICAgdmlzdWFsTGluZUF0SGVpZ2h0KGhlaWdodCwgZG9jVG9wKSB7XG4gICAgICAgIHRoaXMucmVhZE1lYXN1cmVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdTdGF0ZS5saW5lQXRIZWlnaHQoaGVpZ2h0LCBlbnN1cmVUb3AoZG9jVG9wLCB0aGlzLmNvbnRlbnRET00pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHRoZSBoZWlnaHQgaW5mb3JtYXRpb24gb2YgdGhlIHZpc3VhbCBsaW5lcyBpbiB0aGVcbiAgICB2aWV3cG9ydC4gVGhlIGhlaWdodHMgb2YgbGluZXMgYXJlIHJlcG9ydGVkIHJlbGF0aXZlIHRvIHRoZVxuICAgIGdpdmVuIGRvY3VtZW50IHRvcCwgd2hpY2ggZGVmYXVsdHMgdG8gdGhlIHNjcmVlbiBwb3NpdGlvbiBvZiB0aGVcbiAgICBkb2N1bWVudCAoZm9yY2luZyBhIGxheW91dCkuXG4gICAgKi9cbiAgICB2aWV3cG9ydExpbmVzKGYsIGRvY1RvcCkge1xuICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gdGhpcy52aWV3cG9ydDtcbiAgICAgICAgdGhpcy52aWV3U3RhdGUuZm9yRWFjaExpbmUoZnJvbSwgdG8sIGYsIGVuc3VyZVRvcChkb2NUb3AsIHRoaXMuY29udGVudERPTSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBleHRlbnQgYW5kIGhlaWdodCBvZiB0aGUgdmlzdWFsIGxpbmUgKHRoZSBjb250ZW50IHNob3duXG4gICAgaW4gdGhlIGVkaXRvciBhcyBhIGxpbmUsIHdoaWNoIG1heSBiZSBzbWFsbGVyIHRoYW4gYSBkb2N1bWVudFxuICAgIGxpbmUgd2hlbiBicm9rZW4gdXAgYnkgYmxvY2sgd2lkZ2V0cywgb3IgYmlnZ2VyIHRoYW4gYSBkb2N1bWVudFxuICAgIGxpbmUgd2hlbiBsaW5lIGJyZWFrcyBhcmUgY292ZXJlZCBieSByZXBsYWNlZCBkZWNvcmF0aW9ucykgYXRcbiAgICB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgXG4gICAgVmVydGljYWwgcG9zaXRpb25zIGFyZSBjb21wdXRlZCByZWxhdGl2ZSB0byB0aGUgYGRvY1RvcGBcbiAgICBhcmd1bWVudCwgd2hpY2ggZGVmYXVsdHMgdG8gMCBmb3IgdGhpcyBtZXRob2QuIFlvdSBjYW4gcGFzc1xuICAgIGB2aWV3LmNvbnRlbnRET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wYCBoZXJlIHRvIGdldCBzY3JlZW5cbiAgICBjb29yZGluYXRlcy5cbiAgICAqL1xuICAgIHZpc3VhbExpbmVBdChwb3MsIGRvY1RvcCA9IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld1N0YXRlLmxpbmVBdChwb3MsIGRvY1RvcCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBlZGl0b3IncyB0b3RhbCBjb250ZW50IGhlaWdodC5cbiAgICAqL1xuICAgIGdldCBjb250ZW50SGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3U3RhdGUuY29udGVudEhlaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSBhIGN1cnNvciBwb3NpdGlvbiBieSBbZ3JhcGhlbWVcbiAgICBjbHVzdGVyXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3RleHQuZmluZENsdXN0ZXJCcmVhaykuIGBmb3J3YXJkYCBkZXRlcm1pbmVzIHdoZXRoZXJcbiAgICB0aGUgbW90aW9uIGlzIGF3YXkgZnJvbSB0aGUgbGluZSBzdGFydCwgb3IgdG93YXJkcyBpdC4gTW90aW9uIGluXG4gICAgYmlkaXJlY3Rpb25hbCB0ZXh0IGlzIGluIHZpc3VhbCBvcmRlciwgaW4gdGhlIGVkaXRvcidzIFt0ZXh0XG4gICAgZGlyZWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy50ZXh0RGlyZWN0aW9uKS4gV2hlbiB0aGUgc3RhcnRcbiAgICBwb3NpdGlvbiB3YXMgdGhlIGxhc3Qgb25lIG9uIHRoZSBsaW5lLCB0aGUgcmV0dXJuZWQgcG9zaXRpb25cbiAgICB3aWxsIGJlIGFjcm9zcyB0aGUgbGluZSBicmVhay4gSWYgdGhlcmUgaXMgbm8gZnVydGhlciBsaW5lLCB0aGVcbiAgICBvcmlnaW5hbCBwb3NpdGlvbiBpcyByZXR1cm5lZC5cbiAgICBcbiAgICBCeSBkZWZhdWx0LCB0aGlzIG1ldGhvZCBtb3ZlcyBvdmVyIGEgc2luZ2xlIGNsdXN0ZXIuIFRoZVxuICAgIG9wdGlvbmFsIGBieWAgYXJndW1lbnQgY2FuIGJlIHVzZWQgdG8gbW92ZSBhY3Jvc3MgbW9yZS4gSXQgd2lsbFxuICAgIGJlIGNhbGxlZCB3aXRoIHRoZSBmaXJzdCBjbHVzdGVyIGFzIGFyZ3VtZW50LCBhbmQgc2hvdWxkIHJldHVyblxuICAgIGEgcHJlZGljYXRlIHRoYXQgZGV0ZXJtaW5lcywgZm9yIGVhY2ggc3Vic2VxdWVudCBjbHVzdGVyLFxuICAgIHdoZXRoZXIgaXQgc2hvdWxkIGFsc28gYmUgbW92ZWQgb3Zlci5cbiAgICAqL1xuICAgIG1vdmVCeUNoYXIoc3RhcnQsIGZvcndhcmQsIGJ5KSB7XG4gICAgICAgIHJldHVybiBtb3ZlQnlDaGFyKHRoaXMsIHN0YXJ0LCBmb3J3YXJkLCBieSk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgYSBjdXJzb3IgcG9zaXRpb24gYWNyb3NzIHRoZSBuZXh0IGdyb3VwIG9mIGVpdGhlclxuICAgIFtsZXR0ZXJzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmNoYXJDYXRlZ29yaXplcikgb3Igbm9uLWxldHRlclxuICAgIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMuXG4gICAgKi9cbiAgICBtb3ZlQnlHcm91cChzdGFydCwgZm9yd2FyZCkge1xuICAgICAgICByZXR1cm4gbW92ZUJ5Q2hhcih0aGlzLCBzdGFydCwgZm9yd2FyZCwgaW5pdGlhbCA9PiBieUdyb3VwKHRoaXMsIHN0YXJ0LmhlYWQsIGluaXRpYWwpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSB0byB0aGUgbmV4dCBsaW5lIGJvdW5kYXJ5IGluIHRoZSBnaXZlbiBkaXJlY3Rpb24uIElmXG4gICAgYGluY2x1ZGVXcmFwYCBpcyB0cnVlLCBsaW5lIHdyYXBwaW5nIGlzIG9uLCBhbmQgdGhlcmUgaXMgYVxuICAgIGZ1cnRoZXIgd3JhcCBwb2ludCBvbiB0aGUgY3VycmVudCBsaW5lLCB0aGUgd3JhcCBwb2ludCB3aWxsIGJlXG4gICAgcmV0dXJuZWQuIE90aGVyd2lzZSB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSBzdGFydCBvciBlbmRcbiAgICBvZiB0aGUgbGluZS5cbiAgICAqL1xuICAgIG1vdmVUb0xpbmVCb3VuZGFyeShzdGFydCwgZm9yd2FyZCwgaW5jbHVkZVdyYXAgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBtb3ZlVG9MaW5lQm91bmRhcnkodGhpcywgc3RhcnQsIGZvcndhcmQsIGluY2x1ZGVXcmFwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSBhIGN1cnNvciBwb3NpdGlvbiB2ZXJ0aWNhbGx5LiBXaGVuIGBkaXN0YW5jZWAgaXNuJ3QgZ2l2ZW4sXG4gICAgaXQgZGVmYXVsdHMgdG8gbW92aW5nIHRvIHRoZSBuZXh0IGxpbmUgKGluY2x1ZGluZyB3cmFwcGVkXG4gICAgbGluZXMpLiBPdGhlcndpc2UsIGBkaXN0YW5jZWAgc2hvdWxkIHByb3ZpZGUgYSBwb3NpdGl2ZSBkaXN0YW5jZVxuICAgIGluIHBpeGVscy5cbiAgICBcbiAgICBXaGVuIGBzdGFydGAgaGFzIGFcbiAgICBbYGdvYWxDb2x1bW5gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlNlbGVjdGlvblJhbmdlLmdvYWxDb2x1bW4pLCB0aGUgdmVydGljYWxcbiAgICBtb3Rpb24gd2lsbCB1c2UgdGhhdCBhcyBhIHRhcmdldCBob3Jpem9udGFsIHBvc2l0aW9uLiBPdGhlcndpc2UsXG4gICAgdGhlIGN1cnNvcidzIG93biBob3Jpem9udGFsIHBvc2l0aW9uIGlzIHVzZWQuIFRoZSByZXR1cm5lZFxuICAgIGN1cnNvciB3aWxsIGhhdmUgaXRzIGdvYWwgY29sdW1uIHNldCB0byB3aGljaGV2ZXIgY29sdW1uIHdhc1xuICAgIHVzZWQuXG4gICAgKi9cbiAgICBtb3ZlVmVydGljYWxseShzdGFydCwgZm9yd2FyZCwgZGlzdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIG1vdmVWZXJ0aWNhbGx5KHRoaXMsIHN0YXJ0LCBmb3J3YXJkLCBkaXN0YW5jZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFNjcm9sbCB0aGUgZ2l2ZW4gZG9jdW1lbnQgcG9zaXRpb24gaW50byB2aWV3LlxuICAgICovXG4gICAgc2Nyb2xsUG9zSW50b1ZpZXcocG9zKSB7XG4gICAgICAgIHRoaXMudmlld1N0YXRlLnNjcm9sbFRvID0gc3RhdGUuRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MpO1xuICAgICAgICB0aGlzLnJlcXVlc3RNZWFzdXJlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIERPTSBwYXJlbnQgbm9kZSBhbmQgb2Zmc2V0IChjaGlsZCBvZmZzZXQgaWYgYG5vZGVgIGlzXG4gICAgYW4gZWxlbWVudCwgY2hhcmFjdGVyIG9mZnNldCB3aGVuIGl0IGlzIGEgdGV4dCBub2RlKSBhdCB0aGVcbiAgICBnaXZlbiBkb2N1bWVudCBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGRvbUF0UG9zKHBvcykge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2NWaWV3LmRvbUF0UG9zKHBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGRvY3VtZW50IHBvc2l0aW9uIGF0IHRoZSBnaXZlbiBET00gbm9kZS4gQ2FuIGJlIHVzZWZ1bFxuICAgIGZvciBhc3NvY2lhdGluZyBwb3NpdGlvbnMgd2l0aCBET00gZXZlbnRzLiBXaWxsIHJhaXNlIGFuIGVycm9yXG4gICAgd2hlbiBgbm9kZWAgaXNuJ3QgcGFydCBvZiB0aGUgZWRpdG9yIGNvbnRlbnQuXG4gICAgKi9cbiAgICBwb3NBdERPTShub2RlLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY1ZpZXcucG9zRnJvbURPTShub2RlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGRvY3VtZW50IHBvc2l0aW9uIGF0IHRoZSBnaXZlbiBzY3JlZW4gY29vcmRpbmF0ZXMuXG4gICAgUmV0dXJucyBudWxsIGlmIG5vIHZhbGlkIHBvc2l0aW9uIGNvdWxkIGJlIGZvdW5kLlxuICAgICovXG4gICAgcG9zQXRDb29yZHMoY29vcmRzKSB7XG4gICAgICAgIHRoaXMucmVhZE1lYXN1cmVkKCk7XG4gICAgICAgIHJldHVybiBwb3NBdENvb3Jkcyh0aGlzLCBjb29yZHMpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHNjcmVlbiBjb29yZGluYXRlcyBhdCB0aGUgZ2l2ZW4gZG9jdW1lbnQgcG9zaXRpb24uXG4gICAgYHNpZGVgIGRldGVybWluZXMgd2hldGhlciB0aGUgY29vcmRpbmF0ZXMgYXJlIGJhc2VkIG9uIHRoZVxuICAgIGVsZW1lbnQgYmVmb3JlICgtMSkgb3IgYWZ0ZXIgKDEpIHRoZSBwb3NpdGlvbiAoaWYgbm8gZWxlbWVudCBpc1xuICAgIGF2YWlsYWJsZSBvbiB0aGUgZ2l2ZW4gc2lkZSwgdGhlIG1ldGhvZCB3aWxsIHRyYW5zcGFyZW50bHkgdXNlXG4gICAgYW5vdGhlciBzdHJhdGVneSB0byBnZXQgcmVhc29uYWJsZSBjb29yZGluYXRlcykuXG4gICAgKi9cbiAgICBjb29yZHNBdFBvcyhwb3MsIHNpZGUgPSAxKSB7XG4gICAgICAgIHRoaXMucmVhZE1lYXN1cmVkKCk7XG4gICAgICAgIGxldCByZWN0ID0gdGhpcy5kb2NWaWV3LmNvb3Jkc0F0KHBvcywgc2lkZSk7XG4gICAgICAgIGlmICghcmVjdCB8fCByZWN0LmxlZnQgPT0gcmVjdC5yaWdodClcbiAgICAgICAgICAgIHJldHVybiByZWN0O1xuICAgICAgICBsZXQgbGluZSA9IHRoaXMuc3RhdGUuZG9jLmxpbmVBdChwb3MpLCBvcmRlciA9IHRoaXMuYmlkaVNwYW5zKGxpbmUpO1xuICAgICAgICBsZXQgc3BhbiA9IG9yZGVyW0JpZGlTcGFuLmZpbmQob3JkZXIsIHBvcyAtIGxpbmUuZnJvbSwgLTEsIHNpZGUpXTtcbiAgICAgICAgcmV0dXJuIGZsYXR0ZW5SZWN0KHJlY3QsIChzcGFuLmRpciA9PSBleHBvcnRzLkRpcmVjdGlvbi5MVFIpID09IChzaWRlID4gMCkpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgZGVmYXVsdCB3aWR0aCBvZiBhIGNoYXJhY3RlciBpbiB0aGUgZWRpdG9yLiBNYXkgbm90XG4gICAgYWNjdXJhdGVseSByZWZsZWN0IHRoZSB3aWR0aCBvZiBhbGwgY2hhcmFjdGVycyAoZ2l2ZW4gdmFyaWFibGVcbiAgICB3aWR0aCBmb250cyBvciBzdHlsaW5nIG9mIGludmlkaWR1YWwgcmFuZ2VzKS5cbiAgICAqL1xuICAgIGdldCBkZWZhdWx0Q2hhcmFjdGVyV2lkdGgoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5oZWlnaHRPcmFjbGUuY2hhcldpZHRoOyB9XG4gICAgLyoqXG4gICAgVGhlIGRlZmF1bHQgaGVpZ2h0IG9mIGEgbGluZSBpbiB0aGUgZWRpdG9yLiBNYXkgbm90IGJlIGFjY3VyYXRlXG4gICAgZm9yIGFsbCBsaW5lcy5cbiAgICAqL1xuICAgIGdldCBkZWZhdWx0TGluZUhlaWdodCgpIHsgcmV0dXJuIHRoaXMudmlld1N0YXRlLmhlaWdodE9yYWNsZS5saW5lSGVpZ2h0OyB9XG4gICAgLyoqXG4gICAgVGhlIHRleHQgZGlyZWN0aW9uXG4gICAgKFtgZGlyZWN0aW9uYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2RpcmVjdGlvbilcbiAgICBDU1MgcHJvcGVydHkpIG9mIHRoZSBlZGl0b3IuXG4gICAgKi9cbiAgICBnZXQgdGV4dERpcmVjdGlvbigpIHsgcmV0dXJuIHRoaXMudmlld1N0YXRlLmhlaWdodE9yYWNsZS5kaXJlY3Rpb247IH1cbiAgICAvKipcbiAgICBXaGV0aGVyIHRoaXMgZWRpdG9yIFt3cmFwcyBsaW5lc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcubGluZVdyYXBwaW5nKVxuICAgIChhcyBkZXRlcm1pbmVkIGJ5IHRoZVxuICAgIFtgd2hpdGUtc3BhY2VgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1Mvd2hpdGUtc3BhY2UpXG4gICAgQ1NTIHByb3BlcnR5IG9mIGl0cyBjb250ZW50IGVsZW1lbnQpLlxuICAgICovXG4gICAgZ2V0IGxpbmVXcmFwcGluZygpIHsgcmV0dXJuIHRoaXMudmlld1N0YXRlLmhlaWdodE9yYWNsZS5saW5lV3JhcHBpbmc7IH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRoZSBiaWRpcmVjdGlvbmFsIHRleHQgc3RydWN0dXJlIG9mIHRoZSBnaXZlbiBsaW5lXG4gICAgKHdoaWNoIHNob3VsZCBiZSBpbiB0aGUgY3VycmVudCBkb2N1bWVudCkgYXMgYW4gYXJyYXkgb2Ygc3BhblxuICAgIG9iamVjdHMuIFRoZSBvcmRlciBvZiB0aGVzZSBzcGFucyBtYXRjaGVzIHRoZSBbdGV4dFxuICAgIGRpcmVjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcudGV4dERpcmVjdGlvbinigJRpZiB0aGF0IGlzXG4gICAgbGVmdC10by1yaWdodCwgdGhlIGxlZnRtb3N0IHNwYW5zIGNvbWUgZmlyc3QsIG90aGVyd2lzZSB0aGVcbiAgICByaWdodG1vc3Qgc3BhbnMgY29tZSBmaXJzdC5cbiAgICAqL1xuICAgIGJpZGlTcGFucyhsaW5lKSB7XG4gICAgICAgIGlmIChsaW5lLmxlbmd0aCA+IE1heEJpZGlMaW5lKVxuICAgICAgICAgICAgcmV0dXJuIHRyaXZpYWxPcmRlcihsaW5lLmxlbmd0aCk7XG4gICAgICAgIGxldCBkaXIgPSB0aGlzLnRleHREaXJlY3Rpb247XG4gICAgICAgIGZvciAobGV0IGVudHJ5IG9mIHRoaXMuYmlkaUNhY2hlKVxuICAgICAgICAgICAgaWYgKGVudHJ5LmZyb20gPT0gbGluZS5mcm9tICYmIGVudHJ5LmRpciA9PSBkaXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5Lm9yZGVyO1xuICAgICAgICBsZXQgb3JkZXIgPSBjb21wdXRlT3JkZXIobGluZS50ZXh0LCB0aGlzLnRleHREaXJlY3Rpb24pO1xuICAgICAgICB0aGlzLmJpZGlDYWNoZS5wdXNoKG5ldyBDYWNoZWRPcmRlcihsaW5lLmZyb20sIGxpbmUudG8sIGRpciwgb3JkZXIpKTtcbiAgICAgICAgcmV0dXJuIG9yZGVyO1xuICAgIH1cbiAgICAvKipcbiAgICBDaGVjayB3aGV0aGVyIHRoZSBlZGl0b3IgaGFzIGZvY3VzLlxuICAgICovXG4gICAgZ2V0IGhhc0ZvY3VzKCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuaGFzRm9jdXMoKSAmJiB0aGlzLnJvb3QuYWN0aXZlRWxlbWVudCA9PSB0aGlzLmNvbnRlbnRET007XG4gICAgfVxuICAgIC8qKlxuICAgIFB1dCBmb2N1cyBvbiB0aGUgZWRpdG9yLlxuICAgICovXG4gICAgZm9jdXMoKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIuaWdub3JlKCgpID0+IHtcbiAgICAgICAgICAgIGZvY3VzUHJldmVudFNjcm9sbCh0aGlzLmNvbnRlbnRET00pO1xuICAgICAgICAgICAgdGhpcy5kb2NWaWV3LnVwZGF0ZVNlbGVjdGlvbigpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ2xlYW4gdXAgdGhpcyBlZGl0b3IgdmlldywgcmVtb3ZpbmcgaXRzIGVsZW1lbnQgZnJvbSB0aGVcbiAgICBkb2N1bWVudCwgdW5yZWdpc3RlcmluZyBldmVudCBoYW5kbGVycywgYW5kIG5vdGlmeWluZ1xuICAgIHBsdWdpbnMuIFRoZSB2aWV3IGluc3RhbmNlIGNhbiBubyBsb25nZXIgYmUgdXNlZCBhZnRlclxuICAgIGNhbGxpbmcgdGhpcy5cbiAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGZvciAobGV0IHBsdWdpbiBvZiB0aGlzLnBsdWdpbnMpXG4gICAgICAgICAgICBwbHVnaW4uZGVzdHJveSh0aGlzKTtcbiAgICAgICAgdGhpcy5pbnB1dFN0YXRlLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5kb20ucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIuZGVzdHJveSgpO1xuICAgICAgICBpZiAodGhpcy5tZWFzdXJlU2NoZWR1bGVkID4gLTEpXG4gICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLm1lYXN1cmVTY2hlZHVsZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBGYWNldCB0aGF0IGNhbiBiZSB1c2VkIHRvIGFkZCBET00gZXZlbnQgaGFuZGxlcnMuIFRoZSB2YWx1ZVxuICAgIHNob3VsZCBiZSBhbiBvYmplY3QgbWFwcGluZyBldmVudCBuYW1lcyB0byBoYW5kbGVyIGZ1bmN0aW9ucy4gVGhlXG4gICAgZmlyc3Qgc3VjaCBmdW5jdGlvbiB0byByZXR1cm4gdHJ1ZSB3aWxsIGJlIGFzc3VtZWQgdG8gaGF2ZSBoYW5kbGVkXG4gICAgdGhhdCBldmVudCwgYW5kIG5vIG90aGVyIGhhbmRsZXJzIG9yIGJ1aWx0LWluIGJlaGF2aW9yIHdpbGwgYmVcbiAgICBhY3RpdmF0ZWQgZm9yIGl0LlxuICAgIFRoZXNlIGFyZSByZWdpc3RlcmVkIG9uIHRoZSBbY29udGVudFxuICAgIGVsZW1lbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmNvbnRlbnRET00pLCBleGNlcHQgZm9yIGBzY3JvbGxgXG4gICAgaGFuZGxlcnMsIHdoaWNoIHdpbGwgYmUgY2FsbGVkIGFueSB0aW1lIHRoZSBlZGl0b3IncyBbc2Nyb2xsXG4gICAgZWxlbWVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuc2Nyb2xsRE9NKSBvciBvbmUgb2YgaXRzIHBhcmVudCBub2Rlc1xuICAgIGlzIHNjcm9sbGVkLlxuICAgICovXG4gICAgc3RhdGljIGRvbUV2ZW50SGFuZGxlcnMoaGFuZGxlcnMpIHtcbiAgICAgICAgcmV0dXJuIFZpZXdQbHVnaW4uZGVmaW5lKCgpID0+ICh7fSksIHsgZXZlbnRIYW5kbGVyczogaGFuZGxlcnMgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHRoZW1lIGV4dGVuc2lvbi4gVGhlIGZpcnN0IGFyZ3VtZW50IGNhbiBiZSBhXG4gICAgW2BzdHlsZS1tb2RgXShodHRwczovL2dpdGh1Yi5jb20vbWFyaWpuaC9zdHlsZS1tb2QjZG9jdW1lbnRhdGlvbilcbiAgICBzdHlsZSBzcGVjIHByb3ZpZGluZyB0aGUgc3R5bGVzIGZvciB0aGUgdGhlbWUuIFRoZXNlIHdpbGwgYmVcbiAgICBwcmVmaXhlZCB3aXRoIGEgZ2VuZXJhdGVkIGNsYXNzIGZvciB0aGUgc3R5bGUuXG4gICAgXG4gICAgQmVjYXVzZSB0aGUgc2VsZWN0b3JzIHdpbGwgYmUgcHJlZml4ZWQgd2l0aCBhIHNjb3BlIGNsYXNzLCBydWxlXG4gICAgdGhhdCBkaXJlY3RseSBtYXRjaCB0aGUgZWRpdG9yJ3MgW3dyYXBwZXJcbiAgICBlbGVtZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5kb20p4oCUdG8gd2hpY2ggdGhlIHNjb3BlIGNsYXNzIHdpbGwgYmVcbiAgICBhZGRlZOKAlG5lZWQgdG8gYmUgZXhwbGljaXRseSBkaWZmZXJlbnRpYXRlZCBieSBhZGRpbmcgYW4gYCZgIHRvXG4gICAgdGhlIHNlbGVjdG9yIGZvciB0aGF0IGVsZW1lbnTigJRmb3IgZXhhbXBsZVxuICAgIGAmLmNtLWZvY3VzZWRgLlxuICAgIFxuICAgIFdoZW4gYGRhcmtgIGlzIHNldCB0byB0cnVlLCB0aGUgdGhlbWUgd2lsbCBiZSBtYXJrZWQgYXMgZGFyayxcbiAgICB3aGljaCB3aWxsIGNhdXNlIHRoZSBgJmRhcmtgIHJ1bGVzIGZyb20gW2Jhc2VcbiAgICB0aGVtZXNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XmJhc2VUaGVtZSkgdG8gYmUgdXNlZCAoYXMgb3Bwb3NlZCB0b1xuICAgIGAmbGlnaHRgIHdoZW4gYSBsaWdodCB0aGVtZSBpcyBhY3RpdmUpLlxuICAgICovXG4gICAgc3RhdGljIHRoZW1lKHNwZWMsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IHByZWZpeCA9IHN0eWxlTW9kLlN0eWxlTW9kdWxlLm5ld05hbWUoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFt0aGVtZS5vZihwcmVmaXgpLCBzdHlsZU1vZHVsZS5vZihidWlsZFRoZW1lKGAuJHtwcmVmaXh9YCwgc3BlYykpXTtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5kYXJrKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZGFya1RoZW1lLm9mKHRydWUpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IGFkZHMgc3R5bGVzIHRvIHRoZSBiYXNlIHRoZW1lLiBMaWtlXG4gICAgd2l0aCBbYHRoZW1lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdedGhlbWUpLCB1c2UgYCZgIHRvIGluZGljYXRlIHRoZVxuICAgIHBsYWNlIG9mIHRoZSBlZGl0b3Igd3JhcHBlciBlbGVtZW50IHdoZW4gZGlyZWN0bHkgdGFyZ2V0aW5nXG4gICAgdGhhdC4gWW91IGNhbiBhbHNvIHVzZSBgJmRhcmtgIG9yIGAmbGlnaHRgIGluc3RlYWQgdG8gb25seVxuICAgIHRhcmdldCBlZGl0b3JzIHdpdGggYSBkYXJrIG9yIGxpZ2h0IHRoZW1lLlxuICAgICovXG4gICAgc3RhdGljIGJhc2VUaGVtZShzcGVjKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZS5QcmVjLmZhbGxiYWNrKHN0eWxlTW9kdWxlLm9mKGJ1aWxkVGhlbWUoXCIuXCIgKyBiYXNlVGhlbWVJRCwgc3BlYywgbGlnaHREYXJrSURzKSkpO1xuICAgIH1cbn1cbi8qKlxuRmFjZXQgdG8gYWRkIGEgW3N0eWxlXG5tb2R1bGVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJpam5oL3N0eWxlLW1vZCNkb2N1bWVudGF0aW9uKSB0b1xuYW4gZWRpdG9yIHZpZXcuIFRoZSB2aWV3IHdpbGwgZW5zdXJlIHRoYXQgdGhlIG1vZHVsZSBpc1xubW91bnRlZCBpbiBpdHMgW2RvY3VtZW50XG5yb290XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5jb25zdHJ1Y3Rvcl5jb25maWcucm9vdCkuXG4qL1xuRWRpdG9yVmlldy5zdHlsZU1vZHVsZSA9IHN0eWxlTW9kdWxlO1xuLyoqXG5BbiBpbnB1dCBoYW5kbGVyIGNhbiBvdmVycmlkZSB0aGUgd2F5IGNoYW5nZXMgdG8gdGhlIGVkaXRhYmxlXG5ET00gY29udGVudCBhcmUgaGFuZGxlZC4gSGFuZGxlcnMgYXJlIHBhc3NlZCB0aGUgZG9jdW1lbnRcbnBvc2l0aW9ucyBiZXR3ZWVuIHdoaWNoIHRoZSBjaGFuZ2Ugd2FzIGZvdW5kLCBhbmQgdGhlIG5ld1xuY29udGVudC4gV2hlbiBvbmUgcmV0dXJucyB0cnVlLCBubyBmdXJ0aGVyIGlucHV0IGhhbmRsZXJzIGFyZVxuY2FsbGVkIGFuZCB0aGUgZGVmYXVsdCBiZWhhdmlvciBpcyBwcmV2ZW50ZWQuXG4qL1xuRWRpdG9yVmlldy5pbnB1dEhhbmRsZXIgPSBpbnB1dEhhbmRsZXI7XG4vKipcbkFsbG93cyB5b3UgdG8gcHJvdmlkZSBhIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCB3aGVuIHRoZVxubGlicmFyeSBjYXRjaGVzIGFuIGV4Y2VwdGlvbiBmcm9tIGFuIGV4dGVuc2lvbiAobW9zdGx5IGZyb20gdmlld1xucGx1Z2lucywgYnV0IG1heSBiZSB1c2VkIGJ5IG90aGVyIGV4dGVuc2lvbnMgdG8gcm91dGUgZXhjZXB0aW9uc1xuZnJvbSB1c2VyLWNvZGUtcHJvdmlkZWQgY2FsbGJhY2tzKS4gVGhpcyBpcyBtb3N0bHkgdXNlZnVsIGZvclxuZGVidWdnaW5nIGFuZCBsb2dnaW5nLiBTZWUgW2Bsb2dFeGNlcHRpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcubG9nRXhjZXB0aW9uKS5cbiovXG5FZGl0b3JWaWV3LmV4Y2VwdGlvblNpbmsgPSBleGNlcHRpb25TaW5rO1xuLyoqXG5BIGZhY2V0IHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVnaXN0ZXIgYSBmdW5jdGlvbiB0byBiZSBjYWxsZWRcbmV2ZXJ5IHRpbWUgdGhlIHZpZXcgdXBkYXRlcy5cbiovXG5FZGl0b3JWaWV3LnVwZGF0ZUxpc3RlbmVyID0gdXBkYXRlTGlzdGVuZXI7XG4vKipcbkZhY2V0IHRoYXQgY29udHJvbHMgd2hldGhlciB0aGUgZWRpdG9yIGNvbnRlbnQgaXMgZWRpdGFibGUuIFdoZW5cbml0cyBoaWdoZXN0LXByZWNlZGVuY2UgdmFsdWUgaXMgYGZhbHNlYCwgZWRpdGluZyBpcyBkaXNhYmxlZCxcbmFuZCB0aGUgY29udGVudCBlbGVtZW50IHdpbGwgbm8gbG9uZ2VyIGhhdmUgaXRzXG5gY29udGVudGVkaXRhYmxlYCBhdHRyaWJ1dGUgc2V0IHRvIGB0cnVlYC4gKE5vdGUgdGhhdCB0aGlzXG5kb2Vzbid0IGFmZmVjdCBBUEkgY2FsbHMgdGhhdCBjaGFuZ2UgdGhlIGVkaXRvciBjb250ZW50LCBldmVuXG53aGVuIHRob3NlIGFyZSBib3VuZCB0byBrZXlzIG9yIGJ1dHRvbnMuKVxuKi9cbkVkaXRvclZpZXcuZWRpdGFibGUgPSBlZGl0YWJsZTtcbi8qKlxuQWxsb3dzIHlvdSB0byBpbmZsdWVuY2UgdGhlIHdheSBtb3VzZSBzZWxlY3Rpb24gaGFwcGVucy4gVGhlXG5mdW5jdGlvbnMgaW4gdGhpcyBmYWNldCB3aWxsIGJlIGNhbGxlZCBmb3IgYSBgbW91c2Vkb3duYCBldmVudFxub24gdGhlIGVkaXRvciwgYW5kIGNhbiByZXR1cm4gYW4gb2JqZWN0IHRoYXQgb3ZlcnJpZGVzIHRoZSB3YXkgYVxuc2VsZWN0aW9uIGlzIGNvbXB1dGVkIGZyb20gdGhhdCBtb3VzZSBjbGljayBvciBkcmFnLlxuKi9cbkVkaXRvclZpZXcubW91c2VTZWxlY3Rpb25TdHlsZSA9IG1vdXNlU2VsZWN0aW9uU3R5bGU7XG4vKipcbkZhY2V0IHVzZWQgdG8gY29uZmlndXJlIHdoZXRoZXIgYSBnaXZlbiBzZWxlY3Rpb24gZHJhZyBldmVudFxuc2hvdWxkIG1vdmUgb3IgY29weSB0aGUgc2VsZWN0aW9uLiBUaGUgZ2l2ZW4gcHJlZGljYXRlIHdpbGwgYmVcbmNhbGxlZCB3aXRoIHRoZSBgbW91c2Vkb3duYCBldmVudCwgYW5kIGNhbiByZXR1cm4gYHRydWVgIHdoZW5cbnRoZSBkcmFnIHNob3VsZCBtb3ZlIHRoZSBjb250ZW50LlxuKi9cbkVkaXRvclZpZXcuZHJhZ01vdmVzU2VsZWN0aW9uID0gZHJhZ01vdmVzU2VsZWN0aW9uJDE7XG4vKipcbkZhY2V0IHVzZWQgdG8gY29uZmlndXJlIHdoZXRoZXIgYSBnaXZlbiBzZWxlY3RpbmcgY2xpY2sgYWRkc1xuYSBuZXcgcmFuZ2UgdG8gdGhlIGV4aXN0aW5nIHNlbGVjdGlvbiBvciByZXBsYWNlcyBpdCBlbnRpcmVseS5cbiovXG5FZGl0b3JWaWV3LmNsaWNrQWRkc1NlbGVjdGlvblJhbmdlID0gY2xpY2tBZGRzU2VsZWN0aW9uUmFuZ2U7XG4vKipcbkEgZmFjZXQgdGhhdCBkZXRlcm1pbmVzIHdoaWNoIFtkZWNvcmF0aW9uc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkRlY29yYXRpb24pXG5hcmUgc2hvd24gaW4gdGhlIHZpZXcuIFNlZSBhbHNvIFt2aWV3XG5wbHVnaW5zXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld15kZWNvcmF0aW9ucyksIHdoaWNoIGhhdmUgYSBzZXBhcmF0ZVxubWVjaGFuaXNtIGZvciBwcm92aWRpbmcgZGVjb3JhdGlvbnMuXG4qL1xuRWRpdG9yVmlldy5kZWNvcmF0aW9ucyA9IGRlY29yYXRpb25zO1xuLyoqXG5GYWNldCB0aGF0IHByb3ZpZGVzIGFkZGl0aW9uYWwgRE9NIGF0dHJpYnV0ZXMgZm9yIHRoZSBlZGl0b3Inc1xuZWRpdGFibGUgRE9NIGVsZW1lbnQuXG4qL1xuRWRpdG9yVmlldy5jb250ZW50QXR0cmlidXRlcyA9IGNvbnRlbnRBdHRyaWJ1dGVzO1xuLyoqXG5GYWNldCB0aGF0IHByb3ZpZGVzIERPTSBhdHRyaWJ1dGVzIGZvciB0aGUgZWRpdG9yJ3Mgb3V0ZXJcbmVsZW1lbnQuXG4qL1xuRWRpdG9yVmlldy5lZGl0b3JBdHRyaWJ1dGVzID0gZWRpdG9yQXR0cmlidXRlcztcbi8qKlxuQW4gZXh0ZW5zaW9uIHRoYXQgZW5hYmxlcyBsaW5lIHdyYXBwaW5nIGluIHRoZSBlZGl0b3IgKGJ5XG5zZXR0aW5nIENTUyBgd2hpdGUtc3BhY2VgIHRvIGBwcmUtd3JhcGAgaW4gdGhlIGNvbnRlbnQpLlxuKi9cbkVkaXRvclZpZXcubGluZVdyYXBwaW5nID0gRWRpdG9yVmlldy5jb250ZW50QXR0cmlidXRlcy5vZih7IFwiY2xhc3NcIjogXCJjbS1saW5lV3JhcHBpbmdcIiB9KTtcbi8qKlxuU3RhdGUgZWZmZWN0IHVzZWQgdG8gaW5jbHVkZSBzY3JlZW4gcmVhZGVyIGFubm91bmNlbWVudHMgaW4gYVxudHJhbnNhY3Rpb24uIFRoZXNlIHdpbGwgYmUgYWRkZWQgdG8gdGhlIERPTSBpbiBhIHZpc3VhbGx5IGhpZGRlblxuZWxlbWVudCB3aXRoIGBhcmlhLWxpdmU9XCJwb2xpdGVcImAgc2V0LCBhbmQgc2hvdWxkIGJlIHVzZWQgdG9cbmRlc2NyaWJlIGVmZmVjdHMgdGhhdCBhcmUgdmlzdWFsbHkgb2J2aW91cyBidXQgbWF5IG5vdCBiZVxubm90aWNlZCBieSBzY3JlZW4gcmVhZGVyIHVzZXJzIChzdWNoIGFzIG1vdmluZyB0byB0aGUgbmV4dFxuc2VhcmNoIG1hdGNoKS5cbiovXG5FZGl0b3JWaWV3LmFubm91bmNlID0gc3RhdGUuU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG4vLyBNYXhpbXVtIGxpbmUgbGVuZ3RoIGZvciB3aGljaCB3ZSBjb21wdXRlIGFjY3VyYXRlIGJpZGkgaW5mb1xuY29uc3QgTWF4QmlkaUxpbmUgPSA0MDk2O1xuZnVuY3Rpb24gZW5zdXJlVG9wKGdpdmVuLCBkb20pIHtcbiAgICByZXR1cm4gZ2l2ZW4gPT0gbnVsbCA/IGRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgOiBnaXZlbjtcbn1cbmxldCByZXNpemVEZWJvdW5jZSA9IC0xO1xuZnVuY3Rpb24gZW5zdXJlR2xvYmFsSGFuZGxlcigpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCAoKSA9PiB7XG4gICAgICAgIGlmIChyZXNpemVEZWJvdW5jZSA9PSAtMSlcbiAgICAgICAgICAgIHJlc2l6ZURlYm91bmNlID0gc2V0VGltZW91dChoYW5kbGVSZXNpemUsIDUwKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGhhbmRsZVJlc2l6ZSgpIHtcbiAgICByZXNpemVEZWJvdW5jZSA9IC0xO1xuICAgIGxldCBmb3VuZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuY20tY29udGVudFwiKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZvdW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBkb2NWaWV3ID0gQ29udGVudFZpZXcuZ2V0KGZvdW5kW2ldKTtcbiAgICAgICAgaWYgKGRvY1ZpZXcpXG4gICAgICAgICAgICBkb2NWaWV3LmVkaXRvclZpZXcucmVxdWVzdE1lYXN1cmUoKTtcbiAgICB9XG59XG5jb25zdCBCYWRNZWFzdXJlID0ge307XG5jbGFzcyBDYWNoZWRPcmRlciB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8sIGRpciwgb3JkZXIpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLmRpciA9IGRpcjtcbiAgICAgICAgdGhpcy5vcmRlciA9IG9yZGVyO1xuICAgIH1cbiAgICBzdGF0aWMgdXBkYXRlKGNhY2hlLCBjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLmVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW10sIGxhc3REaXIgPSBjYWNoZS5sZW5ndGggPyBjYWNoZVtjYWNoZS5sZW5ndGggLSAxXS5kaXIgOiBleHBvcnRzLkRpcmVjdGlvbi5MVFI7XG4gICAgICAgIGZvciAobGV0IGkgPSBNYXRoLm1heCgwLCBjYWNoZS5sZW5ndGggLSAxMCk7IGkgPCBjYWNoZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGVudHJ5ID0gY2FjaGVbaV07XG4gICAgICAgICAgICBpZiAoZW50cnkuZGlyID09IGxhc3REaXIgJiYgIWNoYW5nZXMudG91Y2hlc1JhbmdlKGVudHJ5LmZyb20sIGVudHJ5LnRvKSlcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgQ2FjaGVkT3JkZXIoY2hhbmdlcy5tYXBQb3MoZW50cnkuZnJvbSwgMSksIGNoYW5nZXMubWFwUG9zKGVudHJ5LnRvLCAtMSksIGVudHJ5LmRpciwgZW50cnkub3JkZXIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cblxuY29uc3QgY3VycmVudFBsYXRmb3JtID0gdHlwZW9mIG5hdmlnYXRvciA9PSBcInVuZGVmaW5lZFwiID8gXCJrZXlcIlxuICAgIDogL01hYy8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pID8gXCJtYWNcIlxuICAgICAgICA6IC9XaW4vLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKSA/IFwid2luXCJcbiAgICAgICAgICAgIDogL0xpbnV4fFgxMS8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pID8gXCJsaW51eFwiXG4gICAgICAgICAgICAgICAgOiBcImtleVwiO1xuZnVuY3Rpb24gbm9ybWFsaXplS2V5TmFtZShuYW1lLCBwbGF0Zm9ybSkge1xuICAgIGNvbnN0IHBhcnRzID0gbmFtZS5zcGxpdCgvLSg/ISQpLyk7XG4gICAgbGV0IHJlc3VsdCA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChyZXN1bHQgPT0gXCJTcGFjZVwiKVxuICAgICAgICByZXN1bHQgPSBcIiBcIjtcbiAgICBsZXQgYWx0LCBjdHJsLCBzaGlmdCwgbWV0YTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICBjb25zdCBtb2QgPSBwYXJ0c1tpXTtcbiAgICAgICAgaWYgKC9eKGNtZHxtZXRhfG0pJC9pLnRlc3QobW9kKSlcbiAgICAgICAgICAgIG1ldGEgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmICgvXmEobHQpPyQvaS50ZXN0KG1vZCkpXG4gICAgICAgICAgICBhbHQgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmICgvXihjfGN0cmx8Y29udHJvbCkkL2kudGVzdChtb2QpKVxuICAgICAgICAgICAgY3RybCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKC9ecyhoaWZ0KT8kL2kudGVzdChtb2QpKVxuICAgICAgICAgICAgc2hpZnQgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmICgvXm1vZCQvaS50ZXN0KG1vZCkpIHtcbiAgICAgICAgICAgIGlmIChwbGF0Zm9ybSA9PSBcIm1hY1wiKVxuICAgICAgICAgICAgICAgIG1ldGEgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGN0cmwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCBtb2RpZmllciBuYW1lOiBcIiArIG1vZCk7XG4gICAgfVxuICAgIGlmIChhbHQpXG4gICAgICAgIHJlc3VsdCA9IFwiQWx0LVwiICsgcmVzdWx0O1xuICAgIGlmIChjdHJsKVxuICAgICAgICByZXN1bHQgPSBcIkN0cmwtXCIgKyByZXN1bHQ7XG4gICAgaWYgKG1ldGEpXG4gICAgICAgIHJlc3VsdCA9IFwiTWV0YS1cIiArIHJlc3VsdDtcbiAgICBpZiAoc2hpZnQpXG4gICAgICAgIHJlc3VsdCA9IFwiU2hpZnQtXCIgKyByZXN1bHQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG1vZGlmaWVycyhuYW1lLCBldmVudCwgc2hpZnQpIHtcbiAgICBpZiAoZXZlbnQuYWx0S2V5KVxuICAgICAgICBuYW1lID0gXCJBbHQtXCIgKyBuYW1lO1xuICAgIGlmIChldmVudC5jdHJsS2V5KVxuICAgICAgICBuYW1lID0gXCJDdHJsLVwiICsgbmFtZTtcbiAgICBpZiAoZXZlbnQubWV0YUtleSlcbiAgICAgICAgbmFtZSA9IFwiTWV0YS1cIiArIG5hbWU7XG4gICAgaWYgKHNoaWZ0ICE9PSBmYWxzZSAmJiBldmVudC5zaGlmdEtleSlcbiAgICAgICAgbmFtZSA9IFwiU2hpZnQtXCIgKyBuYW1lO1xuICAgIHJldHVybiBuYW1lO1xufVxuY29uc3QgaGFuZGxlS2V5RXZlbnRzID0gRWRpdG9yVmlldy5kb21FdmVudEhhbmRsZXJzKHtcbiAgICBrZXlkb3duKGV2ZW50LCB2aWV3KSB7XG4gICAgICAgIHJldHVybiBydW5IYW5kbGVycyhnZXRLZXltYXAodmlldy5zdGF0ZSksIGV2ZW50LCB2aWV3LCBcImVkaXRvclwiKTtcbiAgICB9XG59KTtcbi8qKlxuRmFjZXQgdXNlZCBmb3IgcmVnaXN0ZXJpbmcga2V5bWFwcy5cblxuWW91IGNhbiBhZGQgbXVsdGlwbGUga2V5bWFwcyB0byBhbiBlZGl0b3IuIFRoZWlyIHByaW9yaXRpZXNcbmRldGVybWluZSB0aGVpciBwcmVjZWRlbmNlICh0aGUgb25lcyBzcGVjaWZpZWQgZWFybHkgb3Igd2l0aCBoaWdoXG5wcmlvcml0eSBnZXQgY2hlY2tlZCBmaXJzdCkuIFdoZW4gYSBoYW5kbGVyIGhhcyByZXR1cm5lZCBgdHJ1ZWBcbmZvciBhIGdpdmVuIGtleSwgbm8gZnVydGhlciBoYW5kbGVycyBhcmUgY2FsbGVkLlxuKi9cbmNvbnN0IGtleW1hcCA9IHN0YXRlLkZhY2V0LmRlZmluZSh7IGVuYWJsZXM6IGhhbmRsZUtleUV2ZW50cyB9KTtcbmNvbnN0IEtleW1hcHMgPSBuZXcgV2Vha01hcCgpO1xuLy8gVGhpcyBpcyBoaWRkZW4gYmVoaW5kIGFuIGluZGlyZWN0aW9uLCByYXRoZXIgdGhhbiBkaXJlY3RseSBjb21wdXRlZFxuLy8gYnkgdGhlIGZhY2V0LCB0byBrZWVwIGludGVybmFsIHR5cGVzIG91dCBvZiB0aGUgZmFjZXQncyB0eXBlLlxuZnVuY3Rpb24gZ2V0S2V5bWFwKHN0YXRlKSB7XG4gICAgbGV0IGJpbmRpbmdzID0gc3RhdGUuZmFjZXQoa2V5bWFwKTtcbiAgICBsZXQgbWFwID0gS2V5bWFwcy5nZXQoYmluZGluZ3MpO1xuICAgIGlmICghbWFwKVxuICAgICAgICBLZXltYXBzLnNldChiaW5kaW5ncywgbWFwID0gYnVpbGRLZXltYXAoYmluZGluZ3MucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSwgW10pKSk7XG4gICAgcmV0dXJuIG1hcDtcbn1cbi8qKlxuUnVuIHRoZSBrZXkgaGFuZGxlcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBzY29wZS4gVGhlIGV2ZW50XG5vYmplY3Qgc2hvdWxkIGJlIGBcImtleWRvd25cImAgZXZlbnQuIFJldHVybnMgdHJ1ZSBpZiBhbnkgb2YgdGhlXG5oYW5kbGVycyBoYW5kbGVkIGl0LlxuKi9cbmZ1bmN0aW9uIHJ1blNjb3BlSGFuZGxlcnModmlldywgZXZlbnQsIHNjb3BlKSB7XG4gICAgcmV0dXJuIHJ1bkhhbmRsZXJzKGdldEtleW1hcCh2aWV3LnN0YXRlKSwgZXZlbnQsIHZpZXcsIHNjb3BlKTtcbn1cbmxldCBzdG9yZWRQcmVmaXggPSBudWxsO1xuY29uc3QgUHJlZml4VGltZW91dCA9IDQwMDA7XG5mdW5jdGlvbiBidWlsZEtleW1hcChiaW5kaW5ncywgcGxhdGZvcm0gPSBjdXJyZW50UGxhdGZvcm0pIHtcbiAgICBsZXQgYm91bmQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGxldCBpc1ByZWZpeCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbGV0IGNoZWNrUHJlZml4ID0gKG5hbWUsIGlzKSA9PiB7XG4gICAgICAgIGxldCBjdXJyZW50ID0gaXNQcmVmaXhbbmFtZV07XG4gICAgICAgIGlmIChjdXJyZW50ID09IG51bGwpXG4gICAgICAgICAgICBpc1ByZWZpeFtuYW1lXSA9IGlzO1xuICAgICAgICBlbHNlIGlmIChjdXJyZW50ICE9IGlzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5IGJpbmRpbmcgXCIgKyBuYW1lICsgXCIgaXMgdXNlZCBib3RoIGFzIGEgcmVndWxhciBiaW5kaW5nIGFuZCBhcyBhIG11bHRpLXN0cm9rZSBwcmVmaXhcIik7XG4gICAgfTtcbiAgICBsZXQgYWRkID0gKHNjb3BlLCBrZXksIGNvbW1hbmQsIHByZXZlbnREZWZhdWx0KSA9PiB7XG4gICAgICAgIGxldCBzY29wZU9iaiA9IGJvdW5kW3Njb3BlXSB8fCAoYm91bmRbc2NvcGVdID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgICAgIGxldCBwYXJ0cyA9IGtleS5zcGxpdCgvICg/ISQpLykubWFwKGsgPT4gbm9ybWFsaXplS2V5TmFtZShrLCBwbGF0Zm9ybSkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcHJlZml4ID0gcGFydHMuc2xpY2UoMCwgaSkuam9pbihcIiBcIik7XG4gICAgICAgICAgICBjaGVja1ByZWZpeChwcmVmaXgsIHRydWUpO1xuICAgICAgICAgICAgaWYgKCFzY29wZU9ialtwcmVmaXhdKVxuICAgICAgICAgICAgICAgIHNjb3BlT2JqW3ByZWZpeF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kczogWyh2aWV3KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG91ck9iaiA9IHN0b3JlZFByZWZpeCA9IHsgdmlldywgcHJlZml4LCBzY29wZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4geyBpZiAoc3RvcmVkUHJlZml4ID09IG91ck9iailcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVkUHJlZml4ID0gbnVsbDsgfSwgUHJlZml4VGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZ1bGwgPSBwYXJ0cy5qb2luKFwiIFwiKTtcbiAgICAgICAgY2hlY2tQcmVmaXgoZnVsbCwgZmFsc2UpO1xuICAgICAgICBsZXQgYmluZGluZyA9IHNjb3BlT2JqW2Z1bGxdIHx8IChzY29wZU9ialtmdWxsXSA9IHsgcHJldmVudERlZmF1bHQ6IGZhbHNlLCBjb21tYW5kczogW10gfSk7XG4gICAgICAgIGJpbmRpbmcuY29tbWFuZHMucHVzaChjb21tYW5kKTtcbiAgICAgICAgaWYgKHByZXZlbnREZWZhdWx0KVxuICAgICAgICAgICAgYmluZGluZy5wcmV2ZW50RGVmYXVsdCA9IHRydWU7XG4gICAgfTtcbiAgICBmb3IgKGxldCBiIG9mIGJpbmRpbmdzKSB7XG4gICAgICAgIGxldCBuYW1lID0gYltwbGF0Zm9ybV0gfHwgYi5rZXk7XG4gICAgICAgIGlmICghbmFtZSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBmb3IgKGxldCBzY29wZSBvZiBiLnNjb3BlID8gYi5zY29wZS5zcGxpdChcIiBcIikgOiBbXCJlZGl0b3JcIl0pIHtcbiAgICAgICAgICAgIGFkZChzY29wZSwgbmFtZSwgYi5ydW4sIGIucHJldmVudERlZmF1bHQpO1xuICAgICAgICAgICAgaWYgKGIuc2hpZnQpXG4gICAgICAgICAgICAgICAgYWRkKHNjb3BlLCBcIlNoaWZ0LVwiICsgbmFtZSwgYi5zaGlmdCwgYi5wcmV2ZW50RGVmYXVsdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJvdW5kO1xufVxuZnVuY3Rpb24gcnVuSGFuZGxlcnMobWFwLCBldmVudCwgdmlldywgc2NvcGUpIHtcbiAgICBsZXQgbmFtZSA9IHczY0tleW5hbWUua2V5TmFtZShldmVudCksIGlzQ2hhciA9IG5hbWUubGVuZ3RoID09IDEgJiYgbmFtZSAhPSBcIiBcIjtcbiAgICBsZXQgcHJlZml4ID0gXCJcIiwgZmFsbHRocm91Z2ggPSBmYWxzZTtcbiAgICBpZiAoc3RvcmVkUHJlZml4ICYmIHN0b3JlZFByZWZpeC52aWV3ID09IHZpZXcgJiYgc3RvcmVkUHJlZml4LnNjb3BlID09IHNjb3BlKSB7XG4gICAgICAgIHByZWZpeCA9IHN0b3JlZFByZWZpeC5wcmVmaXggKyBcIiBcIjtcbiAgICAgICAgaWYgKGZhbGx0aHJvdWdoID0gbW9kaWZpZXJDb2Rlcy5pbmRleE9mKGV2ZW50LmtleUNvZGUpIDwgMClcbiAgICAgICAgICAgIHN0b3JlZFByZWZpeCA9IG51bGw7XG4gICAgfVxuICAgIGxldCBydW5Gb3IgPSAoYmluZGluZykgPT4ge1xuICAgICAgICBpZiAoYmluZGluZykge1xuICAgICAgICAgICAgZm9yIChsZXQgY21kIG9mIGJpbmRpbmcuY29tbWFuZHMpXG4gICAgICAgICAgICAgICAgaWYgKGNtZCh2aWV3KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAoYmluZGluZy5wcmV2ZW50RGVmYXVsdClcbiAgICAgICAgICAgICAgICBmYWxsdGhyb3VnaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgbGV0IHNjb3BlT2JqID0gbWFwW3Njb3BlXSwgYmFzZU5hbWU7XG4gICAgaWYgKHNjb3BlT2JqKSB7XG4gICAgICAgIGlmIChydW5Gb3Ioc2NvcGVPYmpbcHJlZml4ICsgbW9kaWZpZXJzKG5hbWUsIGV2ZW50LCAhaXNDaGFyKV0pKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChpc0NoYXIgJiYgKGV2ZW50LnNoaWZ0S2V5IHx8IGV2ZW50LmFsdEtleSB8fCBldmVudC5tZXRhS2V5KSAmJlxuICAgICAgICAgICAgKGJhc2VOYW1lID0gdzNjS2V5bmFtZS5iYXNlW2V2ZW50LmtleUNvZGVdKSAmJiBiYXNlTmFtZSAhPSBuYW1lKSB7XG4gICAgICAgICAgICBpZiAocnVuRm9yKHNjb3BlT2JqW3ByZWZpeCArIG1vZGlmaWVycyhiYXNlTmFtZSwgZXZlbnQsIHRydWUpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNDaGFyICYmIGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICBpZiAocnVuRm9yKHNjb3BlT2JqW3ByZWZpeCArIG1vZGlmaWVycyhuYW1lLCBldmVudCwgdHJ1ZSldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsbHRocm91Z2g7XG59XG5cbmNvbnN0IENhbkhpZGVQcmltYXJ5ID0gIWJyb3dzZXIuaW9zOyAvLyBGSVhNRSB0ZXN0IElFXG5jb25zdCBzZWxlY3Rpb25Db25maWcgPSBzdGF0ZS5GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUoY29uZmlncykge1xuICAgICAgICByZXR1cm4gc3RhdGUuY29tYmluZUNvbmZpZyhjb25maWdzLCB7XG4gICAgICAgICAgICBjdXJzb3JCbGlua1JhdGU6IDEyMDAsXG4gICAgICAgICAgICBkcmF3UmFuZ2VDdXJzb3I6IHRydWVcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgY3Vyc29yQmxpbmtSYXRlOiAoYSwgYikgPT4gTWF0aC5taW4oYSwgYiksXG4gICAgICAgICAgICBkcmF3UmFuZ2VDdXJzb3I6IChhLCBiKSA9PiBhIHx8IGJcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG4vKipcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgaGlkZXMgdGhlIGJyb3dzZXIncyBuYXRpdmUgc2VsZWN0aW9uIGFuZFxuY3Vyc29yLCByZXBsYWNpbmcgdGhlIHNlbGVjdGlvbiB3aXRoIGEgYmFja2dyb3VuZCBiZWhpbmQgdGhlIHRleHRcbih3aXRoIHRoZSBgY20tc2VsZWN0aW9uQmFja2dyb3VuZGAgY2xhc3MpLCBhbmQgdGhlXG5jdXJzb3JzIHdpdGggZWxlbWVudHMgb3ZlcmxhaWQgb3ZlciB0aGUgY29kZSAodXNpbmdcbmBjbS1jdXJzb3ItcHJpbWFyeWAgYW5kIGBjbS1jdXJzb3Itc2Vjb25kYXJ5YCkuXG5cblRoaXMgYWxsb3dzIHRoZSBlZGl0b3IgdG8gZGlzcGxheSBzZWNvbmRhcnkgc2VsZWN0aW9uIHJhbmdlcywgYW5kXG50ZW5kcyB0byBwcm9kdWNlIGEgdHlwZSBvZiBzZWxlY3Rpb24gbW9yZSBpbiBsaW5lIHdpdGggdGhhdCB1c2Vyc1xuZXhwZWN0IGluIGEgdGV4dCBlZGl0b3IgKHRoZSBuYXRpdmUgc2VsZWN0aW9uIHN0eWxpbmcgd2lsbCBvZnRlblxubGVhdmUgZ2FwcyBiZXR3ZWVuIGxpbmVzIGFuZCB3b24ndCBmaWxsIHRoZSBob3Jpem9udGFsIHNwYWNlIGFmdGVyXG5hIGxpbmUgd2hlbiB0aGUgc2VsZWN0aW9uIGNvbnRpbnVlcyBwYXN0IGl0KS5cblxuSXQgZG9lcyBoYXZlIGEgcGVyZm9ybWFuY2UgY29zdCwgaW4gdGhhdCBpdCByZXF1aXJlcyBhbiBleHRyYSBET01cbmxheW91dCBjeWNsZSBmb3IgbWFueSB1cGRhdGVzICh0aGUgc2VsZWN0aW9uIGlzIGRyYXduIGJhc2VkIG9uIERPTVxubGF5b3V0IGluZm9ybWF0aW9uIHRoYXQncyBvbmx5IGF2YWlsYWJsZSBhZnRlciBsYXlpbmcgb3V0IHRoZVxuY29udGVudCkuXG4qL1xuZnVuY3Rpb24gZHJhd1NlbGVjdGlvbihjb25maWcgPSB7fSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIHNlbGVjdGlvbkNvbmZpZy5vZihjb25maWcpLFxuICAgICAgICBkcmF3U2VsZWN0aW9uUGx1Z2luLFxuICAgICAgICBoaWRlTmF0aXZlU2VsZWN0aW9uXG4gICAgXTtcbn1cbmNsYXNzIFBpZWNlIHtcbiAgICBjb25zdHJ1Y3RvcihsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQsIGNsYXNzTmFtZSkge1xuICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICB0aGlzLnRvcCA9IHRvcDtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgfVxuICAgIGRyYXcoKSB7XG4gICAgICAgIGxldCBlbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBlbHQuY2xhc3NOYW1lID0gdGhpcy5jbGFzc05hbWU7XG4gICAgICAgIHRoaXMuYWRqdXN0KGVsdCk7XG4gICAgICAgIHJldHVybiBlbHQ7XG4gICAgfVxuICAgIGFkanVzdChlbHQpIHtcbiAgICAgICAgZWx0LnN0eWxlLmxlZnQgPSB0aGlzLmxlZnQgKyBcInB4XCI7XG4gICAgICAgIGVsdC5zdHlsZS50b3AgPSB0aGlzLnRvcCArIFwicHhcIjtcbiAgICAgICAgaWYgKHRoaXMud2lkdGggPj0gMClcbiAgICAgICAgICAgIGVsdC5zdHlsZS53aWR0aCA9IHRoaXMud2lkdGggKyBcInB4XCI7XG4gICAgICAgIGVsdC5zdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodCArIFwicHhcIjtcbiAgICB9XG4gICAgZXEocCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZWZ0ID09IHAubGVmdCAmJiB0aGlzLnRvcCA9PSBwLnRvcCAmJiB0aGlzLndpZHRoID09IHAud2lkdGggJiYgdGhpcy5oZWlnaHQgPT0gcC5oZWlnaHQgJiZcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID09IHAuY2xhc3NOYW1lO1xuICAgIH1cbn1cbmNvbnN0IGRyYXdTZWxlY3Rpb25QbHVnaW4gPSBWaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnJhbmdlUGllY2VzID0gW107XG4gICAgICAgIHRoaXMuY3Vyc29ycyA9IFtdO1xuICAgICAgICB0aGlzLm1lYXN1cmVSZXEgPSB7IHJlYWQ6IHRoaXMucmVhZFBvcy5iaW5kKHRoaXMpLCB3cml0ZTogdGhpcy5kcmF3U2VsLmJpbmQodGhpcykgfTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25MYXllciA9IHZpZXcuc2Nyb2xsRE9NLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkxheWVyLmNsYXNzTmFtZSA9IFwiY20tc2VsZWN0aW9uTGF5ZXJcIjtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25MYXllci5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgICAgIHRoaXMuY3Vyc29yTGF5ZXIgPSB2aWV3LnNjcm9sbERPTS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgICAgICAgdGhpcy5jdXJzb3JMYXllci5jbGFzc05hbWUgPSBcImNtLWN1cnNvckxheWVyXCI7XG4gICAgICAgIHRoaXMuY3Vyc29yTGF5ZXIuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgICAgICB2aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMubWVhc3VyZVJlcSk7XG4gICAgICAgIHRoaXMuc2V0QmxpbmtSYXRlKCk7XG4gICAgfVxuICAgIHNldEJsaW5rUmF0ZSgpIHtcbiAgICAgICAgdGhpcy5jdXJzb3JMYXllci5zdHlsZS5hbmltYXRpb25EdXJhdGlvbiA9IHRoaXMudmlldy5zdGF0ZS5mYWNldChzZWxlY3Rpb25Db25maWcpLmN1cnNvckJsaW5rUmF0ZSArIFwibXNcIjtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgY29uZkNoYW5nZWQgPSB1cGRhdGUuc3RhcnRTdGF0ZS5mYWNldChzZWxlY3Rpb25Db25maWcpICE9IHVwZGF0ZS5zdGF0ZS5mYWNldChzZWxlY3Rpb25Db25maWcpO1xuICAgICAgICBpZiAoY29uZkNoYW5nZWQgfHwgdXBkYXRlLnNlbGVjdGlvblNldCB8fCB1cGRhdGUuZ2VvbWV0cnlDaGFuZ2VkIHx8IHVwZGF0ZS52aWV3cG9ydENoYW5nZWQpXG4gICAgICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUodGhpcy5tZWFzdXJlUmVxKTtcbiAgICAgICAgaWYgKHVwZGF0ZS50cmFuc2FjdGlvbnMuc29tZSh0ciA9PiB0ci5zY3JvbGxJbnRvVmlldykpXG4gICAgICAgICAgICB0aGlzLmN1cnNvckxheWVyLnN0eWxlLmFuaW1hdGlvbk5hbWUgPSB0aGlzLmN1cnNvckxheWVyLnN0eWxlLmFuaW1hdGlvbk5hbWUgPT0gXCJjbS1ibGlua1wiID8gXCJjbS1ibGluazJcIiA6IFwiY20tYmxpbmtcIjtcbiAgICAgICAgaWYgKGNvbmZDaGFuZ2VkKVxuICAgICAgICAgICAgdGhpcy5zZXRCbGlua1JhdGUoKTtcbiAgICB9XG4gICAgcmVhZFBvcygpIHtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHRoaXMudmlldywgY29uZiA9IHN0YXRlLmZhY2V0KHNlbGVjdGlvbkNvbmZpZyk7XG4gICAgICAgIGxldCByYW5nZVBpZWNlcyA9IHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMubWFwKHIgPT4gci5lbXB0eSA/IFtdIDogbWVhc3VyZVJhbmdlKHRoaXMudmlldywgcikpLnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYikpO1xuICAgICAgICBsZXQgY3Vyc29ycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCByIG9mIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgICAgIGxldCBwcmltID0gciA9PSBzdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICAgICAgICAgIGlmIChyLmVtcHR5ID8gIXByaW0gfHwgQ2FuSGlkZVByaW1hcnkgOiBjb25mLmRyYXdSYW5nZUN1cnNvcikge1xuICAgICAgICAgICAgICAgIGxldCBwaWVjZSA9IG1lYXN1cmVDdXJzb3IodGhpcy52aWV3LCByLCBwcmltKTtcbiAgICAgICAgICAgICAgICBpZiAocGllY2UpXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvcnMucHVzaChwaWVjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgcmFuZ2VQaWVjZXMsIGN1cnNvcnMgfTtcbiAgICB9XG4gICAgZHJhd1NlbCh7IHJhbmdlUGllY2VzLCBjdXJzb3JzIH0pIHtcbiAgICAgICAgaWYgKHJhbmdlUGllY2VzLmxlbmd0aCAhPSB0aGlzLnJhbmdlUGllY2VzLmxlbmd0aCB8fCByYW5nZVBpZWNlcy5zb21lKChwLCBpKSA9PiAhcC5lcSh0aGlzLnJhbmdlUGllY2VzW2ldKSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uTGF5ZXIudGV4dENvbnRlbnQgPSBcIlwiO1xuICAgICAgICAgICAgZm9yIChsZXQgcCBvZiByYW5nZVBpZWNlcylcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkxheWVyLmFwcGVuZENoaWxkKHAuZHJhdygpKTtcbiAgICAgICAgICAgIHRoaXMucmFuZ2VQaWVjZXMgPSByYW5nZVBpZWNlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3Vyc29ycy5sZW5ndGggIT0gdGhpcy5jdXJzb3JzLmxlbmd0aCB8fCBjdXJzb3JzLnNvbWUoKGMsIGkpID0+ICFjLmVxKHRoaXMuY3Vyc29yc1tpXSkpKSB7XG4gICAgICAgICAgICBsZXQgb2xkQ3Vyc29ycyA9IHRoaXMuY3Vyc29yTGF5ZXIuY2hpbGRyZW47XG4gICAgICAgICAgICBpZiAob2xkQ3Vyc29ycy5sZW5ndGggIT09IGN1cnNvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3JMYXllci50ZXh0Q29udGVudCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjIG9mIGN1cnNvcnMpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yTGF5ZXIuYXBwZW5kQ2hpbGQoYy5kcmF3KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3Vyc29ycy5mb3JFYWNoKChjLCBpZHgpID0+IGMuYWRqdXN0KG9sZEN1cnNvcnNbaWR4XSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jdXJzb3JzID0gY3Vyc29ycztcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkxheWVyLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLmN1cnNvckxheWVyLnJlbW92ZSgpO1xuICAgIH1cbn0pO1xuY29uc3QgdGhlbWVTcGVjID0ge1xuICAgIFwiLmNtLWxpbmVcIjoge1xuICAgICAgICBcIiYgOjpzZWxlY3Rpb25cIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwidHJhbnNwYXJlbnQgIWltcG9ydGFudFwiIH0sXG4gICAgICAgIFwiJjo6c2VsZWN0aW9uXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcInRyYW5zcGFyZW50ICFpbXBvcnRhbnRcIiB9XG4gICAgfVxufTtcbmlmIChDYW5IaWRlUHJpbWFyeSlcbiAgICB0aGVtZVNwZWNbXCIuY20tbGluZVwiXS5jYXJldENvbG9yID0gXCJ0cmFuc3BhcmVudCAhaW1wb3J0YW50XCI7XG5jb25zdCBoaWRlTmF0aXZlU2VsZWN0aW9uID0gc3RhdGUuUHJlYy5vdmVycmlkZShFZGl0b3JWaWV3LnRoZW1lKHRoZW1lU3BlYykpO1xuZnVuY3Rpb24gZ2V0QmFzZSh2aWV3KSB7XG4gICAgbGV0IHJlY3QgPSB2aWV3LnNjcm9sbERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgbGVmdCA9IHZpZXcudGV4dERpcmVjdGlvbiA9PSBleHBvcnRzLkRpcmVjdGlvbi5MVFIgPyByZWN0LmxlZnQgOiByZWN0LnJpZ2h0IC0gdmlldy5zY3JvbGxET00uY2xpZW50V2lkdGg7XG4gICAgcmV0dXJuIHsgbGVmdDogbGVmdCAtIHZpZXcuc2Nyb2xsRE9NLnNjcm9sbExlZnQsIHRvcDogcmVjdC50b3AgLSB2aWV3LnNjcm9sbERPTS5zY3JvbGxUb3AgfTtcbn1cbmZ1bmN0aW9uIHdyYXBwZWRMaW5lKHZpZXcsIHBvcywgaW5zaWRlKSB7XG4gICAgbGV0IHJhbmdlID0gc3RhdGUuRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MpO1xuICAgIHJldHVybiB7IGZyb206IE1hdGgubWF4KGluc2lkZS5mcm9tLCB2aWV3Lm1vdmVUb0xpbmVCb3VuZGFyeShyYW5nZSwgZmFsc2UsIHRydWUpLmZyb20pLFxuICAgICAgICB0bzogTWF0aC5taW4oaW5zaWRlLnRvLCB2aWV3Lm1vdmVUb0xpbmVCb3VuZGFyeShyYW5nZSwgdHJ1ZSwgdHJ1ZSkuZnJvbSkgfTtcbn1cbmZ1bmN0aW9uIG1lYXN1cmVSYW5nZSh2aWV3LCByYW5nZSkge1xuICAgIGlmIChyYW5nZS50byA8PSB2aWV3LnZpZXdwb3J0LmZyb20gfHwgcmFuZ2UuZnJvbSA+PSB2aWV3LnZpZXdwb3J0LnRvKVxuICAgICAgICByZXR1cm4gW107XG4gICAgbGV0IGZyb20gPSBNYXRoLm1heChyYW5nZS5mcm9tLCB2aWV3LnZpZXdwb3J0LmZyb20pLCB0byA9IE1hdGgubWluKHJhbmdlLnRvLCB2aWV3LnZpZXdwb3J0LnRvKTtcbiAgICBsZXQgbHRyID0gdmlldy50ZXh0RGlyZWN0aW9uID09IGV4cG9ydHMuRGlyZWN0aW9uLkxUUjtcbiAgICBsZXQgY29udGVudCA9IHZpZXcuY29udGVudERPTSwgY29udGVudFJlY3QgPSBjb250ZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBiYXNlID0gZ2V0QmFzZSh2aWV3KTtcbiAgICBsZXQgbGluZVN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoY29udGVudC5maXJzdENoaWxkKTtcbiAgICBsZXQgbGVmdFNpZGUgPSBjb250ZW50UmVjdC5sZWZ0ICsgcGFyc2VJbnQobGluZVN0eWxlLnBhZGRpbmdMZWZ0KTtcbiAgICBsZXQgcmlnaHRTaWRlID0gY29udGVudFJlY3QucmlnaHQgLSBwYXJzZUludChsaW5lU3R5bGUucGFkZGluZ1JpZ2h0KTtcbiAgICBsZXQgdmlzdWFsU3RhcnQgPSB2aWV3LnZpc3VhbExpbmVBdChmcm9tKTtcbiAgICBsZXQgdmlzdWFsRW5kID0gdmlldy52aXN1YWxMaW5lQXQodG8pO1xuICAgIGlmICh2aWV3LmxpbmVXcmFwcGluZykge1xuICAgICAgICB2aXN1YWxTdGFydCA9IHdyYXBwZWRMaW5lKHZpZXcsIGZyb20sIHZpc3VhbFN0YXJ0KTtcbiAgICAgICAgdmlzdWFsRW5kID0gd3JhcHBlZExpbmUodmlldywgdG8sIHZpc3VhbEVuZCk7XG4gICAgfVxuICAgIGlmICh2aXN1YWxTdGFydC5mcm9tID09IHZpc3VhbEVuZC5mcm9tKSB7XG4gICAgICAgIHJldHVybiBwaWVjZXMoZHJhd0ZvckxpbmUocmFuZ2UuZnJvbSwgcmFuZ2UudG8sIHZpc3VhbFN0YXJ0KSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgdG9wID0gZHJhd0ZvckxpbmUocmFuZ2UuZnJvbSwgbnVsbCwgdmlzdWFsU3RhcnQpO1xuICAgICAgICBsZXQgYm90dG9tID0gZHJhd0ZvckxpbmUobnVsbCwgcmFuZ2UudG8sIHZpc3VhbEVuZCk7XG4gICAgICAgIGxldCBiZXR3ZWVuID0gW107XG4gICAgICAgIGlmICh2aXN1YWxTdGFydC50byA8IHZpc3VhbEVuZC5mcm9tIC0gMSlcbiAgICAgICAgICAgIGJldHdlZW4ucHVzaChwaWVjZShsZWZ0U2lkZSwgdG9wLmJvdHRvbSwgcmlnaHRTaWRlLCBib3R0b20udG9wKSk7XG4gICAgICAgIGVsc2UgaWYgKHRvcC5ib3R0b20gPCBib3R0b20udG9wICYmIGJvdHRvbS50b3AgLSB0b3AuYm90dG9tIDwgNClcbiAgICAgICAgICAgIHRvcC5ib3R0b20gPSBib3R0b20udG9wID0gKHRvcC5ib3R0b20gKyBib3R0b20udG9wKSAvIDI7XG4gICAgICAgIHJldHVybiBwaWVjZXModG9wKS5jb25jYXQoYmV0d2VlbikuY29uY2F0KHBpZWNlcyhib3R0b20pKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGllY2UobGVmdCwgdG9wLCByaWdodCwgYm90dG9tKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGllY2UobGVmdCAtIGJhc2UubGVmdCwgdG9wIC0gYmFzZS50b3AsIHJpZ2h0IC0gbGVmdCwgYm90dG9tIC0gdG9wLCBcImNtLXNlbGVjdGlvbkJhY2tncm91bmRcIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBpZWNlcyh7IHRvcCwgYm90dG9tLCBob3Jpem9udGFsIH0pIHtcbiAgICAgICAgbGV0IHBpZWNlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhvcml6b250YWwubGVuZ3RoOyBpICs9IDIpXG4gICAgICAgICAgICBwaWVjZXMucHVzaChwaWVjZShob3Jpem9udGFsW2ldLCB0b3AsIGhvcml6b250YWxbaSArIDFdLCBib3R0b20pKTtcbiAgICAgICAgcmV0dXJuIHBpZWNlcztcbiAgICB9XG4gICAgLy8gR2V0cyBwYXNzZWQgZnJvbS90byBpbiBsaW5lLWxvY2FsIHBvc2l0aW9uc1xuICAgIGZ1bmN0aW9uIGRyYXdGb3JMaW5lKGZyb20sIHRvLCBsaW5lKSB7XG4gICAgICAgIGxldCB0b3AgPSAxZTksIGJvdHRvbSA9IC0xZTksIGhvcml6b250YWwgPSBbXTtcbiAgICAgICAgZnVuY3Rpb24gYWRkU3Bhbihmcm9tLCBmcm9tT3BlbiwgdG8sIHRvT3BlbiwgZGlyKSB7XG4gICAgICAgICAgICBsZXQgZnJvbUNvb3JkcyA9IHZpZXcuY29vcmRzQXRQb3MoZnJvbSwgZnJvbSA9PSBsaW5lLnRvID8gLTEgOiAxKTtcbiAgICAgICAgICAgIGxldCB0b0Nvb3JkcyA9IHZpZXcuY29vcmRzQXRQb3ModG8sIHRvID09IGxpbmUuZnJvbSA/IDEgOiAtMSk7XG4gICAgICAgICAgICB0b3AgPSBNYXRoLm1pbihmcm9tQ29vcmRzLnRvcCwgdG9Db29yZHMudG9wLCB0b3ApO1xuICAgICAgICAgICAgYm90dG9tID0gTWF0aC5tYXgoZnJvbUNvb3Jkcy5ib3R0b20sIHRvQ29vcmRzLmJvdHRvbSwgYm90dG9tKTtcbiAgICAgICAgICAgIGlmIChkaXIgPT0gZXhwb3J0cy5EaXJlY3Rpb24uTFRSKVxuICAgICAgICAgICAgICAgIGhvcml6b250YWwucHVzaChsdHIgJiYgZnJvbU9wZW4gPyBsZWZ0U2lkZSA6IGZyb21Db29yZHMubGVmdCwgbHRyICYmIHRvT3BlbiA/IHJpZ2h0U2lkZSA6IHRvQ29vcmRzLnJpZ2h0KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBob3Jpem9udGFsLnB1c2goIWx0ciAmJiB0b09wZW4gPyBsZWZ0U2lkZSA6IHRvQ29vcmRzLmxlZnQsICFsdHIgJiYgZnJvbU9wZW4gPyByaWdodFNpZGUgOiBmcm9tQ29vcmRzLnJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnQgPSBmcm9tICE9PSBudWxsICYmIGZyb20gIT09IHZvaWQgMCA/IGZyb20gOiBsaW5lLmZyb20sIGVuZCA9IHRvICE9PSBudWxsICYmIHRvICE9PSB2b2lkIDAgPyB0byA6IGxpbmUudG87XG4gICAgICAgIC8vIFNwbGl0IHRoZSByYW5nZSBieSB2aXNpYmxlIHJhbmdlIGFuZCBkb2N1bWVudCBsaW5lXG4gICAgICAgIGZvciAobGV0IHIgb2Ygdmlldy52aXNpYmxlUmFuZ2VzKVxuICAgICAgICAgICAgaWYgKHIudG8gPiBzdGFydCAmJiByLmZyb20gPCBlbmQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwb3MgPSBNYXRoLm1heChyLmZyb20sIHN0YXJ0KSwgZW5kUG9zID0gTWF0aC5taW4oci50bywgZW5kKTs7KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkb2NMaW5lID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KHBvcyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHNwYW4gb2Ygdmlldy5iaWRpU3BhbnMoZG9jTGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzcGFuRnJvbSA9IHNwYW4uZnJvbSArIGRvY0xpbmUuZnJvbSwgc3BhblRvID0gc3Bhbi50byArIGRvY0xpbmUuZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcGFuRnJvbSA+PSBlbmRQb3MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3BhblRvID4gcG9zKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFNwYW4oTWF0aC5tYXgoc3BhbkZyb20sIHBvcyksIGZyb20gPT0gbnVsbCAmJiBzcGFuRnJvbSA8PSBzdGFydCwgTWF0aC5taW4oc3BhblRvLCBlbmRQb3MpLCB0byA9PSBudWxsICYmIHNwYW5UbyA+PSBlbmQsIHNwYW4uZGlyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwb3MgPSBkb2NMaW5lLnRvICsgMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA+PSBlbmRQb3MpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIGlmIChob3Jpem9udGFsLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgYWRkU3BhbihzdGFydCwgZnJvbSA9PSBudWxsLCBlbmQsIHRvID09IG51bGwsIHZpZXcudGV4dERpcmVjdGlvbik7XG4gICAgICAgIHJldHVybiB7IHRvcCwgYm90dG9tLCBob3Jpem9udGFsIH07XG4gICAgfVxufVxuZnVuY3Rpb24gbWVhc3VyZUN1cnNvcih2aWV3LCBjdXJzb3IsIHByaW1hcnkpIHtcbiAgICBsZXQgcG9zID0gdmlldy5jb29yZHNBdFBvcyhjdXJzb3IuaGVhZCwgY3Vyc29yLmFzc29jIHx8IDEpO1xuICAgIGlmICghcG9zKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgYmFzZSA9IGdldEJhc2Uodmlldyk7XG4gICAgcmV0dXJuIG5ldyBQaWVjZShwb3MubGVmdCAtIGJhc2UubGVmdCwgcG9zLnRvcCAtIGJhc2UudG9wLCAtMSwgcG9zLmJvdHRvbSAtIHBvcy50b3AsIHByaW1hcnkgPyBcImNtLWN1cnNvciBjbS1jdXJzb3ItcHJpbWFyeVwiIDogXCJjbS1jdXJzb3IgY20tY3Vyc29yLXNlY29uZGFyeVwiKTtcbn1cblxuZnVuY3Rpb24gaXRlck1hdGNoZXMoZG9jLCByZSwgZnJvbSwgdG8sIGYpIHtcbiAgICByZS5sYXN0SW5kZXggPSAwO1xuICAgIGZvciAobGV0IGN1cnNvciA9IGRvYy5pdGVyUmFuZ2UoZnJvbSwgdG8pLCBwb3MgPSBmcm9tLCBtOyAhY3Vyc29yLm5leHQoKS5kb25lOyBwb3MgKz0gY3Vyc29yLnZhbHVlLmxlbmd0aCkge1xuICAgICAgICBpZiAoIWN1cnNvci5saW5lQnJlYWspXG4gICAgICAgICAgICB3aGlsZSAobSA9IHJlLmV4ZWMoY3Vyc29yLnZhbHVlKSlcbiAgICAgICAgICAgICAgICBmKHBvcyArIG0uaW5kZXgsIHBvcyArIG0uaW5kZXggKyBtWzBdLmxlbmd0aCwgbSk7XG4gICAgfVxufVxuLyoqXG5IZWxwZXIgY2xhc3MgdXNlZCB0byBtYWtlIGl0IGVhc2llciB0byBtYWludGFpbiBkZWNvcmF0aW9ucyBvblxudmlzaWJsZSBjb2RlIHRoYXQgbWF0Y2hlcyBhIGdpdmVuIHJlZ3VsYXIgZXhwcmVzc2lvbi4gVG8gYmUgdXNlZFxuaW4gYSBbdmlldyBwbHVnaW5dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5WaWV3UGx1Z2luKS4gSW5zdGFuY2VzIG9mIHRoaXMgb2JqZWN0XG5yZXByZXNlbnQgYSBtYXRjaGluZyBjb25maWd1cmF0aW9uLlxuKi9cbmNsYXNzIE1hdGNoRGVjb3JhdG9yIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBkZWNvcmF0b3IuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgbGV0IHsgcmVnZXhwLCBkZWNvcmF0aW9uLCBib3VuZGFyeSB9ID0gY29uZmlnO1xuICAgICAgICBpZiAoIXJlZ2V4cC5nbG9iYWwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSByZWd1bGFyIGV4cHJlc3Npb24gZ2l2ZW4gdG8gTWF0Y2hEZWNvcmF0b3Igc2hvdWxkIGhhdmUgaXRzICdnJyBmbGFnIHNldFwiKTtcbiAgICAgICAgdGhpcy5yZWdleHAgPSByZWdleHA7XG4gICAgICAgIHRoaXMuZ2V0RGVjbyA9IHR5cGVvZiBkZWNvcmF0aW9uID09IFwiZnVuY3Rpb25cIiA/IGRlY29yYXRpb24gOiAoKSA9PiBkZWNvcmF0aW9uO1xuICAgICAgICB0aGlzLmJvdW5kYXJ5ID0gYm91bmRhcnk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXB1dGUgdGhlIGZ1bGwgc2V0IG9mIGRlY29yYXRpb25zIGZvciBtYXRjaGVzIGluIHRoZSBnaXZlblxuICAgIHZpZXcncyB2aWV3cG9ydC4gWW91J2xsIHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4gaW5pdGlhbGl6aW5nIHlvdXJcbiAgICBwbHVnaW4uXG4gICAgKi9cbiAgICBjcmVhdGVEZWNvKHZpZXcpIHtcbiAgICAgICAgbGV0IGJ1aWxkID0gbmV3IHJhbmdlc2V0LlJhbmdlU2V0QnVpbGRlcigpO1xuICAgICAgICBmb3IgKGxldCB7IGZyb20sIHRvIH0gb2Ygdmlldy52aXNpYmxlUmFuZ2VzKVxuICAgICAgICAgICAgaXRlck1hdGNoZXModmlldy5zdGF0ZS5kb2MsIHRoaXMucmVnZXhwLCBmcm9tLCB0bywgKGEsIGIsIG0pID0+IGJ1aWxkLmFkZChhLCBiLCB0aGlzLmdldERlY28obSwgdmlldywgYSkpKTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkLmZpbmlzaCgpO1xuICAgIH1cbiAgICAvKipcbiAgICBVcGRhdGUgYSBzZXQgb2YgZGVjb3JhdGlvbnMgZm9yIGEgdmlldyB1cGRhdGUuIGBkZWNvYCBfbXVzdF8gYmVcbiAgICB0aGUgc2V0IG9mIGRlY29yYXRpb25zIHByb2R1Y2VkIGJ5IF90aGlzXyBgTWF0Y2hEZWNvcmF0b3JgIGZvclxuICAgIHRoZSB2aWV3IHN0YXRlIGJlZm9yZSB0aGUgdXBkYXRlLlxuICAgICovXG4gICAgdXBkYXRlRGVjbyh1cGRhdGUsIGRlY28pIHtcbiAgICAgICAgbGV0IGNoYW5nZUZyb20gPSAxZTksIGNoYW5nZVRvID0gLTE7XG4gICAgICAgIGlmICh1cGRhdGUuZG9jQ2hhbmdlZClcbiAgICAgICAgICAgIHVwZGF0ZS5jaGFuZ2VzLml0ZXJDaGFuZ2VzKChfZiwgX3QsIGZyb20sIHRvKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRvID4gdXBkYXRlLnZpZXcudmlld3BvcnQuZnJvbSAmJiBmcm9tIDwgdXBkYXRlLnZpZXcudmlld3BvcnQudG8pIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlRnJvbSA9IE1hdGgubWluKGZyb20sIGNoYW5nZUZyb20pO1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VUbyA9IE1hdGgubWF4KHRvLCBjaGFuZ2VUbyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGlmICh1cGRhdGUudmlld3BvcnRDaGFuZ2VkIHx8IGNoYW5nZVRvIC0gY2hhbmdlRnJvbSA+IDEwMDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVEZWNvKHVwZGF0ZS52aWV3KTtcbiAgICAgICAgaWYgKGNoYW5nZVRvID4gLTEpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVSYW5nZSh1cGRhdGUudmlldywgZGVjby5tYXAodXBkYXRlLmNoYW5nZXMpLCBjaGFuZ2VGcm9tLCBjaGFuZ2VUbyk7XG4gICAgICAgIHJldHVybiBkZWNvO1xuICAgIH1cbiAgICB1cGRhdGVSYW5nZSh2aWV3LCBkZWNvLCB1cGRhdGVGcm9tLCB1cGRhdGVUbykge1xuICAgICAgICBmb3IgKGxldCByIG9mIHZpZXcudmlzaWJsZVJhbmdlcykge1xuICAgICAgICAgICAgbGV0IGZyb20gPSBNYXRoLm1heChyLmZyb20sIHVwZGF0ZUZyb20pLCB0byA9IE1hdGgubWluKHIudG8sIHVwZGF0ZVRvKTtcbiAgICAgICAgICAgIGlmICh0byA+IGZyb20pIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbUxpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQoZnJvbSksIHRvTGluZSA9IGZyb21MaW5lLnRvIDwgdG8gPyB2aWV3LnN0YXRlLmRvYy5saW5lQXQodG8pIDogZnJvbUxpbmU7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgoci5mcm9tLCBmcm9tTGluZS5mcm9tKSwgZW5kID0gTWF0aC5taW4oci50bywgdG9MaW5lLnRvKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ib3VuZGFyeSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgZnJvbSA+IGZyb21MaW5lLmZyb207IGZyb20tLSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmJvdW5kYXJ5LnRlc3QoZnJvbUxpbmUudGV4dFtmcm9tIC0gMSAtIGZyb21MaW5lLmZyb21dKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IHRvIDwgdG9MaW5lLnRvOyB0bysrKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYm91bmRhcnkudGVzdCh0b0xpbmUudGV4dFt0byAtIHRvTGluZS5mcm9tXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSB0bztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJhbmdlcyA9IFtdLCBtO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tTGluZSA9PSB0b0xpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWdleHAubGFzdEluZGV4ID0gc3RhcnQgLSBmcm9tTGluZS5mcm9tO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKG0gPSB0aGlzLnJlZ2V4cC5leGVjKGZyb21MaW5lLnRleHQpKSAmJiBtLmluZGV4IDwgZW5kIC0gZnJvbUxpbmUuZnJvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBvcyA9IG0uaW5kZXggKyBmcm9tTGluZS5mcm9tO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2godGhpcy5nZXREZWNvKG0sIHZpZXcsIHBvcykucmFuZ2UocG9zLCBwb3MgKyBtWzBdLmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpdGVyTWF0Y2hlcyh2aWV3LnN0YXRlLmRvYywgdGhpcy5yZWdleHAsIHN0YXJ0LCBlbmQsIChmcm9tLCB0bywgbSkgPT4gcmFuZ2VzLnB1c2godGhpcy5nZXREZWNvKG0sIHZpZXcsIGZyb20pLnJhbmdlKGZyb20sIHRvKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWNvID0gZGVjby51cGRhdGUoeyBmaWx0ZXJGcm9tOiBzdGFydCwgZmlsdGVyVG86IGVuZCwgZmlsdGVyOiAoKSA9PiBmYWxzZSwgYWRkOiByYW5nZXMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlY287XG4gICAgfVxufVxuXG5jb25zdCBVbmljb2RlUmVnZXhwU3VwcG9ydCA9IC94Ly51bmljb2RlICE9IG51bGwgPyBcImd1XCIgOiBcImdcIjtcbmNvbnN0IFNwZWNpYWxzID0gbmV3IFJlZ0V4cChcIltcXHUwMDAwLVxcdTAwMDhcXHUwMDBhLVxcdTAwMWZcXHUwMDdmLVxcdTAwOWZcXHUwMGFkXFx1MDYxY1xcdTIwMGJcXHUyMDBlXFx1MjAwZlxcdTIwMjhcXHUyMDI5XFx1ZmVmZlxcdWZmZjktXFx1ZmZmY11cIiwgVW5pY29kZVJlZ2V4cFN1cHBvcnQpO1xuY29uc3QgTmFtZXMgPSB7XG4gICAgMDogXCJudWxsXCIsXG4gICAgNzogXCJiZWxsXCIsXG4gICAgODogXCJiYWNrc3BhY2VcIixcbiAgICAxMDogXCJuZXdsaW5lXCIsXG4gICAgMTE6IFwidmVydGljYWwgdGFiXCIsXG4gICAgMTM6IFwiY2FycmlhZ2UgcmV0dXJuXCIsXG4gICAgMjc6IFwiZXNjYXBlXCIsXG4gICAgODIwMzogXCJ6ZXJvIHdpZHRoIHNwYWNlXCIsXG4gICAgODIwNDogXCJ6ZXJvIHdpZHRoIG5vbi1qb2luZXJcIixcbiAgICA4MjA1OiBcInplcm8gd2lkdGggam9pbmVyXCIsXG4gICAgODIwNjogXCJsZWZ0LXRvLXJpZ2h0IG1hcmtcIixcbiAgICA4MjA3OiBcInJpZ2h0LXRvLWxlZnQgbWFya1wiLFxuICAgIDgyMzI6IFwibGluZSBzZXBhcmF0b3JcIixcbiAgICA4MjMzOiBcInBhcmFncmFwaCBzZXBhcmF0b3JcIixcbiAgICA2NTI3OTogXCJ6ZXJvIHdpZHRoIG5vLWJyZWFrIHNwYWNlXCIsXG4gICAgNjU1MzI6IFwib2JqZWN0IHJlcGxhY2VtZW50XCJcbn07XG5sZXQgX3N1cHBvcnRzVGFiU2l6ZSA9IG51bGw7XG5mdW5jdGlvbiBzdXBwb3J0c1RhYlNpemUoKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChfc3VwcG9ydHNUYWJTaXplID09IG51bGwgJiYgdHlwZW9mIGRvY3VtZW50ICE9IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnQuYm9keSkge1xuICAgICAgICBsZXQgc3R5bGVzID0gZG9jdW1lbnQuYm9keS5zdHlsZTtcbiAgICAgICAgX3N1cHBvcnRzVGFiU2l6ZSA9ICgoX2EgPSBzdHlsZXMudGFiU2l6ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogc3R5bGVzLk1velRhYlNpemUpICE9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBfc3VwcG9ydHNUYWJTaXplIHx8IGZhbHNlO1xufVxuY29uc3Qgc3BlY2lhbENoYXJDb25maWcgPSBzdGF0ZS5GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUoY29uZmlncykge1xuICAgICAgICBsZXQgY29uZmlnID0gc3RhdGUuY29tYmluZUNvbmZpZyhjb25maWdzLCB7XG4gICAgICAgICAgICByZW5kZXI6IG51bGwsXG4gICAgICAgICAgICBzcGVjaWFsQ2hhcnM6IFNwZWNpYWxzLFxuICAgICAgICAgICAgYWRkU3BlY2lhbENoYXJzOiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY29uZmlnLnJlcGxhY2VUYWJzID0gIXN1cHBvcnRzVGFiU2l6ZSgpKVxuICAgICAgICAgICAgY29uZmlnLnNwZWNpYWxDaGFycyA9IG5ldyBSZWdFeHAoXCJcXHR8XCIgKyBjb25maWcuc3BlY2lhbENoYXJzLnNvdXJjZSwgVW5pY29kZVJlZ2V4cFN1cHBvcnQpO1xuICAgICAgICBpZiAoY29uZmlnLmFkZFNwZWNpYWxDaGFycylcbiAgICAgICAgICAgIGNvbmZpZy5zcGVjaWFsQ2hhcnMgPSBuZXcgUmVnRXhwKGNvbmZpZy5zcGVjaWFsQ2hhcnMuc291cmNlICsgXCJ8XCIgKyBjb25maWcuYWRkU3BlY2lhbENoYXJzLnNvdXJjZSwgVW5pY29kZVJlZ2V4cFN1cHBvcnQpO1xuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH1cbn0pO1xuLyoqXG5SZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGluc3RhbGxzIGhpZ2hsaWdodGluZyBvZiBzcGVjaWFsXG5jaGFyYWN0ZXJzLlxuKi9cbmZ1bmN0aW9uIGhpZ2hsaWdodFNwZWNpYWxDaGFycyhcbi8qKlxuQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuKi9cbmNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIFtzcGVjaWFsQ2hhckNvbmZpZy5vZihjb25maWcpLCBzcGVjaWFsQ2hhclBsdWdpbigpXTtcbn1cbmxldCBfcGx1Z2luID0gbnVsbDtcbmZ1bmN0aW9uIHNwZWNpYWxDaGFyUGx1Z2luKCkge1xuICAgIHJldHVybiBfcGx1Z2luIHx8IChfcGx1Z2luID0gVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbkNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdG9yID0gdGhpcy5tYWtlRGVjb3JhdG9yKHZpZXcuc3RhdGUuZmFjZXQoc3BlY2lhbENoYXJDb25maWcpKTtcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmRlY29yYXRvci5jcmVhdGVEZWNvKHZpZXcpO1xuICAgICAgICB9XG4gICAgICAgIG1ha2VEZWNvcmF0b3IoY29uZikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXRjaERlY29yYXRvcih7XG4gICAgICAgICAgICAgICAgcmVnZXhwOiBjb25mLnNwZWNpYWxDaGFycyxcbiAgICAgICAgICAgICAgICBkZWNvcmF0aW9uOiAobSwgdmlldywgcG9zKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB7IGRvYyB9ID0gdmlldy5zdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvZGUgPSB0ZXh0LmNvZGVQb2ludEF0KG1bMF0sIDApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSA9PSA5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbGluZSA9IGRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzaXplID0gdmlldy5zdGF0ZS50YWJTaXplLCBjb2wgPSB0ZXh0LmNvdW50Q29sdW1uKGRvYy5zbGljZVN0cmluZyhsaW5lLmZyb20sIHBvcyksIDAsIHNpemUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb24ucmVwbGFjZSh7IHdpZGdldDogbmV3IFRhYldpZGdldCgoc2l6ZSAtIChjb2wgJSBzaXplKSkgKiB0aGlzLnZpZXcuZGVmYXVsdENoYXJhY3RlcldpZHRoKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvcmF0aW9uQ2FjaGVbY29kZV0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLmRlY29yYXRpb25DYWNoZVtjb2RlXSA9IERlY29yYXRpb24ucmVwbGFjZSh7IHdpZGdldDogbmV3IFNwZWNpYWxDaGFyV2lkZ2V0KGNvbmYsIGNvZGUpIH0pKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJvdW5kYXJ5OiBjb25mLnJlcGxhY2VUYWJzID8gdW5kZWZpbmVkIDogL1teXS9cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgICAgIGxldCBjb25mID0gdXBkYXRlLnN0YXRlLmZhY2V0KHNwZWNpYWxDaGFyQ29uZmlnKTtcbiAgICAgICAgICAgIGlmICh1cGRhdGUuc3RhcnRTdGF0ZS5mYWNldChzcGVjaWFsQ2hhckNvbmZpZykgIT0gY29uZikge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVjb3JhdG9yID0gdGhpcy5tYWtlRGVjb3JhdG9yKGNvbmYpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmRlY29yYXRvci5jcmVhdGVEZWNvKHVwZGF0ZS52aWV3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmRlY29yYXRvci51cGRhdGVEZWNvKHVwZGF0ZSwgdGhpcy5kZWNvcmF0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGRlY29yYXRpb25zOiB2ID0+IHYuZGVjb3JhdGlvbnNcbiAgICB9KSk7XG59XG5jb25zdCBEZWZhdWx0UGxhY2Vob2xkZXIgPSBcIlxcdTIwMjJcIjtcbi8vIEFzc2lnbnMgcGxhY2Vob2xkZXIgY2hhcmFjdGVycyBmcm9tIHRoZSBDb250cm9sIFBpY3R1cmVzIGJsb2NrIHRvXG4vLyBBU0NJSSBjb250cm9sIGNoYXJhY3RlcnNcbmZ1bmN0aW9uIHBsYWNlaG9sZGVyJDEoY29kZSkge1xuICAgIGlmIChjb2RlID49IDMyKVxuICAgICAgICByZXR1cm4gRGVmYXVsdFBsYWNlaG9sZGVyO1xuICAgIGlmIChjb2RlID09IDEwKVxuICAgICAgICByZXR1cm4gXCJcXHUyNDI0XCI7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoOTIxNiArIGNvZGUpO1xufVxuY2xhc3MgU3BlY2lhbENoYXJXaWRnZXQgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBjb2RlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7IHJldHVybiBvdGhlci5jb2RlID09IHRoaXMuY29kZTsgfVxuICAgIHRvRE9NKHZpZXcpIHtcbiAgICAgICAgbGV0IHBoID0gcGxhY2Vob2xkZXIkMSh0aGlzLmNvZGUpO1xuICAgICAgICBsZXQgZGVzYyA9IHZpZXcuc3RhdGUucGhyYXNlKFwiQ29udHJvbCBjaGFyYWN0ZXJcIikgKyBcIiBcIiArIChOYW1lc1t0aGlzLmNvZGVdIHx8IFwiMHhcIiArIHRoaXMuY29kZS50b1N0cmluZygxNikpO1xuICAgICAgICBsZXQgY3VzdG9tID0gdGhpcy5vcHRpb25zLnJlbmRlciAmJiB0aGlzLm9wdGlvbnMucmVuZGVyKHRoaXMuY29kZSwgZGVzYywgcGgpO1xuICAgICAgICBpZiAoY3VzdG9tKVxuICAgICAgICAgICAgcmV0dXJuIGN1c3RvbTtcbiAgICAgICAgbGV0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgc3Bhbi50ZXh0Q29udGVudCA9IHBoO1xuICAgICAgICBzcGFuLnRpdGxlID0gZGVzYztcbiAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIGRlc2MpO1xuICAgICAgICBzcGFuLmNsYXNzTmFtZSA9IFwiY20tc3BlY2lhbENoYXJcIjtcbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxuICAgIGlnbm9yZUV2ZW50KCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cbmNsYXNzIFRhYldpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKHdpZHRoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIG90aGVyLndpZHRoID09IHRoaXMud2lkdGg7IH1cbiAgICB0b0RPTSgpIHtcbiAgICAgICAgbGV0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgc3Bhbi50ZXh0Q29udGVudCA9IFwiXFx0XCI7XG4gICAgICAgIHNwYW4uY2xhc3NOYW1lID0gXCJjbS10YWJcIjtcbiAgICAgICAgc3Bhbi5zdHlsZS53aWR0aCA9IHRoaXMud2lkdGggKyBcInB4XCI7XG4gICAgICAgIHJldHVybiBzcGFuO1xuICAgIH1cbiAgICBpZ25vcmVFdmVudCgpIHsgcmV0dXJuIGZhbHNlOyB9XG59XG5cbi8qKlxuTWFyayBsaW5lcyB0aGF0IGhhdmUgYSBjdXJzb3Igb24gdGhlbSB3aXRoIHRoZSBgXCJjbS1hY3RpdmVMaW5lXCJgXG5ET00gY2xhc3MuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0QWN0aXZlTGluZSgpIHtcbiAgICByZXR1cm4gYWN0aXZlTGluZUhpZ2hsaWdodGVyO1xufVxuY29uc3QgbGluZURlY28gPSBEZWNvcmF0aW9uLmxpbmUoeyBhdHRyaWJ1dGVzOiB7IGNsYXNzOiBcImNtLWFjdGl2ZUxpbmVcIiB9IH0pO1xuY29uc3QgYWN0aXZlTGluZUhpZ2hsaWdodGVyID0gVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZ2V0RGVjbyh2aWV3KTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLnNlbGVjdGlvblNldClcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmdldERlY28odXBkYXRlLnZpZXcpO1xuICAgIH1cbiAgICBnZXREZWNvKHZpZXcpIHtcbiAgICAgICAgbGV0IGxhc3RMaW5lU3RhcnQgPSAtMSwgZGVjbyA9IFtdO1xuICAgICAgICBmb3IgKGxldCByIG9mIHZpZXcuc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgICAgICAgICAgaWYgKCFyLmVtcHR5KVxuICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHZpZXcudmlzdWFsTGluZUF0KHIuaGVhZCk7XG4gICAgICAgICAgICBpZiAobGluZS5mcm9tID4gbGFzdExpbmVTdGFydCkge1xuICAgICAgICAgICAgICAgIGRlY28ucHVzaChsaW5lRGVjby5yYW5nZShsaW5lLmZyb20pKTtcbiAgICAgICAgICAgICAgICBsYXN0TGluZVN0YXJ0ID0gbGluZS5mcm9tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uLnNldChkZWNvKTtcbiAgICB9XG59LCB7XG4gICAgZGVjb3JhdGlvbnM6IHYgPT4gdi5kZWNvcmF0aW9uc1xufSk7XG5cbmNsYXNzIFBsYWNlaG9sZGVyIGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3IoY29udGVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgIH1cbiAgICB0b0RPTSgpIHtcbiAgICAgICAgbGV0IHdyYXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgd3JhcC5jbGFzc05hbWUgPSBcImNtLXBsYWNlaG9sZGVyXCI7XG4gICAgICAgIHdyYXAuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiO1xuICAgICAgICB3cmFwLmFwcGVuZENoaWxkKHR5cGVvZiB0aGlzLmNvbnRlbnQgPT0gXCJzdHJpbmdcIiA/IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMuY29udGVudCkgOiB0aGlzLmNvbnRlbnQpO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuY29udGVudCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgd3JhcC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIFwicGxhY2Vob2xkZXIgXCIgKyB0aGlzLmNvbnRlbnQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB3cmFwLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgcmV0dXJuIHdyYXA7XG4gICAgfVxuICAgIGlnbm9yZUV2ZW50KCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cbi8qKlxuRXh0ZW5zaW9uIHRoYXQgZW5hYmxlcyBhIHBsYWNlaG9sZGVy4oCUYSBwaWVjZSBvZiBleGFtcGxlIGNvbnRlbnRcbnRvIHNob3cgd2hlbiB0aGUgZWRpdG9yIGlzIGVtcHR5LlxuKi9cbmZ1bmN0aW9uIHBsYWNlaG9sZGVyKGNvbnRlbnQpIHtcbiAgICByZXR1cm4gVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICAgICAgdGhpcy5wbGFjZWhvbGRlciA9IERlY29yYXRpb24uc2V0KFtEZWNvcmF0aW9uLndpZGdldCh7IHdpZGdldDogbmV3IFBsYWNlaG9sZGVyKGNvbnRlbnQpLCBzaWRlOiAxIH0pLnJhbmdlKDApXSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGRlY29yYXRpb25zKCkgeyByZXR1cm4gdGhpcy52aWV3LnN0YXRlLmRvYy5sZW5ndGggPyBEZWNvcmF0aW9uLm5vbmUgOiB0aGlzLnBsYWNlaG9sZGVyOyB9XG4gICAgfSwgeyBkZWNvcmF0aW9uczogdiA9PiB2LmRlY29yYXRpb25zIH0pO1xufVxuXG4vKipcbkBpbnRlcm5hbFxuKi9cbmNvbnN0IF9fdGVzdCA9IHsgSGVpZ2h0TWFwLCBIZWlnaHRPcmFjbGUsIE1lYXN1cmVkSGVpZ2h0cywgUXVlcnlUeXBlLCBDaGFuZ2VkUmFuZ2UsIGNvbXB1dGVPcmRlciwgbW92ZVZpc3VhbGx5IH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnUmFuZ2UnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlc2V0LlJhbmdlO1xuICAgIH1cbn0pO1xuZXhwb3J0cy5CaWRpU3BhbiA9IEJpZGlTcGFuO1xuZXhwb3J0cy5CbG9ja0luZm8gPSBCbG9ja0luZm87XG5leHBvcnRzLkRlY29yYXRpb24gPSBEZWNvcmF0aW9uO1xuZXhwb3J0cy5FZGl0b3JWaWV3ID0gRWRpdG9yVmlldztcbmV4cG9ydHMuTWF0Y2hEZWNvcmF0b3IgPSBNYXRjaERlY29yYXRvcjtcbmV4cG9ydHMuUGx1Z2luRmllbGQgPSBQbHVnaW5GaWVsZDtcbmV4cG9ydHMuUGx1Z2luRmllbGRQcm92aWRlciA9IFBsdWdpbkZpZWxkUHJvdmlkZXI7XG5leHBvcnRzLlZpZXdQbHVnaW4gPSBWaWV3UGx1Z2luO1xuZXhwb3J0cy5WaWV3VXBkYXRlID0gVmlld1VwZGF0ZTtcbmV4cG9ydHMuV2lkZ2V0VHlwZSA9IFdpZGdldFR5cGU7XG5leHBvcnRzLl9fdGVzdCA9IF9fdGVzdDtcbmV4cG9ydHMuZHJhd1NlbGVjdGlvbiA9IGRyYXdTZWxlY3Rpb247XG5leHBvcnRzLmhpZ2hsaWdodEFjdGl2ZUxpbmUgPSBoaWdobGlnaHRBY3RpdmVMaW5lO1xuZXhwb3J0cy5oaWdobGlnaHRTcGVjaWFsQ2hhcnMgPSBoaWdobGlnaHRTcGVjaWFsQ2hhcnM7XG5leHBvcnRzLmtleW1hcCA9IGtleW1hcDtcbmV4cG9ydHMubG9nRXhjZXB0aW9uID0gbG9nRXhjZXB0aW9uO1xuZXhwb3J0cy5wbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyO1xuZXhwb3J0cy5ydW5TY29wZUhhbmRsZXJzID0gcnVuU2NvcGVIYW5kbGVycztcbiIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBnbG9iYWwuQWxwaW5lID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICAgIGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgICB9KTtcbiAgICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgICB9XG5cbiAgICByZXR1cm4ga2V5cztcbiAgfVxuXG4gIGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcblxuICAgICAgaWYgKGkgJSAyKSB7XG4gICAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgLy8gVGhhbmtzIEBzdGltdWx1czpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3N0aW11bHVzanMvc3RpbXVsdXMvYmxvYi9tYXN0ZXIvcGFja2FnZXMvJTQwc3RpbXVsdXMvY29yZS9zcmMvYXBwbGljYXRpb24udHNcbiAgZnVuY3Rpb24gZG9tUmVhZHkoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT0gXCJsb2FkaW5nXCIpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgcmVzb2x2ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gYXJyYXlVbmlxdWUoYXJyYXkpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KGFycmF5KSk7XG4gIH1cbiAgZnVuY3Rpb24gaXNUZXN0aW5nKCkge1xuICAgIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKFwiTm9kZS5qc1wiKSB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKFwianNkb21cIik7XG4gIH1cbiAgZnVuY3Rpb24gY2hlY2tlZEF0dHJMb29zZUNvbXBhcmUodmFsdWVBLCB2YWx1ZUIpIHtcbiAgICByZXR1cm4gdmFsdWVBID09IHZhbHVlQjtcbiAgfVxuICBmdW5jdGlvbiB3YXJuSWZNYWxmb3JtZWRUZW1wbGF0ZShlbCwgZGlyZWN0aXZlKSB7XG4gICAgaWYgKGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ3RlbXBsYXRlJykge1xuICAgICAgY29uc29sZS53YXJuKGBBbHBpbmU6IFske2RpcmVjdGl2ZX1dIGRpcmVjdGl2ZSBzaG91bGQgb25seSBiZSBhZGRlZCB0byA8dGVtcGxhdGU+IHRhZ3MuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYWxwaW5lanMvYWxwaW5lIyR7ZGlyZWN0aXZlfWApO1xuICAgIH0gZWxzZSBpZiAoZWwuY29udGVudC5jaGlsZEVsZW1lbnRDb3VudCAhPT0gMSkge1xuICAgICAgY29uc29sZS53YXJuKGBBbHBpbmU6IDx0ZW1wbGF0ZT4gdGFnIHdpdGggWyR7ZGlyZWN0aXZlfV0gZW5jb3VudGVyZWQgd2l0aCBhbiB1bmV4cGVjdGVkIG51bWJlciBvZiByb290IGVsZW1lbnRzLiBNYWtlIHN1cmUgPHRlbXBsYXRlPiBoYXMgYSBzaW5nbGUgcm9vdCBlbGVtZW50LiBgKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24ga2ViYWJDYXNlKHN1YmplY3QpIHtcbiAgICByZXR1cm4gc3ViamVjdC5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCAnJDEtJDInKS5yZXBsYWNlKC9bX1xcc10vLCAnLScpLnRvTG93ZXJDYXNlKCk7XG4gIH1cbiAgZnVuY3Rpb24gY2FtZWxDYXNlKHN1YmplY3QpIHtcbiAgICByZXR1cm4gc3ViamVjdC50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLy0oXFx3KS9nLCAobWF0Y2gsIGNoYXIpID0+IGNoYXIudG9VcHBlckNhc2UoKSk7XG4gIH1cbiAgZnVuY3Rpb24gd2FsayhlbCwgY2FsbGJhY2spIHtcbiAgICBpZiAoY2FsbGJhY2soZWwpID09PSBmYWxzZSkgcmV0dXJuO1xuICAgIGxldCBub2RlID0gZWwuZmlyc3RFbGVtZW50Q2hpbGQ7XG5cbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgd2Fsayhub2RlLCBjYWxsYmFjayk7XG4gICAgICBub2RlID0gbm9kZS5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQpIHtcbiAgICB2YXIgdGltZW91dDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLFxuICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG5cbiAgICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uIGxhdGVyKCkge1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIH07XG5cbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcbiAgICB9O1xuICB9XG5cbiAgY29uc3QgaGFuZGxlRXJyb3IgPSAoZWwsIGV4cHJlc3Npb24sIGVycm9yKSA9PiB7XG4gICAgY29uc29sZS53YXJuKGBBbHBpbmUgRXJyb3I6IFwiJHtlcnJvcn1cIlxcblxcbkV4cHJlc3Npb246IFwiJHtleHByZXNzaW9ufVwiXFxuRWxlbWVudDpgLCBlbCk7XG5cbiAgICBpZiAoIWlzVGVzdGluZygpKSB7XG4gICAgICBPYmplY3QuYXNzaWduKGVycm9yLCB7XG4gICAgICAgIGVsLFxuICAgICAgICBleHByZXNzaW9uXG4gICAgICB9KTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiB0cnlDYXRjaChjYiwge1xuICAgIGVsLFxuICAgIGV4cHJlc3Npb25cbiAgfSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGNiKCk7XG4gICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlID8gdmFsdWUuY2F0Y2goZSA9PiBoYW5kbGVFcnJvcihlbCwgZXhwcmVzc2lvbiwgZSkpIDogdmFsdWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZWwsIGV4cHJlc3Npb24sIGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNhZmVyRXZhbChlbCwgZXhwcmVzc2lvbiwgZGF0YUNvbnRleHQsIGFkZGl0aW9uYWxIZWxwZXJWYXJpYWJsZXMgPSB7fSkge1xuICAgIHJldHVybiB0cnlDYXRjaCgoKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGV4cHJlc3Npb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb24uY2FsbChkYXRhQ29udGV4dCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oWyckZGF0YScsIC4uLk9iamVjdC5rZXlzKGFkZGl0aW9uYWxIZWxwZXJWYXJpYWJsZXMpXSwgYHZhciBfX2FscGluZV9yZXN1bHQ7IHdpdGgoJGRhdGEpIHsgX19hbHBpbmVfcmVzdWx0ID0gJHtleHByZXNzaW9ufSB9OyByZXR1cm4gX19hbHBpbmVfcmVzdWx0YCkoZGF0YUNvbnRleHQsIC4uLk9iamVjdC52YWx1ZXMoYWRkaXRpb25hbEhlbHBlclZhcmlhYmxlcykpO1xuICAgIH0sIHtcbiAgICAgIGVsLFxuICAgICAgZXhwcmVzc2lvblxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHNhZmVyRXZhbE5vUmV0dXJuKGVsLCBleHByZXNzaW9uLCBkYXRhQ29udGV4dCwgYWRkaXRpb25hbEhlbHBlclZhcmlhYmxlcyA9IHt9KSB7XG4gICAgcmV0dXJuIHRyeUNhdGNoKCgpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgZXhwcmVzc2lvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGV4cHJlc3Npb24uY2FsbChkYXRhQ29udGV4dCwgYWRkaXRpb25hbEhlbHBlclZhcmlhYmxlc1snJGV2ZW50J10pKTtcbiAgICAgIH1cblxuICAgICAgbGV0IEFzeW5jRnVuY3Rpb24gPSBGdW5jdGlvbjtcbiAgICAgIC8qIE1PREVSTi1PTkxZOlNUQVJUICovXG5cbiAgICAgIEFzeW5jRnVuY3Rpb24gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYXN5bmMgZnVuY3Rpb24gKCkge30pLmNvbnN0cnVjdG9yO1xuICAgICAgLyogTU9ERVJOLU9OTFk6RU5EICovXG4gICAgICAvLyBGb3IgdGhlIGNhc2VzIHdoZW4gdXNlcnMgcGFzcyBvbmx5IGEgZnVuY3Rpb24gcmVmZXJlbmNlIHRvIHRoZSBjYWxsZXI6IGB4LW9uOmNsaWNrPVwiZm9vXCJgXG4gICAgICAvLyBXaGVyZSBcImZvb1wiIGlzIGEgZnVuY3Rpb24uIEFsc28sIHdlJ2xsIHBhc3MgdGhlIGZ1bmN0aW9uIHRoZSBldmVudCBpbnN0YW5jZSB3aGVuIHdlIGNhbGwgaXQuXG5cbiAgICAgIGlmIChPYmplY3Qua2V5cyhkYXRhQ29udGV4dCkuaW5jbHVkZXMoZXhwcmVzc2lvbikpIHtcbiAgICAgICAgbGV0IG1ldGhvZFJlZmVyZW5jZSA9IG5ldyBGdW5jdGlvbihbJ2RhdGFDb250ZXh0JywgLi4uT2JqZWN0LmtleXMoYWRkaXRpb25hbEhlbHBlclZhcmlhYmxlcyldLCBgd2l0aChkYXRhQ29udGV4dCkgeyByZXR1cm4gJHtleHByZXNzaW9ufSB9YCkoZGF0YUNvbnRleHQsIC4uLk9iamVjdC52YWx1ZXMoYWRkaXRpb25hbEhlbHBlclZhcmlhYmxlcykpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kUmVmZXJlbmNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtZXRob2RSZWZlcmVuY2UuY2FsbChkYXRhQ29udGV4dCwgYWRkaXRpb25hbEhlbHBlclZhcmlhYmxlc1snJGV2ZW50J10pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQXN5bmNGdW5jdGlvbihbJ2RhdGFDb250ZXh0JywgLi4uT2JqZWN0LmtleXMoYWRkaXRpb25hbEhlbHBlclZhcmlhYmxlcyldLCBgd2l0aChkYXRhQ29udGV4dCkgeyAke2V4cHJlc3Npb259IH1gKShkYXRhQ29udGV4dCwgLi4uT2JqZWN0LnZhbHVlcyhhZGRpdGlvbmFsSGVscGVyVmFyaWFibGVzKSkpO1xuICAgIH0sIHtcbiAgICAgIGVsLFxuICAgICAgZXhwcmVzc2lvblxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHhBdHRyUkUgPSAvXngtKG9ufGJpbmR8ZGF0YXx0ZXh0fGh0bWx8bW9kZWx8aWZ8Zm9yfHNob3d8Y2xvYWt8dHJhbnNpdGlvbnxyZWZ8c3ByZWFkKVxcYi87XG4gIGZ1bmN0aW9uIGlzWEF0dHIoYXR0cikge1xuICAgIGNvbnN0IG5hbWUgPSByZXBsYWNlQXRBbmRDb2xvbldpdGhTdGFuZGFyZFN5bnRheChhdHRyLm5hbWUpO1xuICAgIHJldHVybiB4QXR0clJFLnRlc3QobmFtZSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0WEF0dHJzKGVsLCBjb21wb25lbnQsIHR5cGUpIHtcbiAgICBsZXQgZGlyZWN0aXZlcyA9IEFycmF5LmZyb20oZWwuYXR0cmlidXRlcykuZmlsdGVyKGlzWEF0dHIpLm1hcChwYXJzZUh0bWxBdHRyaWJ1dGUpOyAvLyBHZXQgYW4gb2JqZWN0IG9mIGRpcmVjdGl2ZXMgZnJvbSB4LXNwcmVhZC5cblxuICAgIGxldCBzcHJlYWREaXJlY3RpdmUgPSBkaXJlY3RpdmVzLmZpbHRlcihkaXJlY3RpdmUgPT4gZGlyZWN0aXZlLnR5cGUgPT09ICdzcHJlYWQnKVswXTtcblxuICAgIGlmIChzcHJlYWREaXJlY3RpdmUpIHtcbiAgICAgIGxldCBzcHJlYWRPYmplY3QgPSBzYWZlckV2YWwoZWwsIHNwcmVhZERpcmVjdGl2ZS5leHByZXNzaW9uLCBjb21wb25lbnQuJGRhdGEpOyAvLyBBZGQgeC1zcHJlYWQgZGlyZWN0aXZlcyB0byB0aGUgcGlsZSBvZiBleGlzdGluZyBkaXJlY3RpdmVzLlxuXG4gICAgICBkaXJlY3RpdmVzID0gZGlyZWN0aXZlcy5jb25jYXQoT2JqZWN0LmVudHJpZXMoc3ByZWFkT2JqZWN0KS5tYXAoKFtuYW1lLCB2YWx1ZV0pID0+IHBhcnNlSHRtbEF0dHJpYnV0ZSh7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHZhbHVlXG4gICAgICB9KSkpO1xuICAgIH1cblxuICAgIGlmICh0eXBlKSByZXR1cm4gZGlyZWN0aXZlcy5maWx0ZXIoaSA9PiBpLnR5cGUgPT09IHR5cGUpO1xuICAgIHJldHVybiBzb3J0RGlyZWN0aXZlcyhkaXJlY3RpdmVzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNvcnREaXJlY3RpdmVzKGRpcmVjdGl2ZXMpIHtcbiAgICBsZXQgZGlyZWN0aXZlT3JkZXIgPSBbJ2JpbmQnLCAnbW9kZWwnLCAnc2hvdycsICdjYXRjaC1hbGwnXTtcbiAgICByZXR1cm4gZGlyZWN0aXZlcy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICBsZXQgdHlwZUEgPSBkaXJlY3RpdmVPcmRlci5pbmRleE9mKGEudHlwZSkgPT09IC0xID8gJ2NhdGNoLWFsbCcgOiBhLnR5cGU7XG4gICAgICBsZXQgdHlwZUIgPSBkaXJlY3RpdmVPcmRlci5pbmRleE9mKGIudHlwZSkgPT09IC0xID8gJ2NhdGNoLWFsbCcgOiBiLnR5cGU7XG4gICAgICByZXR1cm4gZGlyZWN0aXZlT3JkZXIuaW5kZXhPZih0eXBlQSkgLSBkaXJlY3RpdmVPcmRlci5pbmRleE9mKHR5cGVCKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSHRtbEF0dHJpYnV0ZSh7XG4gICAgbmFtZSxcbiAgICB2YWx1ZVxuICB9KSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZE5hbWUgPSByZXBsYWNlQXRBbmRDb2xvbldpdGhTdGFuZGFyZFN5bnRheChuYW1lKTtcbiAgICBjb25zdCB0eXBlTWF0Y2ggPSBub3JtYWxpemVkTmFtZS5tYXRjaCh4QXR0clJFKTtcbiAgICBjb25zdCB2YWx1ZU1hdGNoID0gbm9ybWFsaXplZE5hbWUubWF0Y2goLzooW2EtekEtWjAtOVxcLTpdKykvKTtcbiAgICBjb25zdCBtb2RpZmllcnMgPSBub3JtYWxpemVkTmFtZS5tYXRjaCgvXFwuW14uXFxdXSsoPz1bXlxcXV0qJCkvZykgfHwgW107XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IHR5cGVNYXRjaCA/IHR5cGVNYXRjaFsxXSA6IG51bGwsXG4gICAgICB2YWx1ZTogdmFsdWVNYXRjaCA/IHZhbHVlTWF0Y2hbMV0gOiBudWxsLFxuICAgICAgbW9kaWZpZXJzOiBtb2RpZmllcnMubWFwKGkgPT4gaS5yZXBsYWNlKCcuJywgJycpKSxcbiAgICAgIGV4cHJlc3Npb246IHZhbHVlXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBpc0Jvb2xlYW5BdHRyKGF0dHJOYW1lKSB7XG4gICAgLy8gQXMgcGVyIEhUTUwgc3BlYyB0YWJsZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmRpY2VzLmh0bWwjYXR0cmlidXRlcy0zOmJvb2xlYW4tYXR0cmlidXRlXG4gICAgLy8gQXJyYXkgcm91Z2hseSBvcmRlcmVkIGJ5IGVzdGltYXRlZCB1c2FnZVxuICAgIGNvbnN0IGJvb2xlYW5BdHRyaWJ1dGVzID0gWydkaXNhYmxlZCcsICdjaGVja2VkJywgJ3JlcXVpcmVkJywgJ3JlYWRvbmx5JywgJ2hpZGRlbicsICdvcGVuJywgJ3NlbGVjdGVkJywgJ2F1dG9mb2N1cycsICdpdGVtc2NvcGUnLCAnbXVsdGlwbGUnLCAnbm92YWxpZGF0ZScsICdhbGxvd2Z1bGxzY3JlZW4nLCAnYWxsb3dwYXltZW50cmVxdWVzdCcsICdmb3Jtbm92YWxpZGF0ZScsICdhdXRvcGxheScsICdjb250cm9scycsICdsb29wJywgJ211dGVkJywgJ3BsYXlzaW5saW5lJywgJ2RlZmF1bHQnLCAnaXNtYXAnLCAncmV2ZXJzZWQnLCAnYXN5bmMnLCAnZGVmZXInLCAnbm9tb2R1bGUnXTtcbiAgICByZXR1cm4gYm9vbGVhbkF0dHJpYnV0ZXMuaW5jbHVkZXMoYXR0ck5hbWUpO1xuICB9XG4gIGZ1bmN0aW9uIHJlcGxhY2VBdEFuZENvbG9uV2l0aFN0YW5kYXJkU3ludGF4KG5hbWUpIHtcbiAgICBpZiAobmFtZS5zdGFydHNXaXRoKCdAJykpIHtcbiAgICAgIHJldHVybiBuYW1lLnJlcGxhY2UoJ0AnLCAneC1vbjonKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUuc3RhcnRzV2l0aCgnOicpKSB7XG4gICAgICByZXR1cm4gbmFtZS5yZXBsYWNlKCc6JywgJ3gtYmluZDonKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmFtZTtcbiAgfVxuICBmdW5jdGlvbiBjb252ZXJ0Q2xhc3NTdHJpbmdUb0FycmF5KGNsYXNzTGlzdCwgZmlsdGVyRm4gPSBCb29sZWFuKSB7XG4gICAgcmV0dXJuIGNsYXNzTGlzdC5zcGxpdCgnICcpLmZpbHRlcihmaWx0ZXJGbik7XG4gIH1cbiAgY29uc3QgVFJBTlNJVElPTl9UWVBFX0lOID0gJ2luJztcbiAgY29uc3QgVFJBTlNJVElPTl9UWVBFX09VVCA9ICdvdXQnO1xuICBjb25zdCBUUkFOU0lUSU9OX0NBTkNFTExFRCA9ICdjYW5jZWxsZWQnO1xuICBmdW5jdGlvbiB0cmFuc2l0aW9uSW4oZWwsIHNob3csIHJlamVjdCwgY29tcG9uZW50LCBmb3JjZVNraXAgPSBmYWxzZSkge1xuICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gdHJhbnNpdGlvbiBvbiB0aGUgaW5pdGlhbCBwYWdlIGxvYWQuXG4gICAgaWYgKGZvcmNlU2tpcCkgcmV0dXJuIHNob3coKTtcblxuICAgIGlmIChlbC5fX3hfdHJhbnNpdGlvbiAmJiBlbC5fX3hfdHJhbnNpdGlvbi50eXBlID09PSBUUkFOU0lUSU9OX1RZUEVfSU4pIHtcbiAgICAgIC8vIHRoZXJlIGlzIGFscmVhZHkgYSBzaW1pbGFyIHRyYW5zaXRpb24gZ29pbmcgb24sIHRoaXMgd2FzIHByb2JhYmx5IHRyaWdnZXJlZCBieVxuICAgICAgLy8gYSBjaGFuZ2UgaW4gYSBkaWZmZXJlbnQgcHJvcGVydHksIGxldCdzIGp1c3QgbGVhdmUgdGhlIHByZXZpb3VzIG9uZSBkb2luZyBpdHMgam9iXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYXR0cnMgPSBnZXRYQXR0cnMoZWwsIGNvbXBvbmVudCwgJ3RyYW5zaXRpb24nKTtcbiAgICBjb25zdCBzaG93QXR0ciA9IGdldFhBdHRycyhlbCwgY29tcG9uZW50LCAnc2hvdycpWzBdOyAvLyBJZiB0aGlzIGlzIHRyaWdnZXJlZCBieSBhIHgtc2hvdy50cmFuc2l0aW9uLlxuXG4gICAgaWYgKHNob3dBdHRyICYmIHNob3dBdHRyLm1vZGlmaWVycy5pbmNsdWRlcygndHJhbnNpdGlvbicpKSB7XG4gICAgICBsZXQgbW9kaWZpZXJzID0gc2hvd0F0dHIubW9kaWZpZXJzOyAvLyBJZiB4LXNob3cudHJhbnNpdGlvbi5vdXQsIHdlJ2xsIHNraXAgdGhlIFwiaW5cIiB0cmFuc2l0aW9uLlxuXG4gICAgICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKCdvdXQnKSAmJiAhbW9kaWZpZXJzLmluY2x1ZGVzKCdpbicpKSByZXR1cm4gc2hvdygpO1xuICAgICAgY29uc3Qgc2V0dGluZ0JvdGhTaWRlc09mVHJhbnNpdGlvbiA9IG1vZGlmaWVycy5pbmNsdWRlcygnaW4nKSAmJiBtb2RpZmllcnMuaW5jbHVkZXMoJ291dCcpOyAvLyBJZiB4LXNob3cudHJhbnNpdGlvbi5pbi4uLm91dC4uLiBvbmx5IHVzZSBcImluXCIgcmVsYXRlZCBtb2RpZmllcnMgZm9yIHRoaXMgdHJhbnNpdGlvbi5cblxuICAgICAgbW9kaWZpZXJzID0gc2V0dGluZ0JvdGhTaWRlc09mVHJhbnNpdGlvbiA/IG1vZGlmaWVycy5maWx0ZXIoKGksIGluZGV4KSA9PiBpbmRleCA8IG1vZGlmaWVycy5pbmRleE9mKCdvdXQnKSkgOiBtb2RpZmllcnM7XG4gICAgICB0cmFuc2l0aW9uSGVscGVySW4oZWwsIG1vZGlmaWVycywgc2hvdywgcmVqZWN0KTsgLy8gT3RoZXJ3aXNlLCB3ZSBjYW4gYXNzdW1lIHgtdHJhbnNpdGlvbjplbnRlci5cbiAgICB9IGVsc2UgaWYgKGF0dHJzLnNvbWUoYXR0ciA9PiBbJ2VudGVyJywgJ2VudGVyLXN0YXJ0JywgJ2VudGVyLWVuZCddLmluY2x1ZGVzKGF0dHIudmFsdWUpKSkge1xuICAgICAgdHJhbnNpdGlvbkNsYXNzZXNJbihlbCwgY29tcG9uZW50LCBhdHRycywgc2hvdywgcmVqZWN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbmVpdGhlciwganVzdCBzaG93IHRoYXQgZGFtbiB0aGluZy5cbiAgICAgIHNob3coKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdHJhbnNpdGlvbk91dChlbCwgaGlkZSwgcmVqZWN0LCBjb21wb25lbnQsIGZvcmNlU2tpcCA9IGZhbHNlKSB7XG4gICAgLy8gV2UgZG9uJ3Qgd2FudCB0byB0cmFuc2l0aW9uIG9uIHRoZSBpbml0aWFsIHBhZ2UgbG9hZC5cbiAgICBpZiAoZm9yY2VTa2lwKSByZXR1cm4gaGlkZSgpO1xuXG4gICAgaWYgKGVsLl9feF90cmFuc2l0aW9uICYmIGVsLl9feF90cmFuc2l0aW9uLnR5cGUgPT09IFRSQU5TSVRJT05fVFlQRV9PVVQpIHtcbiAgICAgIC8vIHRoZXJlIGlzIGFscmVhZHkgYSBzaW1pbGFyIHRyYW5zaXRpb24gZ29pbmcgb24sIHRoaXMgd2FzIHByb2JhYmx5IHRyaWdnZXJlZCBieVxuICAgICAgLy8gYSBjaGFuZ2UgaW4gYSBkaWZmZXJlbnQgcHJvcGVydHksIGxldCdzIGp1c3QgbGVhdmUgdGhlIHByZXZpb3VzIG9uZSBkb2luZyBpdHMgam9iXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYXR0cnMgPSBnZXRYQXR0cnMoZWwsIGNvbXBvbmVudCwgJ3RyYW5zaXRpb24nKTtcbiAgICBjb25zdCBzaG93QXR0ciA9IGdldFhBdHRycyhlbCwgY29tcG9uZW50LCAnc2hvdycpWzBdO1xuXG4gICAgaWYgKHNob3dBdHRyICYmIHNob3dBdHRyLm1vZGlmaWVycy5pbmNsdWRlcygndHJhbnNpdGlvbicpKSB7XG4gICAgICBsZXQgbW9kaWZpZXJzID0gc2hvd0F0dHIubW9kaWZpZXJzO1xuICAgICAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcygnaW4nKSAmJiAhbW9kaWZpZXJzLmluY2x1ZGVzKCdvdXQnKSkgcmV0dXJuIGhpZGUoKTtcbiAgICAgIGNvbnN0IHNldHRpbmdCb3RoU2lkZXNPZlRyYW5zaXRpb24gPSBtb2RpZmllcnMuaW5jbHVkZXMoJ2luJykgJiYgbW9kaWZpZXJzLmluY2x1ZGVzKCdvdXQnKTtcbiAgICAgIG1vZGlmaWVycyA9IHNldHRpbmdCb3RoU2lkZXNPZlRyYW5zaXRpb24gPyBtb2RpZmllcnMuZmlsdGVyKChpLCBpbmRleCkgPT4gaW5kZXggPiBtb2RpZmllcnMuaW5kZXhPZignb3V0JykpIDogbW9kaWZpZXJzO1xuICAgICAgdHJhbnNpdGlvbkhlbHBlck91dChlbCwgbW9kaWZpZXJzLCBzZXR0aW5nQm90aFNpZGVzT2ZUcmFuc2l0aW9uLCBoaWRlLCByZWplY3QpO1xuICAgIH0gZWxzZSBpZiAoYXR0cnMuc29tZShhdHRyID0+IFsnbGVhdmUnLCAnbGVhdmUtc3RhcnQnLCAnbGVhdmUtZW5kJ10uaW5jbHVkZXMoYXR0ci52YWx1ZSkpKSB7XG4gICAgICB0cmFuc2l0aW9uQ2xhc3Nlc091dChlbCwgY29tcG9uZW50LCBhdHRycywgaGlkZSwgcmVqZWN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGlkZSgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0cmFuc2l0aW9uSGVscGVySW4oZWwsIG1vZGlmaWVycywgc2hvd0NhbGxiYWNrLCByZWplY3QpIHtcbiAgICAvLyBEZWZhdWx0IHZhbHVlcyBpbnNwaXJlZCBieTogaHR0cHM6Ly9tYXRlcmlhbC5pby9kZXNpZ24vbW90aW9uL3NwZWVkLmh0bWwjZHVyYXRpb25cbiAgICBjb25zdCBzdHlsZVZhbHVlcyA9IHtcbiAgICAgIGR1cmF0aW9uOiBtb2RpZmllclZhbHVlKG1vZGlmaWVycywgJ2R1cmF0aW9uJywgMTUwKSxcbiAgICAgIG9yaWdpbjogbW9kaWZpZXJWYWx1ZShtb2RpZmllcnMsICdvcmlnaW4nLCAnY2VudGVyJyksXG4gICAgICBmaXJzdDoge1xuICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICBzY2FsZTogbW9kaWZpZXJWYWx1ZShtb2RpZmllcnMsICdzY2FsZScsIDk1KVxuICAgICAgfSxcbiAgICAgIHNlY29uZDoge1xuICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICBzY2FsZTogMTAwXG4gICAgICB9XG4gICAgfTtcbiAgICB0cmFuc2l0aW9uSGVscGVyKGVsLCBtb2RpZmllcnMsIHNob3dDYWxsYmFjaywgKCkgPT4ge30sIHJlamVjdCwgc3R5bGVWYWx1ZXMsIFRSQU5TSVRJT05fVFlQRV9JTik7XG4gIH1cbiAgZnVuY3Rpb24gdHJhbnNpdGlvbkhlbHBlck91dChlbCwgbW9kaWZpZXJzLCBzZXR0aW5nQm90aFNpZGVzT2ZUcmFuc2l0aW9uLCBoaWRlQ2FsbGJhY2ssIHJlamVjdCkge1xuICAgIC8vIE1ha2UgdGhlIFwib3V0XCIgdHJhbnNpdGlvbiAuNXggc2xvd2VyIHRoYW4gdGhlIFwiaW5cIi4gKFZpc3VhbGx5IGJldHRlcilcbiAgICAvLyBIT1dFVkVSLCBpZiB0aGV5IGV4cGxpY2l0bHkgc2V0IGEgZHVyYXRpb24gZm9yIHRoZSBcIm91dFwiIHRyYW5zaXRpb24sXG4gICAgLy8gdXNlIHRoYXQuXG4gICAgY29uc3QgZHVyYXRpb24gPSBzZXR0aW5nQm90aFNpZGVzT2ZUcmFuc2l0aW9uID8gbW9kaWZpZXJWYWx1ZShtb2RpZmllcnMsICdkdXJhdGlvbicsIDE1MCkgOiBtb2RpZmllclZhbHVlKG1vZGlmaWVycywgJ2R1cmF0aW9uJywgMTUwKSAvIDI7XG4gICAgY29uc3Qgc3R5bGVWYWx1ZXMgPSB7XG4gICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICBvcmlnaW46IG1vZGlmaWVyVmFsdWUobW9kaWZpZXJzLCAnb3JpZ2luJywgJ2NlbnRlcicpLFxuICAgICAgZmlyc3Q6IHtcbiAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgc2NhbGU6IDEwMFxuICAgICAgfSxcbiAgICAgIHNlY29uZDoge1xuICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICBzY2FsZTogbW9kaWZpZXJWYWx1ZShtb2RpZmllcnMsICdzY2FsZScsIDk1KVxuICAgICAgfVxuICAgIH07XG4gICAgdHJhbnNpdGlvbkhlbHBlcihlbCwgbW9kaWZpZXJzLCAoKSA9PiB7fSwgaGlkZUNhbGxiYWNrLCByZWplY3QsIHN0eWxlVmFsdWVzLCBUUkFOU0lUSU9OX1RZUEVfT1VUKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1vZGlmaWVyVmFsdWUobW9kaWZpZXJzLCBrZXksIGZhbGxiYWNrKSB7XG4gICAgLy8gSWYgdGhlIG1vZGlmaWVyIGlzbid0IHByZXNlbnQsIHVzZSB0aGUgZGVmYXVsdC5cbiAgICBpZiAobW9kaWZpZXJzLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHJldHVybiBmYWxsYmFjazsgLy8gSWYgaXQgSVMgcHJlc2VudCwgZ3JhYiB0aGUgdmFsdWUgYWZ0ZXIgaXQ6IHgtc2hvdy50cmFuc2l0aW9uLmR1cmF0aW9uLjUwMG1zXG5cbiAgICBjb25zdCByYXdWYWx1ZSA9IG1vZGlmaWVyc1ttb2RpZmllcnMuaW5kZXhPZihrZXkpICsgMV07XG4gICAgaWYgKCFyYXdWYWx1ZSkgcmV0dXJuIGZhbGxiYWNrO1xuXG4gICAgaWYgKGtleSA9PT0gJ3NjYWxlJykge1xuICAgICAgLy8gQ2hlY2sgaWYgdGhlIHZlcnkgbmV4dCB2YWx1ZSBpcyBOT1QgYSBudW1iZXIgYW5kIHJldHVybiB0aGUgZmFsbGJhY2suXG4gICAgICAvLyBJZiB4LXNob3cudHJhbnNpdGlvbi5zY2FsZSwgd2UnbGwgdXNlIHRoZSBkZWZhdWx0IHNjYWxlIHZhbHVlLlxuICAgICAgLy8gVGhhdCBpcyBob3cgYSB1c2VyIG9wdHMgb3V0IG9mIHRoZSBvcGFjaXR5IHRyYW5zaXRpb24uXG4gICAgICBpZiAoIWlzTnVtZXJpYyhyYXdWYWx1ZSkpIHJldHVybiBmYWxsYmFjaztcbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAnZHVyYXRpb24nKSB7XG4gICAgICAvLyBTdXBwb3J0IHgtc2hvdy50cmFuc2l0aW9uLmR1cmF0aW9uLjUwMG1zICYmIGR1cmF0aW9uLjUwMFxuICAgICAgbGV0IG1hdGNoID0gcmF3VmFsdWUubWF0Y2goLyhbMC05XSspbXMvKTtcbiAgICAgIGlmIChtYXRjaCkgcmV0dXJuIG1hdGNoWzFdO1xuICAgIH1cblxuICAgIGlmIChrZXkgPT09ICdvcmlnaW4nKSB7XG4gICAgICAvLyBTdXBwb3J0IGNoYWluaW5nIG9yaWdpbiBkaXJlY3Rpb25zOiB4LXNob3cudHJhbnNpdGlvbi50b3AucmlnaHRcbiAgICAgIGlmIChbJ3RvcCcsICdyaWdodCcsICdsZWZ0JywgJ2NlbnRlcicsICdib3R0b20nXS5pbmNsdWRlcyhtb2RpZmllcnNbbW9kaWZpZXJzLmluZGV4T2Yoa2V5KSArIDJdKSkge1xuICAgICAgICByZXR1cm4gW3Jhd1ZhbHVlLCBtb2RpZmllcnNbbW9kaWZpZXJzLmluZGV4T2Yoa2V5KSArIDJdXS5qb2luKCcgJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhd1ZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhbnNpdGlvbkhlbHBlcihlbCwgbW9kaWZpZXJzLCBob29rMSwgaG9vazIsIHJlamVjdCwgc3R5bGVWYWx1ZXMsIHR5cGUpIHtcbiAgICAvLyBjbGVhciB0aGUgcHJldmlvdXMgdHJhbnNpdGlvbiBpZiBleGlzdHMgdG8gYXZvaWQgY2FjaGluZyB0aGUgd3Jvbmcgc3R5bGVzXG4gICAgaWYgKGVsLl9feF90cmFuc2l0aW9uKSB7XG4gICAgICBlbC5fX3hfdHJhbnNpdGlvbi5jYW5jZWwgJiYgZWwuX194X3RyYW5zaXRpb24uY2FuY2VsKCk7XG4gICAgfSAvLyBJZiB0aGUgdXNlciBzZXQgdGhlc2Ugc3R5bGUgdmFsdWVzLCB3ZSdsbCBwdXQgdGhlbSBiYWNrIHdoZW4gd2UncmUgZG9uZSB3aXRoIHRoZW0uXG5cblxuICAgIGNvbnN0IG9wYWNpdHlDYWNoZSA9IGVsLnN0eWxlLm9wYWNpdHk7XG4gICAgY29uc3QgdHJhbnNmb3JtQ2FjaGUgPSBlbC5zdHlsZS50cmFuc2Zvcm07XG4gICAgY29uc3QgdHJhbnNmb3JtT3JpZ2luQ2FjaGUgPSBlbC5zdHlsZS50cmFuc2Zvcm1PcmlnaW47IC8vIElmIG5vIG1vZGlmaWVycyBhcmUgcHJlc2VudDogeC1zaG93LnRyYW5zaXRpb24sIHdlJ2xsIGRlZmF1bHQgdG8gYm90aCBvcGFjaXR5IGFuZCBzY2FsZS5cblxuICAgIGNvbnN0IG5vTW9kaWZpZXJzID0gIW1vZGlmaWVycy5pbmNsdWRlcygnb3BhY2l0eScpICYmICFtb2RpZmllcnMuaW5jbHVkZXMoJ3NjYWxlJyk7XG4gICAgY29uc3QgdHJhbnNpdGlvbk9wYWNpdHkgPSBub01vZGlmaWVycyB8fCBtb2RpZmllcnMuaW5jbHVkZXMoJ29wYWNpdHknKTtcbiAgICBjb25zdCB0cmFuc2l0aW9uU2NhbGUgPSBub01vZGlmaWVycyB8fCBtb2RpZmllcnMuaW5jbHVkZXMoJ3NjYWxlJyk7IC8vIFRoZXNlIGFyZSB0aGUgZXhwbGljaXQgc3RhZ2VzIG9mIGEgdHJhbnNpdGlvbiAoc2FtZSBzdGFnZXMgZm9yIGluIGFuZCBmb3Igb3V0KS5cbiAgICAvLyBUaGlzIHdheSB5b3UgY2FuIGdldCBhIGJpcmRzIGV5ZSB2aWV3IG9mIHRoZSBob29rcywgYW5kIHRoZSBkaWZmZXJlbmNlc1xuICAgIC8vIGJldHdlZW4gdGhlbS5cblxuICAgIGNvbnN0IHN0YWdlcyA9IHtcbiAgICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAodHJhbnNpdGlvbk9wYWNpdHkpIGVsLnN0eWxlLm9wYWNpdHkgPSBzdHlsZVZhbHVlcy5maXJzdC5vcGFjaXR5O1xuICAgICAgICBpZiAodHJhbnNpdGlvblNjYWxlKSBlbC5zdHlsZS50cmFuc2Zvcm0gPSBgc2NhbGUoJHtzdHlsZVZhbHVlcy5maXJzdC5zY2FsZSAvIDEwMH0pYDtcbiAgICAgIH0sXG5cbiAgICAgIGR1cmluZygpIHtcbiAgICAgICAgaWYgKHRyYW5zaXRpb25TY2FsZSkgZWwuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gc3R5bGVWYWx1ZXMub3JpZ2luO1xuICAgICAgICBlbC5zdHlsZS50cmFuc2l0aW9uUHJvcGVydHkgPSBbdHJhbnNpdGlvbk9wYWNpdHkgPyBgb3BhY2l0eWAgOiBgYCwgdHJhbnNpdGlvblNjYWxlID8gYHRyYW5zZm9ybWAgOiBgYF0uam9pbignICcpLnRyaW0oKTtcbiAgICAgICAgZWwuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gYCR7c3R5bGVWYWx1ZXMuZHVyYXRpb24gLyAxMDAwfXNgO1xuICAgICAgICBlbC5zdHlsZS50cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24gPSBgY3ViaWMtYmV6aWVyKDAuNCwgMC4wLCAwLjIsIDEpYDtcbiAgICAgIH0sXG5cbiAgICAgIHNob3coKSB7XG4gICAgICAgIGhvb2sxKCk7XG4gICAgICB9LFxuXG4gICAgICBlbmQoKSB7XG4gICAgICAgIGlmICh0cmFuc2l0aW9uT3BhY2l0eSkgZWwuc3R5bGUub3BhY2l0eSA9IHN0eWxlVmFsdWVzLnNlY29uZC5vcGFjaXR5O1xuICAgICAgICBpZiAodHJhbnNpdGlvblNjYWxlKSBlbC5zdHlsZS50cmFuc2Zvcm0gPSBgc2NhbGUoJHtzdHlsZVZhbHVlcy5zZWNvbmQuc2NhbGUgLyAxMDB9KWA7XG4gICAgICB9LFxuXG4gICAgICBoaWRlKCkge1xuICAgICAgICBob29rMigpO1xuICAgICAgfSxcblxuICAgICAgY2xlYW51cCgpIHtcbiAgICAgICAgaWYgKHRyYW5zaXRpb25PcGFjaXR5KSBlbC5zdHlsZS5vcGFjaXR5ID0gb3BhY2l0eUNhY2hlO1xuICAgICAgICBpZiAodHJhbnNpdGlvblNjYWxlKSBlbC5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1DYWNoZTtcbiAgICAgICAgaWYgKHRyYW5zaXRpb25TY2FsZSkgZWwuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gdHJhbnNmb3JtT3JpZ2luQ2FjaGU7XG4gICAgICAgIGVsLnN0eWxlLnRyYW5zaXRpb25Qcm9wZXJ0eSA9IG51bGw7XG4gICAgICAgIGVsLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IG51bGw7XG4gICAgICAgIGVsLnN0eWxlLnRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbiA9IG51bGw7XG4gICAgICB9XG5cbiAgICB9O1xuICAgIHRyYW5zaXRpb24oZWwsIHN0YWdlcywgdHlwZSwgcmVqZWN0KTtcbiAgfVxuXG4gIGNvbnN0IGVuc3VyZVN0cmluZ0V4cHJlc3Npb24gPSAoZXhwcmVzc2lvbiwgZWwsIGNvbXBvbmVudCkgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgZXhwcmVzc2lvbiA9PT0gJ2Z1bmN0aW9uJyA/IGNvbXBvbmVudC5ldmFsdWF0ZVJldHVybkV4cHJlc3Npb24oZWwsIGV4cHJlc3Npb24pIDogZXhwcmVzc2lvbjtcbiAgfTtcblxuICBmdW5jdGlvbiB0cmFuc2l0aW9uQ2xhc3Nlc0luKGVsLCBjb21wb25lbnQsIGRpcmVjdGl2ZXMsIHNob3dDYWxsYmFjaywgcmVqZWN0KSB7XG4gICAgY29uc3QgZW50ZXIgPSBjb252ZXJ0Q2xhc3NTdHJpbmdUb0FycmF5KGVuc3VyZVN0cmluZ0V4cHJlc3Npb24oKGRpcmVjdGl2ZXMuZmluZChpID0+IGkudmFsdWUgPT09ICdlbnRlcicpIHx8IHtcbiAgICAgIGV4cHJlc3Npb246ICcnXG4gICAgfSkuZXhwcmVzc2lvbiwgZWwsIGNvbXBvbmVudCkpO1xuICAgIGNvbnN0IGVudGVyU3RhcnQgPSBjb252ZXJ0Q2xhc3NTdHJpbmdUb0FycmF5KGVuc3VyZVN0cmluZ0V4cHJlc3Npb24oKGRpcmVjdGl2ZXMuZmluZChpID0+IGkudmFsdWUgPT09ICdlbnRlci1zdGFydCcpIHx8IHtcbiAgICAgIGV4cHJlc3Npb246ICcnXG4gICAgfSkuZXhwcmVzc2lvbiwgZWwsIGNvbXBvbmVudCkpO1xuICAgIGNvbnN0IGVudGVyRW5kID0gY29udmVydENsYXNzU3RyaW5nVG9BcnJheShlbnN1cmVTdHJpbmdFeHByZXNzaW9uKChkaXJlY3RpdmVzLmZpbmQoaSA9PiBpLnZhbHVlID09PSAnZW50ZXItZW5kJykgfHwge1xuICAgICAgZXhwcmVzc2lvbjogJydcbiAgICB9KS5leHByZXNzaW9uLCBlbCwgY29tcG9uZW50KSk7XG4gICAgdHJhbnNpdGlvbkNsYXNzZXMoZWwsIGVudGVyLCBlbnRlclN0YXJ0LCBlbnRlckVuZCwgc2hvd0NhbGxiYWNrLCAoKSA9PiB7fSwgVFJBTlNJVElPTl9UWVBFX0lOLCByZWplY3QpO1xuICB9XG4gIGZ1bmN0aW9uIHRyYW5zaXRpb25DbGFzc2VzT3V0KGVsLCBjb21wb25lbnQsIGRpcmVjdGl2ZXMsIGhpZGVDYWxsYmFjaywgcmVqZWN0KSB7XG4gICAgY29uc3QgbGVhdmUgPSBjb252ZXJ0Q2xhc3NTdHJpbmdUb0FycmF5KGVuc3VyZVN0cmluZ0V4cHJlc3Npb24oKGRpcmVjdGl2ZXMuZmluZChpID0+IGkudmFsdWUgPT09ICdsZWF2ZScpIHx8IHtcbiAgICAgIGV4cHJlc3Npb246ICcnXG4gICAgfSkuZXhwcmVzc2lvbiwgZWwsIGNvbXBvbmVudCkpO1xuICAgIGNvbnN0IGxlYXZlU3RhcnQgPSBjb252ZXJ0Q2xhc3NTdHJpbmdUb0FycmF5KGVuc3VyZVN0cmluZ0V4cHJlc3Npb24oKGRpcmVjdGl2ZXMuZmluZChpID0+IGkudmFsdWUgPT09ICdsZWF2ZS1zdGFydCcpIHx8IHtcbiAgICAgIGV4cHJlc3Npb246ICcnXG4gICAgfSkuZXhwcmVzc2lvbiwgZWwsIGNvbXBvbmVudCkpO1xuICAgIGNvbnN0IGxlYXZlRW5kID0gY29udmVydENsYXNzU3RyaW5nVG9BcnJheShlbnN1cmVTdHJpbmdFeHByZXNzaW9uKChkaXJlY3RpdmVzLmZpbmQoaSA9PiBpLnZhbHVlID09PSAnbGVhdmUtZW5kJykgfHwge1xuICAgICAgZXhwcmVzc2lvbjogJydcbiAgICB9KS5leHByZXNzaW9uLCBlbCwgY29tcG9uZW50KSk7XG4gICAgdHJhbnNpdGlvbkNsYXNzZXMoZWwsIGxlYXZlLCBsZWF2ZVN0YXJ0LCBsZWF2ZUVuZCwgKCkgPT4ge30sIGhpZGVDYWxsYmFjaywgVFJBTlNJVElPTl9UWVBFX09VVCwgcmVqZWN0KTtcbiAgfVxuICBmdW5jdGlvbiB0cmFuc2l0aW9uQ2xhc3NlcyhlbCwgY2xhc3Nlc0R1cmluZywgY2xhc3Nlc1N0YXJ0LCBjbGFzc2VzRW5kLCBob29rMSwgaG9vazIsIHR5cGUsIHJlamVjdCkge1xuICAgIC8vIGNsZWFyIHRoZSBwcmV2aW91cyB0cmFuc2l0aW9uIGlmIGV4aXN0cyB0byBhdm9pZCBjYWNoaW5nIHRoZSB3cm9uZyBjbGFzc2VzXG4gICAgaWYgKGVsLl9feF90cmFuc2l0aW9uKSB7XG4gICAgICBlbC5fX3hfdHJhbnNpdGlvbi5jYW5jZWwgJiYgZWwuX194X3RyYW5zaXRpb24uY2FuY2VsKCk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3JpZ2luYWxDbGFzc2VzID0gZWwuX194X29yaWdpbmFsX2NsYXNzZXMgfHwgW107XG4gICAgY29uc3Qgc3RhZ2VzID0ge1xuICAgICAgc3RhcnQoKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoLi4uY2xhc3Nlc1N0YXJ0KTtcbiAgICAgIH0sXG5cbiAgICAgIGR1cmluZygpIHtcbiAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCguLi5jbGFzc2VzRHVyaW5nKTtcbiAgICAgIH0sXG5cbiAgICAgIHNob3coKSB7XG4gICAgICAgIGhvb2sxKCk7XG4gICAgICB9LFxuXG4gICAgICBlbmQoKSB7XG4gICAgICAgIC8vIERvbid0IHJlbW92ZSBjbGFzc2VzIHRoYXQgd2VyZSBpbiB0aGUgb3JpZ2luYWwgY2xhc3MgYXR0cmlidXRlLlxuICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKC4uLmNsYXNzZXNTdGFydC5maWx0ZXIoaSA9PiAhb3JpZ2luYWxDbGFzc2VzLmluY2x1ZGVzKGkpKSk7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoLi4uY2xhc3Nlc0VuZCk7XG4gICAgICB9LFxuXG4gICAgICBoaWRlKCkge1xuICAgICAgICBob29rMigpO1xuICAgICAgfSxcblxuICAgICAgY2xlYW51cCgpIHtcbiAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSguLi5jbGFzc2VzRHVyaW5nLmZpbHRlcihpID0+ICFvcmlnaW5hbENsYXNzZXMuaW5jbHVkZXMoaSkpKTtcbiAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSguLi5jbGFzc2VzRW5kLmZpbHRlcihpID0+ICFvcmlnaW5hbENsYXNzZXMuaW5jbHVkZXMoaSkpKTtcbiAgICAgIH1cblxuICAgIH07XG4gICAgdHJhbnNpdGlvbihlbCwgc3RhZ2VzLCB0eXBlLCByZWplY3QpO1xuICB9XG4gIGZ1bmN0aW9uIHRyYW5zaXRpb24oZWwsIHN0YWdlcywgdHlwZSwgcmVqZWN0KSB7XG4gICAgY29uc3QgZmluaXNoID0gb25jZSgoKSA9PiB7XG4gICAgICBzdGFnZXMuaGlkZSgpOyAvLyBBZGRpbmcgYW4gXCJpc0Nvbm5lY3RlZFwiIGNoZWNrLCBpbiBjYXNlIHRoZSBjYWxsYmFja1xuICAgICAgLy8gcmVtb3ZlZCB0aGUgZWxlbWVudCBmcm9tIHRoZSBET00uXG5cbiAgICAgIGlmIChlbC5pc0Nvbm5lY3RlZCkge1xuICAgICAgICBzdGFnZXMuY2xlYW51cCgpO1xuICAgICAgfVxuXG4gICAgICBkZWxldGUgZWwuX194X3RyYW5zaXRpb247XG4gICAgfSk7XG4gICAgZWwuX194X3RyYW5zaXRpb24gPSB7XG4gICAgICAvLyBTZXQgdHJhbnNpdGlvbiB0eXBlIHNvIHdlIGNhbiBhdm9pZCBjbGVhcmluZyB0cmFuc2l0aW9uIGlmIHRoZSBkaXJlY3Rpb24gaXMgdGhlIHNhbWVcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAvLyBjcmVhdGUgYSBjYWxsYmFjayBmb3IgdGhlIGxhc3Qgc3RhZ2VzIG9mIHRoZSB0cmFuc2l0aW9uIHNvIHdlIGNhbiBjYWxsIGl0XG4gICAgICAvLyBmcm9tIGRpZmZlcmVudCBwb2ludCBhbmQgZWFybHkgdGVybWluYXRlIGl0LiBPbmNlIHdpbGwgZW5zdXJlIHRoYXQgZnVuY3Rpb25cbiAgICAgIC8vIGlzIG9ubHkgY2FsbGVkIG9uZSB0aW1lLlxuICAgICAgY2FuY2VsOiBvbmNlKCgpID0+IHtcbiAgICAgICAgcmVqZWN0KFRSQU5TSVRJT05fQ0FOQ0VMTEVEKTtcbiAgICAgICAgZmluaXNoKCk7XG4gICAgICB9KSxcbiAgICAgIGZpbmlzaCxcbiAgICAgIC8vIFRoaXMgc3RvcmUgdGhlIG5leHQgYW5pbWF0aW9uIGZyYW1lIHNvIHdlIGNhbiBjYW5jZWwgaXRcbiAgICAgIG5leHRGcmFtZTogbnVsbFxuICAgIH07XG4gICAgc3RhZ2VzLnN0YXJ0KCk7XG4gICAgc3RhZ2VzLmR1cmluZygpO1xuICAgIGVsLl9feF90cmFuc2l0aW9uLm5leHRGcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAvLyBOb3RlOiBTYWZhcmkncyB0cmFuc2l0aW9uRHVyYXRpb24gcHJvcGVydHkgd2lsbCBsaXN0IG91dCBjb21tYSBzZXBhcmF0ZWQgdHJhbnNpdGlvbiBkdXJhdGlvbnNcbiAgICAgIC8vIGZvciBldmVyeSBzaW5nbGUgdHJhbnNpdGlvbiBwcm9wZXJ0eS4gTGV0J3MgZ3JhYiB0aGUgZmlyc3Qgb25lIGFuZCBjYWxsIGl0IGEgZGF5LlxuICAgICAgbGV0IGR1cmF0aW9uID0gTnVtYmVyKGdldENvbXB1dGVkU3R5bGUoZWwpLnRyYW5zaXRpb25EdXJhdGlvbi5yZXBsYWNlKC8sLiovLCAnJykucmVwbGFjZSgncycsICcnKSkgKiAxMDAwO1xuXG4gICAgICBpZiAoZHVyYXRpb24gPT09IDApIHtcbiAgICAgICAgZHVyYXRpb24gPSBOdW1iZXIoZ2V0Q29tcHV0ZWRTdHlsZShlbCkuYW5pbWF0aW9uRHVyYXRpb24ucmVwbGFjZSgncycsICcnKSkgKiAxMDAwO1xuICAgICAgfVxuXG4gICAgICBzdGFnZXMuc2hvdygpO1xuICAgICAgZWwuX194X3RyYW5zaXRpb24ubmV4dEZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgc3RhZ2VzLmVuZCgpO1xuICAgICAgICBzZXRUaW1lb3V0KGVsLl9feF90cmFuc2l0aW9uLmZpbmlzaCwgZHVyYXRpb24pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gaXNOdW1lcmljKHN1YmplY3QpIHtcbiAgICByZXR1cm4gIUFycmF5LmlzQXJyYXkoc3ViamVjdCkgJiYgIWlzTmFOKHN1YmplY3QpO1xuICB9IC8vIFRoYW5rcyBAdnVlanNcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS9ibG9iLzRkZTQ2NDlkOTYzNzI2MmE5YjAwNzcyMGI1OWY4MGFjNzJhNTYyMGMvc3JjL3NoYXJlZC91dGlsLmpzXG5cbiAgZnVuY3Rpb24gb25jZShjYWxsYmFjaykge1xuICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlRm9yRGlyZWN0aXZlKGNvbXBvbmVudCwgdGVtcGxhdGVFbCwgZXhwcmVzc2lvbiwgaW5pdGlhbFVwZGF0ZSwgZXh0cmFWYXJzKSB7XG4gICAgd2FybklmTWFsZm9ybWVkVGVtcGxhdGUodGVtcGxhdGVFbCwgJ3gtZm9yJyk7XG4gICAgbGV0IGl0ZXJhdG9yTmFtZXMgPSB0eXBlb2YgZXhwcmVzc2lvbiA9PT0gJ2Z1bmN0aW9uJyA/IHBhcnNlRm9yRXhwcmVzc2lvbihjb21wb25lbnQuZXZhbHVhdGVSZXR1cm5FeHByZXNzaW9uKHRlbXBsYXRlRWwsIGV4cHJlc3Npb24pKSA6IHBhcnNlRm9yRXhwcmVzc2lvbihleHByZXNzaW9uKTtcbiAgICBsZXQgaXRlbXMgPSBldmFsdWF0ZUl0ZW1zQW5kUmV0dXJuRW1wdHlJZlhJZklzUHJlc2VudEFuZEZhbHNlT25FbGVtZW50KGNvbXBvbmVudCwgdGVtcGxhdGVFbCwgaXRlcmF0b3JOYW1lcywgZXh0cmFWYXJzKTsgLy8gQXMgd2Ugd2FsayB0aGUgYXJyYXksIHdlJ2xsIGFsc28gd2FsayB0aGUgRE9NICh1cGRhdGluZy9jcmVhdGluZyBhcyB3ZSBnbykuXG5cbiAgICBsZXQgY3VycmVudEVsID0gdGVtcGxhdGVFbDtcbiAgICBpdGVtcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgbGV0IGl0ZXJhdGlvblNjb3BlVmFyaWFibGVzID0gZ2V0SXRlcmF0aW9uU2NvcGVWYXJpYWJsZXMoaXRlcmF0b3JOYW1lcywgaXRlbSwgaW5kZXgsIGl0ZW1zLCBleHRyYVZhcnMoKSk7XG4gICAgICBsZXQgY3VycmVudEtleSA9IGdlbmVyYXRlS2V5Rm9ySXRlcmF0aW9uKGNvbXBvbmVudCwgdGVtcGxhdGVFbCwgaW5kZXgsIGl0ZXJhdGlvblNjb3BlVmFyaWFibGVzKTtcbiAgICAgIGxldCBuZXh0RWwgPSBsb29rQWhlYWRGb3JNYXRjaGluZ0tleWVkRWxlbWVudEFuZE1vdmVJdElmRm91bmQoY3VycmVudEVsLm5leHRFbGVtZW50U2libGluZywgY3VycmVudEtleSk7IC8vIElmIHdlIGhhdmVuJ3QgZm91bmQgYSBtYXRjaGluZyBrZXksIGluc2VydCB0aGUgZWxlbWVudCBhdCB0aGUgY3VycmVudCBwb3NpdGlvbi5cblxuICAgICAgaWYgKCFuZXh0RWwpIHtcbiAgICAgICAgbmV4dEVsID0gYWRkRWxlbWVudEluTG9vcEFmdGVyQ3VycmVudEVsKHRlbXBsYXRlRWwsIGN1cnJlbnRFbCk7IC8vIEFuZCB0cmFuc2l0aW9uIGl0IGluIGlmIGl0J3Mgbm90IHRoZSBmaXJzdCBwYWdlIGxvYWQuXG5cbiAgICAgICAgdHJhbnNpdGlvbkluKG5leHRFbCwgKCkgPT4ge30sICgpID0+IHt9LCBjb21wb25lbnQsIGluaXRpYWxVcGRhdGUpO1xuICAgICAgICBuZXh0RWwuX194X2ZvciA9IGl0ZXJhdGlvblNjb3BlVmFyaWFibGVzO1xuICAgICAgICBjb21wb25lbnQuaW5pdGlhbGl6ZUVsZW1lbnRzKG5leHRFbCwgKCkgPT4gbmV4dEVsLl9feF9mb3IpOyAvLyBPdGhlcndpc2UgdXBkYXRlIHRoZSBlbGVtZW50IHdlIGZvdW5kLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGVtcG9yYXJpbHkgcmVtb3ZlIHRoZSBrZXkgaW5kaWNhdG9yIHRvIGFsbG93IHRoZSBub3JtYWwgXCJ1cGRhdGVFbGVtZW50c1wiIHRvIHdvcmsuXG4gICAgICAgIGRlbGV0ZSBuZXh0RWwuX194X2Zvcl9rZXk7XG4gICAgICAgIG5leHRFbC5fX3hfZm9yID0gaXRlcmF0aW9uU2NvcGVWYXJpYWJsZXM7XG4gICAgICAgIGNvbXBvbmVudC51cGRhdGVFbGVtZW50cyhuZXh0RWwsICgpID0+IG5leHRFbC5fX3hfZm9yKTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudEVsID0gbmV4dEVsO1xuICAgICAgY3VycmVudEVsLl9feF9mb3Jfa2V5ID0gY3VycmVudEtleTtcbiAgICB9KTtcbiAgICByZW1vdmVBbnlMZWZ0T3ZlckVsZW1lbnRzRnJvbVByZXZpb3VzVXBkYXRlKGN1cnJlbnRFbCwgY29tcG9uZW50KTtcbiAgfSAvLyBUaGlzIHdhcyB0YWtlbiBmcm9tIFZ1ZUpTIDIuKiBjb3JlLiBUaGFua3MgVnVlIVxuXG4gIGZ1bmN0aW9uIHBhcnNlRm9yRXhwcmVzc2lvbihleHByZXNzaW9uKSB7XG4gICAgbGV0IGZvckl0ZXJhdG9yUkUgPSAvLChbXixcXH1cXF1dKikoPzosKFteLFxcfVxcXV0qKSk/JC87XG4gICAgbGV0IHN0cmlwUGFyZW5zUkUgPSAvXlxcKHxcXCkkL2c7XG4gICAgbGV0IGZvckFsaWFzUkUgPSAvKFtcXHNcXFNdKj8pXFxzKyg/OmlufG9mKVxccysoW1xcc1xcU10qKS87XG4gICAgbGV0IGluTWF0Y2ggPSBTdHJpbmcoZXhwcmVzc2lvbikubWF0Y2goZm9yQWxpYXNSRSk7XG4gICAgaWYgKCFpbk1hdGNoKSByZXR1cm47XG4gICAgbGV0IHJlcyA9IHt9O1xuICAgIHJlcy5pdGVtcyA9IGluTWF0Y2hbMl0udHJpbSgpO1xuICAgIGxldCBpdGVtID0gaW5NYXRjaFsxXS50cmltKCkucmVwbGFjZShzdHJpcFBhcmVuc1JFLCAnJyk7XG4gICAgbGV0IGl0ZXJhdG9yTWF0Y2ggPSBpdGVtLm1hdGNoKGZvckl0ZXJhdG9yUkUpO1xuXG4gICAgaWYgKGl0ZXJhdG9yTWF0Y2gpIHtcbiAgICAgIHJlcy5pdGVtID0gaXRlbS5yZXBsYWNlKGZvckl0ZXJhdG9yUkUsICcnKS50cmltKCk7XG4gICAgICByZXMuaW5kZXggPSBpdGVyYXRvck1hdGNoWzFdLnRyaW0oKTtcblxuICAgICAgaWYgKGl0ZXJhdG9yTWF0Y2hbMl0pIHtcbiAgICAgICAgcmVzLmNvbGxlY3Rpb24gPSBpdGVyYXRvck1hdGNoWzJdLnRyaW0oKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVzLml0ZW0gPSBpdGVtO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRJdGVyYXRpb25TY29wZVZhcmlhYmxlcyhpdGVyYXRvck5hbWVzLCBpdGVtLCBpbmRleCwgaXRlbXMsIGV4dHJhVmFycykge1xuICAgIC8vIFdlIG11c3QgY3JlYXRlIGEgbmV3IG9iamVjdCwgc28gZWFjaCBpdGVyYXRpb24gaGFzIGEgbmV3IHNjb3BlXG4gICAgbGV0IHNjb3BlVmFyaWFibGVzID0gZXh0cmFWYXJzID8gX29iamVjdFNwcmVhZDIoe30sIGV4dHJhVmFycykgOiB7fTtcbiAgICBzY29wZVZhcmlhYmxlc1tpdGVyYXRvck5hbWVzLml0ZW1dID0gaXRlbTtcbiAgICBpZiAoaXRlcmF0b3JOYW1lcy5pbmRleCkgc2NvcGVWYXJpYWJsZXNbaXRlcmF0b3JOYW1lcy5pbmRleF0gPSBpbmRleDtcbiAgICBpZiAoaXRlcmF0b3JOYW1lcy5jb2xsZWN0aW9uKSBzY29wZVZhcmlhYmxlc1tpdGVyYXRvck5hbWVzLmNvbGxlY3Rpb25dID0gaXRlbXM7XG4gICAgcmV0dXJuIHNjb3BlVmFyaWFibGVzO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVLZXlGb3JJdGVyYXRpb24oY29tcG9uZW50LCBlbCwgaW5kZXgsIGl0ZXJhdGlvblNjb3BlVmFyaWFibGVzKSB7XG4gICAgbGV0IGJpbmRLZXlBdHRyaWJ1dGUgPSBnZXRYQXR0cnMoZWwsIGNvbXBvbmVudCwgJ2JpbmQnKS5maWx0ZXIoYXR0ciA9PiBhdHRyLnZhbHVlID09PSAna2V5JylbMF07IC8vIElmIHRoZSBkZXYgaGFzbid0IHNwZWNpZmllZCBhIGtleSwganVzdCByZXR1cm4gdGhlIGluZGV4IG9mIHRoZSBpdGVyYXRpb24uXG5cbiAgICBpZiAoIWJpbmRLZXlBdHRyaWJ1dGUpIHJldHVybiBpbmRleDtcbiAgICByZXR1cm4gY29tcG9uZW50LmV2YWx1YXRlUmV0dXJuRXhwcmVzc2lvbihlbCwgYmluZEtleUF0dHJpYnV0ZS5leHByZXNzaW9uLCAoKSA9PiBpdGVyYXRpb25TY29wZVZhcmlhYmxlcyk7XG4gIH1cblxuICBmdW5jdGlvbiBldmFsdWF0ZUl0ZW1zQW5kUmV0dXJuRW1wdHlJZlhJZklzUHJlc2VudEFuZEZhbHNlT25FbGVtZW50KGNvbXBvbmVudCwgZWwsIGl0ZXJhdG9yTmFtZXMsIGV4dHJhVmFycykge1xuICAgIGxldCBpZkF0dHJpYnV0ZSA9IGdldFhBdHRycyhlbCwgY29tcG9uZW50LCAnaWYnKVswXTtcblxuICAgIGlmIChpZkF0dHJpYnV0ZSAmJiAhY29tcG9uZW50LmV2YWx1YXRlUmV0dXJuRXhwcmVzc2lvbihlbCwgaWZBdHRyaWJ1dGUuZXhwcmVzc2lvbikpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBsZXQgaXRlbXMgPSBjb21wb25lbnQuZXZhbHVhdGVSZXR1cm5FeHByZXNzaW9uKGVsLCBpdGVyYXRvck5hbWVzLml0ZW1zLCBleHRyYVZhcnMpOyAvLyBUaGlzIGFkZHMgc3VwcG9ydCBmb3IgdGhlIGBpIGluIG5gIHN5bnRheC5cblxuICAgIGlmIChpc051bWVyaWMoaXRlbXMpICYmIGl0ZW1zID49IDApIHtcbiAgICAgIGl0ZW1zID0gQXJyYXkuZnJvbShBcnJheShpdGVtcykua2V5cygpLCBpID0+IGkgKyAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRFbGVtZW50SW5Mb29wQWZ0ZXJDdXJyZW50RWwodGVtcGxhdGVFbCwgY3VycmVudEVsKSB7XG4gICAgbGV0IGNsb25lID0gZG9jdW1lbnQuaW1wb3J0Tm9kZSh0ZW1wbGF0ZUVsLmNvbnRlbnQsIHRydWUpO1xuICAgIGN1cnJlbnRFbC5wYXJlbnRFbGVtZW50Lmluc2VydEJlZm9yZShjbG9uZSwgY3VycmVudEVsLm5leHRFbGVtZW50U2libGluZyk7XG4gICAgcmV0dXJuIGN1cnJlbnRFbC5uZXh0RWxlbWVudFNpYmxpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBsb29rQWhlYWRGb3JNYXRjaGluZ0tleWVkRWxlbWVudEFuZE1vdmVJdElmRm91bmQobmV4dEVsLCBjdXJyZW50S2V5KSB7XG4gICAgaWYgKCFuZXh0RWwpIHJldHVybjsgLy8gSWYgd2UgYXJlIGFscmVhZHkgcGFzdCB0aGUgeC1mb3IgZ2VuZXJhdGVkIGVsZW1lbnRzLCB3ZSBkb24ndCBuZWVkIHRvIGxvb2sgYWhlYWQuXG5cbiAgICBpZiAobmV4dEVsLl9feF9mb3Jfa2V5ID09PSB1bmRlZmluZWQpIHJldHVybjsgLy8gSWYgdGhlIHRoZSBrZXkncyBETyBtYXRjaCwgbm8gbmVlZCB0byBsb29rIGFoZWFkLlxuXG4gICAgaWYgKG5leHRFbC5fX3hfZm9yX2tleSA9PT0gY3VycmVudEtleSkgcmV0dXJuIG5leHRFbDsgLy8gSWYgdGhleSBkb24ndCwgd2UnbGwgbG9vayBhaGVhZCBmb3IgYSBtYXRjaC5cbiAgICAvLyBJZiB3ZSBmaW5kIGl0LCB3ZSdsbCBtb3ZlIGl0IHRvIHRoZSBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBsb29wLlxuXG4gICAgbGV0IHRtcE5leHRFbCA9IG5leHRFbDtcblxuICAgIHdoaWxlICh0bXBOZXh0RWwpIHtcbiAgICAgIGlmICh0bXBOZXh0RWwuX194X2Zvcl9rZXkgPT09IGN1cnJlbnRLZXkpIHtcbiAgICAgICAgcmV0dXJuIHRtcE5leHRFbC5wYXJlbnRFbGVtZW50Lmluc2VydEJlZm9yZSh0bXBOZXh0RWwsIG5leHRFbCk7XG4gICAgICB9XG5cbiAgICAgIHRtcE5leHRFbCA9IHRtcE5leHRFbC5uZXh0RWxlbWVudFNpYmxpbmcgJiYgdG1wTmV4dEVsLm5leHRFbGVtZW50U2libGluZy5fX3hfZm9yX2tleSAhPT0gdW5kZWZpbmVkID8gdG1wTmV4dEVsLm5leHRFbGVtZW50U2libGluZyA6IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUFueUxlZnRPdmVyRWxlbWVudHNGcm9tUHJldmlvdXNVcGRhdGUoY3VycmVudEVsLCBjb21wb25lbnQpIHtcbiAgICB2YXIgbmV4dEVsZW1lbnRGcm9tT2xkTG9vcCA9IGN1cnJlbnRFbC5uZXh0RWxlbWVudFNpYmxpbmcgJiYgY3VycmVudEVsLm5leHRFbGVtZW50U2libGluZy5fX3hfZm9yX2tleSAhPT0gdW5kZWZpbmVkID8gY3VycmVudEVsLm5leHRFbGVtZW50U2libGluZyA6IGZhbHNlO1xuXG4gICAgd2hpbGUgKG5leHRFbGVtZW50RnJvbU9sZExvb3ApIHtcbiAgICAgIGxldCBuZXh0RWxlbWVudEZyb21PbGRMb29wSW1tdXRhYmxlID0gbmV4dEVsZW1lbnRGcm9tT2xkTG9vcDtcbiAgICAgIGxldCBuZXh0U2libGluZyA9IG5leHRFbGVtZW50RnJvbU9sZExvb3AubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgdHJhbnNpdGlvbk91dChuZXh0RWxlbWVudEZyb21PbGRMb29wLCAoKSA9PiB7XG4gICAgICAgIG5leHRFbGVtZW50RnJvbU9sZExvb3BJbW11dGFibGUucmVtb3ZlKCk7XG4gICAgICB9LCAoKSA9PiB7fSwgY29tcG9uZW50KTtcbiAgICAgIG5leHRFbGVtZW50RnJvbU9sZExvb3AgPSBuZXh0U2libGluZyAmJiBuZXh0U2libGluZy5fX3hfZm9yX2tleSAhPT0gdW5kZWZpbmVkID8gbmV4dFNpYmxpbmcgOiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVBdHRyaWJ1dGVCaW5kaW5nRGlyZWN0aXZlKGNvbXBvbmVudCwgZWwsIGF0dHJOYW1lLCBleHByZXNzaW9uLCBleHRyYVZhcnMsIGF0dHJUeXBlLCBtb2RpZmllcnMpIHtcbiAgICB2YXIgdmFsdWUgPSBjb21wb25lbnQuZXZhbHVhdGVSZXR1cm5FeHByZXNzaW9uKGVsLCBleHByZXNzaW9uLCBleHRyYVZhcnMpO1xuXG4gICAgaWYgKGF0dHJOYW1lID09PSAndmFsdWUnKSB7XG4gICAgICBpZiAoQWxwaW5lLmlnbm9yZUZvY3VzZWRGb3JWYWx1ZUJpbmRpbmcgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5pc1NhbWVOb2RlKGVsKSkgcmV0dXJuOyAvLyBJZiBuZXN0ZWQgbW9kZWwga2V5IGlzIHVuZGVmaW5lZCwgc2V0IHRoZSBkZWZhdWx0IHZhbHVlIHRvIGVtcHR5IHN0cmluZy5cblxuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgU3RyaW5nKGV4cHJlc3Npb24pLm1hdGNoKC9cXC4vKSkge1xuICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWwudHlwZSA9PT0gJ3JhZGlvJykge1xuICAgICAgICAvLyBTZXQgcmFkaW8gdmFsdWUgZnJvbSB4LWJpbmQ6dmFsdWUsIGlmIG5vIFwidmFsdWVcIiBhdHRyaWJ1dGUgZXhpc3RzLlxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgYW55IGluaXRpYWwgc3RhdGUgdmFsdWVzLCByYWRpbyB3aWxsIGhhdmUgYSBjb3JyZWN0XG4gICAgICAgIC8vIFwiY2hlY2tlZFwiIHZhbHVlIHNpbmNlIHgtYmluZDp2YWx1ZSBpcyBwcm9jZXNzZWQgYmVmb3JlIHgtbW9kZWwuXG4gICAgICAgIGlmIChlbC5hdHRyaWJ1dGVzLnZhbHVlID09PSB1bmRlZmluZWQgJiYgYXR0clR5cGUgPT09ICdiaW5kJykge1xuICAgICAgICAgIGVsLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoYXR0clR5cGUgIT09ICdiaW5kJykge1xuICAgICAgICAgIGVsLmNoZWNrZWQgPSBjaGVja2VkQXR0ckxvb3NlQ29tcGFyZShlbC52YWx1ZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVsLnR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICAgICAgLy8gSWYgd2UgYXJlIGV4cGxpY2l0bHkgYmluZGluZyBhIHN0cmluZyB0byB0aGUgOnZhbHVlLCBzZXQgdGhlIHN0cmluZyxcbiAgICAgICAgLy8gSWYgdGhlIHZhbHVlIGlzIGEgYm9vbGVhbiwgbGVhdmUgaXQgYWxvbmUsIGl0IHdpbGwgYmUgc2V0IHRvIFwib25cIlxuICAgICAgICAvLyBhdXRvbWF0aWNhbGx5LlxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicgJiYgIVtudWxsLCB1bmRlZmluZWRdLmluY2x1ZGVzKHZhbHVlKSAmJiBhdHRyVHlwZSA9PT0gJ2JpbmQnKSB7XG4gICAgICAgICAgZWwudmFsdWUgPSBTdHJpbmcodmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGF0dHJUeXBlICE9PSAnYmluZCcpIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIC8vIEknbSBwdXJwb3NlbHkgbm90IHVzaW5nIEFycmF5LmluY2x1ZGVzIGhlcmUgYmVjYXVzZSBpdCdzXG4gICAgICAgICAgICAvLyBzdHJpY3QsIGFuZCBiZWNhdXNlIG9mIE51bWVyaWMvU3RyaW5nIG1pcy1jYXN0aW5nLCBJXG4gICAgICAgICAgICAvLyB3YW50IHRoZSBcImluY2x1ZGVzXCIgdG8gYmUgXCJmdXp6eVwiLlxuICAgICAgICAgICAgZWwuY2hlY2tlZCA9IHZhbHVlLnNvbWUodmFsID0+IGNoZWNrZWRBdHRyTG9vc2VDb21wYXJlKHZhbCwgZWwudmFsdWUpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWwuY2hlY2tlZCA9ICEhdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVsLnRhZ05hbWUgPT09ICdTRUxFQ1QnKSB7XG4gICAgICAgIHVwZGF0ZVNlbGVjdChlbCwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGVsLnZhbHVlID09PSB2YWx1ZSkgcmV0dXJuO1xuICAgICAgICBlbC52YWx1ZSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXR0ck5hbWUgPT09ICdjbGFzcycpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBjb25zdCBvcmlnaW5hbENsYXNzZXMgPSBlbC5fX3hfb3JpZ2luYWxfY2xhc3NlcyB8fCBbXTtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGFycmF5VW5pcXVlKG9yaWdpbmFsQ2xhc3Nlcy5jb25jYXQodmFsdWUpKS5qb2luKCcgJykpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIFNvcnRpbmcgdGhlIGtleXMgLyBjbGFzcyBuYW1lcyBieSB0aGVpciBib29sZWFuIHZhbHVlIHdpbGwgZW5zdXJlIHRoYXRcbiAgICAgICAgLy8gYW55dGhpbmcgdGhhdCBldmFsdWF0ZXMgdG8gYGZhbHNlYCBhbmQgbmVlZHMgdG8gcmVtb3ZlIGNsYXNzZXMgaXMgcnVuIGZpcnN0LlxuICAgICAgICBjb25zdCBrZXlzU29ydGVkQnlCb29sZWFuVmFsdWUgPSBPYmplY3Qua2V5cyh2YWx1ZSkuc29ydCgoYSwgYikgPT4gdmFsdWVbYV0gLSB2YWx1ZVtiXSk7XG4gICAgICAgIGtleXNTb3J0ZWRCeUJvb2xlYW5WYWx1ZS5mb3JFYWNoKGNsYXNzTmFtZXMgPT4ge1xuICAgICAgICAgIGlmICh2YWx1ZVtjbGFzc05hbWVzXSkge1xuICAgICAgICAgICAgY29udmVydENsYXNzU3RyaW5nVG9BcnJheShjbGFzc05hbWVzKS5mb3JFYWNoKGNsYXNzTmFtZSA9PiBlbC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb252ZXJ0Q2xhc3NTdHJpbmdUb0FycmF5KGNsYXNzTmFtZXMpLmZvckVhY2goY2xhc3NOYW1lID0+IGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsQ2xhc3NlcyA9IGVsLl9feF9vcmlnaW5hbF9jbGFzc2VzIHx8IFtdO1xuICAgICAgICBjb25zdCBuZXdDbGFzc2VzID0gdmFsdWUgPyBjb252ZXJ0Q2xhc3NTdHJpbmdUb0FycmF5KHZhbHVlKSA6IFtdO1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgYXJyYXlVbmlxdWUob3JpZ2luYWxDbGFzc2VzLmNvbmNhdChuZXdDbGFzc2VzKSkuam9pbignICcpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYXR0ck5hbWUgPSBtb2RpZmllcnMuaW5jbHVkZXMoJ2NhbWVsJykgPyBjYW1lbENhc2UoYXR0ck5hbWUpIDogYXR0ck5hbWU7IC8vIElmIGFuIGF0dHJpYnV0ZSdzIGJvdW5kIHZhbHVlIGlzIG51bGwsIHVuZGVmaW5lZCBvciBmYWxzZSwgcmVtb3ZlIHRoZSBhdHRyaWJ1dGVcblxuICAgICAgaWYgKFtudWxsLCB1bmRlZmluZWQsIGZhbHNlXS5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlzQm9vbGVhbkF0dHIoYXR0ck5hbWUpID8gc2V0SWZDaGFuZ2VkKGVsLCBhdHRyTmFtZSwgYXR0ck5hbWUpIDogc2V0SWZDaGFuZ2VkKGVsLCBhdHRyTmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldElmQ2hhbmdlZChlbCwgYXR0ck5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKGVsLmdldEF0dHJpYnV0ZShhdHRyTmFtZSkgIT0gdmFsdWUpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVNlbGVjdChlbCwgdmFsdWUpIHtcbiAgICBjb25zdCBhcnJheVdyYXBwZWRWYWx1ZSA9IFtdLmNvbmNhdCh2YWx1ZSkubWFwKHZhbHVlID0+IHtcbiAgICAgIHJldHVybiB2YWx1ZSArICcnO1xuICAgIH0pO1xuICAgIEFycmF5LmZyb20oZWwub3B0aW9ucykuZm9yRWFjaChvcHRpb24gPT4ge1xuICAgICAgb3B0aW9uLnNlbGVjdGVkID0gYXJyYXlXcmFwcGVkVmFsdWUuaW5jbHVkZXMob3B0aW9uLnZhbHVlIHx8IG9wdGlvbi50ZXh0KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVRleHREaXJlY3RpdmUoZWwsIG91dHB1dCwgZXhwcmVzc2lvbikge1xuICAgIC8vIElmIG5lc3RlZCBtb2RlbCBrZXkgaXMgdW5kZWZpbmVkLCBzZXQgdGhlIGRlZmF1bHQgdmFsdWUgdG8gZW1wdHkgc3RyaW5nLlxuICAgIGlmIChvdXRwdXQgPT09IHVuZGVmaW5lZCAmJiBTdHJpbmcoZXhwcmVzc2lvbikubWF0Y2goL1xcLi8pKSB7XG4gICAgICBvdXRwdXQgPSAnJztcbiAgICB9XG5cbiAgICBlbC50ZXh0Q29udGVudCA9IG91dHB1dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUh0bWxEaXJlY3RpdmUoY29tcG9uZW50LCBlbCwgZXhwcmVzc2lvbiwgZXh0cmFWYXJzKSB7XG4gICAgZWwuaW5uZXJIVE1MID0gY29tcG9uZW50LmV2YWx1YXRlUmV0dXJuRXhwcmVzc2lvbihlbCwgZXhwcmVzc2lvbiwgZXh0cmFWYXJzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVNob3dEaXJlY3RpdmUoY29tcG9uZW50LCBlbCwgdmFsdWUsIG1vZGlmaWVycywgaW5pdGlhbFVwZGF0ZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgaGlkZSA9ICgpID0+IHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICBlbC5fX3hfaXNfc2hvd24gPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgY29uc3Qgc2hvdyA9ICgpID0+IHtcbiAgICAgIGlmIChlbC5zdHlsZS5sZW5ndGggPT09IDEgJiYgZWwuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnKSB7XG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsLnN0eWxlLnJlbW92ZVByb3BlcnR5KCdkaXNwbGF5Jyk7XG4gICAgICB9XG5cbiAgICAgIGVsLl9feF9pc19zaG93biA9IHRydWU7XG4gICAgfTtcblxuICAgIGlmIChpbml0aWFsVXBkYXRlID09PSB0cnVlKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgc2hvdygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGlkZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgaGFuZGxlID0gKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGlmIChlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgfHwgZWwuX194X3RyYW5zaXRpb24pIHtcbiAgICAgICAgICB0cmFuc2l0aW9uSW4oZWwsICgpID0+IHtcbiAgICAgICAgICAgIHNob3coKTtcbiAgICAgICAgICB9LCByZWplY3QsIGNvbXBvbmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXNvbHZlKCgpID0+IHt9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChlbC5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZScpIHtcbiAgICAgICAgICB0cmFuc2l0aW9uT3V0KGVsLCAoKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKCgpID0+IHtcbiAgICAgICAgICAgICAgaGlkZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSwgcmVqZWN0LCBjb21wb25lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUoKCkgPT4ge30pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTsgLy8gVGhlIHdvcmtpbmcgb2YgeC1zaG93IGlzIGEgYml0IGNvbXBsZXggYmVjYXVzZSB3ZSBuZWVkIHRvXG4gICAgLy8gd2FpdCBmb3IgYW55IGNoaWxkIHRyYW5zaXRpb25zIHRvIGZpbmlzaCBiZWZvcmUgaGlkaW5nXG4gICAgLy8gc29tZSBlbGVtZW50LiBBbHNvLCB0aGlzIGhhcyB0byBiZSBkb25lIHJlY3Vyc2l2ZWx5LlxuICAgIC8vIElmIHgtc2hvdy5pbW1lZGlhdGUsIGZvcmVnb2UgdGhlIHdhaXRpbmcuXG5cblxuICAgIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoJ2ltbWVkaWF0ZScpKSB7XG4gICAgICBoYW5kbGUoZmluaXNoID0+IGZpbmlzaCgpLCAoKSA9PiB7fSk7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyB4LXNob3cgaXMgZW5jb3VudGVyZWQgZHVyaW5nIGEgRE9NIHRyZWUgd2Fsay4gSWYgYW4gZWxlbWVudFxuICAgIC8vIHdlIGVuY291bnRlciBpcyBOT1QgYSBjaGlsZCBvZiBhbm90aGVyIHgtc2hvdyBlbGVtZW50IHdlXG4gICAgLy8gY2FuIGV4ZWN1dGUgdGhlIHByZXZpb3VzIHgtc2hvdyBzdGFjayAoaWYgb25lIGV4aXN0cykuXG5cblxuICAgIGlmIChjb21wb25lbnQuc2hvd0RpcmVjdGl2ZUxhc3RFbGVtZW50ICYmICFjb21wb25lbnQuc2hvd0RpcmVjdGl2ZUxhc3RFbGVtZW50LmNvbnRhaW5zKGVsKSkge1xuICAgICAgY29tcG9uZW50LmV4ZWN1dGVBbmRDbGVhclJlbWFpbmluZ1Nob3dEaXJlY3RpdmVTdGFjaygpO1xuICAgIH1cblxuICAgIGNvbXBvbmVudC5zaG93RGlyZWN0aXZlU3RhY2sucHVzaChoYW5kbGUpO1xuICAgIGNvbXBvbmVudC5zaG93RGlyZWN0aXZlTGFzdEVsZW1lbnQgPSBlbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUlmRGlyZWN0aXZlKGNvbXBvbmVudCwgZWwsIGV4cHJlc3Npb25SZXN1bHQsIGluaXRpYWxVcGRhdGUsIGV4dHJhVmFycykge1xuICAgIHdhcm5JZk1hbGZvcm1lZFRlbXBsYXRlKGVsLCAneC1pZicpO1xuICAgIGNvbnN0IGVsZW1lbnRIYXNBbHJlYWR5QmVlbkFkZGVkID0gZWwubmV4dEVsZW1lbnRTaWJsaW5nICYmIGVsLm5leHRFbGVtZW50U2libGluZy5fX3hfaW5zZXJ0ZWRfbWUgPT09IHRydWU7XG5cbiAgICBpZiAoZXhwcmVzc2lvblJlc3VsdCAmJiAoIWVsZW1lbnRIYXNBbHJlYWR5QmVlbkFkZGVkIHx8IGVsLl9feF90cmFuc2l0aW9uKSkge1xuICAgICAgY29uc3QgY2xvbmUgPSBkb2N1bWVudC5pbXBvcnROb2RlKGVsLmNvbnRlbnQsIHRydWUpO1xuICAgICAgZWwucGFyZW50RWxlbWVudC5pbnNlcnRCZWZvcmUoY2xvbmUsIGVsLm5leHRFbGVtZW50U2libGluZyk7XG4gICAgICB0cmFuc2l0aW9uSW4oZWwubmV4dEVsZW1lbnRTaWJsaW5nLCAoKSA9PiB7fSwgKCkgPT4ge30sIGNvbXBvbmVudCwgaW5pdGlhbFVwZGF0ZSk7XG4gICAgICBjb21wb25lbnQuaW5pdGlhbGl6ZUVsZW1lbnRzKGVsLm5leHRFbGVtZW50U2libGluZywgZXh0cmFWYXJzKTtcbiAgICAgIGVsLm5leHRFbGVtZW50U2libGluZy5fX3hfaW5zZXJ0ZWRfbWUgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoIWV4cHJlc3Npb25SZXN1bHQgJiYgZWxlbWVudEhhc0FscmVhZHlCZWVuQWRkZWQpIHtcbiAgICAgIHRyYW5zaXRpb25PdXQoZWwubmV4dEVsZW1lbnRTaWJsaW5nLCAoKSA9PiB7XG4gICAgICAgIGVsLm5leHRFbGVtZW50U2libGluZy5yZW1vdmUoKTtcbiAgICAgIH0sICgpID0+IHt9LCBjb21wb25lbnQsIGluaXRpYWxVcGRhdGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyTGlzdGVuZXIoY29tcG9uZW50LCBlbCwgZXZlbnQsIG1vZGlmaWVycywgZXhwcmVzc2lvbiwgZXh0cmFWYXJzID0ge30pIHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgcGFzc2l2ZTogbW9kaWZpZXJzLmluY2x1ZGVzKCdwYXNzaXZlJylcbiAgICB9O1xuXG4gICAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcygnY2FtZWwnKSkge1xuICAgICAgZXZlbnQgPSBjYW1lbENhc2UoZXZlbnQpO1xuICAgIH1cblxuICAgIGxldCBoYW5kbGVyLCBsaXN0ZW5lclRhcmdldDtcblxuICAgIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoJ2F3YXknKSkge1xuICAgICAgbGlzdGVuZXJUYXJnZXQgPSBkb2N1bWVudDtcblxuICAgICAgaGFuZGxlciA9IGUgPT4ge1xuICAgICAgICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiB0aGUgY2xpY2sgY2FtZSBmcm9tIHRoZSBlbGVtZW50IG9yIHdpdGhpbiBpdC5cbiAgICAgICAgaWYgKGVsLmNvbnRhaW5zKGUudGFyZ2V0KSkgcmV0dXJuOyAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiB0aGlzIGVsZW1lbnQgaXNuJ3QgY3VycmVudGx5IHZpc2libGUuXG5cbiAgICAgICAgaWYgKGVsLm9mZnNldFdpZHRoIDwgMSAmJiBlbC5vZmZzZXRIZWlnaHQgPCAxKSByZXR1cm47IC8vIE5vdyB0aGF0IHdlIGFyZSBzdXJlIHRoZSBlbGVtZW50IGlzIHZpc2libGUsIEFORCB0aGUgY2xpY2tcbiAgICAgICAgLy8gaXMgZnJvbSBvdXRzaWRlIGl0LCBsZXQncyBydW4gdGhlIGV4cHJlc3Npb24uXG5cbiAgICAgICAgcnVuTGlzdGVuZXJIYW5kbGVyKGNvbXBvbmVudCwgZXhwcmVzc2lvbiwgZSwgZXh0cmFWYXJzKTtcblxuICAgICAgICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKCdvbmNlJykpIHtcbiAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdGVuZXJUYXJnZXQgPSBtb2RpZmllcnMuaW5jbHVkZXMoJ3dpbmRvdycpID8gd2luZG93IDogbW9kaWZpZXJzLmluY2x1ZGVzKCdkb2N1bWVudCcpID8gZG9jdW1lbnQgOiBlbDtcblxuICAgICAgaGFuZGxlciA9IGUgPT4ge1xuICAgICAgICAvLyBSZW1vdmUgdGhpcyBnbG9iYWwgZXZlbnQgaGFuZGxlciBpZiB0aGUgZWxlbWVudCB0aGF0IGRlY2xhcmVkIGl0XG4gICAgICAgIC8vIGhhcyBiZWVuIHJlbW92ZWQuIEl0J3Mgbm93IHN0YWxlLlxuICAgICAgICBpZiAobGlzdGVuZXJUYXJnZXQgPT09IHdpbmRvdyB8fCBsaXN0ZW5lclRhcmdldCA9PT0gZG9jdW1lbnQpIHtcbiAgICAgICAgICBpZiAoIWRvY3VtZW50LmJvZHkuY29udGFpbnMoZWwpKSB7XG4gICAgICAgICAgICBsaXN0ZW5lclRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNLZXlFdmVudChldmVudCkpIHtcbiAgICAgICAgICBpZiAoaXNMaXN0ZW5pbmdGb3JBU3BlY2lmaWNLZXlUaGF0SGFzbnRCZWVuUHJlc3NlZChlLCBtb2RpZmllcnMpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcygncHJldmVudCcpKSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoJ3N0b3AnKSkgZS5zdG9wUHJvcGFnYXRpb24oKTsgLy8gSWYgdGhlIC5zZWxmIG1vZGlmaWVyIGlzbid0IHByZXNlbnQsIG9yIGlmIGl0IGlzIHByZXNlbnQgYW5kXG4gICAgICAgIC8vIHRoZSB0YXJnZXQgZWxlbWVudCBtYXRjaGVzIHRoZSBlbGVtZW50IHdlIGFyZSByZWdpc3RlcmluZyB0aGVcbiAgICAgICAgLy8gZXZlbnQgb24sIHJ1biB0aGUgaGFuZGxlclxuXG4gICAgICAgIGlmICghbW9kaWZpZXJzLmluY2x1ZGVzKCdzZWxmJykgfHwgZS50YXJnZXQgPT09IGVsKSB7XG4gICAgICAgICAgY29uc3QgcmV0dXJuVmFsdWUgPSBydW5MaXN0ZW5lckhhbmRsZXIoY29tcG9uZW50LCBleHByZXNzaW9uLCBlLCBleHRyYVZhcnMpO1xuICAgICAgICAgIHJldHVyblZhbHVlLnRoZW4odmFsdWUgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKCdvbmNlJykpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lclRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoJ2RlYm91bmNlJykpIHtcbiAgICAgIGxldCBuZXh0TW9kaWZpZXIgPSBtb2RpZmllcnNbbW9kaWZpZXJzLmluZGV4T2YoJ2RlYm91bmNlJykgKyAxXSB8fCAnaW52YWxpZC13YWl0JztcbiAgICAgIGxldCB3YWl0ID0gaXNOdW1lcmljKG5leHRNb2RpZmllci5zcGxpdCgnbXMnKVswXSkgPyBOdW1iZXIobmV4dE1vZGlmaWVyLnNwbGl0KCdtcycpWzBdKSA6IDI1MDtcbiAgICAgIGhhbmRsZXIgPSBkZWJvdW5jZShoYW5kbGVyLCB3YWl0KTtcbiAgICB9XG5cbiAgICBsaXN0ZW5lclRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJ1bkxpc3RlbmVySGFuZGxlcihjb21wb25lbnQsIGV4cHJlc3Npb24sIGUsIGV4dHJhVmFycykge1xuICAgIHJldHVybiBjb21wb25lbnQuZXZhbHVhdGVDb21tYW5kRXhwcmVzc2lvbihlLnRhcmdldCwgZXhwcmVzc2lvbiwgKCkgPT4ge1xuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBleHRyYVZhcnMoKSksIHt9LCB7XG4gICAgICAgICckZXZlbnQnOiBlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzS2V5RXZlbnQoZXZlbnQpIHtcbiAgICByZXR1cm4gWydrZXlkb3duJywgJ2tleXVwJ10uaW5jbHVkZXMoZXZlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNMaXN0ZW5pbmdGb3JBU3BlY2lmaWNLZXlUaGF0SGFzbnRCZWVuUHJlc3NlZChlLCBtb2RpZmllcnMpIHtcbiAgICBsZXQga2V5TW9kaWZpZXJzID0gbW9kaWZpZXJzLmZpbHRlcihpID0+IHtcbiAgICAgIHJldHVybiAhWyd3aW5kb3cnLCAnZG9jdW1lbnQnLCAncHJldmVudCcsICdzdG9wJ10uaW5jbHVkZXMoaSk7XG4gICAgfSk7XG5cbiAgICBpZiAoa2V5TW9kaWZpZXJzLmluY2x1ZGVzKCdkZWJvdW5jZScpKSB7XG4gICAgICBsZXQgZGVib3VuY2VJbmRleCA9IGtleU1vZGlmaWVycy5pbmRleE9mKCdkZWJvdW5jZScpO1xuICAgICAga2V5TW9kaWZpZXJzLnNwbGljZShkZWJvdW5jZUluZGV4LCBpc051bWVyaWMoKGtleU1vZGlmaWVyc1tkZWJvdW5jZUluZGV4ICsgMV0gfHwgJ2ludmFsaWQtd2FpdCcpLnNwbGl0KCdtcycpWzBdKSA/IDIgOiAxKTtcbiAgICB9IC8vIElmIG5vIG1vZGlmaWVyIGlzIHNwZWNpZmllZCwgd2UnbGwgY2FsbCBpdCBhIHByZXNzLlxuXG5cbiAgICBpZiAoa2V5TW9kaWZpZXJzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlOyAvLyBJZiBvbmUgaXMgcGFzc2VkLCBBTkQgaXQgbWF0Y2hlcyB0aGUga2V5IHByZXNzZWQsIHdlJ2xsIGNhbGwgaXQgYSBwcmVzcy5cblxuICAgIGlmIChrZXlNb2RpZmllcnMubGVuZ3RoID09PSAxICYmIGtleU1vZGlmaWVyc1swXSA9PT0ga2V5VG9Nb2RpZmllcihlLmtleSkpIHJldHVybiBmYWxzZTsgLy8gVGhlIHVzZXIgaXMgbGlzdGVuaW5nIGZvciBrZXkgY29tYmluYXRpb25zLlxuXG4gICAgY29uc3Qgc3lzdGVtS2V5TW9kaWZpZXJzID0gWydjdHJsJywgJ3NoaWZ0JywgJ2FsdCcsICdtZXRhJywgJ2NtZCcsICdzdXBlciddO1xuICAgIGNvbnN0IHNlbGVjdGVkU3lzdGVtS2V5TW9kaWZpZXJzID0gc3lzdGVtS2V5TW9kaWZpZXJzLmZpbHRlcihtb2RpZmllciA9PiBrZXlNb2RpZmllcnMuaW5jbHVkZXMobW9kaWZpZXIpKTtcbiAgICBrZXlNb2RpZmllcnMgPSBrZXlNb2RpZmllcnMuZmlsdGVyKGkgPT4gIXNlbGVjdGVkU3lzdGVtS2V5TW9kaWZpZXJzLmluY2x1ZGVzKGkpKTtcblxuICAgIGlmIChzZWxlY3RlZFN5c3RlbUtleU1vZGlmaWVycy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBhY3RpdmVseVByZXNzZWRLZXlNb2RpZmllcnMgPSBzZWxlY3RlZFN5c3RlbUtleU1vZGlmaWVycy5maWx0ZXIobW9kaWZpZXIgPT4ge1xuICAgICAgICAvLyBBbGlhcyBcImNtZFwiIGFuZCBcInN1cGVyXCIgdG8gXCJtZXRhXCJcbiAgICAgICAgaWYgKG1vZGlmaWVyID09PSAnY21kJyB8fCBtb2RpZmllciA9PT0gJ3N1cGVyJykgbW9kaWZpZXIgPSAnbWV0YSc7XG4gICAgICAgIHJldHVybiBlW2Ake21vZGlmaWVyfUtleWBdO1xuICAgICAgfSk7IC8vIElmIGFsbCB0aGUgbW9kaWZpZXJzIHNlbGVjdGVkIGFyZSBwcmVzc2VkLCAuLi5cblxuICAgICAgaWYgKGFjdGl2ZWx5UHJlc3NlZEtleU1vZGlmaWVycy5sZW5ndGggPT09IHNlbGVjdGVkU3lzdGVtS2V5TW9kaWZpZXJzLmxlbmd0aCkge1xuICAgICAgICAvLyBBTkQgdGhlIHJlbWFpbmluZyBrZXkgaXMgcHJlc3NlZCBhcyB3ZWxsLiBJdCdzIGEgcHJlc3MuXG4gICAgICAgIGlmIChrZXlNb2RpZmllcnNbMF0gPT09IGtleVRvTW9kaWZpZXIoZS5rZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSAvLyBXZSdsbCBjYWxsIGl0IE5PVCBhIHZhbGlkIGtleXByZXNzLlxuXG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGtleVRvTW9kaWZpZXIoa2V5KSB7XG4gICAgc3dpdGNoIChrZXkpIHtcbiAgICAgIGNhc2UgJy8nOlxuICAgICAgICByZXR1cm4gJ3NsYXNoJztcblxuICAgICAgY2FzZSAnICc6XG4gICAgICBjYXNlICdTcGFjZWJhcic6XG4gICAgICAgIHJldHVybiAnc3BhY2UnO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4ga2V5ICYmIGtlYmFiQ2FzZShrZXkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyTW9kZWxMaXN0ZW5lcihjb21wb25lbnQsIGVsLCBtb2RpZmllcnMsIGV4cHJlc3Npb24sIGV4dHJhVmFycykge1xuICAgIC8vIElmIHRoZSBlbGVtZW50IHdlIGFyZSBiaW5kaW5nIHRvIGlzIGEgc2VsZWN0LCBhIHJhZGlvLCBvciBjaGVja2JveFxuICAgIC8vIHdlJ2xsIGxpc3RlbiBmb3IgdGhlIGNoYW5nZSBldmVudCBpbnN0ZWFkIG9mIHRoZSBcImlucHV0XCIgZXZlbnQuXG4gICAgdmFyIGV2ZW50ID0gZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc2VsZWN0JyB8fCBbJ2NoZWNrYm94JywgJ3JhZGlvJ10uaW5jbHVkZXMoZWwudHlwZSkgfHwgbW9kaWZpZXJzLmluY2x1ZGVzKCdsYXp5JykgPyAnY2hhbmdlJyA6ICdpbnB1dCc7XG4gICAgY29uc3QgbGlzdGVuZXJFeHByZXNzaW9uID0gYCR7ZXhwcmVzc2lvbn0gPSByaWdodFNpZGVPZkV4cHJlc3Npb24oJGV2ZW50LCAke2V4cHJlc3Npb259KWA7XG4gICAgcmVnaXN0ZXJMaXN0ZW5lcihjb21wb25lbnQsIGVsLCBldmVudCwgbW9kaWZpZXJzLCBsaXN0ZW5lckV4cHJlc3Npb24sICgpID0+IHtcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZXh0cmFWYXJzKCkpLCB7fSwge1xuICAgICAgICByaWdodFNpZGVPZkV4cHJlc3Npb246IGdlbmVyYXRlTW9kZWxBc3NpZ25tZW50RnVuY3Rpb24oZWwsIG1vZGlmaWVycywgZXhwcmVzc2lvbilcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVNb2RlbEFzc2lnbm1lbnRGdW5jdGlvbihlbCwgbW9kaWZpZXJzLCBleHByZXNzaW9uKSB7XG4gICAgaWYgKGVsLnR5cGUgPT09ICdyYWRpbycpIHtcbiAgICAgIC8vIFJhZGlvIGJ1dHRvbnMgb25seSB3b3JrIHByb3Blcmx5IHdoZW4gdGhleSBzaGFyZSBhIG5hbWUgYXR0cmlidXRlLlxuICAgICAgLy8gUGVvcGxlIG1pZ2h0IGFzc3VtZSB3ZSB0YWtlIGNhcmUgb2YgdGhhdCBmb3IgdGhlbSwgYmVjYXVzZVxuICAgICAgLy8gdGhleSBhbHJlYWR5IHNldCBhIHNoYXJlZCBcIngtbW9kZWxcIiBhdHRyaWJ1dGUuXG4gICAgICBpZiAoIWVsLmhhc0F0dHJpYnV0ZSgnbmFtZScpKSBlbC5zZXRBdHRyaWJ1dGUoJ25hbWUnLCBleHByZXNzaW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKGV2ZW50LCBjdXJyZW50VmFsdWUpID0+IHtcbiAgICAgIC8vIENoZWNrIGZvciBldmVudC5kZXRhaWwgZHVlIHRvIGFuIGlzc3VlIHdoZXJlIElFMTEgaGFuZGxlcyBvdGhlciBldmVudHMgYXMgYSBDdXN0b21FdmVudC5cbiAgICAgIGlmIChldmVudCBpbnN0YW5jZW9mIEN1c3RvbUV2ZW50ICYmIGV2ZW50LmRldGFpbCkge1xuICAgICAgICByZXR1cm4gZXZlbnQuZGV0YWlsO1xuICAgICAgfSBlbHNlIGlmIChlbC50eXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgICAgIC8vIElmIHRoZSBkYXRhIHdlIGFyZSBiaW5kaW5nIHRvIGlzIGFuIGFycmF5LCB0b2dnbGUgaXRzIHZhbHVlIGluc2lkZSB0aGUgYXJyYXkuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnRWYWx1ZSkpIHtcbiAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IG1vZGlmaWVycy5pbmNsdWRlcygnbnVtYmVyJykgPyBzYWZlUGFyc2VOdW1iZXIoZXZlbnQudGFyZ2V0LnZhbHVlKSA6IGV2ZW50LnRhcmdldC52YWx1ZTtcbiAgICAgICAgICByZXR1cm4gZXZlbnQudGFyZ2V0LmNoZWNrZWQgPyBjdXJyZW50VmFsdWUuY29uY2F0KFtuZXdWYWx1ZV0pIDogY3VycmVudFZhbHVlLmZpbHRlcihlbCA9PiAhY2hlY2tlZEF0dHJMb29zZUNvbXBhcmUoZWwsIG5ld1ZhbHVlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGV2ZW50LnRhcmdldC5jaGVja2VkO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3NlbGVjdCcgJiYgZWwubXVsdGlwbGUpIHtcbiAgICAgICAgcmV0dXJuIG1vZGlmaWVycy5pbmNsdWRlcygnbnVtYmVyJykgPyBBcnJheS5mcm9tKGV2ZW50LnRhcmdldC5zZWxlY3RlZE9wdGlvbnMpLm1hcChvcHRpb24gPT4ge1xuICAgICAgICAgIGNvbnN0IHJhd1ZhbHVlID0gb3B0aW9uLnZhbHVlIHx8IG9wdGlvbi50ZXh0O1xuICAgICAgICAgIHJldHVybiBzYWZlUGFyc2VOdW1iZXIocmF3VmFsdWUpO1xuICAgICAgICB9KSA6IEFycmF5LmZyb20oZXZlbnQudGFyZ2V0LnNlbGVjdGVkT3B0aW9ucykubWFwKG9wdGlvbiA9PiB7XG4gICAgICAgICAgcmV0dXJuIG9wdGlvbi52YWx1ZSB8fCBvcHRpb24udGV4dDtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCByYXdWYWx1ZSA9IGV2ZW50LnRhcmdldC52YWx1ZTtcbiAgICAgICAgcmV0dXJuIG1vZGlmaWVycy5pbmNsdWRlcygnbnVtYmVyJykgPyBzYWZlUGFyc2VOdW1iZXIocmF3VmFsdWUpIDogbW9kaWZpZXJzLmluY2x1ZGVzKCd0cmltJykgPyByYXdWYWx1ZS50cmltKCkgOiByYXdWYWx1ZTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc2FmZVBhcnNlTnVtYmVyKHJhd1ZhbHVlKSB7XG4gICAgY29uc3QgbnVtYmVyID0gcmF3VmFsdWUgPyBwYXJzZUZsb2F0KHJhd1ZhbHVlKSA6IG51bGw7XG4gICAgcmV0dXJuIGlzTnVtZXJpYyhudW1iZXIpID8gbnVtYmVyIDogcmF3VmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQ29weXJpZ2h0IChDKSAyMDE3IHNhbGVzZm9yY2UuY29tLCBpbmMuXG4gICAqL1xuICBjb25zdCB7IGlzQXJyYXkgfSA9IEFycmF5O1xuICBjb25zdCB7IGdldFByb3RvdHlwZU9mLCBjcmVhdGU6IE9iamVjdENyZWF0ZSwgZGVmaW5lUHJvcGVydHk6IE9iamVjdERlZmluZVByb3BlcnR5LCBkZWZpbmVQcm9wZXJ0aWVzOiBPYmplY3REZWZpbmVQcm9wZXJ0aWVzLCBpc0V4dGVuc2libGUsIGdldE93blByb3BlcnR5RGVzY3JpcHRvciwgZ2V0T3duUHJvcGVydHlOYW1lcywgZ2V0T3duUHJvcGVydHlTeW1ib2xzLCBwcmV2ZW50RXh0ZW5zaW9ucywgaGFzT3duUHJvcGVydHksIH0gPSBPYmplY3Q7XG4gIGNvbnN0IHsgcHVzaDogQXJyYXlQdXNoLCBjb25jYXQ6IEFycmF5Q29uY2F0LCBtYXA6IEFycmF5TWFwLCB9ID0gQXJyYXkucHJvdG90eXBlO1xuICBmdW5jdGlvbiBpc1VuZGVmaW5lZChvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT09IHVuZGVmaW5lZDtcbiAgfVxuICBmdW5jdGlvbiBpc0Z1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbic7XG4gIH1cbiAgZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCc7XG4gIH1cbiAgY29uc3QgcHJveHlUb1ZhbHVlTWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgZnVuY3Rpb24gcmVnaXN0ZXJQcm94eShwcm94eSwgdmFsdWUpIHtcbiAgICAgIHByb3h5VG9WYWx1ZU1hcC5zZXQocHJveHksIHZhbHVlKTtcbiAgfVxuICBjb25zdCB1bndyYXAgPSAocmVwbGljYU9yQW55KSA9PiBwcm94eVRvVmFsdWVNYXAuZ2V0KHJlcGxpY2FPckFueSkgfHwgcmVwbGljYU9yQW55O1xuXG4gIGZ1bmN0aW9uIHdyYXBWYWx1ZShtZW1icmFuZSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBtZW1icmFuZS52YWx1ZUlzT2JzZXJ2YWJsZSh2YWx1ZSkgPyBtZW1icmFuZS5nZXRQcm94eSh2YWx1ZSkgOiB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVW53cmFwIHByb3BlcnR5IGRlc2NyaXB0b3JzIHdpbGwgc2V0IHZhbHVlIG9uIG9yaWdpbmFsIGRlc2NyaXB0b3JcbiAgICogV2Ugb25seSBuZWVkIHRvIHVud3JhcCBpZiB2YWx1ZSBpcyBzcGVjaWZpZWRcbiAgICogQHBhcmFtIGRlc2NyaXB0b3IgZXh0ZXJuYWwgZGVzY3JwaXRvciBwcm92aWRlZCB0byBkZWZpbmUgbmV3IHByb3BlcnR5IG9uIG9yaWdpbmFsIHZhbHVlXG4gICAqL1xuICBmdW5jdGlvbiB1bndyYXBEZXNjcmlwdG9yKGRlc2NyaXB0b3IpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGRlc2NyaXB0b3IsICd2YWx1ZScpKSB7XG4gICAgICAgICAgZGVzY3JpcHRvci52YWx1ZSA9IHVud3JhcChkZXNjcmlwdG9yLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXNjcmlwdG9yO1xuICB9XG4gIGZ1bmN0aW9uIGxvY2tTaGFkb3dUYXJnZXQobWVtYnJhbmUsIHNoYWRvd1RhcmdldCwgb3JpZ2luYWxUYXJnZXQpIHtcbiAgICAgIGNvbnN0IHRhcmdldEtleXMgPSBBcnJheUNvbmNhdC5jYWxsKGdldE93blByb3BlcnR5TmFtZXMob3JpZ2luYWxUYXJnZXQpLCBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMob3JpZ2luYWxUYXJnZXQpKTtcbiAgICAgIHRhcmdldEtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgbGV0IGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob3JpZ2luYWxUYXJnZXQsIGtleSk7XG4gICAgICAgICAgLy8gV2UgZG8gbm90IG5lZWQgdG8gd3JhcCB0aGUgZGVzY3JpcHRvciBpZiBjb25maWd1cmFibGVcbiAgICAgICAgICAvLyBCZWNhdXNlIHdlIGNhbiBkZWFsIHdpdGggd3JhcHBpbmcgaXQgd2hlbiB1c2VyIGdvZXMgdGhyb3VnaFxuICAgICAgICAgIC8vIEdldCBvd24gcHJvcGVydHkgZGVzY3JpcHRvci4gVGhlcmUgaXMgYWxzbyBhIGNoYW5jZSB0aGF0IHRoaXMgZGVzY3JpcHRvclxuICAgICAgICAgIC8vIGNvdWxkIGNoYW5nZSBzb21ldGltZSBpbiB0aGUgZnV0dXJlLCBzbyB3ZSBjYW4gZGVmZXIgd3JhcHBpbmdcbiAgICAgICAgICAvLyB1bnRpbCB3ZSBuZWVkIHRvXG4gICAgICAgICAgaWYgKCFkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuICAgICAgICAgICAgICBkZXNjcmlwdG9yID0gd3JhcERlc2NyaXB0b3IobWVtYnJhbmUsIGRlc2NyaXB0b3IsIHdyYXBWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIE9iamVjdERlZmluZVByb3BlcnR5KHNoYWRvd1RhcmdldCwga2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgIH0pO1xuICAgICAgcHJldmVudEV4dGVuc2lvbnMoc2hhZG93VGFyZ2V0KTtcbiAgfVxuICBjbGFzcyBSZWFjdGl2ZVByb3h5SGFuZGxlciB7XG4gICAgICBjb25zdHJ1Y3RvcihtZW1icmFuZSwgdmFsdWUpIHtcbiAgICAgICAgICB0aGlzLm9yaWdpbmFsVGFyZ2V0ID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5tZW1icmFuZSA9IG1lbWJyYW5lO1xuICAgICAgfVxuICAgICAgZ2V0KHNoYWRvd1RhcmdldCwga2V5KSB7XG4gICAgICAgICAgY29uc3QgeyBvcmlnaW5hbFRhcmdldCwgbWVtYnJhbmUgfSA9IHRoaXM7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBvcmlnaW5hbFRhcmdldFtrZXldO1xuICAgICAgICAgIGNvbnN0IHsgdmFsdWVPYnNlcnZlZCB9ID0gbWVtYnJhbmU7XG4gICAgICAgICAgdmFsdWVPYnNlcnZlZChvcmlnaW5hbFRhcmdldCwga2V5KTtcbiAgICAgICAgICByZXR1cm4gbWVtYnJhbmUuZ2V0UHJveHkodmFsdWUpO1xuICAgICAgfVxuICAgICAgc2V0KHNoYWRvd1RhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgICAgICAgIGNvbnN0IHsgb3JpZ2luYWxUYXJnZXQsIG1lbWJyYW5lOiB7IHZhbHVlTXV0YXRlZCB9IH0gPSB0aGlzO1xuICAgICAgICAgIGNvbnN0IG9sZFZhbHVlID0gb3JpZ2luYWxUYXJnZXRba2V5XTtcbiAgICAgICAgICBpZiAob2xkVmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgIG9yaWdpbmFsVGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgdmFsdWVNdXRhdGVkKG9yaWdpbmFsVGFyZ2V0LCBrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChrZXkgPT09ICdsZW5ndGgnICYmIGlzQXJyYXkob3JpZ2luYWxUYXJnZXQpKSB7XG4gICAgICAgICAgICAgIC8vIGZpeCBmb3IgaXNzdWUgIzIzNjogcHVzaCB3aWxsIGFkZCB0aGUgbmV3IGluZGV4LCBhbmQgYnkgdGhlIHRpbWUgbGVuZ3RoXG4gICAgICAgICAgICAgIC8vIGlzIHVwZGF0ZWQsIHRoZSBpbnRlcm5hbCBsZW5ndGggaXMgYWxyZWFkeSBlcXVhbCB0byB0aGUgbmV3IGxlbmd0aCB2YWx1ZVxuICAgICAgICAgICAgICAvLyB0aGVyZWZvcmUsIHRoZSBvbGRWYWx1ZSBpcyBlcXVhbCB0byB0aGUgdmFsdWUuIFRoaXMgaXMgdGhlIGZvcmtpbmcgbG9naWNcbiAgICAgICAgICAgICAgLy8gdG8gc3VwcG9ydCB0aGlzIHVzZSBjYXNlLlxuICAgICAgICAgICAgICB2YWx1ZU11dGF0ZWQob3JpZ2luYWxUYXJnZXQsIGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgZGVsZXRlUHJvcGVydHkoc2hhZG93VGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgICBjb25zdCB7IG9yaWdpbmFsVGFyZ2V0LCBtZW1icmFuZTogeyB2YWx1ZU11dGF0ZWQgfSB9ID0gdGhpcztcbiAgICAgICAgICBkZWxldGUgb3JpZ2luYWxUYXJnZXRba2V5XTtcbiAgICAgICAgICB2YWx1ZU11dGF0ZWQob3JpZ2luYWxUYXJnZXQsIGtleSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBhcHBseShzaGFkb3dUYXJnZXQsIHRoaXNBcmcsIGFyZ0FycmF5KSB7XG4gICAgICAgICAgLyogTm8gb3AgKi9cbiAgICAgIH1cbiAgICAgIGNvbnN0cnVjdCh0YXJnZXQsIGFyZ0FycmF5LCBuZXdUYXJnZXQpIHtcbiAgICAgICAgICAvKiBObyBvcCAqL1xuICAgICAgfVxuICAgICAgaGFzKHNoYWRvd1RhcmdldCwga2V5KSB7XG4gICAgICAgICAgY29uc3QgeyBvcmlnaW5hbFRhcmdldCwgbWVtYnJhbmU6IHsgdmFsdWVPYnNlcnZlZCB9IH0gPSB0aGlzO1xuICAgICAgICAgIHZhbHVlT2JzZXJ2ZWQob3JpZ2luYWxUYXJnZXQsIGtleSk7XG4gICAgICAgICAgcmV0dXJuIGtleSBpbiBvcmlnaW5hbFRhcmdldDtcbiAgICAgIH1cbiAgICAgIG93bktleXMoc2hhZG93VGFyZ2V0KSB7XG4gICAgICAgICAgY29uc3QgeyBvcmlnaW5hbFRhcmdldCB9ID0gdGhpcztcbiAgICAgICAgICByZXR1cm4gQXJyYXlDb25jYXQuY2FsbChnZXRPd25Qcm9wZXJ0eU5hbWVzKG9yaWdpbmFsVGFyZ2V0KSwgZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9yaWdpbmFsVGFyZ2V0KSk7XG4gICAgICB9XG4gICAgICBpc0V4dGVuc2libGUoc2hhZG93VGFyZ2V0KSB7XG4gICAgICAgICAgY29uc3Qgc2hhZG93SXNFeHRlbnNpYmxlID0gaXNFeHRlbnNpYmxlKHNoYWRvd1RhcmdldCk7XG4gICAgICAgICAgaWYgKCFzaGFkb3dJc0V4dGVuc2libGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNoYWRvd0lzRXh0ZW5zaWJsZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgeyBvcmlnaW5hbFRhcmdldCwgbWVtYnJhbmUgfSA9IHRoaXM7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0SXNFeHRlbnNpYmxlID0gaXNFeHRlbnNpYmxlKG9yaWdpbmFsVGFyZ2V0KTtcbiAgICAgICAgICBpZiAoIXRhcmdldElzRXh0ZW5zaWJsZSkge1xuICAgICAgICAgICAgICBsb2NrU2hhZG93VGFyZ2V0KG1lbWJyYW5lLCBzaGFkb3dUYXJnZXQsIG9yaWdpbmFsVGFyZ2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRhcmdldElzRXh0ZW5zaWJsZTtcbiAgICAgIH1cbiAgICAgIHNldFByb3RvdHlwZU9mKHNoYWRvd1RhcmdldCwgcHJvdG90eXBlKSB7XG4gICAgICB9XG4gICAgICBnZXRQcm90b3R5cGVPZihzaGFkb3dUYXJnZXQpIHtcbiAgICAgICAgICBjb25zdCB7IG9yaWdpbmFsVGFyZ2V0IH0gPSB0aGlzO1xuICAgICAgICAgIHJldHVybiBnZXRQcm90b3R5cGVPZihvcmlnaW5hbFRhcmdldCk7XG4gICAgICB9XG4gICAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc2hhZG93VGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgICBjb25zdCB7IG9yaWdpbmFsVGFyZ2V0LCBtZW1icmFuZSB9ID0gdGhpcztcbiAgICAgICAgICBjb25zdCB7IHZhbHVlT2JzZXJ2ZWQgfSA9IHRoaXMubWVtYnJhbmU7XG4gICAgICAgICAgLy8ga2V5cyBsb29rZWQgdXAgdmlhIGhhc093blByb3BlcnR5IG5lZWQgdG8gYmUgcmVhY3RpdmVcbiAgICAgICAgICB2YWx1ZU9ic2VydmVkKG9yaWdpbmFsVGFyZ2V0LCBrZXkpO1xuICAgICAgICAgIGxldCBkZXNjID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9yaWdpbmFsVGFyZ2V0LCBrZXkpO1xuICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChkZXNjKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZGVzYztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc2hhZG93RGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzaGFkb3dUYXJnZXQsIGtleSk7XG4gICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChzaGFkb3dEZXNjcmlwdG9yKSkge1xuICAgICAgICAgICAgICByZXR1cm4gc2hhZG93RGVzY3JpcHRvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gTm90ZTogYnkgYWNjZXNzaW5nIHRoZSBkZXNjcmlwdG9yLCB0aGUga2V5IGlzIG1hcmtlZCBhcyBvYnNlcnZlZFxuICAgICAgICAgIC8vIGJ1dCBhY2Nlc3MgdG8gdGhlIHZhbHVlLCBzZXR0ZXIgb3IgZ2V0dGVyIChpZiBhdmFpbGFibGUpIGNhbm5vdCBvYnNlcnZlXG4gICAgICAgICAgLy8gbXV0YXRpb25zLCBqdXN0IGxpa2UgcmVndWxhciBtZXRob2RzLCBpbiB3aGljaCBjYXNlIHdlIGp1c3QgZG8gbm90aGluZy5cbiAgICAgICAgICBkZXNjID0gd3JhcERlc2NyaXB0b3IobWVtYnJhbmUsIGRlc2MsIHdyYXBWYWx1ZSk7XG4gICAgICAgICAgaWYgKCFkZXNjLmNvbmZpZ3VyYWJsZSkge1xuICAgICAgICAgICAgICAvLyBJZiBkZXNjcmlwdG9yIGZyb20gb3JpZ2luYWwgdGFyZ2V0IGlzIG5vdCBjb25maWd1cmFibGUsXG4gICAgICAgICAgICAgIC8vIFdlIG11c3QgY29weSB0aGUgd3JhcHBlZCBkZXNjcmlwdG9yIG92ZXIgdG8gdGhlIHNoYWRvdyB0YXJnZXQuXG4gICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgcHJveHkgd2lsbCB0aHJvdyBhbiBpbnZhcmlhbnQgZXJyb3IuXG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMgb3VyIGxhc3QgY2hhbmNlIHRvIGxvY2sgdGhlIHZhbHVlLlxuICAgICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9Qcm94eS9oYW5kbGVyL2dldE93blByb3BlcnR5RGVzY3JpcHRvciNJbnZhcmlhbnRzXG4gICAgICAgICAgICAgIE9iamVjdERlZmluZVByb3BlcnR5KHNoYWRvd1RhcmdldCwga2V5LCBkZXNjKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRlc2M7XG4gICAgICB9XG4gICAgICBwcmV2ZW50RXh0ZW5zaW9ucyhzaGFkb3dUYXJnZXQpIHtcbiAgICAgICAgICBjb25zdCB7IG9yaWdpbmFsVGFyZ2V0LCBtZW1icmFuZSB9ID0gdGhpcztcbiAgICAgICAgICBsb2NrU2hhZG93VGFyZ2V0KG1lbWJyYW5lLCBzaGFkb3dUYXJnZXQsIG9yaWdpbmFsVGFyZ2V0KTtcbiAgICAgICAgICBwcmV2ZW50RXh0ZW5zaW9ucyhvcmlnaW5hbFRhcmdldCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBkZWZpbmVQcm9wZXJ0eShzaGFkb3dUYXJnZXQsIGtleSwgZGVzY3JpcHRvcikge1xuICAgICAgICAgIGNvbnN0IHsgb3JpZ2luYWxUYXJnZXQsIG1lbWJyYW5lIH0gPSB0aGlzO1xuICAgICAgICAgIGNvbnN0IHsgdmFsdWVNdXRhdGVkIH0gPSBtZW1icmFuZTtcbiAgICAgICAgICBjb25zdCB7IGNvbmZpZ3VyYWJsZSB9ID0gZGVzY3JpcHRvcjtcbiAgICAgICAgICAvLyBXZSBoYXZlIHRvIGNoZWNrIGZvciB2YWx1ZSBpbiBkZXNjcmlwdG9yXG4gICAgICAgICAgLy8gYmVjYXVzZSBPYmplY3QuZnJlZXplKHByb3h5KSBjYWxscyB0aGlzIG1ldGhvZFxuICAgICAgICAgIC8vIHdpdGggb25seSB7IGNvbmZpZ3VyYWJsZTogZmFsc2UsIHdyaXRlYWJsZTogZmFsc2UgfVxuICAgICAgICAgIC8vIEFkZGl0aW9uYWxseSwgbWV0aG9kIHdpbGwgb25seSBiZSBjYWxsZWQgd2l0aCB3cml0ZWFibGU6ZmFsc2VcbiAgICAgICAgICAvLyBpZiB0aGUgZGVzY3JpcHRvciBoYXMgYSB2YWx1ZSwgYXMgb3Bwb3NlZCB0byBnZXR0ZXIvc2V0dGVyXG4gICAgICAgICAgLy8gU28gd2UgY2FuIGp1c3QgY2hlY2sgaWYgd3JpdGFibGUgaXMgcHJlc2VudCBhbmQgdGhlbiBzZWUgaWZcbiAgICAgICAgICAvLyB2YWx1ZSBpcyBwcmVzZW50LiBUaGlzIGVsaW1pbmF0ZXMgZ2V0dGVyIGFuZCBzZXR0ZXIgZGVzY3JpcHRvcnNcbiAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChkZXNjcmlwdG9yLCAnd3JpdGFibGUnKSAmJiAhaGFzT3duUHJvcGVydHkuY2FsbChkZXNjcmlwdG9yLCAndmFsdWUnKSkge1xuICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbERlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob3JpZ2luYWxUYXJnZXQsIGtleSk7XG4gICAgICAgICAgICAgIGRlc2NyaXB0b3IudmFsdWUgPSBvcmlnaW5hbERlc2NyaXB0b3IudmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIE9iamVjdERlZmluZVByb3BlcnR5KG9yaWdpbmFsVGFyZ2V0LCBrZXksIHVud3JhcERlc2NyaXB0b3IoZGVzY3JpcHRvcikpO1xuICAgICAgICAgIGlmIChjb25maWd1cmFibGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIE9iamVjdERlZmluZVByb3BlcnR5KHNoYWRvd1RhcmdldCwga2V5LCB3cmFwRGVzY3JpcHRvcihtZW1icmFuZSwgZGVzY3JpcHRvciwgd3JhcFZhbHVlKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhbHVlTXV0YXRlZChvcmlnaW5hbFRhcmdldCwga2V5KTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXBSZWFkT25seVZhbHVlKG1lbWJyYW5lLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG1lbWJyYW5lLnZhbHVlSXNPYnNlcnZhYmxlKHZhbHVlKSA/IG1lbWJyYW5lLmdldFJlYWRPbmx5UHJveHkodmFsdWUpIDogdmFsdWU7XG4gIH1cbiAgY2xhc3MgUmVhZE9ubHlIYW5kbGVyIHtcbiAgICAgIGNvbnN0cnVjdG9yKG1lbWJyYW5lLCB2YWx1ZSkge1xuICAgICAgICAgIHRoaXMub3JpZ2luYWxUYXJnZXQgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLm1lbWJyYW5lID0gbWVtYnJhbmU7XG4gICAgICB9XG4gICAgICBnZXQoc2hhZG93VGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgICBjb25zdCB7IG1lbWJyYW5lLCBvcmlnaW5hbFRhcmdldCB9ID0gdGhpcztcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IG9yaWdpbmFsVGFyZ2V0W2tleV07XG4gICAgICAgICAgY29uc3QgeyB2YWx1ZU9ic2VydmVkIH0gPSBtZW1icmFuZTtcbiAgICAgICAgICB2YWx1ZU9ic2VydmVkKG9yaWdpbmFsVGFyZ2V0LCBrZXkpO1xuICAgICAgICAgIHJldHVybiBtZW1icmFuZS5nZXRSZWFkT25seVByb3h5KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHNldChzaGFkb3dUYXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBkZWxldGVQcm9wZXJ0eShzaGFkb3dUYXJnZXQsIGtleSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGFwcGx5KHNoYWRvd1RhcmdldCwgdGhpc0FyZywgYXJnQXJyYXkpIHtcbiAgICAgICAgICAvKiBObyBvcCAqL1xuICAgICAgfVxuICAgICAgY29uc3RydWN0KHRhcmdldCwgYXJnQXJyYXksIG5ld1RhcmdldCkge1xuICAgICAgICAgIC8qIE5vIG9wICovXG4gICAgICB9XG4gICAgICBoYXMoc2hhZG93VGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgICBjb25zdCB7IG9yaWdpbmFsVGFyZ2V0LCBtZW1icmFuZTogeyB2YWx1ZU9ic2VydmVkIH0gfSA9IHRoaXM7XG4gICAgICAgICAgdmFsdWVPYnNlcnZlZChvcmlnaW5hbFRhcmdldCwga2V5KTtcbiAgICAgICAgICByZXR1cm4ga2V5IGluIG9yaWdpbmFsVGFyZ2V0O1xuICAgICAgfVxuICAgICAgb3duS2V5cyhzaGFkb3dUYXJnZXQpIHtcbiAgICAgICAgICBjb25zdCB7IG9yaWdpbmFsVGFyZ2V0IH0gPSB0aGlzO1xuICAgICAgICAgIHJldHVybiBBcnJheUNvbmNhdC5jYWxsKGdldE93blByb3BlcnR5TmFtZXMob3JpZ2luYWxUYXJnZXQpLCBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMob3JpZ2luYWxUYXJnZXQpKTtcbiAgICAgIH1cbiAgICAgIHNldFByb3RvdHlwZU9mKHNoYWRvd1RhcmdldCwgcHJvdG90eXBlKSB7XG4gICAgICB9XG4gICAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc2hhZG93VGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgICBjb25zdCB7IG9yaWdpbmFsVGFyZ2V0LCBtZW1icmFuZSB9ID0gdGhpcztcbiAgICAgICAgICBjb25zdCB7IHZhbHVlT2JzZXJ2ZWQgfSA9IG1lbWJyYW5lO1xuICAgICAgICAgIC8vIGtleXMgbG9va2VkIHVwIHZpYSBoYXNPd25Qcm9wZXJ0eSBuZWVkIHRvIGJlIHJlYWN0aXZlXG4gICAgICAgICAgdmFsdWVPYnNlcnZlZChvcmlnaW5hbFRhcmdldCwga2V5KTtcbiAgICAgICAgICBsZXQgZGVzYyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihvcmlnaW5hbFRhcmdldCwga2V5KTtcbiAgICAgICAgICBpZiAoaXNVbmRlZmluZWQoZGVzYykpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRlc2M7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHNoYWRvd0Rlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc2hhZG93VGFyZ2V0LCBrZXkpO1xuICAgICAgICAgIGlmICghaXNVbmRlZmluZWQoc2hhZG93RGVzY3JpcHRvcikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNoYWRvd0Rlc2NyaXB0b3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIE5vdGU6IGJ5IGFjY2Vzc2luZyB0aGUgZGVzY3JpcHRvciwgdGhlIGtleSBpcyBtYXJrZWQgYXMgb2JzZXJ2ZWRcbiAgICAgICAgICAvLyBidXQgYWNjZXNzIHRvIHRoZSB2YWx1ZSBvciBnZXR0ZXIgKGlmIGF2YWlsYWJsZSkgY2Fubm90IGJlIG9ic2VydmVkLFxuICAgICAgICAgIC8vIGp1c3QgbGlrZSByZWd1bGFyIG1ldGhvZHMsIGluIHdoaWNoIGNhc2Ugd2UganVzdCBkbyBub3RoaW5nLlxuICAgICAgICAgIGRlc2MgPSB3cmFwRGVzY3JpcHRvcihtZW1icmFuZSwgZGVzYywgd3JhcFJlYWRPbmx5VmFsdWUpO1xuICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGRlc2MsICdzZXQnKSkge1xuICAgICAgICAgICAgICBkZXNjLnNldCA9IHVuZGVmaW5lZDsgLy8gcmVhZE9ubHkgbWVtYnJhbmUgZG9lcyBub3QgYWxsb3cgc2V0dGVyc1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWRlc2MuY29uZmlndXJhYmxlKSB7XG4gICAgICAgICAgICAgIC8vIElmIGRlc2NyaXB0b3IgZnJvbSBvcmlnaW5hbCB0YXJnZXQgaXMgbm90IGNvbmZpZ3VyYWJsZSxcbiAgICAgICAgICAgICAgLy8gV2UgbXVzdCBjb3B5IHRoZSB3cmFwcGVkIGRlc2NyaXB0b3Igb3ZlciB0byB0aGUgc2hhZG93IHRhcmdldC5cbiAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBwcm94eSB3aWxsIHRocm93IGFuIGludmFyaWFudCBlcnJvci5cbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyBvdXIgbGFzdCBjaGFuY2UgdG8gbG9jayB0aGUgdmFsdWUuXG4gICAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1Byb3h5L2hhbmRsZXIvZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yI0ludmFyaWFudHNcbiAgICAgICAgICAgICAgT2JqZWN0RGVmaW5lUHJvcGVydHkoc2hhZG93VGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZGVzYztcbiAgICAgIH1cbiAgICAgIHByZXZlbnRFeHRlbnNpb25zKHNoYWRvd1RhcmdldCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGRlZmluZVByb3BlcnR5KHNoYWRvd1RhcmdldCwga2V5LCBkZXNjcmlwdG9yKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZVNoYWRvd1RhcmdldCh2YWx1ZSkge1xuICAgICAgbGV0IHNoYWRvd1RhcmdldCA9IHVuZGVmaW5lZDtcbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIHNoYWRvd1RhcmdldCA9IFtdO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgc2hhZG93VGFyZ2V0ID0ge307XG4gICAgICB9XG4gICAgICByZXR1cm4gc2hhZG93VGFyZ2V0O1xuICB9XG4gIGNvbnN0IE9iamVjdERvdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG4gIGZ1bmN0aW9uIGRlZmF1bHRWYWx1ZUlzT2JzZXJ2YWJsZSh2YWx1ZSkge1xuICAgICAgLy8gaW50ZW50aW9uYWxseSBjaGVja2luZyBmb3IgbnVsbFxuICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gdHJlYXQgYWxsIG5vbi1vYmplY3QgdHlwZXMsIGluY2x1ZGluZyB1bmRlZmluZWQsIGFzIG5vbi1vYnNlcnZhYmxlIHZhbHVlc1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByb3RvID0gZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuICAgICAgcmV0dXJuIChwcm90byA9PT0gT2JqZWN0RG90UHJvdG90eXBlIHx8IHByb3RvID09PSBudWxsIHx8IGdldFByb3RvdHlwZU9mKHByb3RvKSA9PT0gbnVsbCk7XG4gIH1cbiAgY29uc3QgZGVmYXVsdFZhbHVlT2JzZXJ2ZWQgPSAob2JqLCBrZXkpID0+IHtcbiAgICAgIC8qIGRvIG5vdGhpbmcgKi9cbiAgfTtcbiAgY29uc3QgZGVmYXVsdFZhbHVlTXV0YXRlZCA9IChvYmosIGtleSkgPT4ge1xuICAgICAgLyogZG8gbm90aGluZyAqL1xuICB9O1xuICBjb25zdCBkZWZhdWx0VmFsdWVEaXN0b3J0aW9uID0gKHZhbHVlKSA9PiB2YWx1ZTtcbiAgZnVuY3Rpb24gd3JhcERlc2NyaXB0b3IobWVtYnJhbmUsIGRlc2NyaXB0b3IsIGdldFZhbHVlKSB7XG4gICAgICBjb25zdCB7IHNldCwgZ2V0IH0gPSBkZXNjcmlwdG9yO1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoZGVzY3JpcHRvciwgJ3ZhbHVlJykpIHtcbiAgICAgICAgICBkZXNjcmlwdG9yLnZhbHVlID0gZ2V0VmFsdWUobWVtYnJhbmUsIGRlc2NyaXB0b3IudmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChnZXQpKSB7XG4gICAgICAgICAgICAgIGRlc2NyaXB0b3IuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgLy8gaW52b2tpbmcgdGhlIG9yaWdpbmFsIGdldHRlciB3aXRoIHRoZSBvcmlnaW5hbCB0YXJnZXRcbiAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRWYWx1ZShtZW1icmFuZSwgZ2V0LmNhbGwodW53cmFwKHRoaXMpKSk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXNVbmRlZmluZWQoc2V0KSkge1xuICAgICAgICAgICAgICBkZXNjcmlwdG9yLnNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCB3ZSBkb24ndCBoYXZlIGEgY2xlYXIgaW5kaWNhdGlvbiBvZiB3aGV0aGVyXG4gICAgICAgICAgICAgICAgICAvLyBvciBub3QgYSB2YWxpZCBtdXRhdGlvbiB3aWxsIG9jY3VyLCB3ZSBkb24ndCBoYXZlIHRoZSBrZXksXG4gICAgICAgICAgICAgICAgICAvLyBhbmQgd2UgYXJlIG5vdCBzdXJlIHdoeSBhbmQgaG93IHRoZXkgYXJlIGludm9raW5nIHRoaXMgc2V0dGVyLlxuICAgICAgICAgICAgICAgICAgLy8gTmV2ZXJ0aGVsZXNzIHdlIHByZXNlcnZlIHRoZSBvcmlnaW5hbCBzZW1hbnRpY3MgYnkgaW52b2tpbmcgdGhlXG4gICAgICAgICAgICAgICAgICAvLyBvcmlnaW5hbCBzZXR0ZXIgd2l0aCB0aGUgb3JpZ2luYWwgdGFyZ2V0IGFuZCB0aGUgdW53cmFwcGVkIHZhbHVlXG4gICAgICAgICAgICAgICAgICBzZXQuY2FsbCh1bndyYXAodGhpcyksIG1lbWJyYW5lLnVud3JhcFByb3h5KHZhbHVlKSk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRlc2NyaXB0b3I7XG4gIH1cbiAgY2xhc3MgUmVhY3RpdmVNZW1icmFuZSB7XG4gICAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZURpc3RvcnRpb24gPSBkZWZhdWx0VmFsdWVEaXN0b3J0aW9uO1xuICAgICAgICAgIHRoaXMudmFsdWVNdXRhdGVkID0gZGVmYXVsdFZhbHVlTXV0YXRlZDtcbiAgICAgICAgICB0aGlzLnZhbHVlT2JzZXJ2ZWQgPSBkZWZhdWx0VmFsdWVPYnNlcnZlZDtcbiAgICAgICAgICB0aGlzLnZhbHVlSXNPYnNlcnZhYmxlID0gZGVmYXVsdFZhbHVlSXNPYnNlcnZhYmxlO1xuICAgICAgICAgIHRoaXMub2JqZWN0R3JhcGggPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICAgIGlmICghaXNVbmRlZmluZWQob3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgY29uc3QgeyB2YWx1ZURpc3RvcnRpb24sIHZhbHVlTXV0YXRlZCwgdmFsdWVPYnNlcnZlZCwgdmFsdWVJc09ic2VydmFibGUgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICAgIHRoaXMudmFsdWVEaXN0b3J0aW9uID0gaXNGdW5jdGlvbih2YWx1ZURpc3RvcnRpb24pID8gdmFsdWVEaXN0b3J0aW9uIDogZGVmYXVsdFZhbHVlRGlzdG9ydGlvbjtcbiAgICAgICAgICAgICAgdGhpcy52YWx1ZU11dGF0ZWQgPSBpc0Z1bmN0aW9uKHZhbHVlTXV0YXRlZCkgPyB2YWx1ZU11dGF0ZWQgOiBkZWZhdWx0VmFsdWVNdXRhdGVkO1xuICAgICAgICAgICAgICB0aGlzLnZhbHVlT2JzZXJ2ZWQgPSBpc0Z1bmN0aW9uKHZhbHVlT2JzZXJ2ZWQpID8gdmFsdWVPYnNlcnZlZCA6IGRlZmF1bHRWYWx1ZU9ic2VydmVkO1xuICAgICAgICAgICAgICB0aGlzLnZhbHVlSXNPYnNlcnZhYmxlID0gaXNGdW5jdGlvbih2YWx1ZUlzT2JzZXJ2YWJsZSkgPyB2YWx1ZUlzT2JzZXJ2YWJsZSA6IGRlZmF1bHRWYWx1ZUlzT2JzZXJ2YWJsZTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBnZXRQcm94eSh2YWx1ZSkge1xuICAgICAgICAgIGNvbnN0IHVud3JhcHBlZFZhbHVlID0gdW53cmFwKHZhbHVlKTtcbiAgICAgICAgICBjb25zdCBkaXN0b3J0ZWQgPSB0aGlzLnZhbHVlRGlzdG9ydGlvbih1bndyYXBwZWRWYWx1ZSk7XG4gICAgICAgICAgaWYgKHRoaXMudmFsdWVJc09ic2VydmFibGUoZGlzdG9ydGVkKSkge1xuICAgICAgICAgICAgICBjb25zdCBvID0gdGhpcy5nZXRSZWFjdGl2ZVN0YXRlKHVud3JhcHBlZFZhbHVlLCBkaXN0b3J0ZWQpO1xuICAgICAgICAgICAgICAvLyB3aGVuIHRyeWluZyB0byBleHRyYWN0IHRoZSB3cml0YWJsZSB2ZXJzaW9uIG9mIGEgcmVhZG9ubHlcbiAgICAgICAgICAgICAgLy8gd2UgcmV0dXJuIHRoZSByZWFkb25seS5cbiAgICAgICAgICAgICAgcmV0dXJuIG8ucmVhZE9ubHkgPT09IHZhbHVlID8gdmFsdWUgOiBvLnJlYWN0aXZlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZGlzdG9ydGVkO1xuICAgICAgfVxuICAgICAgZ2V0UmVhZE9ubHlQcm94eSh2YWx1ZSkge1xuICAgICAgICAgIHZhbHVlID0gdW53cmFwKHZhbHVlKTtcbiAgICAgICAgICBjb25zdCBkaXN0b3J0ZWQgPSB0aGlzLnZhbHVlRGlzdG9ydGlvbih2YWx1ZSk7XG4gICAgICAgICAgaWYgKHRoaXMudmFsdWVJc09ic2VydmFibGUoZGlzdG9ydGVkKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRSZWFjdGl2ZVN0YXRlKHZhbHVlLCBkaXN0b3J0ZWQpLnJlYWRPbmx5O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZGlzdG9ydGVkO1xuICAgICAgfVxuICAgICAgdW53cmFwUHJveHkocCkge1xuICAgICAgICAgIHJldHVybiB1bndyYXAocCk7XG4gICAgICB9XG4gICAgICBnZXRSZWFjdGl2ZVN0YXRlKHZhbHVlLCBkaXN0b3J0ZWRWYWx1ZSkge1xuICAgICAgICAgIGNvbnN0IHsgb2JqZWN0R3JhcGgsIH0gPSB0aGlzO1xuICAgICAgICAgIGxldCByZWFjdGl2ZVN0YXRlID0gb2JqZWN0R3JhcGguZ2V0KGRpc3RvcnRlZFZhbHVlKTtcbiAgICAgICAgICBpZiAocmVhY3RpdmVTdGF0ZSkge1xuICAgICAgICAgICAgICByZXR1cm4gcmVhY3RpdmVTdGF0ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgbWVtYnJhbmUgPSB0aGlzO1xuICAgICAgICAgIHJlYWN0aXZlU3RhdGUgPSB7XG4gICAgICAgICAgICAgIGdldCByZWFjdGl2ZSgpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHJlYWN0aXZlSGFuZGxlciA9IG5ldyBSZWFjdGl2ZVByb3h5SGFuZGxlcihtZW1icmFuZSwgZGlzdG9ydGVkVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgLy8gY2FjaGluZyB0aGUgcmVhY3RpdmUgcHJveHkgYWZ0ZXIgdGhlIGZpcnN0IHRpbWUgaXQgaXMgYWNjZXNzZWRcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KGNyZWF0ZVNoYWRvd1RhcmdldChkaXN0b3J0ZWRWYWx1ZSksIHJlYWN0aXZlSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICByZWdpc3RlclByb3h5KHByb3h5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICBPYmplY3REZWZpbmVQcm9wZXJ0eSh0aGlzLCAncmVhY3RpdmUnLCB7IHZhbHVlOiBwcm94eSB9KTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBwcm94eTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZ2V0IHJlYWRPbmx5KCkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcmVhZE9ubHlIYW5kbGVyID0gbmV3IFJlYWRPbmx5SGFuZGxlcihtZW1icmFuZSwgZGlzdG9ydGVkVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgLy8gY2FjaGluZyB0aGUgcmVhZE9ubHkgcHJveHkgYWZ0ZXIgdGhlIGZpcnN0IHRpbWUgaXQgaXMgYWNjZXNzZWRcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KGNyZWF0ZVNoYWRvd1RhcmdldChkaXN0b3J0ZWRWYWx1ZSksIHJlYWRPbmx5SGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICByZWdpc3RlclByb3h5KHByb3h5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICBPYmplY3REZWZpbmVQcm9wZXJ0eSh0aGlzLCAncmVhZE9ubHknLCB7IHZhbHVlOiBwcm94eSB9KTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBwcm94eTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgb2JqZWN0R3JhcGguc2V0KGRpc3RvcnRlZFZhbHVlLCByZWFjdGl2ZVN0YXRlKTtcbiAgICAgICAgICByZXR1cm4gcmVhY3RpdmVTdGF0ZTtcbiAgICAgIH1cbiAgfVxuICAvKiogdmVyc2lvbjogMC4yNi4wICovXG5cbiAgZnVuY3Rpb24gd3JhcChkYXRhLCBtdXRhdGlvbkNhbGxiYWNrKSB7XG5cbiAgICBsZXQgbWVtYnJhbmUgPSBuZXcgUmVhY3RpdmVNZW1icmFuZSh7XG4gICAgICB2YWx1ZU11dGF0ZWQodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgbXV0YXRpb25DYWxsYmFjayh0YXJnZXQsIGtleSk7XG4gICAgICB9XG5cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogbWVtYnJhbmUuZ2V0UHJveHkoZGF0YSksXG4gICAgICBtZW1icmFuZTogbWVtYnJhbmVcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHVud3JhcCQxKG1lbWJyYW5lLCBvYnNlcnZhYmxlKSB7XG4gICAgbGV0IHVud3JhcHBlZERhdGEgPSBtZW1icmFuZS51bndyYXBQcm94eShvYnNlcnZhYmxlKTtcbiAgICBsZXQgY29weSA9IHt9O1xuICAgIE9iamVjdC5rZXlzKHVud3JhcHBlZERhdGEpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmIChbJyRlbCcsICckcmVmcycsICckbmV4dFRpY2snLCAnJHdhdGNoJ10uaW5jbHVkZXMoa2V5KSkgcmV0dXJuO1xuICAgICAgY29weVtrZXldID0gdW53cmFwcGVkRGF0YVtrZXldO1xuICAgIH0pO1xuICAgIHJldHVybiBjb3B5O1xuICB9XG5cbiAgY2xhc3MgQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihlbCwgY29tcG9uZW50Rm9yQ2xvbmUgPSBudWxsKSB7XG4gICAgICB0aGlzLiRlbCA9IGVsO1xuICAgICAgY29uc3QgZGF0YUF0dHIgPSB0aGlzLiRlbC5nZXRBdHRyaWJ1dGUoJ3gtZGF0YScpO1xuICAgICAgY29uc3QgZGF0YUV4cHJlc3Npb24gPSBkYXRhQXR0ciA9PT0gJycgPyAne30nIDogZGF0YUF0dHI7XG4gICAgICBjb25zdCBpbml0RXhwcmVzc2lvbiA9IHRoaXMuJGVsLmdldEF0dHJpYnV0ZSgneC1pbml0Jyk7XG4gICAgICBsZXQgZGF0YUV4dHJhcyA9IHtcbiAgICAgICAgJGVsOiB0aGlzLiRlbFxuICAgICAgfTtcbiAgICAgIGxldCBjYW5vbmljYWxDb21wb25lbnRFbGVtZW50UmVmZXJlbmNlID0gY29tcG9uZW50Rm9yQ2xvbmUgPyBjb21wb25lbnRGb3JDbG9uZS4kZWwgOiB0aGlzLiRlbDtcbiAgICAgIE9iamVjdC5lbnRyaWVzKEFscGluZS5tYWdpY1Byb3BlcnRpZXMpLmZvckVhY2goKFtuYW1lLCBjYWxsYmFja10pID0+IHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRhdGFFeHRyYXMsIGAkJHtuYW1lfWAsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjYW5vbmljYWxDb21wb25lbnRFbGVtZW50UmVmZXJlbmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnVub2JzZXJ2ZWREYXRhID0gY29tcG9uZW50Rm9yQ2xvbmUgPyBjb21wb25lbnRGb3JDbG9uZS5nZXRVbm9ic2VydmVkRGF0YSgpIDogc2FmZXJFdmFsKGVsLCBkYXRhRXhwcmVzc2lvbiwgZGF0YUV4dHJhcyk7XG4gICAgICAvLyBDb25zdHJ1Y3QgYSBQcm94eS1iYXNlZCBvYnNlcnZhYmxlLiBUaGlzIHdpbGwgYmUgdXNlZCB0byBoYW5kbGUgcmVhY3Rpdml0eS5cblxuICAgICAgbGV0IHtcbiAgICAgICAgbWVtYnJhbmUsXG4gICAgICAgIGRhdGFcbiAgICAgIH0gPSB0aGlzLndyYXBEYXRhSW5PYnNlcnZhYmxlKHRoaXMudW5vYnNlcnZlZERhdGEpO1xuICAgICAgdGhpcy4kZGF0YSA9IGRhdGE7XG4gICAgICB0aGlzLm1lbWJyYW5lID0gbWVtYnJhbmU7IC8vIEFmdGVyIG1ha2luZyB1c2VyLXN1cHBsaWVkIGRhdGEgbWV0aG9kcyByZWFjdGl2ZSwgd2UgY2FuIG5vdyBhZGRcbiAgICAgIC8vIG91ciBtYWdpYyBwcm9wZXJ0aWVzIHRvIHRoZSBvcmlnaW5hbCBkYXRhIGZvciBhY2Nlc3MuXG5cbiAgICAgIHRoaXMudW5vYnNlcnZlZERhdGEuJGVsID0gdGhpcy4kZWw7XG4gICAgICB0aGlzLnVub2JzZXJ2ZWREYXRhLiRyZWZzID0gdGhpcy5nZXRSZWZzUHJveHkoKTtcbiAgICAgIHRoaXMubmV4dFRpY2tTdGFjayA9IFtdO1xuXG4gICAgICB0aGlzLnVub2JzZXJ2ZWREYXRhLiRuZXh0VGljayA9IGNhbGxiYWNrID0+IHtcbiAgICAgICAgdGhpcy5uZXh0VGlja1N0YWNrLnB1c2goY2FsbGJhY2spO1xuICAgICAgfTtcblxuICAgICAgdGhpcy53YXRjaGVycyA9IHt9O1xuXG4gICAgICB0aGlzLnVub2JzZXJ2ZWREYXRhLiR3YXRjaCA9IChwcm9wZXJ0eSwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLndhdGNoZXJzW3Byb3BlcnR5XSkgdGhpcy53YXRjaGVyc1twcm9wZXJ0eV0gPSBbXTtcbiAgICAgICAgdGhpcy53YXRjaGVyc1twcm9wZXJ0eV0ucHVzaChjYWxsYmFjayk7XG4gICAgICB9O1xuICAgICAgLyogTU9ERVJOLU9OTFk6U1RBUlQgKi9cbiAgICAgIC8vIFdlIHJlbW92ZSB0aGlzIHBpZWNlIG9mIGNvZGUgZnJvbSB0aGUgbGVnYWN5IGJ1aWxkLlxuICAgICAgLy8gSW4gSUUxMSwgd2UgaGF2ZSBhbHJlYWR5IGRlZmluZWQgb3VyIGhlbHBlcnMgYXQgdGhpcyBwb2ludC5cbiAgICAgIC8vIFJlZ2lzdGVyIGN1c3RvbSBtYWdpYyBwcm9wZXJ0aWVzLlxuXG5cbiAgICAgIE9iamVjdC5lbnRyaWVzKEFscGluZS5tYWdpY1Byb3BlcnRpZXMpLmZvckVhY2goKFtuYW1lLCBjYWxsYmFja10pID0+IHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMudW5vYnNlcnZlZERhdGEsIGAkJHtuYW1lfWAsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjYW5vbmljYWxDb21wb25lbnRFbGVtZW50UmVmZXJlbmNlLCB0aGlzLiRlbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgLyogTU9ERVJOLU9OTFk6RU5EICovXG5cbiAgICAgIHRoaXMuc2hvd0RpcmVjdGl2ZVN0YWNrID0gW107XG4gICAgICB0aGlzLnNob3dEaXJlY3RpdmVMYXN0RWxlbWVudDtcbiAgICAgIGNvbXBvbmVudEZvckNsb25lIHx8IEFscGluZS5vbkJlZm9yZUNvbXBvbmVudEluaXRpYWxpemVkcy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKHRoaXMpKTtcbiAgICAgIHZhciBpbml0UmV0dXJuZWRDYWxsYmFjazsgLy8gSWYgeC1pbml0IGlzIHByZXNlbnQgQU5EIHdlIGFyZW4ndCBjbG9uaW5nIChza2lwIHgtaW5pdCBvbiBjbG9uZSlcblxuICAgICAgaWYgKGluaXRFeHByZXNzaW9uICYmICFjb21wb25lbnRGb3JDbG9uZSkge1xuICAgICAgICAvLyBXZSB3YW50IHRvIGFsbG93IGRhdGEgbWFuaXB1bGF0aW9uLCBidXQgbm90IHRyaWdnZXIgRE9NIHVwZGF0ZXMganVzdCB5ZXQuXG4gICAgICAgIC8vIFdlIGhhdmVuJ3QgZXZlbiBpbml0aWFsaXplZCB0aGUgZWxlbWVudHMgd2l0aCB0aGVpciBBbHBpbmUgYmluZGluZ3MuIEkgbWVhbiBjJ21vbi5cbiAgICAgICAgdGhpcy5wYXVzZVJlYWN0aXZpdHkgPSB0cnVlO1xuICAgICAgICBpbml0UmV0dXJuZWRDYWxsYmFjayA9IHRoaXMuZXZhbHVhdGVSZXR1cm5FeHByZXNzaW9uKHRoaXMuJGVsLCBpbml0RXhwcmVzc2lvbik7XG4gICAgICAgIHRoaXMucGF1c2VSZWFjdGl2aXR5ID0gZmFsc2U7XG4gICAgICB9IC8vIFJlZ2lzdGVyIGFsbCBvdXIgbGlzdGVuZXJzIGFuZCBzZXQgYWxsIG91ciBhdHRyaWJ1dGUgYmluZGluZ3MuXG4gICAgICAvLyBJZiB3ZSdyZSBjbG9uaW5nIGEgY29tcG9uZW50LCB0aGUgdGhpcmQgcGFyYW1ldGVyIGVuc3VyZXMgbm8gZHVwbGljYXRlXG4gICAgICAvLyBldmVudCBsaXN0ZW5lcnMgYXJlIHJlZ2lzdGVyZWQgKHRoZSBtdXRhdGlvbiBvYnNlcnZlciB3aWxsIHRha2UgY2FyZSBvZiB0aGVtKVxuXG5cbiAgICAgIHRoaXMuaW5pdGlhbGl6ZUVsZW1lbnRzKHRoaXMuJGVsLCAoKSA9PiB7fSwgY29tcG9uZW50Rm9yQ2xvbmUpOyAvLyBVc2UgbXV0YXRpb24gb2JzZXJ2ZXIgdG8gZGV0ZWN0IG5ldyBlbGVtZW50cyBiZWluZyBhZGRlZCB3aXRoaW4gdGhpcyBjb21wb25lbnQgYXQgcnVuLXRpbWUuXG4gICAgICAvLyBBbHBpbmUncyBqdXN0IHNvIGRhcm4gZmxleGlibGUgYW1pcml0ZT9cblxuICAgICAgdGhpcy5saXN0ZW5Gb3JOZXdFbGVtZW50c1RvSW5pdGlhbGl6ZSgpO1xuXG4gICAgICBpZiAodHlwZW9mIGluaXRSZXR1cm5lZENhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFJ1biB0aGUgY2FsbGJhY2sgcmV0dXJuZWQgZnJvbSB0aGUgXCJ4LWluaXRcIiBob29rIHRvIGFsbG93IHRoZSB1c2VyIHRvIGRvIHN0dWZmIGFmdGVyXG4gICAgICAgIC8vIEFscGluZSdzIGdvdCBpdCdzIGdydWJieSBsaXR0bGUgcGF3cyBhbGwgb3ZlciBldmVyeXRoaW5nLlxuICAgICAgICBpbml0UmV0dXJuZWRDYWxsYmFjay5jYWxsKHRoaXMuJGRhdGEpO1xuICAgICAgfVxuXG4gICAgICBjb21wb25lbnRGb3JDbG9uZSB8fCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgQWxwaW5lLm9uQ29tcG9uZW50SW5pdGlhbGl6ZWRzLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2sodGhpcykpO1xuICAgICAgfSwgMCk7XG4gICAgfVxuXG4gICAgZ2V0VW5vYnNlcnZlZERhdGEoKSB7XG4gICAgICByZXR1cm4gdW53cmFwJDEodGhpcy5tZW1icmFuZSwgdGhpcy4kZGF0YSk7XG4gICAgfVxuXG4gICAgd3JhcERhdGFJbk9ic2VydmFibGUoZGF0YSkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgbGV0IHVwZGF0ZURvbSA9IGRlYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi51cGRhdGVFbGVtZW50cyhzZWxmLiRlbCk7XG4gICAgICB9LCAwKTtcbiAgICAgIHJldHVybiB3cmFwKGRhdGEsICh0YXJnZXQsIGtleSkgPT4ge1xuICAgICAgICBpZiAoc2VsZi53YXRjaGVyc1trZXldKSB7XG4gICAgICAgICAgLy8gSWYgdGhlcmUncyBhIHdhdGNoZXIgZm9yIHRoaXMgc3BlY2lmaWMga2V5LCBydW4gaXQuXG4gICAgICAgICAgc2VsZi53YXRjaGVyc1trZXldLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2sodGFyZ2V0W2tleV0pKTtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkpIHtcbiAgICAgICAgICAvLyBBcnJheXMgYXJlIHNwZWNpYWwgY2FzZXMsIGlmIGFueSBvZiB0aGUgaXRlbXMgY2hhbmdlLCB3ZSBjb25zaWRlciB0aGUgYXJyYXkgYXMgbXV0YXRlZC5cbiAgICAgICAgICBPYmplY3Qua2V5cyhzZWxmLndhdGNoZXJzKS5mb3JFYWNoKGZ1bGxEb3ROb3RhdGlvbktleSA9PiB7XG4gICAgICAgICAgICBsZXQgZG90Tm90YXRpb25QYXJ0cyA9IGZ1bGxEb3ROb3RhdGlvbktleS5zcGxpdCgnLicpOyAvLyBJZ25vcmUgbGVuZ3RoIG11dGF0aW9ucyBzaW5jZSB0aGV5IHdvdWxkIHJlc3VsdCBpbiBkdXBsaWNhdGUgY2FsbHMuXG4gICAgICAgICAgICAvLyBGb3IgZXhhbXBsZSwgd2hlbiBjYWxsaW5nIHB1c2gsIHdlIHdvdWxkIGdldCBhIG11dGF0aW9uIGZvciB0aGUgaXRlbSdzIGtleVxuICAgICAgICAgICAgLy8gYW5kIGEgc2Vjb25kIG11dGF0aW9uIGZvciB0aGUgbGVuZ3RoIHByb3BlcnR5LlxuXG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnbGVuZ3RoJykgcmV0dXJuO1xuICAgICAgICAgICAgZG90Tm90YXRpb25QYXJ0cy5yZWR1Y2UoKGNvbXBhcmlzb25EYXRhLCBwYXJ0KSA9PiB7XG4gICAgICAgICAgICAgIGlmIChPYmplY3QuaXModGFyZ2V0LCBjb21wYXJpc29uRGF0YVtwYXJ0XSkpIHtcbiAgICAgICAgICAgICAgICBzZWxmLndhdGNoZXJzW2Z1bGxEb3ROb3RhdGlvbktleV0uZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjayh0YXJnZXQpKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBjb21wYXJpc29uRGF0YVtwYXJ0XTtcbiAgICAgICAgICAgIH0sIHNlbGYudW5vYnNlcnZlZERhdGEpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIExldCdzIHdhbGsgdGhyb3VnaCB0aGUgd2F0Y2hlcnMgd2l0aCBcImRvdC1ub3RhdGlvblwiIChmb28uYmFyKSBhbmQgc2VlXG4gICAgICAgICAgLy8gaWYgdGhpcyBtdXRhdGlvbiBmaXRzIGFueSBvZiB0aGVtLlxuICAgICAgICAgIE9iamVjdC5rZXlzKHNlbGYud2F0Y2hlcnMpLmZpbHRlcihpID0+IGkuaW5jbHVkZXMoJy4nKSkuZm9yRWFjaChmdWxsRG90Tm90YXRpb25LZXkgPT4ge1xuICAgICAgICAgICAgbGV0IGRvdE5vdGF0aW9uUGFydHMgPSBmdWxsRG90Tm90YXRpb25LZXkuc3BsaXQoJy4nKTsgLy8gSWYgdGhpcyBkb3Qtbm90YXRpb24gd2F0Y2hlcidzIGxhc3QgXCJwYXJ0XCIgZG9lc24ndCBtYXRjaCB0aGUgY3VycmVudFxuICAgICAgICAgICAgLy8ga2V5LCB0aGVuIHNraXAgaXQgZWFybHkgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuXG5cbiAgICAgICAgICAgIGlmIChrZXkgIT09IGRvdE5vdGF0aW9uUGFydHNbZG90Tm90YXRpb25QYXJ0cy5sZW5ndGggLSAxXSkgcmV0dXJuOyAvLyBOb3csIHdhbGsgdGhyb3VnaCB0aGUgZG90LW5vdGF0aW9uIFwicGFydHNcIiByZWN1cnNpdmVseSB0byBmaW5kXG4gICAgICAgICAgICAvLyBhIG1hdGNoLCBhbmQgY2FsbCB0aGUgd2F0Y2hlciBpZiBvbmUncyBmb3VuZC5cblxuICAgICAgICAgICAgZG90Tm90YXRpb25QYXJ0cy5yZWR1Y2UoKGNvbXBhcmlzb25EYXRhLCBwYXJ0KSA9PiB7XG4gICAgICAgICAgICAgIGlmIChPYmplY3QuaXModGFyZ2V0LCBjb21wYXJpc29uRGF0YSkpIHtcbiAgICAgICAgICAgICAgICAvLyBSdW4gdGhlIHdhdGNoZXJzLlxuICAgICAgICAgICAgICAgIHNlbGYud2F0Y2hlcnNbZnVsbERvdE5vdGF0aW9uS2V5XS5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKHRhcmdldFtrZXldKSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gY29tcGFyaXNvbkRhdGFbcGFydF07XG4gICAgICAgICAgICB9LCBzZWxmLnVub2JzZXJ2ZWREYXRhKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSAvLyBEb24ndCByZWFjdCB0byBkYXRhIGNoYW5nZXMgZm9yIGNhc2VzIGxpa2UgdGhlIGB4LWNyZWF0ZWRgIGhvb2suXG5cblxuICAgICAgICBpZiAoc2VsZi5wYXVzZVJlYWN0aXZpdHkpIHJldHVybjtcbiAgICAgICAgdXBkYXRlRG9tKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB3YWxrQW5kU2tpcE5lc3RlZENvbXBvbmVudHMoZWwsIGNhbGxiYWNrLCBpbml0aWFsaXplQ29tcG9uZW50Q2FsbGJhY2sgPSAoKSA9PiB7fSkge1xuICAgICAgd2FsayhlbCwgZWwgPT4ge1xuICAgICAgICAvLyBXZSd2ZSBoaXQgYSBjb21wb25lbnQuXG4gICAgICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoJ3gtZGF0YScpKSB7XG4gICAgICAgICAgLy8gSWYgaXQncyBub3QgdGhlIGN1cnJlbnQgb25lLlxuICAgICAgICAgIGlmICghZWwuaXNTYW1lTm9kZSh0aGlzLiRlbCkpIHtcbiAgICAgICAgICAgIC8vIEluaXRpYWxpemUgaXQgaWYgaXQncyBub3QuXG4gICAgICAgICAgICBpZiAoIWVsLl9feCkgaW5pdGlhbGl6ZUNvbXBvbmVudENhbGxiYWNrKGVsKTsgLy8gTm93IHdlJ2xsIGxldCB0aGF0IHN1Yi1jb21wb25lbnQgZGVhbCB3aXRoIGl0c2VsZi5cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlbCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpbml0aWFsaXplRWxlbWVudHMocm9vdEVsLCBleHRyYVZhcnMgPSAoKSA9PiB7fSwgY29tcG9uZW50Rm9yQ2xvbmUgPSBmYWxzZSkge1xuICAgICAgdGhpcy53YWxrQW5kU2tpcE5lc3RlZENvbXBvbmVudHMocm9vdEVsLCBlbCA9PiB7XG4gICAgICAgIC8vIERvbid0IHRvdWNoIHNwYXducyBmcm9tIGZvciBsb29wXG4gICAgICAgIGlmIChlbC5fX3hfZm9yX2tleSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gZmFsc2U7IC8vIERvbid0IHRvdWNoIHNwYXducyBmcm9tIGlmIGRpcmVjdGl2ZXNcblxuICAgICAgICBpZiAoZWwuX194X2luc2VydGVkX21lICE9PSB1bmRlZmluZWQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplRWxlbWVudChlbCwgZXh0cmFWYXJzLCBjb21wb25lbnRGb3JDbG9uZSA/IGZhbHNlIDogdHJ1ZSk7XG4gICAgICB9LCBlbCA9PiB7XG4gICAgICAgIGlmICghY29tcG9uZW50Rm9yQ2xvbmUpIGVsLl9feCA9IG5ldyBDb21wb25lbnQoZWwpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmV4ZWN1dGVBbmRDbGVhclJlbWFpbmluZ1Nob3dEaXJlY3RpdmVTdGFjaygpO1xuICAgICAgdGhpcy5leGVjdXRlQW5kQ2xlYXJOZXh0VGlja1N0YWNrKHJvb3RFbCk7XG4gICAgfVxuXG4gICAgaW5pdGlhbGl6ZUVsZW1lbnQoZWwsIGV4dHJhVmFycywgc2hvdWxkUmVnaXN0ZXJMaXN0ZW5lcnMgPSB0cnVlKSB7XG4gICAgICAvLyBUbyBzdXBwb3J0IGNsYXNzIGF0dHJpYnV0ZSBtZXJnaW5nLCB3ZSBoYXZlIHRvIGtub3cgd2hhdCB0aGUgZWxlbWVudCdzXG4gICAgICAvLyBvcmlnaW5hbCBjbGFzcyBhdHRyaWJ1dGUgbG9va2VkIGxpa2UgZm9yIHJlZmVyZW5jZS5cbiAgICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoJ2NsYXNzJykgJiYgZ2V0WEF0dHJzKGVsLCB0aGlzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGVsLl9feF9vcmlnaW5hbF9jbGFzc2VzID0gY29udmVydENsYXNzU3RyaW5nVG9BcnJheShlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykpO1xuICAgICAgfVxuXG4gICAgICBzaG91bGRSZWdpc3Rlckxpc3RlbmVycyAmJiB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKGVsLCBleHRyYVZhcnMpO1xuICAgICAgdGhpcy5yZXNvbHZlQm91bmRBdHRyaWJ1dGVzKGVsLCB0cnVlLCBleHRyYVZhcnMpO1xuICAgIH1cblxuICAgIHVwZGF0ZUVsZW1lbnRzKHJvb3RFbCwgZXh0cmFWYXJzID0gKCkgPT4ge30pIHtcbiAgICAgIHRoaXMud2Fsa0FuZFNraXBOZXN0ZWRDb21wb25lbnRzKHJvb3RFbCwgZWwgPT4ge1xuICAgICAgICAvLyBEb24ndCB0b3VjaCBzcGF3bnMgZnJvbSBmb3IgbG9vcCAoYW5kIGNoZWNrIGlmIHRoZSByb290IGlzIGFjdHVhbGx5IGEgZm9yIGxvb3AgaW4gYSBwYXJlbnQsIGRvbid0IHNraXAgaXQuKVxuICAgICAgICBpZiAoZWwuX194X2Zvcl9rZXkgIT09IHVuZGVmaW5lZCAmJiAhZWwuaXNTYW1lTm9kZSh0aGlzLiRlbCkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50KGVsLCBleHRyYVZhcnMpO1xuICAgICAgfSwgZWwgPT4ge1xuICAgICAgICBlbC5fX3ggPSBuZXcgQ29tcG9uZW50KGVsKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5leGVjdXRlQW5kQ2xlYXJSZW1haW5pbmdTaG93RGlyZWN0aXZlU3RhY2soKTtcbiAgICAgIHRoaXMuZXhlY3V0ZUFuZENsZWFyTmV4dFRpY2tTdGFjayhyb290RWwpO1xuICAgIH1cblxuICAgIGV4ZWN1dGVBbmRDbGVhck5leHRUaWNrU3RhY2soZWwpIHtcbiAgICAgIC8vIFNraXAgc3Bhd25zIGZyb20gYWxwaW5lIGRpcmVjdGl2ZXNcbiAgICAgIGlmIChlbCA9PT0gdGhpcy4kZWwgJiYgdGhpcy5uZXh0VGlja1N0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gV2UgcnVuIHRoZSB0aWNrIHN0YWNrIGFmdGVyIHRoZSBuZXh0IGZyYW1lIHRvIGFsbG93IGFueVxuICAgICAgICAvLyBydW5uaW5nIHRyYW5zaXRpb25zIHRvIHBhc3MgdGhlIGluaXRpYWwgc2hvdyBzdGFnZS5cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICB3aGlsZSAodGhpcy5uZXh0VGlja1N0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMubmV4dFRpY2tTdGFjay5zaGlmdCgpKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBleGVjdXRlQW5kQ2xlYXJSZW1haW5pbmdTaG93RGlyZWN0aXZlU3RhY2soKSB7XG4gICAgICAvLyBUaGUgZ29hbCBoZXJlIGlzIHRvIHN0YXJ0IGFsbCB0aGUgeC1zaG93IHRyYW5zaXRpb25zXG4gICAgICAvLyBhbmQgYnVpbGQgYSBuZXN0ZWQgcHJvbWlzZSBjaGFpbiBzbyB0aGF0IGVsZW1lbnRzXG4gICAgICAvLyBvbmx5IGhpZGUgd2hlbiB0aGUgY2hpbGRyZW4gYXJlIGZpbmlzaGVkIGhpZGluZy5cbiAgICAgIHRoaXMuc2hvd0RpcmVjdGl2ZVN0YWNrLnJldmVyc2UoKS5tYXAoaGFuZGxlciA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgaGFuZGxlcihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH0pLnJlZHVjZSgocHJvbWlzZUNoYWluLCBwcm9taXNlKSA9PiB7XG4gICAgICAgIHJldHVybiBwcm9taXNlQ2hhaW4udGhlbigoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmaW5pc2hFbGVtZW50ID0+IHtcbiAgICAgICAgICAgIGZpbmlzaEVsZW1lbnQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9LCBQcm9taXNlLnJlc29sdmUoKCkgPT4ge30pKS5jYXRjaChlID0+IHtcbiAgICAgICAgaWYgKGUgIT09IFRSQU5TSVRJT05fQ0FOQ0VMTEVEKSB0aHJvdyBlO1xuICAgICAgfSk7IC8vIFdlJ3ZlIHByb2Nlc3NlZCB0aGUgaGFuZGxlciBzdGFjay4gbGV0J3MgY2xlYXIgaXQuXG5cbiAgICAgIHRoaXMuc2hvd0RpcmVjdGl2ZVN0YWNrID0gW107XG4gICAgICB0aGlzLnNob3dEaXJlY3RpdmVMYXN0RWxlbWVudCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB1cGRhdGVFbGVtZW50KGVsLCBleHRyYVZhcnMpIHtcbiAgICAgIHRoaXMucmVzb2x2ZUJvdW5kQXR0cmlidXRlcyhlbCwgZmFsc2UsIGV4dHJhVmFycyk7XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJMaXN0ZW5lcnMoZWwsIGV4dHJhVmFycykge1xuICAgICAgZ2V0WEF0dHJzKGVsLCB0aGlzKS5mb3JFYWNoKCh7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBtb2RpZmllcnMsXG4gICAgICAgIGV4cHJlc3Npb25cbiAgICAgIH0pID0+IHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSAnb24nOlxuICAgICAgICAgICAgcmVnaXN0ZXJMaXN0ZW5lcih0aGlzLCBlbCwgdmFsdWUsIG1vZGlmaWVycywgZXhwcmVzc2lvbiwgZXh0cmFWYXJzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnbW9kZWwnOlxuICAgICAgICAgICAgcmVnaXN0ZXJNb2RlbExpc3RlbmVyKHRoaXMsIGVsLCBtb2RpZmllcnMsIGV4cHJlc3Npb24sIGV4dHJhVmFycyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVzb2x2ZUJvdW5kQXR0cmlidXRlcyhlbCwgaW5pdGlhbFVwZGF0ZSA9IGZhbHNlLCBleHRyYVZhcnMpIHtcbiAgICAgIGxldCBhdHRycyA9IGdldFhBdHRycyhlbCwgdGhpcyk7XG4gICAgICBhdHRycy5mb3JFYWNoKCh7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBtb2RpZmllcnMsXG4gICAgICAgIGV4cHJlc3Npb25cbiAgICAgIH0pID0+IHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSAnbW9kZWwnOlxuICAgICAgICAgICAgaGFuZGxlQXR0cmlidXRlQmluZGluZ0RpcmVjdGl2ZSh0aGlzLCBlbCwgJ3ZhbHVlJywgZXhwcmVzc2lvbiwgZXh0cmFWYXJzLCB0eXBlLCBtb2RpZmllcnMpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdiaW5kJzpcbiAgICAgICAgICAgIC8vIFRoZSA6a2V5IGJpbmRpbmcgb24gYW4geC1mb3IgaXMgc3BlY2lhbCwgaWdub3JlIGl0LlxuICAgICAgICAgICAgaWYgKGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3RlbXBsYXRlJyAmJiB2YWx1ZSA9PT0gJ2tleScpIHJldHVybjtcbiAgICAgICAgICAgIGhhbmRsZUF0dHJpYnV0ZUJpbmRpbmdEaXJlY3RpdmUodGhpcywgZWwsIHZhbHVlLCBleHByZXNzaW9uLCBleHRyYVZhcnMsIHR5cGUsIG1vZGlmaWVycyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMuZXZhbHVhdGVSZXR1cm5FeHByZXNzaW9uKGVsLCBleHByZXNzaW9uLCBleHRyYVZhcnMpO1xuICAgICAgICAgICAgaGFuZGxlVGV4dERpcmVjdGl2ZShlbCwgb3V0cHV0LCBleHByZXNzaW9uKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICAgICAgICBoYW5kbGVIdG1sRGlyZWN0aXZlKHRoaXMsIGVsLCBleHByZXNzaW9uLCBleHRyYVZhcnMpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdzaG93JzpcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLmV2YWx1YXRlUmV0dXJuRXhwcmVzc2lvbihlbCwgZXhwcmVzc2lvbiwgZXh0cmFWYXJzKTtcbiAgICAgICAgICAgIGhhbmRsZVNob3dEaXJlY3RpdmUodGhpcywgZWwsIG91dHB1dCwgbW9kaWZpZXJzLCBpbml0aWFsVXBkYXRlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnaWYnOlxuICAgICAgICAgICAgLy8gSWYgdGhpcyBlbGVtZW50IGFsc28gaGFzIHgtZm9yIG9uIGl0LCBkb24ndCBwcm9jZXNzIHgtaWYuXG4gICAgICAgICAgICAvLyBXZSB3aWxsIGxldCB0aGUgXCJ4LWZvclwiIGRpcmVjdGl2ZSBoYW5kbGUgdGhlIFwiaWZcImluZy5cbiAgICAgICAgICAgIGlmIChhdHRycy5zb21lKGkgPT4gaS50eXBlID09PSAnZm9yJykpIHJldHVybjtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLmV2YWx1YXRlUmV0dXJuRXhwcmVzc2lvbihlbCwgZXhwcmVzc2lvbiwgZXh0cmFWYXJzKTtcbiAgICAgICAgICAgIGhhbmRsZUlmRGlyZWN0aXZlKHRoaXMsIGVsLCBvdXRwdXQsIGluaXRpYWxVcGRhdGUsIGV4dHJhVmFycyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2Zvcic6XG4gICAgICAgICAgICBoYW5kbGVGb3JEaXJlY3RpdmUodGhpcywgZWwsIGV4cHJlc3Npb24sIGluaXRpYWxVcGRhdGUsIGV4dHJhVmFycyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2Nsb2FrJzpcbiAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgneC1jbG9haycpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGV2YWx1YXRlUmV0dXJuRXhwcmVzc2lvbihlbCwgZXhwcmVzc2lvbiwgZXh0cmFWYXJzID0gKCkgPT4ge30pIHtcbiAgICAgIHJldHVybiBzYWZlckV2YWwoZWwsIGV4cHJlc3Npb24sIHRoaXMuJGRhdGEsIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBleHRyYVZhcnMoKSksIHt9LCB7XG4gICAgICAgICRkaXNwYXRjaDogdGhpcy5nZXREaXNwYXRjaEZ1bmN0aW9uKGVsKVxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIGV2YWx1YXRlQ29tbWFuZEV4cHJlc3Npb24oZWwsIGV4cHJlc3Npb24sIGV4dHJhVmFycyA9ICgpID0+IHt9KSB7XG4gICAgICByZXR1cm4gc2FmZXJFdmFsTm9SZXR1cm4oZWwsIGV4cHJlc3Npb24sIHRoaXMuJGRhdGEsIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBleHRyYVZhcnMoKSksIHt9LCB7XG4gICAgICAgICRkaXNwYXRjaDogdGhpcy5nZXREaXNwYXRjaEZ1bmN0aW9uKGVsKVxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIGdldERpc3BhdGNoRnVuY3Rpb24oZWwpIHtcbiAgICAgIHJldHVybiAoZXZlbnQsIGRldGFpbCA9IHt9KSA9PiB7XG4gICAgICAgIGVsLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KGV2ZW50LCB7XG4gICAgICAgICAgZGV0YWlsLFxuICAgICAgICAgIGJ1YmJsZXM6IHRydWVcbiAgICAgICAgfSkpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBsaXN0ZW5Gb3JOZXdFbGVtZW50c1RvSW5pdGlhbGl6ZSgpIHtcbiAgICAgIGNvbnN0IHRhcmdldE5vZGUgPSB0aGlzLiRlbDtcbiAgICAgIGNvbnN0IG9ic2VydmVyT3B0aW9ucyA9IHtcbiAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgICAgICBzdWJ0cmVlOiB0cnVlXG4gICAgICB9O1xuICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihtdXRhdGlvbnMgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG11dGF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIC8vIEZpbHRlciBvdXQgbXV0YXRpb25zIHRyaWdnZXJlZCBmcm9tIGNoaWxkIGNvbXBvbmVudHMuXG4gICAgICAgICAgY29uc3QgY2xvc2VzdFBhcmVudENvbXBvbmVudCA9IG11dGF0aW9uc1tpXS50YXJnZXQuY2xvc2VzdCgnW3gtZGF0YV0nKTtcbiAgICAgICAgICBpZiAoIShjbG9zZXN0UGFyZW50Q29tcG9uZW50ICYmIGNsb3Nlc3RQYXJlbnRDb21wb25lbnQuaXNTYW1lTm9kZSh0aGlzLiRlbCkpKSBjb250aW51ZTtcblxuICAgICAgICAgIGlmIChtdXRhdGlvbnNbaV0udHlwZSA9PT0gJ2F0dHJpYnV0ZXMnICYmIG11dGF0aW9uc1tpXS5hdHRyaWJ1dGVOYW1lID09PSAneC1kYXRhJykge1xuICAgICAgICAgICAgY29uc3QgeEF0dHIgPSBtdXRhdGlvbnNbaV0udGFyZ2V0LmdldEF0dHJpYnV0ZSgneC1kYXRhJykgfHwgJ3t9JztcbiAgICAgICAgICAgIGNvbnN0IHJhd0RhdGEgPSBzYWZlckV2YWwodGhpcy4kZWwsIHhBdHRyLCB7XG4gICAgICAgICAgICAgICRlbDogdGhpcy4kZWxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMocmF3RGF0YSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICBpZiAodGhpcy4kZGF0YVtrZXldICE9PSByYXdEYXRhW2tleV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRkYXRhW2tleV0gPSByYXdEYXRhW2tleV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChtdXRhdGlvbnNbaV0uYWRkZWROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBtdXRhdGlvbnNbaV0uYWRkZWROb2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gMSB8fCBub2RlLl9feF9pbnNlcnRlZF9tZSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgIGlmIChub2RlLm1hdGNoZXMoJ1t4LWRhdGFdJykgJiYgIW5vZGUuX194KSB7XG4gICAgICAgICAgICAgICAgbm9kZS5fX3ggPSBuZXcgQ29tcG9uZW50KG5vZGUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZUVsZW1lbnRzKG5vZGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG9ic2VydmVyLm9ic2VydmUodGFyZ2V0Tm9kZSwgb2JzZXJ2ZXJPcHRpb25zKTtcbiAgICB9XG5cbiAgICBnZXRSZWZzUHJveHkoKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgcmVmT2JqID0ge307XG4gICAgICAvLyBPbmUgb2YgdGhlIGdvYWxzIG9mIHRoaXMgaXMgdG8gbm90IGhvbGQgZWxlbWVudHMgaW4gbWVtb3J5LCBidXQgcmF0aGVyIHJlLWV2YWx1YXRlXG4gICAgICAvLyB0aGUgRE9NIHdoZW4gdGhlIHN5c3RlbSBuZWVkcyBzb21ldGhpbmcgZnJvbSBpdC4gVGhpcyB3YXksIHRoZSBmcmFtZXdvcmsgaXMgZmxleGlibGUgYW5kXG4gICAgICAvLyBmcmllbmRseSB0byBvdXRzaWRlIERPTSBjaGFuZ2VzIGZyb20gbGlicmFyaWVzIGxpa2UgVnVlL0xpdmV3aXJlLlxuICAgICAgLy8gRm9yIHRoaXMgcmVhc29uLCBJJ20gdXNpbmcgYW4gXCJvbi1kZW1hbmRcIiBwcm94eSB0byBmYWtlIGEgXCIkcmVmc1wiIG9iamVjdC5cblxuICAgICAgcmV0dXJuIG5ldyBQcm94eShyZWZPYmosIHtcbiAgICAgICAgZ2V0KG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICAgICAgICBpZiAocHJvcGVydHkgPT09ICckaXNBbHBpbmVQcm94eScpIHJldHVybiB0cnVlO1xuICAgICAgICAgIHZhciByZWY7IC8vIFdlIGNhbid0IGp1c3QgcXVlcnkgdGhlIERPTSBiZWNhdXNlIGl0J3MgaGFyZCB0byBmaWx0ZXIgb3V0IHJlZnMgaW5cbiAgICAgICAgICAvLyBuZXN0ZWQgY29tcG9uZW50cy5cblxuICAgICAgICAgIHNlbGYud2Fsa0FuZFNraXBOZXN0ZWRDb21wb25lbnRzKHNlbGYuJGVsLCBlbCA9PiB7XG4gICAgICAgICAgICBpZiAoZWwuaGFzQXR0cmlidXRlKCd4LXJlZicpICYmIGVsLmdldEF0dHJpYnV0ZSgneC1yZWYnKSA9PT0gcHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgcmVmID0gZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHJlZjtcbiAgICAgICAgfVxuXG4gICAgICB9KTtcbiAgICB9XG5cbiAgfVxuXG4gIGNvbnN0IEFscGluZSA9IHtcbiAgICB2ZXJzaW9uOiBcIjIuOC4yXCIsXG4gICAgcGF1c2VNdXRhdGlvbk9ic2VydmVyOiBmYWxzZSxcbiAgICBtYWdpY1Byb3BlcnRpZXM6IHt9LFxuICAgIG9uQ29tcG9uZW50SW5pdGlhbGl6ZWRzOiBbXSxcbiAgICBvbkJlZm9yZUNvbXBvbmVudEluaXRpYWxpemVkczogW10sXG4gICAgaWdub3JlRm9jdXNlZEZvclZhbHVlQmluZGluZzogZmFsc2UsXG4gICAgc3RhcnQ6IGFzeW5jIGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgaWYgKCFpc1Rlc3RpbmcoKSkge1xuICAgICAgICBhd2FpdCBkb21SZWFkeSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRpc2NvdmVyQ29tcG9uZW50cyhlbCA9PiB7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZUNvbXBvbmVudChlbCk7XG4gICAgICB9KTsgLy8gSXQncyBlYXNpZXIgYW5kIG1vcmUgcGVyZm9ybWFudCB0byBqdXN0IHN1cHBvcnQgVHVyYm9saW5rcyB0aGFuIGxpc3RlblxuICAgICAgLy8gdG8gTXV0YXRpb25PYnNlcnZlciBtdXRhdGlvbnMgYXQgdGhlIGRvY3VtZW50IGxldmVsLlxuXG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidHVyYm9saW5rczpsb2FkXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy5kaXNjb3ZlclVuaW5pdGlhbGl6ZWRDb21wb25lbnRzKGVsID0+IHtcbiAgICAgICAgICB0aGlzLmluaXRpYWxpemVDb21wb25lbnQoZWwpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5saXN0ZW5Gb3JOZXdVbmluaXRpYWxpemVkQ29tcG9uZW50c0F0UnVuVGltZSgpO1xuICAgIH0sXG4gICAgZGlzY292ZXJDb21wb25lbnRzOiBmdW5jdGlvbiBkaXNjb3ZlckNvbXBvbmVudHMoY2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IHJvb3RFbHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbeC1kYXRhXScpO1xuICAgICAgcm9vdEVscy5mb3JFYWNoKHJvb3RFbCA9PiB7XG4gICAgICAgIGNhbGxiYWNrKHJvb3RFbCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGRpc2NvdmVyVW5pbml0aWFsaXplZENvbXBvbmVudHM6IGZ1bmN0aW9uIGRpc2NvdmVyVW5pbml0aWFsaXplZENvbXBvbmVudHMoY2FsbGJhY2ssIGVsID0gbnVsbCkge1xuICAgICAgY29uc3Qgcm9vdEVscyA9IChlbCB8fCBkb2N1bWVudCkucXVlcnlTZWxlY3RvckFsbCgnW3gtZGF0YV0nKTtcbiAgICAgIEFycmF5LmZyb20ocm9vdEVscykuZmlsdGVyKGVsID0+IGVsLl9feCA9PT0gdW5kZWZpbmVkKS5mb3JFYWNoKHJvb3RFbCA9PiB7XG4gICAgICAgIGNhbGxiYWNrKHJvb3RFbCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGxpc3RlbkZvck5ld1VuaW5pdGlhbGl6ZWRDb21wb25lbnRzQXRSdW5UaW1lOiBmdW5jdGlvbiBsaXN0ZW5Gb3JOZXdVbmluaXRpYWxpemVkQ29tcG9uZW50c0F0UnVuVGltZSgpIHtcbiAgICAgIGNvbnN0IHRhcmdldE5vZGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdib2R5Jyk7XG4gICAgICBjb25zdCBvYnNlcnZlck9wdGlvbnMgPSB7XG4gICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICAgICAgc3VidHJlZTogdHJ1ZVxuICAgICAgfTtcbiAgICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobXV0YXRpb25zID0+IHtcbiAgICAgICAgaWYgKHRoaXMucGF1c2VNdXRhdGlvbk9ic2VydmVyKSByZXR1cm47XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXRhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAobXV0YXRpb25zW2ldLmFkZGVkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbXV0YXRpb25zW2ldLmFkZGVkTm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgICAgLy8gRGlzY2FyZCBub24tZWxlbWVudCBub2RlcyAobGlrZSBsaW5lLWJyZWFrcylcbiAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT09IDEpIHJldHVybjsgLy8gRGlzY2FyZCBhbnkgY2hhbmdlcyBoYXBwZW5pbmcgd2l0aGluIGFuIGV4aXN0aW5nIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgLy8gVGhleSB3aWxsIHRha2UgY2FyZSBvZiB0aGVtc2VsdmVzLlxuXG4gICAgICAgICAgICAgIGlmIChub2RlLnBhcmVudEVsZW1lbnQgJiYgbm9kZS5wYXJlbnRFbGVtZW50LmNsb3Nlc3QoJ1t4LWRhdGFdJykpIHJldHVybjtcbiAgICAgICAgICAgICAgdGhpcy5kaXNjb3ZlclVuaW5pdGlhbGl6ZWRDb21wb25lbnRzKGVsID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxpemVDb21wb25lbnQoZWwpO1xuICAgICAgICAgICAgICB9LCBub2RlLnBhcmVudEVsZW1lbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG9ic2VydmVyLm9ic2VydmUodGFyZ2V0Tm9kZSwgb2JzZXJ2ZXJPcHRpb25zKTtcbiAgICB9LFxuICAgIGluaXRpYWxpemVDb21wb25lbnQ6IGZ1bmN0aW9uIGluaXRpYWxpemVDb21wb25lbnQoZWwpIHtcbiAgICAgIGlmICghZWwuX194KSB7XG4gICAgICAgIC8vIFdyYXAgaW4gYSB0cnkvY2F0Y2ggc28gdGhhdCB3ZSBkb24ndCBwcmV2ZW50IG90aGVyIGNvbXBvbmVudHNcbiAgICAgICAgLy8gZnJvbSBpbml0aWFsaXppbmcgd2hlbiBvbmUgY29tcG9uZW50IGNvbnRhaW5zIGFuIGVycm9yLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIGVsLl9feCA9IG5ldyBDb21wb25lbnQoZWwpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNsb25lOiBmdW5jdGlvbiBjbG9uZShjb21wb25lbnQsIG5ld0VsKSB7XG4gICAgICBpZiAoIW5ld0VsLl9feCkge1xuICAgICAgICBuZXdFbC5fX3ggPSBuZXcgQ29tcG9uZW50KG5ld0VsLCBjb21wb25lbnQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgYWRkTWFnaWNQcm9wZXJ0eTogZnVuY3Rpb24gYWRkTWFnaWNQcm9wZXJ0eShuYW1lLCBjYWxsYmFjaykge1xuICAgICAgdGhpcy5tYWdpY1Byb3BlcnRpZXNbbmFtZV0gPSBjYWxsYmFjaztcbiAgICB9LFxuICAgIG9uQ29tcG9uZW50SW5pdGlhbGl6ZWQ6IGZ1bmN0aW9uIG9uQ29tcG9uZW50SW5pdGlhbGl6ZWQoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMub25Db21wb25lbnRJbml0aWFsaXplZHMucHVzaChjYWxsYmFjayk7XG4gICAgfSxcbiAgICBvbkJlZm9yZUNvbXBvbmVudEluaXRpYWxpemVkOiBmdW5jdGlvbiBvbkJlZm9yZUNvbXBvbmVudEluaXRpYWxpemVkKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLm9uQmVmb3JlQ29tcG9uZW50SW5pdGlhbGl6ZWRzLnB1c2goY2FsbGJhY2spO1xuICAgIH1cbiAgfTtcblxuICBpZiAoIWlzVGVzdGluZygpKSB7XG4gICAgd2luZG93LkFscGluZSA9IEFscGluZTtcblxuICAgIGlmICh3aW5kb3cuZGVmZXJMb2FkaW5nQWxwaW5lKSB7XG4gICAgICB3aW5kb3cuZGVmZXJMb2FkaW5nQWxwaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93LkFscGluZS5zdGFydCgpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5BbHBpbmUuc3RhcnQoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gQWxwaW5lO1xuXG59KSkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBjcmVsdCgpIHtcbiAgdmFyIGVsdCA9IGFyZ3VtZW50c1swXTtcbiAgaWYgKHR5cGVvZiBlbHQgPT0gXCJzdHJpbmdcIikgZWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChlbHQpO1xuICB2YXIgaSA9IDEsIG5leHQgPSBhcmd1bWVudHNbMV07XG4gIGlmIChuZXh0ICYmIHR5cGVvZiBuZXh0ID09IFwib2JqZWN0XCIgJiYgbmV4dC5ub2RlVHlwZSA9PSBudWxsICYmICFBcnJheS5pc0FycmF5KG5leHQpKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBuZXh0KSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5leHQsIG5hbWUpKSB7XG4gICAgICB2YXIgdmFsdWUgPSBuZXh0W25hbWVdO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiKSBlbHQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICAgIGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIGVsdFtuYW1lXSA9IHZhbHVlO1xuICAgIH1cbiAgICBpKys7XG4gIH1cbiAgZm9yICg7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFkZChlbHQsIGFyZ3VtZW50c1tpXSk7XG4gIHJldHVybiBlbHRcbn1cblxuZnVuY3Rpb24gYWRkKGVsdCwgY2hpbGQpIHtcbiAgaWYgKHR5cGVvZiBjaGlsZCA9PSBcInN0cmluZ1wiKSB7XG4gICAgZWx0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNoaWxkKSk7XG4gIH0gZWxzZSBpZiAoY2hpbGQgPT0gbnVsbCkgOyBlbHNlIGlmIChjaGlsZC5ub2RlVHlwZSAhPSBudWxsKSB7XG4gICAgZWx0LmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNoaWxkKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGQubGVuZ3RoOyBpKyspIGFkZChlbHQsIGNoaWxkW2ldKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlVuc3VwcG9ydGVkIGNoaWxkIG5vZGU6IFwiICsgY2hpbGQpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVsdDtcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLy8vIFRoZSBkZWZhdWx0IG1heGltdW0gbGVuZ3RoIG9mIGEgYFRyZWVCdWZmZXJgIG5vZGUuXG5jb25zdCBEZWZhdWx0QnVmZmVyTGVuZ3RoID0gMTAyNDtcbmxldCBuZXh0UHJvcElEID0gMDtcbmNvbnN0IENhY2hlZE5vZGUgPSBuZXcgV2Vha01hcCgpO1xuLy8vIEVhY2ggW25vZGUgdHlwZV0oI3RyZWUuTm9kZVR5cGUpIGNhbiBoYXZlIG1ldGFkYXRhIGFzc29jaWF0ZWQgd2l0aFxuLy8vIGl0IGluIHByb3BzLiBJbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyByZXByZXNlbnQgcHJvcCBuYW1lcy5cbmNsYXNzIE5vZGVQcm9wIHtcbiAgICAvLy8gQ3JlYXRlIGEgbmV3IG5vZGUgcHJvcCB0eXBlLiBZb3UgY2FuIG9wdGlvbmFsbHkgcGFzcyBhXG4gICAgLy8vIGBkZXNlcmlhbGl6ZWAgZnVuY3Rpb24uXG4gICAgY29uc3RydWN0b3IoeyBkZXNlcmlhbGl6ZSB9ID0ge30pIHtcbiAgICAgICAgdGhpcy5pZCA9IG5leHRQcm9wSUQrKztcbiAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZSA9IGRlc2VyaWFsaXplIHx8ICgoKSA9PiB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIG5vZGUgdHlwZSBkb2Vzbid0IGRlZmluZSBhIGRlc2VyaWFsaXplIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8vIENyZWF0ZSBhIHN0cmluZy12YWx1ZWQgbm9kZSBwcm9wIHdob3NlIGRlc2VyaWFsaXplIGZ1bmN0aW9uIGlzXG4gICAgLy8vIHRoZSBpZGVudGl0eSBmdW5jdGlvbi5cbiAgICBzdGF0aWMgc3RyaW5nKCkgeyByZXR1cm4gbmV3IE5vZGVQcm9wKHsgZGVzZXJpYWxpemU6IHN0ciA9PiBzdHIgfSk7IH1cbiAgICAvLy8gQ3JlYXRlIGEgbnVtYmVyLXZhbHVlZCBub2RlIHByb3Agd2hvc2UgZGVzZXJpYWxpemUgZnVuY3Rpb24gaXNcbiAgICAvLy8ganVzdCBgTnVtYmVyYC5cbiAgICBzdGF0aWMgbnVtYmVyKCkgeyByZXR1cm4gbmV3IE5vZGVQcm9wKHsgZGVzZXJpYWxpemU6IE51bWJlciB9KTsgfVxuICAgIC8vLyBDcmVhdGVzIGEgYm9vbGVhbi12YWx1ZWQgbm9kZSBwcm9wIHdob3NlIGRlc2VyaWFsaXplIGZ1bmN0aW9uXG4gICAgLy8vIHJldHVybnMgdHJ1ZSBmb3IgYW55IGlucHV0LlxuICAgIHN0YXRpYyBmbGFnKCkgeyByZXR1cm4gbmV3IE5vZGVQcm9wKHsgZGVzZXJpYWxpemU6ICgpID0+IHRydWUgfSk7IH1cbiAgICAvLy8gU3RvcmUgYSB2YWx1ZSBmb3IgdGhpcyBwcm9wIGluIHRoZSBnaXZlbiBvYmplY3QuIFRoaXMgY2FuIGJlXG4gICAgLy8vIHVzZWZ1bCB3aGVuIGJ1aWxkaW5nIHVwIGEgcHJvcCBvYmplY3QgdG8gcGFzcyB0byB0aGVcbiAgICAvLy8gW2BOb2RlVHlwZWBdKCN0cmVlLk5vZGVUeXBlKSBjb25zdHJ1Y3Rvci4gUmV0dXJucyBpdHMgZmlyc3RcbiAgICAvLy8gYXJndW1lbnQuXG4gICAgc2V0KHByb3BPYmosIHZhbHVlKSB7XG4gICAgICAgIHByb3BPYmpbdGhpcy5pZF0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHByb3BPYmo7XG4gICAgfVxuICAgIC8vLyBUaGlzIGlzIG1lYW50IHRvIGJlIHVzZWQgd2l0aFxuICAgIC8vLyBbYE5vZGVTZXQuZXh0ZW5kYF0oI3RyZWUuTm9kZVNldC5leHRlbmQpIG9yXG4gICAgLy8vIFtgUGFyc2VyLndpdGhQcm9wc2BdKCNsZXplci5QYXJzZXIud2l0aFByb3BzKSB0byBjb21wdXRlIHByb3BcbiAgICAvLy8gdmFsdWVzIGZvciBlYWNoIG5vZGUgdHlwZSBpbiB0aGUgc2V0LiBUYWtlcyBhIFttYXRjaFxuICAgIC8vLyBvYmplY3RdKCN0cmVlLk5vZGVUeXBlXm1hdGNoKSBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgdW5kZWZpbmVkXG4gICAgLy8vIGlmIHRoZSBub2RlIHR5cGUgZG9lc24ndCBnZXQgdGhpcyBwcm9wLCBhbmQgdGhlIHByb3AncyB2YWx1ZSBpZlxuICAgIC8vLyBpdCBkb2VzLlxuICAgIGFkZChtYXRjaCkge1xuICAgICAgICBpZiAodHlwZW9mIG1hdGNoICE9IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIG1hdGNoID0gTm9kZVR5cGUubWF0Y2gobWF0Y2gpO1xuICAgICAgICByZXR1cm4gKHR5cGUpID0+IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBtYXRjaCh0eXBlKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBbdGhpcywgcmVzdWx0XTtcbiAgICAgICAgfTtcbiAgICB9XG59XG4vLy8gUHJvcCB0aGF0IGlzIHVzZWQgdG8gZGVzY3JpYmUgbWF0Y2hpbmcgZGVsaW1pdGVycy4gRm9yIG9wZW5pbmdcbi8vLyBkZWxpbWl0ZXJzLCB0aGlzIGhvbGRzIGFuIGFycmF5IG9mIG5vZGUgbmFtZXMgKHdyaXR0ZW4gYXMgYVxuLy8vIHNwYWNlLXNlcGFyYXRlZCBzdHJpbmcgd2hlbiBkZWNsYXJpbmcgdGhpcyBwcm9wIGluIGEgZ3JhbW1hcilcbi8vLyBmb3IgdGhlIG5vZGUgdHlwZXMgb2YgY2xvc2luZyBkZWxpbWl0ZXJzIHRoYXQgbWF0Y2ggaXQuXG5Ob2RlUHJvcC5jbG9zZWRCeSA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbi8vLyBUaGUgaW52ZXJzZSBvZiBbYG9wZW5lZEJ5YF0oI3RyZWUuTm9kZVByb3BeY2xvc2VkQnkpLiBUaGlzIGlzXG4vLy8gYXR0YWNoZWQgdG8gY2xvc2luZyBkZWxpbWl0ZXJzLCBob2xkaW5nIGFuIGFycmF5IG9mIG5vZGUgbmFtZXNcbi8vLyBvZiB0eXBlcyBvZiBtYXRjaGluZyBvcGVuaW5nIGRlbGltaXRlcnMuXG5Ob2RlUHJvcC5vcGVuZWRCeSA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbi8vLyBVc2VkIHRvIGFzc2lnbiBub2RlIHR5cGVzIHRvIGdyb3VwcyAoZm9yIGV4YW1wbGUsIGFsbCBub2RlXG4vLy8gdHlwZXMgdGhhdCByZXByZXNlbnQgYW4gZXhwcmVzc2lvbiBjb3VsZCBiZSB0YWdnZWQgd2l0aCBhblxuLy8vIGBcIkV4cHJlc3Npb25cImAgZ3JvdXApLlxuTm9kZVByb3AuZ3JvdXAgPSBuZXcgTm9kZVByb3AoeyBkZXNlcmlhbGl6ZTogc3RyID0+IHN0ci5zcGxpdChcIiBcIikgfSk7XG5jb25zdCBub1Byb3BzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8vLyBFYWNoIG5vZGUgaW4gYSBzeW50YXggdHJlZSBoYXMgYSBub2RlIHR5cGUgYXNzb2NpYXRlZCB3aXRoIGl0LlxuY2xhc3MgTm9kZVR5cGUge1xuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gVGhlIG5hbWUgb2YgdGhlIG5vZGUgdHlwZS4gTm90IG5lY2Vzc2FyaWx5IHVuaXF1ZSwgYnV0IGlmIHRoZVxuICAgIC8vLyBncmFtbWFyIHdhcyB3cml0dGVuIHByb3Blcmx5LCBkaWZmZXJlbnQgbm9kZSB0eXBlcyB3aXRoIHRoZVxuICAgIC8vLyBzYW1lIG5hbWUgd2l0aGluIGEgbm9kZSBzZXQgc2hvdWxkIHBsYXkgdGhlIHNhbWUgc2VtYW50aWNcbiAgICAvLy8gcm9sZS5cbiAgICBuYW1lLCBcbiAgICAvLy8gQGludGVybmFsXG4gICAgcHJvcHMsIFxuICAgIC8vLyBUaGUgaWQgb2YgdGhpcyBub2RlIGluIGl0cyBzZXQuIENvcnJlc3BvbmRzIHRvIHRoZSB0ZXJtIGlkc1xuICAgIC8vLyB1c2VkIGluIHRoZSBwYXJzZXIuXG4gICAgaWQsIFxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBmbGFncyA9IDApIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICB9XG4gICAgc3RhdGljIGRlZmluZShzcGVjKSB7XG4gICAgICAgIGxldCBwcm9wcyA9IHNwZWMucHJvcHMgJiYgc3BlYy5wcm9wcy5sZW5ndGggPyBPYmplY3QuY3JlYXRlKG51bGwpIDogbm9Qcm9wcztcbiAgICAgICAgbGV0IGZsYWdzID0gKHNwZWMudG9wID8gMSAvKiBUb3AgKi8gOiAwKSB8IChzcGVjLnNraXBwZWQgPyAyIC8qIFNraXBwZWQgKi8gOiAwKSB8XG4gICAgICAgICAgICAoc3BlYy5lcnJvciA/IDQgLyogRXJyb3IgKi8gOiAwKSB8IChzcGVjLm5hbWUgPT0gbnVsbCA/IDggLyogQW5vbnltb3VzICovIDogMCk7XG4gICAgICAgIGxldCB0eXBlID0gbmV3IE5vZGVUeXBlKHNwZWMubmFtZSB8fCBcIlwiLCBwcm9wcywgc3BlYy5pZCwgZmxhZ3MpO1xuICAgICAgICBpZiAoc3BlYy5wcm9wcylcbiAgICAgICAgICAgIGZvciAobGV0IHNyYyBvZiBzcGVjLnByb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNyYykpXG4gICAgICAgICAgICAgICAgICAgIHNyYyA9IHNyYyh0eXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoc3JjKVxuICAgICAgICAgICAgICAgICAgICBzcmNbMF0uc2V0KHByb3BzLCBzcmNbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gICAgLy8vIFJldHJpZXZlcyBhIG5vZGUgcHJvcCBmb3IgdGhpcyB0eXBlLiBXaWxsIHJldHVybiBgdW5kZWZpbmVkYCBpZlxuICAgIC8vLyB0aGUgcHJvcCBpc24ndCBwcmVzZW50IG9uIHRoaXMgbm9kZS5cbiAgICBwcm9wKHByb3ApIHsgcmV0dXJuIHRoaXMucHJvcHNbcHJvcC5pZF07IH1cbiAgICAvLy8gVHJ1ZSB3aGVuIHRoaXMgaXMgdGhlIHRvcCBub2RlIG9mIGEgZ3JhbW1hci5cbiAgICBnZXQgaXNUb3AoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDEgLyogVG9wICovKSA+IDA7IH1cbiAgICAvLy8gVHJ1ZSB3aGVuIHRoaXMgbm9kZSBpcyBwcm9kdWNlZCBieSBhIHNraXAgcnVsZS5cbiAgICBnZXQgaXNTa2lwcGVkKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiAyIC8qIFNraXBwZWQgKi8pID4gMDsgfVxuICAgIC8vLyBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIGlzIGFuIGVycm9yIG5vZGUuXG4gICAgZ2V0IGlzRXJyb3IoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDQgLyogRXJyb3IgKi8pID4gMDsgfVxuICAgIC8vLyBXaGVuIHRydWUsIHRoaXMgbm9kZSB0eXBlIGRvZXNuJ3QgY29ycmVzcG9uZCB0byBhIHVzZXItZGVjbGFyZWRcbiAgICAvLy8gbmFtZWQgbm9kZSwgZm9yIGV4YW1wbGUgYmVjYXVzZSBpdCBpcyB1c2VkIHRvIGNhY2hlIHJlcGV0aXRpb24uXG4gICAgZ2V0IGlzQW5vbnltb3VzKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiA4IC8qIEFub255bW91cyAqLykgPiAwOyB9XG4gICAgLy8vIFJldHVybnMgdHJ1ZSB3aGVuIHRoaXMgbm9kZSdzIG5hbWUgb3Igb25lIG9mIGl0c1xuICAgIC8vLyBbZ3JvdXBzXSgjdHJlZS5Ob2RlUHJvcF5ncm91cCkgbWF0Y2hlcyB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgIGlzKG5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uYW1lID09IG5hbWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBsZXQgZ3JvdXAgPSB0aGlzLnByb3AoTm9kZVByb3AuZ3JvdXApO1xuICAgICAgICAgICAgcmV0dXJuIGdyb3VwID8gZ3JvdXAuaW5kZXhPZihuYW1lKSA+IC0xIDogZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaWQgPT0gbmFtZTtcbiAgICB9XG4gICAgLy8vIENyZWF0ZSBhIGZ1bmN0aW9uIGZyb20gbm9kZSB0eXBlcyB0byBhcmJpdHJhcnkgdmFsdWVzIGJ5XG4gICAgLy8vIHNwZWNpZnlpbmcgYW4gb2JqZWN0IHdob3NlIHByb3BlcnR5IG5hbWVzIGFyZSBub2RlIG9yXG4gICAgLy8vIFtncm91cF0oI3RyZWUuTm9kZVByb3BeZ3JvdXApIG5hbWVzLiBPZnRlbiB1c2VmdWwgd2l0aFxuICAgIC8vLyBbYE5vZGVQcm9wLmFkZGBdKCN0cmVlLk5vZGVQcm9wLmFkZCkuIFlvdSBjYW4gcHV0IG11bHRpcGxlXG4gICAgLy8vIG5hbWVzLCBzZXBhcmF0ZWQgYnkgc3BhY2VzLCBpbiBhIHNpbmdsZSBwcm9wZXJ0eSBuYW1lIHRvIG1hcFxuICAgIC8vLyBtdWx0aXBsZSBub2RlIG5hbWVzIHRvIGEgc2luZ2xlIHZhbHVlLlxuICAgIHN0YXRpYyBtYXRjaChtYXApIHtcbiAgICAgICAgbGV0IGRpcmVjdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gbWFwKVxuICAgICAgICAgICAgZm9yIChsZXQgbmFtZSBvZiBwcm9wLnNwbGl0KFwiIFwiKSlcbiAgICAgICAgICAgICAgICBkaXJlY3RbbmFtZV0gPSBtYXBbcHJvcF07XG4gICAgICAgIHJldHVybiAobm9kZSkgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgZ3JvdXBzID0gbm9kZS5wcm9wKE5vZGVQcm9wLmdyb3VwKSwgaSA9IC0xOyBpIDwgKGdyb3VwcyA/IGdyb3Vwcy5sZW5ndGggOiAwKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gZGlyZWN0W2kgPCAwID8gbm9kZS5uYW1lIDogZ3JvdXBzW2ldXTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG4vLy8gQW4gZW1wdHkgZHVtbXkgbm9kZSB0eXBlIHRvIHVzZSB3aGVuIG5vIGFjdHVhbCB0eXBlIGlzIGF2YWlsYWJsZS5cbk5vZGVUeXBlLm5vbmUgPSBuZXcgTm9kZVR5cGUoXCJcIiwgT2JqZWN0LmNyZWF0ZShudWxsKSwgMCwgOCAvKiBBbm9ueW1vdXMgKi8pO1xuLy8vIEEgbm9kZSBzZXQgaG9sZHMgYSBjb2xsZWN0aW9uIG9mIG5vZGUgdHlwZXMuIEl0IGlzIHVzZWQgdG9cbi8vLyBjb21wYWN0bHkgcmVwcmVzZW50IHRyZWVzIGJ5IHN0b3JpbmcgdGhlaXIgdHlwZSBpZHMsIHJhdGhlciB0aGFuIGFcbi8vLyBmdWxsIHBvaW50ZXIgdG8gdGhlIHR5cGUgb2JqZWN0LCBpbiBhIG51bWJlciBhcnJheS4gRWFjaCBwYXJzZXJcbi8vLyBbaGFzXSgjbGV6ZXIuUGFyc2VyLm5vZGVTZXQpIGEgbm9kZSBzZXQsIGFuZCBbdHJlZVxuLy8vIGJ1ZmZlcnNdKCN0cmVlLlRyZWVCdWZmZXIpIGNhbiBvbmx5IHN0b3JlIGNvbGxlY3Rpb25zIG9mIG5vZGVzXG4vLy8gZnJvbSB0aGUgc2FtZSBzZXQuIEEgc2V0IGNhbiBoYXZlIGEgbWF4aW11bSBvZiAyKioxNiAoNjU1MzYpXG4vLy8gbm9kZSB0eXBlcyBpbiBpdCwgc28gdGhhdCB0aGUgaWRzIGZpdCBpbnRvIDE2LWJpdCB0eXBlZCBhcnJheVxuLy8vIHNsb3RzLlxuY2xhc3MgTm9kZVNldCB7XG4gICAgLy8vIENyZWF0ZSBhIHNldCB3aXRoIHRoZSBnaXZlbiB0eXBlcy4gVGhlIGBpZGAgcHJvcGVydHkgb2YgZWFjaFxuICAgIC8vLyB0eXBlIHNob3VsZCBjb3JyZXNwb25kIHRvIGl0cyBwb3NpdGlvbiB3aXRoaW4gdGhlIGFycmF5LlxuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBUaGUgbm9kZSB0eXBlcyBpbiB0aGlzIHNldCwgYnkgaWQuXG4gICAgdHlwZXMpIHtcbiAgICAgICAgdGhpcy50eXBlcyA9IHR5cGVzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHR5cGVzW2ldLmlkICE9IGkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJOb2RlIHR5cGUgaWRzIHNob3VsZCBjb3JyZXNwb25kIHRvIGFycmF5IHBvc2l0aW9ucyB3aGVuIGNyZWF0aW5nIGEgbm9kZSBzZXRcIik7XG4gICAgfVxuICAgIC8vLyBDcmVhdGUgYSBjb3B5IG9mIHRoaXMgc2V0IHdpdGggc29tZSBub2RlIHByb3BlcnRpZXMgYWRkZWQuIFRoZVxuICAgIC8vLyBhcmd1bWVudHMgdG8gdGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNyZWF0ZWQgd2l0aFxuICAgIC8vLyBbYE5vZGVQcm9wLmFkZGBdKCN0cmVlLk5vZGVQcm9wLmFkZCkuXG4gICAgZXh0ZW5kKC4uLnByb3BzKSB7XG4gICAgICAgIGxldCBuZXdUeXBlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCB0eXBlIG9mIHRoaXMudHlwZXMpIHtcbiAgICAgICAgICAgIGxldCBuZXdQcm9wcyA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKGxldCBzb3VyY2Ugb2YgcHJvcHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgYWRkID0gc291cmNlKHR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChhZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXdQcm9wcylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgdHlwZS5wcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIGFkZFswXS5zZXQobmV3UHJvcHMsIGFkZFsxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3VHlwZXMucHVzaChuZXdQcm9wcyA/IG5ldyBOb2RlVHlwZSh0eXBlLm5hbWUsIG5ld1Byb3BzLCB0eXBlLmlkLCB0eXBlLmZsYWdzKSA6IHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTm9kZVNldChuZXdUeXBlcyk7XG4gICAgfVxufVxuLy8vIEEgcGllY2Ugb2Ygc3ludGF4IHRyZWUuIFRoZXJlIGFyZSB0d28gd2F5cyB0byBhcHByb2FjaCB0aGVzZVxuLy8vIHRyZWVzOiB0aGUgd2F5IHRoZXkgYXJlIGFjdHVhbGx5IHN0b3JlZCBpbiBtZW1vcnksIGFuZCB0aGVcbi8vLyBjb252ZW5pZW50IHdheS5cbi8vL1xuLy8vIFN5bnRheCB0cmVlcyBhcmUgc3RvcmVkIGFzIGEgdHJlZSBvZiBgVHJlZWAgYW5kIGBUcmVlQnVmZmVyYFxuLy8vIG9iamVjdHMuIEJ5IHBhY2tpbmcgZGV0YWlsIGluZm9ybWF0aW9uIGludG8gYFRyZWVCdWZmZXJgIGxlYWZcbi8vLyBub2RlcywgdGhlIHJlcHJlc2VudGF0aW9uIGlzIG1hZGUgYSBsb3QgbW9yZSBtZW1vcnktZWZmaWNpZW50LlxuLy8vXG4vLy8gSG93ZXZlciwgd2hlbiB5b3Ugd2FudCB0byBhY3R1YWxseSB3b3JrIHdpdGggdHJlZSBub2RlcywgdGhpc1xuLy8vIHJlcHJlc2VudGF0aW9uIGlzIHZlcnkgYXdrd2FyZCwgc28gbW9zdCBjbGllbnQgY29kZSB3aWxsIHdhbnQgdG9cbi8vLyB1c2UgdGhlIGBUcmVlQ3Vyc29yYCBpbnRlcmZhY2UgaW5zdGVhZCwgd2hpY2ggcHJvdmlkZXMgYSB2aWV3IG9uXG4vLy8gc29tZSBwYXJ0IG9mIHRoaXMgZGF0YSBzdHJ1Y3R1cmUsIGFuZCBjYW4gYmUgdXNlZCB0byBtb3ZlIGFyb3VuZFxuLy8vIHRvIGFkamFjZW50IG5vZGVzLlxuY2xhc3MgVHJlZSB7XG4gICAgLy8vIENvbnN0cnVjdCBhIG5ldyB0cmVlLiBZb3UgdXN1YWxseSB3YW50IHRvIGdvIHRocm91Z2hcbiAgICAvLy8gW2BUcmVlLmJ1aWxkYF0oI3RyZWUuVHJlZV5idWlsZCkgaW5zdGVhZC5cbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBcbiAgICAvLy8gVGhlIHRyZWUncyBjaGlsZCBub2Rlcy4gQ2hpbGRyZW4gc21hbGwgZW5vdWdoIHRvIGZpdCBpbiBhXG4gICAgLy8vIGBUcmVlQnVmZmVyIHdpbGwgYmUgcmVwcmVzZW50ZWQgYXMgc3VjaCwgb3RoZXIgY2hpbGRyZW4gY2FuIGJlXG4gICAgLy8vIGZ1cnRoZXIgYFRyZWVgIGluc3RhbmNlcyB3aXRoIHRoZWlyIG93biBpbnRlcm5hbCBzdHJ1Y3R1cmUuXG4gICAgY2hpbGRyZW4sIFxuICAgIC8vLyBUaGUgcG9zaXRpb25zIChvZmZzZXRzIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGlzIHRyZWUpIG9mXG4gICAgLy8vIHRoZSBjaGlsZHJlbi5cbiAgICBwb3NpdGlvbnMsIFxuICAgIC8vLyBUaGUgdG90YWwgbGVuZ3RoIG9mIHRoaXMgdHJlZVxuICAgIGxlbmd0aCkge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMucG9zaXRpb25zID0gcG9zaXRpb25zO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLm1hcChjID0+IGMudG9TdHJpbmcoKSkuam9pbigpO1xuICAgICAgICByZXR1cm4gIXRoaXMudHlwZS5uYW1lID8gY2hpbGRyZW4gOlxuICAgICAgICAgICAgKC9cXFcvLnRlc3QodGhpcy50eXBlLm5hbWUpICYmICF0aGlzLnR5cGUuaXNFcnJvciA/IEpTT04uc3RyaW5naWZ5KHRoaXMudHlwZS5uYW1lKSA6IHRoaXMudHlwZS5uYW1lKSArXG4gICAgICAgICAgICAgICAgKGNoaWxkcmVuLmxlbmd0aCA/IFwiKFwiICsgY2hpbGRyZW4gKyBcIilcIiA6IFwiXCIpO1xuICAgIH1cbiAgICAvLy8gR2V0IGEgW3RyZWUgY3Vyc29yXSgjdHJlZS5UcmVlQ3Vyc29yKSByb290ZWQgYXQgdGhpcyB0cmVlLiBXaGVuXG4gICAgLy8vIGBwb3NgIGlzIGdpdmVuLCB0aGUgY3Vyc29yIGlzIFttb3ZlZF0oI3RyZWUuVHJlZUN1cnNvci5tb3ZlVG8pXG4gICAgLy8vIHRvIHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgc2lkZS5cbiAgICBjdXJzb3IocG9zLCBzaWRlID0gMCkge1xuICAgICAgICBsZXQgc2NvcGUgPSAocG9zICE9IG51bGwgJiYgQ2FjaGVkTm9kZS5nZXQodGhpcykpIHx8IHRoaXMudG9wTm9kZTtcbiAgICAgICAgbGV0IGN1cnNvciA9IG5ldyBUcmVlQ3Vyc29yKHNjb3BlKTtcbiAgICAgICAgaWYgKHBvcyAhPSBudWxsKSB7XG4gICAgICAgICAgICBjdXJzb3IubW92ZVRvKHBvcywgc2lkZSk7XG4gICAgICAgICAgICBDYWNoZWROb2RlLnNldCh0aGlzLCBjdXJzb3IuX3RyZWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJzb3I7XG4gICAgfVxuICAgIC8vLyBHZXQgYSBbdHJlZSBjdXJzb3JdKCN0cmVlLlRyZWVDdXJzb3IpIHRoYXQsIHVubGlrZSByZWd1bGFyXG4gICAgLy8vIGN1cnNvcnMsIGRvZXNuJ3Qgc2tpcCBbYW5vbnltb3VzXSgjdHJlZS5Ob2RlVHlwZS5pc0Fub255bW91cylcbiAgICAvLy8gbm9kZXMuXG4gICAgZnVsbEN1cnNvcigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlQ3Vyc29yKHRoaXMudG9wTm9kZSwgdHJ1ZSk7XG4gICAgfVxuICAgIC8vLyBHZXQgYSBbc3ludGF4IG5vZGVdKCN0cmVlLlN5bnRheE5vZGUpIG9iamVjdCBmb3IgdGhlIHRvcCBvZiB0aGVcbiAgICAvLy8gdHJlZS5cbiAgICBnZXQgdG9wTm9kZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlTm9kZSh0aGlzLCAwLCAwLCBudWxsKTtcbiAgICB9XG4gICAgLy8vIEdldCB0aGUgW3N5bnRheCBub2RlXSgjdHJlZS5TeW50YXhOb2RlKSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgLy8vIElmIGBzaWRlYCBpcyAtMSwgdGhpcyB3aWxsIG1vdmUgaW50byBub2RlcyB0aGF0IGVuZCBhdCB0aGVcbiAgICAvLy8gcG9zaXRpb24uIElmIDEsIGl0J2xsIG1vdmUgaW50byBub2RlcyB0aGF0IHN0YXJ0IGF0IHRoZVxuICAgIC8vLyBwb3NpdGlvbi4gV2l0aCAwLCBpdCdsbCBvbmx5IGVudGVyIG5vZGVzIHRoYXQgY292ZXIgdGhlIHBvc2l0aW9uXG4gICAgLy8vIGZyb20gYm90aCBzaWRlcy5cbiAgICByZXNvbHZlKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3Vyc29yKHBvcywgc2lkZSkubm9kZTtcbiAgICB9XG4gICAgLy8vIEl0ZXJhdGUgb3ZlciB0aGUgdHJlZSBhbmQgaXRzIGNoaWxkcmVuLCBjYWxsaW5nIGBlbnRlcmAgZm9yIGFueVxuICAgIC8vLyBub2RlIHRoYXQgdG91Y2hlcyB0aGUgYGZyb21gL2B0b2AgcmVnaW9uIChpZiBnaXZlbikgYmVmb3JlXG4gICAgLy8vIHJ1bm5pbmcgb3ZlciBzdWNoIGEgbm9kZSdzIGNoaWxkcmVuLCBhbmQgYGxlYXZlYCAoaWYgZ2l2ZW4pIHdoZW5cbiAgICAvLy8gbGVhdmluZyB0aGUgbm9kZS4gV2hlbiBgZW50ZXJgIHJldHVybnMgYGZhbHNlYCwgdGhlIGdpdmVuIG5vZGVcbiAgICAvLy8gd2lsbCBub3QgaGF2ZSBpdHMgY2hpbGRyZW4gaXRlcmF0ZWQgb3ZlciAob3IgYGxlYXZlYCBjYWxsZWQpLlxuICAgIGl0ZXJhdGUoc3BlYykge1xuICAgICAgICBsZXQgeyBlbnRlciwgbGVhdmUsIGZyb20gPSAwLCB0byA9IHRoaXMubGVuZ3RoIH0gPSBzcGVjO1xuICAgICAgICBmb3IgKGxldCBjID0gdGhpcy5jdXJzb3IoKTs7KSB7XG4gICAgICAgICAgICBsZXQgbXVzdExlYXZlID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoYy5mcm9tIDw9IHRvICYmIGMudG8gPj0gZnJvbSAmJiAoYy50eXBlLmlzQW5vbnltb3VzIHx8IGVudGVyKGMudHlwZSwgYy5mcm9tLCBjLnRvKSAhPT0gZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMuZmlyc3RDaGlsZCgpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZiAoIWMudHlwZS5pc0Fub255bW91cylcbiAgICAgICAgICAgICAgICAgICAgbXVzdExlYXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBpZiAobXVzdExlYXZlICYmIGxlYXZlKVxuICAgICAgICAgICAgICAgICAgICBsZWF2ZShjLnR5cGUsIGMuZnJvbSwgYy50byk7XG4gICAgICAgICAgICAgICAgbXVzdExlYXZlID0gYy50eXBlLmlzQW5vbnltb3VzO1xuICAgICAgICAgICAgICAgIGlmIChjLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmICghYy5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIG11c3RMZWF2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIEJhbGFuY2UgdGhlIGRpcmVjdCBjaGlsZHJlbiBvZiB0aGlzIHRyZWUuXG4gICAgYmFsYW5jZShtYXhCdWZmZXJMZW5ndGggPSBEZWZhdWx0QnVmZmVyTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmxlbmd0aCA8PSBCYWxhbmNlQnJhbmNoRmFjdG9yID8gdGhpc1xuICAgICAgICAgICAgOiBiYWxhbmNlUmFuZ2UodGhpcy50eXBlLCBOb2RlVHlwZS5ub25lLCB0aGlzLmNoaWxkcmVuLCB0aGlzLnBvc2l0aW9ucywgMCwgdGhpcy5jaGlsZHJlbi5sZW5ndGgsIDAsIG1heEJ1ZmZlckxlbmd0aCwgdGhpcy5sZW5ndGgsIDApO1xuICAgIH1cbiAgICAvLy8gQnVpbGQgYSB0cmVlIGZyb20gYSBwb3N0Zml4LW9yZGVyZWQgYnVmZmVyIG9mIG5vZGUgaW5mb3JtYXRpb24sXG4gICAgLy8vIG9yIGEgY3Vyc29yIG92ZXIgc3VjaCBhIGJ1ZmZlci5cbiAgICBzdGF0aWMgYnVpbGQoZGF0YSkgeyByZXR1cm4gYnVpbGRUcmVlKGRhdGEpOyB9XG59XG4vLy8gVGhlIGVtcHR5IHRyZWVcblRyZWUuZW1wdHkgPSBuZXcgVHJlZShOb2RlVHlwZS5ub25lLCBbXSwgW10sIDApO1xuLy8gRm9yIHRyZWVzIHRoYXQgbmVlZCBhIGNvbnRleHQgaGFzaCBhdHRhY2hlZCwgd2UncmUgdXNpbmcgdGhpc1xuLy8ga2x1ZGdlIHdoaWNoIGFzc2lnbnMgYW4gZXh0cmEgcHJvcGVydHkgZGlyZWN0bHkgYWZ0ZXJcbi8vIGluaXRpYWxpemF0aW9uIChjcmVhdGluZyBhIHNpbmdsZSBuZXcgb2JqZWN0IHNoYXBlKS5cbmZ1bmN0aW9uIHdpdGhIYXNoKHRyZWUsIGhhc2gpIHtcbiAgICBpZiAoaGFzaClcbiAgICAgICAgdHJlZS5jb250ZXh0SGFzaCA9IGhhc2g7XG4gICAgcmV0dXJuIHRyZWU7XG59XG4vLy8gVHJlZSBidWZmZXJzIGNvbnRhaW4gKHR5cGUsIHN0YXJ0LCBlbmQsIGVuZEluZGV4KSBxdWFkcyBmb3IgZWFjaFxuLy8vIG5vZGUuIEluIHN1Y2ggYSBidWZmZXIsIG5vZGVzIGFyZSBzdG9yZWQgaW4gcHJlZml4IG9yZGVyIChwYXJlbnRzXG4vLy8gYmVmb3JlIGNoaWxkcmVuLCB3aXRoIHRoZSBlbmRJbmRleCBvZiB0aGUgcGFyZW50IGluZGljYXRpbmcgd2hpY2hcbi8vLyBjaGlsZHJlbiBiZWxvbmcgdG8gaXQpXG5jbGFzcyBUcmVlQnVmZmVyIHtcbiAgICAvLy8gQ3JlYXRlIGEgdHJlZSBidWZmZXIgQGludGVybmFsXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGJ1ZmZlciwgXG4gICAgLy8gVGhlIHRvdGFsIGxlbmd0aCBvZiB0aGUgZ3JvdXAgb2Ygbm9kZXMgaW4gdGhlIGJ1ZmZlci5cbiAgICBsZW5ndGgsIFxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzZXQsIHR5cGUgPSBOb2RlVHlwZS5ub25lKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5zZXQgPSBzZXQ7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5idWZmZXIubGVuZ3RoOykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5jaGlsZFN0cmluZyhpbmRleCkpO1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLmJ1ZmZlcltpbmRleCArIDNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbihcIixcIik7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBjaGlsZFN0cmluZyhpbmRleCkge1xuICAgICAgICBsZXQgaWQgPSB0aGlzLmJ1ZmZlcltpbmRleF0sIGVuZEluZGV4ID0gdGhpcy5idWZmZXJbaW5kZXggKyAzXTtcbiAgICAgICAgbGV0IHR5cGUgPSB0aGlzLnNldC50eXBlc1tpZF0sIHJlc3VsdCA9IHR5cGUubmFtZTtcbiAgICAgICAgaWYgKC9cXFcvLnRlc3QocmVzdWx0KSAmJiAhdHlwZS5pc0Vycm9yKVxuICAgICAgICAgICAgcmVzdWx0ID0gSlNPTi5zdHJpbmdpZnkocmVzdWx0KTtcbiAgICAgICAgaW5kZXggKz0gNDtcbiAgICAgICAgaWYgKGVuZEluZGV4ID09IGluZGV4KVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gW107XG4gICAgICAgIHdoaWxlIChpbmRleCA8IGVuZEluZGV4KSB7XG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHRoaXMuY2hpbGRTdHJpbmcoaW5kZXgpKTtcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5idWZmZXJbaW5kZXggKyAzXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0ICsgXCIoXCIgKyBjaGlsZHJlbi5qb2luKFwiLFwiKSArIFwiKVwiO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgZmluZENoaWxkKHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBkaXIsIGFmdGVyKSB7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcywgcGljayA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSAhPSBlbmRJbmRleDsgaSA9IGJ1ZmZlcltpICsgM10pIHtcbiAgICAgICAgICAgIGlmIChhZnRlciAhPSAtMTAwMDAwMDAwIC8qIE5vbmUgKi8pIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSBidWZmZXJbaSArIDFdLCBlbmQgPSBidWZmZXJbaSArIDJdO1xuICAgICAgICAgICAgICAgIGlmIChkaXIgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmQgPiBhZnRlcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpY2sgPSBpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kID4gYWZ0ZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydCA8IGFmdGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgcGljayA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmQgPj0gYWZ0ZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwaWNrID0gaTtcbiAgICAgICAgICAgICAgICBpZiAoZGlyID4gMClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBpY2s7XG4gICAgfVxufVxuY2xhc3MgVHJlZU5vZGUge1xuICAgIGNvbnN0cnVjdG9yKG5vZGUsIGZyb20sIGluZGV4LCBfcGFyZW50KSB7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gX3BhcmVudDtcbiAgICB9XG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiB0aGlzLm5vZGUudHlwZTsgfVxuICAgIGdldCBuYW1lKCkgeyByZXR1cm4gdGhpcy5ub2RlLnR5cGUubmFtZTsgfVxuICAgIGdldCB0bygpIHsgcmV0dXJuIHRoaXMuZnJvbSArIHRoaXMubm9kZS5sZW5ndGg7IH1cbiAgICBuZXh0Q2hpbGQoaSwgZGlyLCBhZnRlciwgZnVsbCA9IGZhbHNlKSB7XG4gICAgICAgIGZvciAobGV0IHBhcmVudCA9IHRoaXM7Oykge1xuICAgICAgICAgICAgZm9yIChsZXQgeyBjaGlsZHJlbiwgcG9zaXRpb25zIH0gPSBwYXJlbnQubm9kZSwgZSA9IGRpciA+IDAgPyBjaGlsZHJlbi5sZW5ndGggOiAtMTsgaSAhPSBlOyBpICs9IGRpcikge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gY2hpbGRyZW5baV0sIHN0YXJ0ID0gcG9zaXRpb25zW2ldICsgcGFyZW50LmZyb207XG4gICAgICAgICAgICAgICAgaWYgKGFmdGVyICE9IC0xMDAwMDAwMDAgLyogTm9uZSAqLyAmJiAoZGlyIDwgMCA/IHN0YXJ0ID49IGFmdGVyIDogc3RhcnQgKyBuZXh0Lmxlbmd0aCA8PSBhZnRlcikpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0IGluc3RhbmNlb2YgVHJlZUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSBuZXh0LmZpbmRDaGlsZCgwLCBuZXh0LmJ1ZmZlci5sZW5ndGgsIGRpciwgYWZ0ZXIgPT0gLTEwMDAwMDAwMCAvKiBOb25lICovID8gLTEwMDAwMDAwMCAvKiBOb25lICovIDogYWZ0ZXIgLSBzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJOb2RlKG5ldyBCdWZmZXJDb250ZXh0KHBhcmVudCwgbmV4dCwgaSwgc3RhcnQpLCBudWxsLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZ1bGwgfHwgKCFuZXh0LnR5cGUuaXNBbm9ueW1vdXMgfHwgaGFzQ2hpbGQobmV4dCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbm5lciA9IG5ldyBUcmVlTm9kZShuZXh0LCBzdGFydCwgaSwgcGFyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bGwgfHwgIWlubmVyLnR5cGUuaXNBbm9ueW1vdXMgPyBpbm5lciA6IGlubmVyLm5leHRDaGlsZChkaXIgPCAwID8gbmV4dC5jaGlsZHJlbi5sZW5ndGggLSAxIDogMCwgZGlyLCBhZnRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZ1bGwgfHwgIXBhcmVudC50eXBlLmlzQW5vbnltb3VzKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaSA9IHBhcmVudC5pbmRleCArIGRpcjtcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5fcGFyZW50O1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLm5leHRDaGlsZCgwLCAxLCAtMTAwMDAwMDAwIC8qIE5vbmUgKi8pOyB9XG4gICAgZ2V0IGxhc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMubmV4dENoaWxkKHRoaXMubm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxLCAtMSwgLTEwMDAwMDAwMCAvKiBOb25lICovKTsgfVxuICAgIGNoaWxkQWZ0ZXIocG9zKSB7IHJldHVybiB0aGlzLm5leHRDaGlsZCgwLCAxLCBwb3MpOyB9XG4gICAgY2hpbGRCZWZvcmUocG9zKSB7IHJldHVybiB0aGlzLm5leHRDaGlsZCh0aGlzLm5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMSwgLTEsIHBvcyk7IH1cbiAgICBuZXh0U2lnbmlmaWNhbnRQYXJlbnQoKSB7XG4gICAgICAgIGxldCB2YWwgPSB0aGlzO1xuICAgICAgICB3aGlsZSAodmFsLnR5cGUuaXNBbm9ueW1vdXMgJiYgdmFsLl9wYXJlbnQpXG4gICAgICAgICAgICB2YWwgPSB2YWwuX3BhcmVudDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5uZXh0U2lnbmlmaWNhbnRQYXJlbnQoKSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBuZXh0U2libGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5uZXh0Q2hpbGQodGhpcy5pbmRleCArIDEsIDEsIC0xKSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBwcmV2U2libGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5uZXh0Q2hpbGQodGhpcy5pbmRleCAtIDEsIC0xLCAtMSkgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgY3Vyc29yKCkgeyByZXR1cm4gbmV3IFRyZWVDdXJzb3IodGhpcyk7IH1cbiAgICByZXNvbHZlKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3Vyc29yLm1vdmVUbyhwb3MsIHNpZGUpLm5vZGU7XG4gICAgfVxuICAgIGdldENoaWxkKHR5cGUsIGJlZm9yZSA9IG51bGwsIGFmdGVyID0gbnVsbCkge1xuICAgICAgICBsZXQgciA9IGdldENoaWxkcmVuKHRoaXMsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpO1xuICAgICAgICByZXR1cm4gci5sZW5ndGggPyByWzBdIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0Q2hpbGRyZW4odHlwZSwgYmVmb3JlID0gbnVsbCwgYWZ0ZXIgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBnZXRDaGlsZHJlbih0aGlzLCB0eXBlLCBiZWZvcmUsIGFmdGVyKTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5ub2RlLnRvU3RyaW5nKCk7IH1cbn1cbmZ1bmN0aW9uIGdldENoaWxkcmVuKG5vZGUsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpIHtcbiAgICBsZXQgY3VyID0gbm9kZS5jdXJzb3IsIHJlc3VsdCA9IFtdO1xuICAgIGlmICghY3VyLmZpcnN0Q2hpbGQoKSlcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICBpZiAoYmVmb3JlICE9IG51bGwpXG4gICAgICAgIHdoaWxlICghY3VyLnR5cGUuaXMoYmVmb3JlKSlcbiAgICAgICAgICAgIGlmICghY3VyLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChhZnRlciAhPSBudWxsICYmIGN1ci50eXBlLmlzKGFmdGVyKSlcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGlmIChjdXIudHlwZS5pcyh0eXBlKSlcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1ci5ub2RlKTtcbiAgICAgICAgaWYgKCFjdXIubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgIHJldHVybiBhZnRlciA9PSBudWxsID8gcmVzdWx0IDogW107XG4gICAgfVxufVxuY2xhc3MgQnVmZmVyQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBidWZmZXIsIGluZGV4LCBzdGFydCkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgIH1cbn1cbmNsYXNzIEJ1ZmZlck5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIF9wYXJlbnQsIGluZGV4KSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy50eXBlID0gY29udGV4dC5idWZmZXIuc2V0LnR5cGVzW2NvbnRleHQuYnVmZmVyLmJ1ZmZlcltpbmRleF1dO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHsgcmV0dXJuIHRoaXMudHlwZS5uYW1lOyB9XG4gICAgZ2V0IGZyb20oKSB7IHJldHVybiB0aGlzLmNvbnRleHQuc3RhcnQgKyB0aGlzLmNvbnRleHQuYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgMV07IH1cbiAgICBnZXQgdG8oKSB7IHJldHVybiB0aGlzLmNvbnRleHQuc3RhcnQgKyB0aGlzLmNvbnRleHQuYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgMl07IH1cbiAgICBjaGlsZChkaXIsIGFmdGVyKSB7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgaW5kZXggPSBidWZmZXIuZmluZENoaWxkKHRoaXMuaW5kZXggKyA0LCBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXSwgZGlyLCBhZnRlciA9PSAtMTAwMDAwMDAwIC8qIE5vbmUgKi8gPyAtMTAwMDAwMDAwIC8qIE5vbmUgKi8gOiBhZnRlciAtIHRoaXMuY29udGV4dC5zdGFydCk7XG4gICAgICAgIHJldHVybiBpbmRleCA8IDAgPyBudWxsIDogbmV3IEJ1ZmZlck5vZGUodGhpcy5jb250ZXh0LCB0aGlzLCBpbmRleCk7XG4gICAgfVxuICAgIGdldCBmaXJzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5jaGlsZCgxLCAtMTAwMDAwMDAwIC8qIE5vbmUgKi8pOyB9XG4gICAgZ2V0IGxhc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuY2hpbGQoLTEsIC0xMDAwMDAwMDAgLyogTm9uZSAqLyk7IH1cbiAgICBjaGlsZEFmdGVyKHBvcykgeyByZXR1cm4gdGhpcy5jaGlsZCgxLCBwb3MpOyB9XG4gICAgY2hpbGRCZWZvcmUocG9zKSB7IHJldHVybiB0aGlzLmNoaWxkKC0xLCBwb3MpOyB9XG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCB8fCB0aGlzLmNvbnRleHQucGFyZW50Lm5leHRTaWduaWZpY2FudFBhcmVudCgpO1xuICAgIH1cbiAgICBleHRlcm5hbFNpYmxpbmcoZGlyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgPyBudWxsIDogdGhpcy5jb250ZXh0LnBhcmVudC5uZXh0Q2hpbGQodGhpcy5jb250ZXh0LmluZGV4ICsgZGlyLCBkaXIsIC0xKTtcbiAgICB9XG4gICAgZ2V0IG5leHRTaWJsaW5nKCkge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IGFmdGVyID0gYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM107XG4gICAgICAgIGlmIChhZnRlciA8ICh0aGlzLl9wYXJlbnQgPyBidWZmZXIuYnVmZmVyW3RoaXMuX3BhcmVudC5pbmRleCArIDNdIDogYnVmZmVyLmJ1ZmZlci5sZW5ndGgpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJOb2RlKHRoaXMuY29udGV4dCwgdGhpcy5fcGFyZW50LCBhZnRlcik7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dGVybmFsU2libGluZygxKTtcbiAgICB9XG4gICAgZ2V0IHByZXZTaWJsaW5nKCkge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHBhcmVudFN0YXJ0ID0gdGhpcy5fcGFyZW50ID8gdGhpcy5fcGFyZW50LmluZGV4ICsgNCA6IDA7XG4gICAgICAgIGlmICh0aGlzLmluZGV4ID09IHBhcmVudFN0YXJ0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZXJuYWxTaWJsaW5nKC0xKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJOb2RlKHRoaXMuY29udGV4dCwgdGhpcy5fcGFyZW50LCBidWZmZXIuZmluZENoaWxkKHBhcmVudFN0YXJ0LCB0aGlzLmluZGV4LCAtMSwgLTEwMDAwMDAwMCAvKiBOb25lICovKSk7XG4gICAgfVxuICAgIGdldCBjdXJzb3IoKSB7IHJldHVybiBuZXcgVHJlZUN1cnNvcih0aGlzKTsgfVxuICAgIHJlc29sdmUocG9zLCBzaWRlID0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJzb3IubW92ZVRvKHBvcywgc2lkZSkubm9kZTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5jb250ZXh0LmJ1ZmZlci5jaGlsZFN0cmluZyh0aGlzLmluZGV4KTsgfVxuICAgIGdldENoaWxkKHR5cGUsIGJlZm9yZSA9IG51bGwsIGFmdGVyID0gbnVsbCkge1xuICAgICAgICBsZXQgciA9IGdldENoaWxkcmVuKHRoaXMsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpO1xuICAgICAgICByZXR1cm4gci5sZW5ndGggPyByWzBdIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0Q2hpbGRyZW4odHlwZSwgYmVmb3JlID0gbnVsbCwgYWZ0ZXIgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBnZXRDaGlsZHJlbih0aGlzLCB0eXBlLCBiZWZvcmUsIGFmdGVyKTtcbiAgICB9XG59XG4vLy8gQSB0cmVlIGN1cnNvciBvYmplY3QgZm9jdXNlcyBvbiBhIGdpdmVuIG5vZGUgaW4gYSBzeW50YXggdHJlZSwgYW5kXG4vLy8gYWxsb3dzIHlvdSB0byBtb3ZlIHRvIGFkamFjZW50IG5vZGVzLlxuY2xhc3MgVHJlZUN1cnNvciB7XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGNvbnN0cnVjdG9yKG5vZGUsIGZ1bGwgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmZ1bGwgPSBmdWxsO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIHRoaXMuYnVmZmVyTm9kZSA9IG51bGw7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMueWllbGROb2RlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdHJlZSA9IG5vZGUuY29udGV4dC5wYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5vZGUuY29udGV4dDtcbiAgICAgICAgICAgIGZvciAobGV0IG4gPSBub2RlLl9wYXJlbnQ7IG47IG4gPSBuLl9wYXJlbnQpXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFjay51bnNoaWZ0KG4uaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJOb2RlID0gbm9kZTtcbiAgICAgICAgICAgIHRoaXMueWllbGRCdWYobm9kZS5pbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIFNob3J0aGFuZCBmb3IgYC50eXBlLm5hbWVgLlxuICAgIGdldCBuYW1lKCkgeyByZXR1cm4gdGhpcy50eXBlLm5hbWU7IH1cbiAgICB5aWVsZE5vZGUobm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuX3RyZWUgPSBub2RlO1xuICAgICAgICB0aGlzLnR5cGUgPSBub2RlLnR5cGU7XG4gICAgICAgIHRoaXMuZnJvbSA9IG5vZGUuZnJvbTtcbiAgICAgICAgdGhpcy50byA9IG5vZGUudG87XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB5aWVsZEJ1ZihpbmRleCwgdHlwZSkge1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIGxldCB7IHN0YXJ0LCBidWZmZXIgfSA9IHRoaXMuYnVmZmVyO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlIHx8IGJ1ZmZlci5zZXQudHlwZXNbYnVmZmVyLmJ1ZmZlcltpbmRleF1dO1xuICAgICAgICB0aGlzLmZyb20gPSBzdGFydCArIGJ1ZmZlci5idWZmZXJbaW5kZXggKyAxXTtcbiAgICAgICAgdGhpcy50byA9IHN0YXJ0ICsgYnVmZmVyLmJ1ZmZlcltpbmRleCArIDJdO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgeWllbGQobm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkTm9kZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5vZGUuY29udGV4dDtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYobm9kZS5pbmRleCwgbm9kZS50eXBlKTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIgPyB0aGlzLmJ1ZmZlci5idWZmZXIuY2hpbGRTdHJpbmcodGhpcy5pbmRleCkgOiB0aGlzLl90cmVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBlbnRlcihkaXIsIGFmdGVyKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZCh0aGlzLl90cmVlLm5leHRDaGlsZChkaXIgPCAwID8gdGhpcy5fdHJlZS5ub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDEgOiAwLCBkaXIsIGFmdGVyLCB0aGlzLmZ1bGwpKTtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgbGV0IGluZGV4ID0gYnVmZmVyLmZpbmRDaGlsZCh0aGlzLmluZGV4ICsgNCwgYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM10sIGRpciwgYWZ0ZXIgPT0gLTEwMDAwMDAwMCAvKiBOb25lICovID8gLTEwMDAwMDAwMCAvKiBOb25lICovIDogYWZ0ZXIgLSB0aGlzLmJ1ZmZlci5zdGFydCk7XG4gICAgICAgIGlmIChpbmRleCA8IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLmluZGV4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYoaW5kZXgpO1xuICAgIH1cbiAgICAvLy8gTW92ZSB0aGUgY3Vyc29yIHRvIHRoaXMgbm9kZSdzIGZpcnN0IGNoaWxkLiBXaGVuIHRoaXMgcmV0dXJuc1xuICAgIC8vLyBmYWxzZSwgdGhlIG5vZGUgaGFzIG5vIGNoaWxkLCBhbmQgdGhlIGN1cnNvciBoYXMgbm90IGJlZW4gbW92ZWQuXG4gICAgZmlyc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuZW50ZXIoMSwgLTEwMDAwMDAwMCAvKiBOb25lICovKTsgfVxuICAgIC8vLyBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhpcyBub2RlJ3MgbGFzdCBjaGlsZC5cbiAgICBsYXN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmVudGVyKC0xLCAtMTAwMDAwMDAwIC8qIE5vbmUgKi8pOyB9XG4gICAgLy8vIE1vdmUgdGhlIGN1cnNvciB0byB0aGUgZmlyc3QgY2hpbGQgdGhhdCBzdGFydHMgYXQgb3IgYWZ0ZXIgYHBvc2AuXG4gICAgY2hpbGRBZnRlcihwb3MpIHsgcmV0dXJuIHRoaXMuZW50ZXIoMSwgcG9zKTsgfVxuICAgIC8vLyBNb3ZlIHRvIHRoZSBsYXN0IGNoaWxkIHRoYXQgZW5kcyBhdCBvciBiZWZvcmUgYHBvc2AuXG4gICAgY2hpbGRCZWZvcmUocG9zKSB7IHJldHVybiB0aGlzLmVudGVyKC0xLCBwb3MpOyB9XG4gICAgLy8vIE1vdmUgdGhlIG5vZGUncyBwYXJlbnQgbm9kZSwgaWYgdGhpcyBpc24ndCB0aGUgdG9wIG5vZGUuXG4gICAgcGFyZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGROb2RlKHRoaXMuZnVsbCA/IHRoaXMuX3RyZWUuX3BhcmVudCA6IHRoaXMuX3RyZWUucGFyZW50KTtcbiAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYodGhpcy5zdGFjay5wb3AoKSk7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLmZ1bGwgPyB0aGlzLmJ1ZmZlci5wYXJlbnQgOiB0aGlzLmJ1ZmZlci5wYXJlbnQubmV4dFNpZ25pZmljYW50UGFyZW50KCk7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGROb2RlKHBhcmVudCk7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzaWJsaW5nKGRpcikge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuICF0aGlzLl90cmVlLl9wYXJlbnQgPyBmYWxzZVxuICAgICAgICAgICAgICAgIDogdGhpcy55aWVsZCh0aGlzLl90cmVlLl9wYXJlbnQubmV4dENoaWxkKHRoaXMuX3RyZWUuaW5kZXggKyBkaXIsIGRpciwgLTEwMDAwMDAwMCAvKiBOb25lICovLCB0aGlzLmZ1bGwpKTtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmJ1ZmZlciwgZCA9IHRoaXMuc3RhY2subGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGRpciA8IDApIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnRTdGFydCA9IGQgPCAwID8gMCA6IHRoaXMuc3RhY2tbZF0gKyA0O1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXggIT0gcGFyZW50U3RhcnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYoYnVmZmVyLmZpbmRDaGlsZChwYXJlbnRTdGFydCwgdGhpcy5pbmRleCwgLTEsIC0xMDAwMDAwMDAgLyogTm9uZSAqLykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGFmdGVyID0gYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM107XG4gICAgICAgICAgICBpZiAoYWZ0ZXIgPCAoZCA8IDAgPyBidWZmZXIuYnVmZmVyLmxlbmd0aCA6IGJ1ZmZlci5idWZmZXJbdGhpcy5zdGFja1tkXSArIDNdKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZEJ1ZihhZnRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGQgPCAwID8gdGhpcy55aWVsZCh0aGlzLmJ1ZmZlci5wYXJlbnQubmV4dENoaWxkKHRoaXMuYnVmZmVyLmluZGV4ICsgZGlyLCBkaXIsIC0xMDAwMDAwMDAgLyogTm9uZSAqLywgdGhpcy5mdWxsKSkgOiBmYWxzZTtcbiAgICB9XG4gICAgLy8vIE1vdmUgdG8gdGhpcyBub2RlJ3MgbmV4dCBzaWJsaW5nLCBpZiBhbnkuXG4gICAgbmV4dFNpYmxpbmcoKSB7IHJldHVybiB0aGlzLnNpYmxpbmcoMSk7IH1cbiAgICAvLy8gTW92ZSB0byB0aGlzIG5vZGUncyBwcmV2aW91cyBzaWJsaW5nLCBpZiBhbnkuXG4gICAgcHJldlNpYmxpbmcoKSB7IHJldHVybiB0aGlzLnNpYmxpbmcoLTEpOyB9XG4gICAgYXRMYXN0Tm9kZShkaXIpIHtcbiAgICAgICAgbGV0IGluZGV4LCBwYXJlbnQsIHsgYnVmZmVyIH0gPSB0aGlzO1xuICAgICAgICBpZiAoYnVmZmVyKSB7XG4gICAgICAgICAgICBpZiAoZGlyID4gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluZGV4IDwgYnVmZmVyLmJ1ZmZlci5idWZmZXIubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaW5kZXg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlci5idWZmZXIuYnVmZmVyW2kgKyAzXSA8IHRoaXMuaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoeyBpbmRleCwgcGFyZW50IH0gPSBidWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKHsgaW5kZXgsIF9wYXJlbnQ6IHBhcmVudCB9ID0gdGhpcy5fdHJlZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IHBhcmVudDsgeyBpbmRleCwgX3BhcmVudDogcGFyZW50IH0gPSBwYXJlbnQpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBpbmRleCArIGRpciwgZSA9IGRpciA8IDAgPyAtMSA6IHBhcmVudC5ub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSAhPSBlOyBpICs9IGRpcikge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZCA9IHBhcmVudC5ub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZ1bGwgfHwgIWNoaWxkLnR5cGUuaXNBbm9ueW1vdXMgfHwgY2hpbGQgaW5zdGFuY2VvZiBUcmVlQnVmZmVyIHx8IGhhc0NoaWxkKGNoaWxkKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBtb3ZlKGRpcikge1xuICAgICAgICBpZiAodGhpcy5lbnRlcihkaXIsIC0xMDAwMDAwMDAgLyogTm9uZSAqLykpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2libGluZyhkaXIpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXRMYXN0Tm9kZShkaXIpIHx8ICF0aGlzLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gTW92ZSB0byB0aGUgbmV4dCBub2RlIGluIGFcbiAgICAvLy8gW3ByZS1vcmRlcl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVHJlZV90cmF2ZXJzYWwjUHJlLW9yZGVyXyhOTFIpKVxuICAgIC8vLyB0cmF2ZXJzYWwsIGdvaW5nIGZyb20gYSBub2RlIHRvIGl0cyBmaXJzdCBjaGlsZCBvciwgaWYgdGhlXG4gICAgLy8vIGN1cnJlbnQgbm9kZSBpcyBlbXB0eSwgaXRzIG5leHQgc2libGluZyBvciB0aGUgbmV4dCBzaWJsaW5nIG9mXG4gICAgLy8vIHRoZSBmaXJzdCBwYXJlbnQgbm9kZSB0aGF0IGhhcyBvbmUuXG4gICAgbmV4dCgpIHsgcmV0dXJuIHRoaXMubW92ZSgxKTsgfVxuICAgIC8vLyBNb3ZlIHRvIHRoZSBuZXh0IG5vZGUgaW4gYSBsYXN0LXRvLWZpcnN0IHByZS1vcmRlciB0cmF2ZXJhbC4gQVxuICAgIC8vLyBub2RlIGlzIGZvbGxvd2VkIGJ5IGlzdCBsYXN0IGNoaWxkIG9yLCBpZiBpdCBoYXMgbm9uZSwgaXRzXG4gICAgLy8vIHByZXZpb3VzIHNpYmxpbmcgb3IgdGhlIHByZXZpb3VzIHNpYmxpbmcgb2YgdGhlIGZpcnN0IHBhcmVudFxuICAgIC8vLyBub2RlIHRoYXQgaGFzIG9uZS5cbiAgICBwcmV2KCkgeyByZXR1cm4gdGhpcy5tb3ZlKC0xKTsgfVxuICAgIC8vLyBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIGlubmVybW9zdCBub2RlIHRoYXQgY292ZXJzIGBwb3NgLiBJZlxuICAgIC8vLyBgc2lkZWAgaXMgLTEsIGl0IHdpbGwgZW50ZXIgbm9kZXMgdGhhdCBlbmQgYXQgYHBvc2AuIElmIGl0IGlzIDEsXG4gICAgLy8vIGl0IHdpbGwgZW50ZXIgbm9kZXMgdGhhdCBzdGFydCBhdCBgcG9zYC5cbiAgICBtb3ZlVG8ocG9zLCBzaWRlID0gMCkge1xuICAgICAgICAvLyBNb3ZlIHVwIHRvIGEgbm9kZSB0aGF0IGFjdHVhbGx5IGhvbGRzIHRoZSBwb3NpdGlvbiwgaWYgcG9zc2libGVcbiAgICAgICAgd2hpbGUgKHRoaXMuZnJvbSA9PSB0aGlzLnRvIHx8XG4gICAgICAgICAgICAoc2lkZSA8IDEgPyB0aGlzLmZyb20gPj0gcG9zIDogdGhpcy5mcm9tID4gcG9zKSB8fFxuICAgICAgICAgICAgKHNpZGUgPiAtMSA/IHRoaXMudG8gPD0gcG9zIDogdGhpcy50byA8IHBvcykpXG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFRoZW4gc2NhbiBkb3duIGludG8gY2hpbGQgbm9kZXMgYXMgZmFyIGFzIHBvc3NpYmxlXG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmIChzaWRlIDwgMCA/ICF0aGlzLmNoaWxkQmVmb3JlKHBvcykgOiAhdGhpcy5jaGlsZEFmdGVyKHBvcykpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAodGhpcy5mcm9tID09IHRoaXMudG8gfHxcbiAgICAgICAgICAgICAgICAoc2lkZSA8IDEgPyB0aGlzLmZyb20gPj0gcG9zIDogdGhpcy5mcm9tID4gcG9zKSB8fFxuICAgICAgICAgICAgICAgIChzaWRlID4gLTEgPyB0aGlzLnRvIDw9IHBvcyA6IHRoaXMudG8gPCBwb3MpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8vIEdldCBhIFtzeW50YXggbm9kZV0oI3RyZWUuU3ludGF4Tm9kZSkgYXQgdGhlIGN1cnNvcidzIGN1cnJlbnRcbiAgICAvLy8gcG9zaXRpb24uXG4gICAgZ2V0IG5vZGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJlZTtcbiAgICAgICAgbGV0IGNhY2hlID0gdGhpcy5idWZmZXJOb2RlLCByZXN1bHQgPSBudWxsLCBkZXB0aCA9IDA7XG4gICAgICAgIGlmIChjYWNoZSAmJiBjYWNoZS5jb250ZXh0ID09IHRoaXMuYnVmZmVyKSB7XG4gICAgICAgICAgICBzY2FuOiBmb3IgKGxldCBpbmRleCA9IHRoaXMuaW5kZXgsIGQgPSB0aGlzLnN0YWNrLmxlbmd0aDsgZCA+PSAwOykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGMgPSBjYWNoZTsgYzsgYyA9IGMuX3BhcmVudClcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMuaW5kZXggPT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PSB0aGlzLmluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gYztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoID0gZCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBzY2FuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLnN0YWNrWy0tZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IGRlcHRoOyBpIDwgdGhpcy5zdGFjay5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCdWZmZXJOb2RlKHRoaXMuYnVmZmVyLCByZXN1bHQsIHRoaXMuc3RhY2tbaV0pO1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJOb2RlID0gbmV3IEJ1ZmZlck5vZGUodGhpcy5idWZmZXIsIHJlc3VsdCwgdGhpcy5pbmRleCk7XG4gICAgfVxuICAgIC8vLyBHZXQgdGhlIFt0cmVlXSgjdHJlZS5UcmVlKSB0aGF0IHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgbm9kZSwgaWZcbiAgICAvLy8gYW55LiBXaWxsIHJldHVybiBudWxsIHdoZW4gdGhlIG5vZGUgaXMgaW4gYSBbdHJlZVxuICAgIC8vLyBidWZmZXJdKCN0cmVlLlRyZWVCdWZmZXIpLlxuICAgIGdldCB0cmVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIgPyBudWxsIDogdGhpcy5fdHJlZS5ub2RlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhc0NoaWxkKHRyZWUpIHtcbiAgICByZXR1cm4gdHJlZS5jaGlsZHJlbi5zb21lKGNoID0+ICFjaC50eXBlLmlzQW5vbnltb3VzIHx8IGNoIGluc3RhbmNlb2YgVHJlZUJ1ZmZlciB8fCBoYXNDaGlsZChjaCkpO1xufVxuY2xhc3MgRmxhdEJ1ZmZlckN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoYnVmZmVyLCBpbmRleCkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIH1cbiAgICBnZXQgaWQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gNF07IH1cbiAgICBnZXQgc3RhcnQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gM107IH1cbiAgICBnZXQgZW5kKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDJdOyB9XG4gICAgZ2V0IHNpemUoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gMV07IH1cbiAgICBnZXQgcG9zKCkgeyByZXR1cm4gdGhpcy5pbmRleDsgfVxuICAgIG5leHQoKSB7IHRoaXMuaW5kZXggLT0gNDsgfVxuICAgIGZvcmsoKSB7IHJldHVybiBuZXcgRmxhdEJ1ZmZlckN1cnNvcih0aGlzLmJ1ZmZlciwgdGhpcy5pbmRleCk7IH1cbn1cbmNvbnN0IEJhbGFuY2VCcmFuY2hGYWN0b3IgPSA4O1xuZnVuY3Rpb24gYnVpbGRUcmVlKGRhdGEpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHsgYnVmZmVyLCBub2RlU2V0LCB0b3BJRCA9IDAsIG1heEJ1ZmZlckxlbmd0aCA9IERlZmF1bHRCdWZmZXJMZW5ndGgsIHJldXNlZCA9IFtdLCBtaW5SZXBlYXRUeXBlID0gbm9kZVNldC50eXBlcy5sZW5ndGggfSA9IGRhdGE7XG4gICAgbGV0IGN1cnNvciA9IEFycmF5LmlzQXJyYXkoYnVmZmVyKSA/IG5ldyBGbGF0QnVmZmVyQ3Vyc29yKGJ1ZmZlciwgYnVmZmVyLmxlbmd0aCkgOiBidWZmZXI7XG4gICAgbGV0IHR5cGVzID0gbm9kZVNldC50eXBlcztcbiAgICBsZXQgY29udGV4dEhhc2ggPSAwO1xuICAgIGZ1bmN0aW9uIHRha2VOb2RlKHBhcmVudFN0YXJ0LCBtaW5Qb3MsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGluUmVwZWF0KSB7XG4gICAgICAgIGxldCB7IGlkLCBzdGFydCwgZW5kLCBzaXplIH0gPSBjdXJzb3I7XG4gICAgICAgIGxldCBzdGFydFBvcyA9IHN0YXJ0IC0gcGFyZW50U3RhcnQ7XG4gICAgICAgIGlmIChzaXplIDwgMCkge1xuICAgICAgICAgICAgaWYgKHNpemUgPT0gLTEpIHsgLy8gUmV1c2VkIG5vZGVcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHJldXNlZFtpZF0pO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKHN0YXJ0UG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeyAvLyBDb250ZXh0IGNoYW5nZVxuICAgICAgICAgICAgICAgIGNvbnRleHRIYXNoID0gaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0eXBlID0gdHlwZXNbaWRdLCBub2RlLCBidWZmZXI7XG4gICAgICAgIGlmIChlbmQgLSBzdGFydCA8PSBtYXhCdWZmZXJMZW5ndGggJiYgKGJ1ZmZlciA9IGZpbmRCdWZmZXJTaXplKGN1cnNvci5wb3MgLSBtaW5Qb3MsIGluUmVwZWF0KSkpIHtcbiAgICAgICAgICAgIC8vIFNtYWxsIGVub3VnaCBmb3IgYSBidWZmZXIsIGFuZCBubyByZXVzZWQgbm9kZXMgaW5zaWRlXG4gICAgICAgICAgICBsZXQgZGF0YSA9IG5ldyBVaW50MTZBcnJheShidWZmZXIuc2l6ZSAtIGJ1ZmZlci5za2lwKTtcbiAgICAgICAgICAgIGxldCBlbmRQb3MgPSBjdXJzb3IucG9zIC0gYnVmZmVyLnNpemUsIGluZGV4ID0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IGVuZFBvcylcbiAgICAgICAgICAgICAgICBpbmRleCA9IGNvcHlUb0J1ZmZlcihidWZmZXIuc3RhcnQsIGRhdGEsIGluZGV4LCBpblJlcGVhdCk7XG4gICAgICAgICAgICBub2RlID0gbmV3IFRyZWVCdWZmZXIoZGF0YSwgZW5kIC0gYnVmZmVyLnN0YXJ0LCBub2RlU2V0LCBpblJlcGVhdCA8IDAgPyBOb2RlVHlwZS5ub25lIDogdHlwZXNbaW5SZXBlYXRdKTtcbiAgICAgICAgICAgIHN0YXJ0UG9zID0gYnVmZmVyLnN0YXJ0IC0gcGFyZW50U3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIE1ha2UgaXQgYSBub2RlXG4gICAgICAgICAgICBsZXQgZW5kUG9zID0gY3Vyc29yLnBvcyAtIHNpemU7XG4gICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgbGV0IGxvY2FsQ2hpbGRyZW4gPSBbXSwgbG9jYWxQb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIGxldCBsb2NhbEluUmVwZWF0ID0gaWQgPj0gbWluUmVwZWF0VHlwZSA/IGlkIDogLTE7XG4gICAgICAgICAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IGVuZFBvcykge1xuICAgICAgICAgICAgICAgIGlmIChjdXJzb3IuaWQgPT0gbG9jYWxJblJlcGVhdClcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRha2VOb2RlKHN0YXJ0LCBlbmRQb3MsIGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCBsb2NhbEluUmVwZWF0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucmV2ZXJzZSgpO1xuICAgICAgICAgICAgbG9jYWxQb3NpdGlvbnMucmV2ZXJzZSgpO1xuICAgICAgICAgICAgaWYgKGxvY2FsSW5SZXBlYXQgPiAtMSAmJiBsb2NhbENoaWxkcmVuLmxlbmd0aCA+IEJhbGFuY2VCcmFuY2hGYWN0b3IpXG4gICAgICAgICAgICAgICAgbm9kZSA9IGJhbGFuY2VSYW5nZSh0eXBlLCB0eXBlLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgMCwgbG9jYWxDaGlsZHJlbi5sZW5ndGgsIDAsIG1heEJ1ZmZlckxlbmd0aCwgZW5kIC0gc3RhcnQsIGNvbnRleHRIYXNoKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBub2RlID0gd2l0aEhhc2gobmV3IFRyZWUodHlwZSwgbG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIGVuZCAtIHN0YXJ0KSwgY29udGV4dEhhc2gpO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKHN0YXJ0UG9zKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmluZEJ1ZmZlclNpemUobWF4U2l6ZSwgaW5SZXBlYXQpIHtcbiAgICAgICAgLy8gU2NhbiB0aHJvdWdoIHRoZSBidWZmZXIgdG8gZmluZCBwcmV2aW91cyBzaWJsaW5ncyB0aGF0IGZpdFxuICAgICAgICAvLyB0b2dldGhlciBpbiBhIFRyZWVCdWZmZXIsIGFuZCBkb24ndCBjb250YWluIGFueSByZXVzZWQgbm9kZXNcbiAgICAgICAgLy8gKHdoaWNoIGNhbid0IGJlIHN0b3JlZCBpbiBhIGJ1ZmZlcikuXG4gICAgICAgIC8vIElmIGBpblJlcGVhdGAgaXMgPiAtMSwgaWdub3JlIG5vZGUgYm91bmRhcmllcyBvZiB0aGF0IHR5cGUgZm9yXG4gICAgICAgIC8vIG5lc3RpbmcsIGJ1dCBtYWtlIHN1cmUgdGhlIGVuZCBmYWxscyBlaXRoZXIgYXQgdGhlIHN0YXJ0XG4gICAgICAgIC8vIChgbWF4U2l6ZWApIG9yIGJlZm9yZSBzdWNoIGEgbm9kZS5cbiAgICAgICAgbGV0IGZvcmsgPSBjdXJzb3IuZm9yaygpO1xuICAgICAgICBsZXQgc2l6ZSA9IDAsIHN0YXJ0ID0gMCwgc2tpcCA9IDAsIG1pblN0YXJ0ID0gZm9yay5lbmQgLSBtYXhCdWZmZXJMZW5ndGg7XG4gICAgICAgIGxldCByZXN1bHQgPSB7IHNpemU6IDAsIHN0YXJ0OiAwLCBza2lwOiAwIH07XG4gICAgICAgIHNjYW46IGZvciAobGV0IG1pblBvcyA9IGZvcmsucG9zIC0gbWF4U2l6ZTsgZm9yay5wb3MgPiBtaW5Qb3M7KSB7XG4gICAgICAgICAgICAvLyBQcmV0ZW5kIG5lc3RlZCByZXBlYXQgbm9kZXMgb2YgdGhlIHNhbWUgdHlwZSBkb24ndCBleGlzdFxuICAgICAgICAgICAgaWYgKGZvcmsuaWQgPT0gaW5SZXBlYXQpIHtcbiAgICAgICAgICAgICAgICAvLyBFeGNlcHQgdGhhdCB3ZSBzdG9yZSB0aGUgY3VycmVudCBzdGF0ZSBhcyBhIHZhbGlkIHJldHVyblxuICAgICAgICAgICAgICAgIC8vIHZhbHVlLlxuICAgICAgICAgICAgICAgIHJlc3VsdC5zaXplID0gc2l6ZTtcbiAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgICAgICByZXN1bHQuc2tpcCA9IHNraXA7XG4gICAgICAgICAgICAgICAgc2tpcCArPSA0O1xuICAgICAgICAgICAgICAgIHNpemUgKz0gNDtcbiAgICAgICAgICAgICAgICBmb3JrLm5leHQoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBub2RlU2l6ZSA9IGZvcmsuc2l6ZSwgc3RhcnRQb3MgPSBmb3JrLnBvcyAtIG5vZGVTaXplO1xuICAgICAgICAgICAgaWYgKG5vZGVTaXplIDwgMCB8fCBzdGFydFBvcyA8IG1pblBvcyB8fCBmb3JrLnN0YXJ0IDwgbWluU3RhcnQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsZXQgbG9jYWxTa2lwcGVkID0gZm9yay5pZCA+PSBtaW5SZXBlYXRUeXBlID8gNCA6IDA7XG4gICAgICAgICAgICBsZXQgbm9kZVN0YXJ0ID0gZm9yay5zdGFydDtcbiAgICAgICAgICAgIGZvcmsubmV4dCgpO1xuICAgICAgICAgICAgd2hpbGUgKGZvcmsucG9zID4gc3RhcnRQb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9yay5zaXplIDwgMClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgc2NhbjtcbiAgICAgICAgICAgICAgICBpZiAoZm9yay5pZCA+PSBtaW5SZXBlYXRUeXBlKVxuICAgICAgICAgICAgICAgICAgICBsb2NhbFNraXBwZWQgKz0gNDtcbiAgICAgICAgICAgICAgICBmb3JrLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXJ0ID0gbm9kZVN0YXJ0O1xuICAgICAgICAgICAgc2l6ZSArPSBub2RlU2l6ZTtcbiAgICAgICAgICAgIHNraXAgKz0gbG9jYWxTa2lwcGVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpblJlcGVhdCA8IDAgfHwgc2l6ZSA9PSBtYXhTaXplKSB7XG4gICAgICAgICAgICByZXN1bHQuc2l6ZSA9IHNpemU7XG4gICAgICAgICAgICByZXN1bHQuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgIHJlc3VsdC5za2lwID0gc2tpcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LnNpemUgPiA0ID8gcmVzdWx0IDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb3B5VG9CdWZmZXIoYnVmZmVyU3RhcnQsIGJ1ZmZlciwgaW5kZXgsIGluUmVwZWF0KSB7XG4gICAgICAgIGxldCB7IGlkLCBzdGFydCwgZW5kLCBzaXplIH0gPSBjdXJzb3I7XG4gICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgIGlmIChpZCA9PSBpblJlcGVhdClcbiAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSBpbmRleDtcbiAgICAgICAgaWYgKHNpemUgPiA0KSB7XG4gICAgICAgICAgICBsZXQgZW5kUG9zID0gY3Vyc29yLnBvcyAtIChzaXplIC0gNCk7XG4gICAgICAgICAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IGVuZFBvcylcbiAgICAgICAgICAgICAgICBpbmRleCA9IGNvcHlUb0J1ZmZlcihidWZmZXJTdGFydCwgYnVmZmVyLCBpbmRleCwgaW5SZXBlYXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpZCA8IG1pblJlcGVhdFR5cGUpIHsgLy8gRG9uJ3QgY29weSByZXBlYXQgbm9kZXMgaW50byBidWZmZXJzXG4gICAgICAgICAgICBidWZmZXJbLS1pbmRleF0gPSBzdGFydEluZGV4O1xuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gZW5kIC0gYnVmZmVyU3RhcnQ7XG4gICAgICAgICAgICBidWZmZXJbLS1pbmRleF0gPSBzdGFydCAtIGJ1ZmZlclN0YXJ0O1xuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gaWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgICBsZXQgY2hpbGRyZW4gPSBbXSwgcG9zaXRpb25zID0gW107XG4gICAgd2hpbGUgKGN1cnNvci5wb3MgPiAwKVxuICAgICAgICB0YWtlTm9kZShkYXRhLnN0YXJ0IHx8IDAsIDAsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIC0xKTtcbiAgICBsZXQgbGVuZ3RoID0gKF9hID0gZGF0YS5sZW5ndGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChjaGlsZHJlbi5sZW5ndGggPyBwb3NpdGlvbnNbMF0gKyBjaGlsZHJlblswXS5sZW5ndGggOiAwKTtcbiAgICByZXR1cm4gbmV3IFRyZWUodHlwZXNbdG9wSURdLCBjaGlsZHJlbi5yZXZlcnNlKCksIHBvc2l0aW9ucy5yZXZlcnNlKCksIGxlbmd0aCk7XG59XG5mdW5jdGlvbiBiYWxhbmNlUmFuZ2Uob3V0ZXJUeXBlLCBpbm5lclR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGZyb20sIHRvLCBzdGFydCwgbWF4QnVmZmVyTGVuZ3RoLCBsZW5ndGgsIGNvbnRleHRIYXNoKSB7XG4gICAgbGV0IGxvY2FsQ2hpbGRyZW4gPSBbXSwgbG9jYWxQb3NpdGlvbnMgPSBbXTtcbiAgICBpZiAobGVuZ3RoIDw9IG1heEJ1ZmZlckxlbmd0aCkge1xuICAgICAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucHVzaChjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICBsb2NhbFBvc2l0aW9ucy5wdXNoKHBvc2l0aW9uc1tpXSAtIHN0YXJ0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IG1heENoaWxkID0gTWF0aC5tYXgobWF4QnVmZmVyTGVuZ3RoLCBNYXRoLmNlaWwobGVuZ3RoICogMS41IC8gQmFsYW5jZUJyYW5jaEZhY3RvcikpO1xuICAgICAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOykge1xuICAgICAgICAgICAgbGV0IGdyb3VwRnJvbSA9IGksIGdyb3VwU3RhcnQgPSBwb3NpdGlvbnNbaV07XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dEVuZCA9IHBvc2l0aW9uc1tpXSArIGNoaWxkcmVuW2ldLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobmV4dEVuZCAtIGdyb3VwU3RhcnQgPiBtYXhDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA9PSBncm91cEZyb20gKyAxKSB7XG4gICAgICAgICAgICAgICAgbGV0IG9ubHkgPSBjaGlsZHJlbltncm91cEZyb21dO1xuICAgICAgICAgICAgICAgIGlmIChvbmx5IGluc3RhbmNlb2YgVHJlZSAmJiBvbmx5LnR5cGUgPT0gaW5uZXJUeXBlICYmIG9ubHkubGVuZ3RoID4gbWF4Q2hpbGQgPDwgMSkgeyAvLyBUb28gYmlnLCBjb2xsYXBzZVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG9ubHkuY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucHVzaChvbmx5LmNoaWxkcmVuW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsUG9zaXRpb25zLnB1c2gob25seS5wb3NpdGlvbnNbal0gKyBncm91cFN0YXJ0IC0gc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2NhbENoaWxkcmVuLnB1c2gob25seSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpID09IGdyb3VwRnJvbSArIDEpIHtcbiAgICAgICAgICAgICAgICBsb2NhbENoaWxkcmVuLnB1c2goY2hpbGRyZW5bZ3JvdXBGcm9tXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5uZXIgPSBiYWxhbmNlUmFuZ2UoaW5uZXJUeXBlLCBpbm5lclR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGdyb3VwRnJvbSwgaSwgZ3JvdXBTdGFydCwgbWF4QnVmZmVyTGVuZ3RoLCBwb3NpdGlvbnNbaSAtIDFdICsgY2hpbGRyZW5baSAtIDFdLmxlbmd0aCAtIGdyb3VwU3RhcnQsIGNvbnRleHRIYXNoKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXJUeXBlICE9IE5vZGVUeXBlLm5vbmUgJiYgIWNvbnRhaW5zVHlwZShpbm5lci5jaGlsZHJlbiwgaW5uZXJUeXBlKSlcbiAgICAgICAgICAgICAgICAgICAgaW5uZXIgPSB3aXRoSGFzaChuZXcgVHJlZShOb2RlVHlwZS5ub25lLCBpbm5lci5jaGlsZHJlbiwgaW5uZXIucG9zaXRpb25zLCBpbm5lci5sZW5ndGgpLCBjb250ZXh0SGFzaCk7XG4gICAgICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5wdXNoKGlubmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvY2FsUG9zaXRpb25zLnB1c2goZ3JvdXBTdGFydCAtIHN0YXJ0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gd2l0aEhhc2gobmV3IFRyZWUob3V0ZXJUeXBlLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgbGVuZ3RoKSwgY29udGV4dEhhc2gpO1xufVxuZnVuY3Rpb24gY29udGFpbnNUeXBlKG5vZGVzLCB0eXBlKSB7XG4gICAgZm9yIChsZXQgZWx0IG9mIG5vZGVzKVxuICAgICAgICBpZiAoZWx0LnR5cGUgPT0gdHlwZSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbi8vLyBUcmVlIGZyYWdtZW50cyBhcmUgdXNlZCBkdXJpbmcgW2luY3JlbWVudGFsXG4vLy8gcGFyc2luZ10oI2xlemVyLlBhcnNlT3B0aW9ucy5mcmFnbWVudHMpIHRvIHRyYWNrIHBhcnRzIG9mIG9sZFxuLy8vIHRyZWVzIHRoYXQgY2FuIGJlIHJldXNlZCBpbiBhIG5ldyBwYXJzZS4gQW4gYXJyYXkgb2YgZnJhZ21lbnRzIGlzXG4vLy8gdXNlZCB0byB0cmFjayByZWdpb25zIG9mIGFuIG9sZCB0cmVlIHdob3NlIG5vZGVzIG1pZ2h0IGJlIHJldXNlZFxuLy8vIGluIG5ldyBwYXJzZXMuIFVzZSB0aGUgc3RhdGljXG4vLy8gW2BhcHBseUNoYW5nZXNgXSgjdHJlZS5UcmVlRnJhZ21lbnReYXBwbHlDaGFuZ2VzKSBtZXRob2QgdG8gdXBkYXRlXG4vLy8gZnJhZ21lbnRzIGZvciBkb2N1bWVudCBjaGFuZ2VzLlxuY2xhc3MgVHJlZUZyYWdtZW50IHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gVGhlIHN0YXJ0IG9mIHRoZSB1bmNoYW5nZWQgcmFuZ2UgcG9pbnRlZCB0byBieSB0aGlzIGZyYWdtZW50LlxuICAgIC8vLyBUaGlzIHJlZmVycyB0byBhbiBvZmZzZXQgaW4gdGhlIF91cGRhdGVkXyBkb2N1bWVudCAoYXMgb3Bwb3NlZFxuICAgIC8vLyB0byB0aGUgb3JpZ2luYWwgdHJlZSkuXG4gICAgZnJvbSwgXG4gICAgLy8vIFRoZSBlbmQgb2YgdGhlIHVuY2hhbmdlZCByYW5nZS5cbiAgICB0bywgXG4gICAgLy8vIFRoZSB0cmVlIHRoYXQgdGhpcyBmcmFnbWVudCBpcyBiYXNlZCBvbi5cbiAgICB0cmVlLCBcbiAgICAvLy8gVGhlIG9mZnNldCBiZXR3ZWVuIHRoZSBmcmFnbWVudCdzIHRyZWUgYW5kIHRoZSBkb2N1bWVudCB0aGF0XG4gICAgLy8vIHRoaXMgZnJhZ21lbnQgY2FuIGJlIHVzZWQgYWdhaW5zdC4gQWRkIHRoaXMgd2hlbiBnb2luZyBmcm9tXG4gICAgLy8vIGRvY3VtZW50IHRvIHRyZWUgcG9zaXRpb25zLCBzdWJ0cmFjdCBpdCB0byBnbyBmcm9tIHRyZWUgdG9cbiAgICAvLy8gZG9jdW1lbnQgcG9zaXRpb25zLlxuICAgIG9mZnNldCwgb3Blbikge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMudHJlZSA9IHRyZWU7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLm9wZW4gPSBvcGVuO1xuICAgIH1cbiAgICBnZXQgb3BlblN0YXJ0KCkgeyByZXR1cm4gKHRoaXMub3BlbiAmIDEgLyogU3RhcnQgKi8pID4gMDsgfVxuICAgIGdldCBvcGVuRW5kKCkgeyByZXR1cm4gKHRoaXMub3BlbiAmIDIgLyogRW5kICovKSA+IDA7IH1cbiAgICAvLy8gQXBwbHkgYSBzZXQgb2YgZWRpdHMgdG8gYW4gYXJyYXkgb2YgZnJhZ21lbnRzLCByZW1vdmluZyBvclxuICAgIC8vLyBzcGxpdHRpbmcgZnJhZ21lbnRzIGFzIG5lY2Vzc2FyeSB0byByZW1vdmUgZWRpdGVkIHJhbmdlcywgYW5kXG4gICAgLy8vIGFkanVzdGluZyBvZmZzZXRzIGZvciBmcmFnbWVudHMgdGhhdCBtb3ZlZC5cbiAgICBzdGF0aWMgYXBwbHlDaGFuZ2VzKGZyYWdtZW50cywgY2hhbmdlcywgbWluR2FwID0gMTI4KSB7XG4gICAgICAgIGlmICghY2hhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnRzO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBmSSA9IDEsIG5leHRGID0gZnJhZ21lbnRzLmxlbmd0aCA/IGZyYWdtZW50c1swXSA6IG51bGw7XG4gICAgICAgIGxldCBjSSA9IDAsIHBvcyA9IDAsIG9mZiA9IDA7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBuZXh0QyA9IGNJIDwgY2hhbmdlcy5sZW5ndGggPyBjaGFuZ2VzW2NJKytdIDogbnVsbDtcbiAgICAgICAgICAgIGxldCBuZXh0UG9zID0gbmV4dEMgPyBuZXh0Qy5mcm9tQSA6IDFlOTtcbiAgICAgICAgICAgIGlmIChuZXh0UG9zIC0gcG9zID49IG1pbkdhcClcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV4dEYgJiYgbmV4dEYuZnJvbSA8IG5leHRQb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN1dCA9IG5leHRGO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zID49IGN1dC5mcm9tIHx8IG5leHRQb3MgPD0gY3V0LnRvIHx8IG9mZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZGcm9tID0gTWF0aC5tYXgoY3V0LmZyb20sIHBvcykgLSBvZmYsIGZUbyA9IE1hdGgubWluKGN1dC50bywgbmV4dFBvcykgLSBvZmY7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXQgPSBmRnJvbSA+PSBmVG8gPyBudWxsIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgVHJlZUZyYWdtZW50KGZGcm9tLCBmVG8sIGN1dC50cmVlLCBjdXQub2Zmc2V0ICsgb2ZmLCAoY0kgPiAwID8gMSAvKiBTdGFydCAqLyA6IDApIHwgKG5leHRDID8gMiAvKiBFbmQgKi8gOiAwKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1dClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0Ri50byA+IG5leHRQb3MpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgbmV4dEYgPSBmSSA8IGZyYWdtZW50cy5sZW5ndGggPyBmcmFnbWVudHNbZkkrK10gOiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbmV4dEMpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBwb3MgPSBuZXh0Qy50b0E7XG4gICAgICAgICAgICBvZmYgPSBuZXh0Qy50b0EgLSBuZXh0Qy50b0I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8vIENyZWF0ZSBhIHNldCBvZiBmcmFnbWVudHMgZnJvbSBhIGZyZXNobHkgcGFyc2VkIHRyZWUsIG9yIHVwZGF0ZVxuICAgIC8vLyBhbiBleGlzdGluZyBzZXQgb2YgZnJhZ21lbnRzIGJ5IHJlcGxhY2luZyB0aGUgb25lcyB0aGF0IG92ZXJsYXBcbiAgICAvLy8gd2l0aCBhIHRyZWUgd2l0aCBjb250ZW50IGZyb20gdGhlIG5ldyB0cmVlLiBXaGVuIGBwYXJ0aWFsYCBpc1xuICAgIC8vLyB0cnVlLCB0aGUgcGFyc2UgaXMgdHJlYXRlZCBhcyBpbmNvbXBsZXRlLCBhbmQgdGhlIHRva2VuIGF0IGl0c1xuICAgIC8vLyBlbmQgaXMgbm90IGluY2x1ZGVkIGluIFtgc2FmZVRvYF0oI3RyZWUuVHJlZUZyYWdtZW50LnNhZmVUbykuXG4gICAgc3RhdGljIGFkZFRyZWUodHJlZSwgZnJhZ21lbnRzID0gW10sIHBhcnRpYWwgPSBmYWxzZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW25ldyBUcmVlRnJhZ21lbnQoMCwgdHJlZS5sZW5ndGgsIHRyZWUsIDAsIHBhcnRpYWwgPyAyIC8qIEVuZCAqLyA6IDApXTtcbiAgICAgICAgZm9yIChsZXQgZiBvZiBmcmFnbWVudHMpXG4gICAgICAgICAgICBpZiAoZi50byA+IHRyZWUubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGYpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8vIENyZWF0ZXMgYW4gYElucHV0YCB0aGF0IGlzIGJhY2tlZCBieSBhIHNpbmdsZSwgZmxhdCBzdHJpbmcuXG5mdW5jdGlvbiBzdHJpbmdJbnB1dChpbnB1dCkgeyByZXR1cm4gbmV3IFN0cmluZ0lucHV0KGlucHV0KTsgfVxuY2xhc3MgU3RyaW5nSW5wdXQge1xuICAgIGNvbnN0cnVjdG9yKHN0cmluZywgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgfVxuICAgIGdldChwb3MpIHtcbiAgICAgICAgcmV0dXJuIHBvcyA8IDAgfHwgcG9zID49IHRoaXMubGVuZ3RoID8gLTEgOiB0aGlzLnN0cmluZy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgfVxuICAgIGxpbmVBZnRlcihwb3MpIHtcbiAgICAgICAgaWYgKHBvcyA8IDApXG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgbGV0IGVuZCA9IHRoaXMuc3RyaW5nLmluZGV4T2YoXCJcXG5cIiwgcG9zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKHBvcywgZW5kIDwgMCA/IHRoaXMubGVuZ3RoIDogTWF0aC5taW4oZW5kLCB0aGlzLmxlbmd0aCkpO1xuICAgIH1cbiAgICByZWFkKGZyb20sIHRvKSB7IHJldHVybiB0aGlzLnN0cmluZy5zbGljZShmcm9tLCBNYXRoLm1pbih0aGlzLmxlbmd0aCwgdG8pKTsgfVxuICAgIGNsaXAoYXQpIHsgcmV0dXJuIG5ldyBTdHJpbmdJbnB1dCh0aGlzLnN0cmluZywgYXQpOyB9XG59XG5cbmV4cG9ydHMuRGVmYXVsdEJ1ZmZlckxlbmd0aCA9IERlZmF1bHRCdWZmZXJMZW5ndGg7XG5leHBvcnRzLk5vZGVQcm9wID0gTm9kZVByb3A7XG5leHBvcnRzLk5vZGVTZXQgPSBOb2RlU2V0O1xuZXhwb3J0cy5Ob2RlVHlwZSA9IE5vZGVUeXBlO1xuZXhwb3J0cy5UcmVlID0gVHJlZTtcbmV4cG9ydHMuVHJlZUJ1ZmZlciA9IFRyZWVCdWZmZXI7XG5leHBvcnRzLlRyZWVDdXJzb3IgPSBUcmVlQ3Vyc29yO1xuZXhwb3J0cy5UcmVlRnJhZ21lbnQgPSBUcmVlRnJhZ21lbnQ7XG5leHBvcnRzLnN0cmluZ0lucHV0ID0gc3RyaW5nSW5wdXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmVlLmNqcy5tYXBcbiIsInZhciBDID0gXCJcXHUwMzdjXCJcbnZhciBDT1VOVCA9IHR5cGVvZiBTeW1ib2wgPT0gXCJ1bmRlZmluZWRcIiA/IFwiX19cIiArIEMgOiBTeW1ib2wuZm9yKEMpXG52YXIgU0VUID0gdHlwZW9mIFN5bWJvbCA9PSBcInVuZGVmaW5lZFwiID8gXCJfX3N0eWxlU2V0XCIgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxZTgpIDogU3ltYm9sKFwic3R5bGVTZXRcIilcbnZhciB0b3AgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9XG5cbi8vIDo6IC0gU3R5bGUgbW9kdWxlcyBlbmNhcHN1bGF0ZSBhIHNldCBvZiBDU1MgcnVsZXMgZGVmaW5lZCBmcm9tXG4vLyBKYXZhU2NyaXB0LiBUaGVpciBkZWZpbml0aW9ucyBhcmUgb25seSBhdmFpbGFibGUgaW4gYSBnaXZlbiBET01cbi8vIHJvb3QgYWZ0ZXIgaXQgaGFzIGJlZW4gX21vdW50ZWRfIHRoZXJlIHdpdGggYFN0eWxlTW9kdWxlLm1vdW50YC5cbi8vXG4vLyBTdHlsZSBtb2R1bGVzIHNob3VsZCBiZSBjcmVhdGVkIG9uY2UgYW5kIHN0b3JlZCBzb21ld2hlcmUsIGFzXG4vLyBvcHBvc2VkIHRvIHJlLWNyZWF0aW5nIHRoZW0gZXZlcnkgdGltZSB5b3UgbmVlZCB0aGVtLiBUaGUgYW1vdW50IG9mXG4vLyBDU1MgcnVsZXMgZ2VuZXJhdGVkIGZvciBhIGdpdmVuIERPTSByb290IGlzIGJvdW5kZWQgYnkgdGhlIGFtb3VudFxuLy8gb2Ygc3R5bGUgbW9kdWxlcyB0aGF0IHdlcmUgdXNlZC4gU28gdG8gYXZvaWQgbGVha2luZyBydWxlcywgZG9uJ3Rcbi8vIGNyZWF0ZSB0aGVzZSBkeW5hbWljYWxseSwgYnV0IHRyZWF0IHRoZW0gYXMgb25lLXRpbWUgYWxsb2NhdGlvbnMuXG52YXIgU3R5bGVNb2R1bGUgPSBleHBvcnRzLlN0eWxlTW9kdWxlID0gZnVuY3Rpb24gU3R5bGVNb2R1bGUoc3BlYywgb3B0aW9ucykge1xuICB0aGlzLnJ1bGVzID0gW11cbiAgdmFyIHJlZiA9IG9wdGlvbnMgfHwge307XG4gIHZhciBmaW5pc2ggPSByZWYuZmluaXNoO1xuXG4gIGZ1bmN0aW9uIHNwbGl0U2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gL15ALy50ZXN0KHNlbGVjdG9yKSA/IFtzZWxlY3Rvcl0gOiBzZWxlY3Rvci5zcGxpdCgvLFxccyovKVxuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVyKHNlbGVjdG9ycywgc3BlYywgdGFyZ2V0LCBpc0tleWZyYW1lcykge1xuICAgIHZhciBsb2NhbCA9IFtdLCBpc0F0ID0gL15AKFxcdyspXFxiLy5leGVjKHNlbGVjdG9yc1swXSksIGtleWZyYW1lcyA9IGlzQXQgJiYgaXNBdFsxXSA9PSBcImtleWZyYW1lc1wiXG4gICAgaWYgKGlzQXQgJiYgc3BlYyA9PSBudWxsKSB7IHJldHVybiB0YXJnZXQucHVzaChzZWxlY3RvcnNbMF0gKyBcIjtcIikgfVxuICAgIGZvciAodmFyIHByb3AgaW4gc3BlYykge1xuICAgICAgdmFyIHZhbHVlID0gc3BlY1twcm9wXVxuICAgICAgaWYgKC8mLy50ZXN0KHByb3ApKSB7XG4gICAgICAgIHJlbmRlcihwcm9wLnNwbGl0KC8sXFxzKi8pLm1hcChmdW5jdGlvbiAocGFydCkgeyByZXR1cm4gc2VsZWN0b3JzLm1hcChmdW5jdGlvbiAoc2VsKSB7IHJldHVybiBwYXJ0LnJlcGxhY2UoLyYvLCBzZWwpOyB9KTsgfSkucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmNvbmNhdChiKTsgfSksXG4gICAgICAgICAgICAgICB2YWx1ZSwgdGFyZ2V0KVxuICAgICAgfSBlbHNlIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZiAoIWlzQXQpIHsgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgdmFsdWUgb2YgYSBwcm9wZXJ0eSAoXCIgKyBwcm9wICsgXCIpIHNob3VsZCBiZSBhIHByaW1pdGl2ZSB2YWx1ZS5cIikgfVxuICAgICAgICByZW5kZXIoc3BsaXRTZWxlY3Rvcihwcm9wKSwgdmFsdWUsIGxvY2FsLCBrZXlmcmFtZXMpXG4gICAgICB9IGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgbG9jYWwucHVzaChwcm9wLnJlcGxhY2UoL18uKi8sIFwiXCIpLnJlcGxhY2UoL1tBLVpdL2csIGZ1bmN0aW9uIChsKSB7IHJldHVybiBcIi1cIiArIGwudG9Mb3dlckNhc2UoKTsgfSkgKyBcIjogXCIgKyB2YWx1ZSArIFwiO1wiKVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobG9jYWwubGVuZ3RoIHx8IGtleWZyYW1lcykge1xuICAgICAgdGFyZ2V0LnB1c2goKGZpbmlzaCAmJiAhaXNBdCAmJiAhaXNLZXlmcmFtZXMgPyBzZWxlY3RvcnMubWFwKGZpbmlzaCkgOiBzZWxlY3RvcnMpLmpvaW4oXCIsIFwiKSArXG4gICAgICAgICAgICAgICAgICBcIiB7XCIgKyBsb2NhbC5qb2luKFwiIFwiKSArIFwifVwiKVxuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIHByb3AgaW4gc3BlYykgeyByZW5kZXIoc3BsaXRTZWxlY3Rvcihwcm9wKSwgc3BlY1twcm9wXSwgdGhpcy5ydWxlcykgfVxufTtcblxuLy8gOjogKCkg4oaSIHN0cmluZ1xuLy8gUmV0dXJucyBhIHN0cmluZyBjb250YWluaW5nIHRoZSBtb2R1bGUncyBDU1MgcnVsZXMuXG5TdHlsZU1vZHVsZS5wcm90b3R5cGUuZ2V0UnVsZXMgPSBmdW5jdGlvbiBnZXRSdWxlcyAoKSB7IHJldHVybiB0aGlzLnJ1bGVzLmpvaW4oXCJcXG5cIikgfTtcblxuLy8gOjogKCkg4oaSIHN0cmluZ1xuLy8gR2VuZXJhdGUgYSBuZXcgdW5pcXVlIENTUyBjbGFzcyBuYW1lLlxuU3R5bGVNb2R1bGUubmV3TmFtZSA9IGZ1bmN0aW9uIG5ld05hbWUgKCkge1xuICB2YXIgaWQgPSB0b3BbQ09VTlRdIHx8IDFcbiAgdG9wW0NPVU5UXSA9IGlkICsgMVxuICByZXR1cm4gQyArIGlkLnRvU3RyaW5nKDM2KVxufTtcblxuLy8gOjogKHVuaW9uPERvY3VtZW50LCBTaGFkb3dSb290PiwgdW5pb248W1N0eWxlTW9kdWxlXSwgU3R5bGVNb2R1bGU+KVxuLy9cbi8vIE1vdW50IHRoZSBnaXZlbiBzZXQgb2YgbW9kdWxlcyBpbiB0aGUgZ2l2ZW4gRE9NIHJvb3QsIHdoaWNoIGVuc3VyZXNcbi8vIHRoYXQgdGhlIENTUyBydWxlcyBkZWZpbmVkIGJ5IHRoZSBtb2R1bGUgYXJlIGF2YWlsYWJsZSBpbiB0aGF0XG4vLyBjb250ZXh0LlxuLy9cbi8vIFJ1bGVzIGFyZSBvbmx5IGFkZGVkIHRvIHRoZSBkb2N1bWVudCBvbmNlIHBlciByb290LlxuLy9cbi8vIFJ1bGUgb3JkZXIgd2lsbCBmb2xsb3cgdGhlIG9yZGVyIG9mIHRoZSBtb2R1bGVzLCBzbyB0aGF0IHJ1bGVzIGZyb21cbi8vIG1vZHVsZXMgbGF0ZXIgaW4gdGhlIGFycmF5IHRha2UgcHJlY2VkZW5jZSBvZiB0aG9zZSBmcm9tIGVhcmxpZXJcbi8vIG1vZHVsZXMuIElmIHlvdSBjYWxsIHRoaXMgZnVuY3Rpb24gbXVsdGlwbGUgdGltZXMgZm9yIHRoZSBzYW1lIHJvb3Rcbi8vIGluIGEgd2F5IHRoYXQgY2hhbmdlcyB0aGUgb3JkZXIgb2YgYWxyZWFkeSBtb3VudGVkIG1vZHVsZXMsIHRoZSBvbGRcbi8vIG9yZGVyIHdpbGwgYmUgY2hhbmdlZC5cblN0eWxlTW9kdWxlLm1vdW50ID0gZnVuY3Rpb24gbW91bnQgKHJvb3QsIG1vZHVsZXMpIHtcbiAgKHJvb3RbU0VUXSB8fCBuZXcgU3R5bGVTZXQocm9vdCkpLm1vdW50KEFycmF5LmlzQXJyYXkobW9kdWxlcykgPyBtb2R1bGVzIDogW21vZHVsZXNdKVxufTtcblxudmFyIGFkb3B0ZWRTZXQgPSBudWxsXG5cbnZhciBTdHlsZVNldCA9IGZ1bmN0aW9uIFN0eWxlU2V0KHJvb3QpIHtcbiAgaWYgKCFyb290LmhlYWQgJiYgcm9vdC5hZG9wdGVkU3R5bGVTaGVldHMgJiYgdHlwZW9mIENTU1N0eWxlU2hlZXQgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGlmIChhZG9wdGVkU2V0KSB7XG4gICAgICByb290LmFkb3B0ZWRTdHlsZVNoZWV0cyA9IFthZG9wdGVkU2V0LnNoZWV0XS5jb25jYXQocm9vdC5hZG9wdGVkU3R5bGVTaGVldHMpXG4gICAgICByZXR1cm4gcm9vdFtTRVRdID0gYWRvcHRlZFNldFxuICAgIH1cbiAgICB0aGlzLnNoZWV0ID0gbmV3IENTU1N0eWxlU2hlZXRcbiAgICByb290LmFkb3B0ZWRTdHlsZVNoZWV0cyA9IFt0aGlzLnNoZWV0XS5jb25jYXQocm9vdC5hZG9wdGVkU3R5bGVTaGVldHMpXG4gICAgYWRvcHRlZFNldCA9IHRoaXNcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnN0eWxlVGFnID0gKHJvb3Qub3duZXJEb2N1bWVudCB8fCByb290KS5jcmVhdGVFbGVtZW50KFwic3R5bGVcIilcbiAgICB2YXIgdGFyZ2V0ID0gcm9vdC5oZWFkIHx8IHJvb3RcbiAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKHRoaXMuc3R5bGVUYWcsIHRhcmdldC5maXJzdENoaWxkKVxuICB9XG4gIHRoaXMubW9kdWxlcyA9IFtdXG4gIHJvb3RbU0VUXSA9IHRoaXNcbn07XG5cblN0eWxlU2V0LnByb3RvdHlwZS5tb3VudCA9IGZ1bmN0aW9uIG1vdW50IChtb2R1bGVzKSB7XG4gIHZhciBzaGVldCA9IHRoaXMuc2hlZXRcbiAgdmFyIHBvcyA9IDAgLyogQ3VycmVudCBydWxlIG9mZnNldCAqLywgaiA9IDAgLyogSW5kZXggaW50byB0aGlzLm1vZHVsZXMgKi9cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG1vZCA9IG1vZHVsZXNbaV0sIGluZGV4ID0gdGhpcy5tb2R1bGVzLmluZGV4T2YobW9kKVxuICAgIGlmIChpbmRleCA8IGogJiYgaW5kZXggPiAtMSkgeyAvLyBPcmRlcmluZyBjb25mbGljdFxuICAgICAgdGhpcy5tb2R1bGVzLnNwbGljZShpbmRleCwgMSlcbiAgICAgIGotLVxuICAgICAgaW5kZXggPSAtMVxuICAgIH1cbiAgICBpZiAoaW5kZXggPT0gLTEpIHtcbiAgICAgIHRoaXMubW9kdWxlcy5zcGxpY2UoaisrLCAwLCBtb2QpXG4gICAgICBpZiAoc2hlZXQpIHsgZm9yICh2YXIgayA9IDA7IGsgPCBtb2QucnVsZXMubGVuZ3RoOyBrKyspXG4gICAgICAgIHsgc2hlZXQuaW5zZXJ0UnVsZShtb2QucnVsZXNba10sIHBvcysrKSB9IH1cbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKGogPCBpbmRleCkgeyBwb3MgKz0gdGhpcy5tb2R1bGVzW2orK10ucnVsZXMubGVuZ3RoIH1cbiAgICAgIHBvcyArPSBtb2QucnVsZXMubGVuZ3RoXG4gICAgICBqKytcbiAgICB9XG4gIH1cblxuICBpZiAoIXNoZWV0KSB7XG4gICAgdmFyIHRleHQgPSBcIlwiXG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgdGhpcy5tb2R1bGVzLmxlbmd0aDsgaSQxKyspXG4gICAgICB7IHRleHQgKz0gdGhpcy5tb2R1bGVzW2kkMV0uZ2V0UnVsZXMoKSArIFwiXFxuXCIgfVxuICAgIHRoaXMuc3R5bGVUYWcudGV4dENvbnRlbnQgPSB0ZXh0XG4gIH1cbn07XG5cbi8vIFN0eWxlOjpPYmplY3Q8dW5pb248U3R5bGUsc3RyaW5nPj5cbi8vXG4vLyBBIHN0eWxlIGlzIGFuIG9iamVjdCB0aGF0LCBpbiB0aGUgc2ltcGxlIGNhc2UsIG1hcHMgQ1NTIHByb3BlcnR5XG4vLyBuYW1lcyB0byBzdHJpbmdzIGhvbGRpbmcgdGhlaXIgdmFsdWVzLCBhcyBpbiBge2NvbG9yOiBcInJlZFwiLFxuLy8gZm9udFdlaWdodDogXCJib2xkXCJ9YC4gVGhlIHByb3BlcnR5IG5hbWVzIGNhbiBiZSBnaXZlbiBpblxuLy8gY2FtZWwtY2FzZeKAlHRoZSBsaWJyYXJ5IHdpbGwgaW5zZXJ0IGEgZGFzaCBiZWZvcmUgY2FwaXRhbCBsZXR0ZXJzXG4vLyB3aGVuIGNvbnZlcnRpbmcgdGhlbSB0byBDU1MuXG4vL1xuLy8gSWYgeW91IGluY2x1ZGUgYW4gdW5kZXJzY29yZSBpbiBhIHByb3BlcnR5IG5hbWUsIGl0IGFuZCBldmVyeXRoaW5nXG4vLyBhZnRlciBpdCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgb3V0cHV0LCB3aGljaCBjYW4gYmUgdXNlZnVsIHdoZW5cbi8vIHByb3ZpZGluZyBhIHByb3BlcnR5IG11bHRpcGxlIHRpbWVzLCBmb3IgYnJvd3NlciBjb21wYXRpYmlsaXR5XG4vLyByZWFzb25zLlxuLy9cbi8vIEEgcHJvcGVydHkgaW4gYSBzdHlsZSBvYmplY3QgY2FuIGFsc28gYmUgYSBzdWItc2VsZWN0b3IsIHdoaWNoXG4vLyBleHRlbmRzIHRoZSBjdXJyZW50IGNvbnRleHQgdG8gYWRkIGEgcHNldWRvLXNlbGVjdG9yIG9yIGEgY2hpbGRcbi8vIHNlbGVjdG9yLiBTdWNoIGEgcHJvcGVydHkgc2hvdWxkIGNvbnRhaW4gYSBgJmAgY2hhcmFjdGVyLCB3aGljaFxuLy8gd2lsbCBiZSByZXBsYWNlZCBieSB0aGUgY3VycmVudCBzZWxlY3Rvci4gRm9yIGV4YW1wbGUgYHtcIiY6YmVmb3JlXCI6XG4vLyB7Y29udGVudDogJ1wiaGlcIid9fWAuIFN1Yi1zZWxlY3RvcnMgYW5kIHJlZ3VsYXIgcHJvcGVydGllcyBjYW5cbi8vIGZyZWVseSBiZSBtaXhlZCBpbiBhIGdpdmVuIG9iamVjdC4gQW55IHByb3BlcnR5IGNvbnRhaW5pbmcgYSBgJmAgaXNcbi8vIGFzc3VtZWQgdG8gYmUgYSBzdWItc2VsZWN0b3IuXG4vL1xuLy8gRmluYWxseSwgYSBwcm9wZXJ0eSBjYW4gc3BlY2lmeSBhbiBALWJsb2NrIHRvIGJlIHdyYXBwZWQgYXJvdW5kIHRoZVxuLy8gc3R5bGVzIGRlZmluZWQgaW5zaWRlIHRoZSBvYmplY3QgdGhhdCdzIHRoZSBwcm9wZXJ0eSdzIHZhbHVlLiBGb3Jcbi8vIGV4YW1wbGUgdG8gY3JlYXRlIGEgbWVkaWEgcXVlcnkgeW91IGNhbiBkbyBge1wiQG1lZGlhIHNjcmVlbiBhbmRcbi8vIChtaW4td2lkdGg6IDQwMHB4KVwiOiB7Li4ufX1gLlxuXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBiYXNlID0ge1xuICA4OiBcIkJhY2tzcGFjZVwiLFxuICA5OiBcIlRhYlwiLFxuICAxMDogXCJFbnRlclwiLFxuICAxMjogXCJOdW1Mb2NrXCIsXG4gIDEzOiBcIkVudGVyXCIsXG4gIDE2OiBcIlNoaWZ0XCIsXG4gIDE3OiBcIkNvbnRyb2xcIixcbiAgMTg6IFwiQWx0XCIsXG4gIDIwOiBcIkNhcHNMb2NrXCIsXG4gIDI3OiBcIkVzY2FwZVwiLFxuICAzMjogXCIgXCIsXG4gIDMzOiBcIlBhZ2VVcFwiLFxuICAzNDogXCJQYWdlRG93blwiLFxuICAzNTogXCJFbmRcIixcbiAgMzY6IFwiSG9tZVwiLFxuICAzNzogXCJBcnJvd0xlZnRcIixcbiAgMzg6IFwiQXJyb3dVcFwiLFxuICAzOTogXCJBcnJvd1JpZ2h0XCIsXG4gIDQwOiBcIkFycm93RG93blwiLFxuICA0NDogXCJQcmludFNjcmVlblwiLFxuICA0NTogXCJJbnNlcnRcIixcbiAgNDY6IFwiRGVsZXRlXCIsXG4gIDU5OiBcIjtcIixcbiAgNjE6IFwiPVwiLFxuICA5MTogXCJNZXRhXCIsXG4gIDkyOiBcIk1ldGFcIixcbiAgMTA2OiBcIipcIixcbiAgMTA3OiBcIitcIixcbiAgMTA4OiBcIixcIixcbiAgMTA5OiBcIi1cIixcbiAgMTEwOiBcIi5cIixcbiAgMTExOiBcIi9cIixcbiAgMTQ0OiBcIk51bUxvY2tcIixcbiAgMTQ1OiBcIlNjcm9sbExvY2tcIixcbiAgMTYwOiBcIlNoaWZ0XCIsXG4gIDE2MTogXCJTaGlmdFwiLFxuICAxNjI6IFwiQ29udHJvbFwiLFxuICAxNjM6IFwiQ29udHJvbFwiLFxuICAxNjQ6IFwiQWx0XCIsXG4gIDE2NTogXCJBbHRcIixcbiAgMTczOiBcIi1cIixcbiAgMTg2OiBcIjtcIixcbiAgMTg3OiBcIj1cIixcbiAgMTg4OiBcIixcIixcbiAgMTg5OiBcIi1cIixcbiAgMTkwOiBcIi5cIixcbiAgMTkxOiBcIi9cIixcbiAgMTkyOiBcImBcIixcbiAgMjE5OiBcIltcIixcbiAgMjIwOiBcIlxcXFxcIixcbiAgMjIxOiBcIl1cIixcbiAgMjIyOiBcIidcIixcbiAgMjI5OiBcInFcIlxufTtcblxudmFyIHNoaWZ0ID0ge1xuICA0ODogXCIpXCIsXG4gIDQ5OiBcIiFcIixcbiAgNTA6IFwiQFwiLFxuICA1MTogXCIjXCIsXG4gIDUyOiBcIiRcIixcbiAgNTM6IFwiJVwiLFxuICA1NDogXCJeXCIsXG4gIDU1OiBcIiZcIixcbiAgNTY6IFwiKlwiLFxuICA1NzogXCIoXCIsXG4gIDU5OiBcIjpcIixcbiAgNjE6IFwiK1wiLFxuICAxNzM6IFwiX1wiLFxuICAxODY6IFwiOlwiLFxuICAxODc6IFwiK1wiLFxuICAxODg6IFwiPFwiLFxuICAxODk6IFwiX1wiLFxuICAxOTA6IFwiPlwiLFxuICAxOTE6IFwiP1wiLFxuICAxOTI6IFwiflwiLFxuICAyMTk6IFwie1wiLFxuICAyMjA6IFwifFwiLFxuICAyMjE6IFwifVwiLFxuICAyMjI6IFwiXFxcIlwiLFxuICAyMjk6IFwiUVwiXG59O1xuXG52YXIgY2hyb21lID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiICYmIC9DaHJvbWVcXC8oXFxkKykvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG52YXIgc2FmYXJpID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiICYmIC9BcHBsZSBDb21wdXRlci8udGVzdChuYXZpZ2F0b3IudmVuZG9yKTtcbnZhciBnZWNrbyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiAmJiAvR2Vja29cXC9cXGQrLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xudmFyIG1hYyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiAmJiAvTWFjLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSk7XG52YXIgaWUgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgJiYgL01TSUUgXFxkfFRyaWRlbnRcXC8oPzpbNy05XXxcXGR7Mix9KVxcLi4qcnY6KFxcZCspLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpO1xudmFyIGJyb2tlbk1vZGlmaWVyTmFtZXMgPSBjaHJvbWUgJiYgKG1hYyB8fCArY2hyb21lWzFdIDwgNTcpIHx8IGdlY2tvICYmIG1hYztcblxuLy8gRmlsbCBpbiB0aGUgZGlnaXQga2V5c1xuZm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSBiYXNlWzQ4ICsgaV0gPSBiYXNlWzk2ICsgaV0gPSBTdHJpbmcoaSk7XG5cbi8vIFRoZSBmdW5jdGlvbiBrZXlzXG5mb3IgKHZhciBpID0gMTsgaSA8PSAyNDsgaSsrKSBiYXNlW2kgKyAxMTFdID0gXCJGXCIgKyBpO1xuXG4vLyBBbmQgdGhlIGFscGhhYmV0aWMga2V5c1xuZm9yICh2YXIgaSA9IDY1OyBpIDw9IDkwOyBpKyspIHtcbiAgYmFzZVtpXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSArIDMyKTtcbiAgc2hpZnRbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpO1xufVxuXG4vLyBGb3IgZWFjaCBjb2RlIHRoYXQgZG9lc24ndCBoYXZlIGEgc2hpZnQtZXF1aXZhbGVudCwgY29weSB0aGUgYmFzZSBuYW1lXG5mb3IgKHZhciBjb2RlIGluIGJhc2UpIGlmICghc2hpZnQuaGFzT3duUHJvcGVydHkoY29kZSkpIHNoaWZ0W2NvZGVdID0gYmFzZVtjb2RlXTtcblxuZnVuY3Rpb24ga2V5TmFtZShldmVudCkge1xuICAvLyBEb24ndCB0cnVzdCBldmVudC5rZXkgaW4gQ2hyb21lIHdoZW4gdGhlcmUgYXJlIG1vZGlmaWVycyB1bnRpbFxuICAvLyB0aGV5IGZpeCBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD02MzM4MzhcbiAgdmFyIGlnbm9yZUtleSA9IGJyb2tlbk1vZGlmaWVyTmFtZXMgJiYgKGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQuYWx0S2V5IHx8IGV2ZW50Lm1ldGFLZXkpIHx8XG4gICAgKHNhZmFyaSB8fCBpZSkgJiYgZXZlbnQuc2hpZnRLZXkgJiYgZXZlbnQua2V5ICYmIGV2ZW50LmtleS5sZW5ndGggPT0gMTtcbiAgdmFyIG5hbWUgPSAoIWlnbm9yZUtleSAmJiBldmVudC5rZXkpIHx8XG4gICAgKGV2ZW50LnNoaWZ0S2V5ID8gc2hpZnQgOiBiYXNlKVtldmVudC5rZXlDb2RlXSB8fFxuICAgIGV2ZW50LmtleSB8fCBcIlVuaWRlbnRpZmllZFwiO1xuICAvLyBFZGdlIHNvbWV0aW1lcyBwcm9kdWNlcyB3cm9uZyBuYW1lcyAoSXNzdWUgIzMpXG4gIGlmIChuYW1lID09IFwiRXNjXCIpIG5hbWUgPSBcIkVzY2FwZVwiO1xuICBpZiAobmFtZSA9PSBcIkRlbFwiKSBuYW1lID0gXCJEZWxldGVcIjtcbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9lbi11cy9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvODg2MDU3MS9cbiAgaWYgKG5hbWUgPT0gXCJMZWZ0XCIpIG5hbWUgPSBcIkFycm93TGVmdFwiO1xuICBpZiAobmFtZSA9PSBcIlVwXCIpIG5hbWUgPSBcIkFycm93VXBcIjtcbiAgaWYgKG5hbWUgPT0gXCJSaWdodFwiKSBuYW1lID0gXCJBcnJvd1JpZ2h0XCI7XG4gIGlmIChuYW1lID09IFwiRG93blwiKSBuYW1lID0gXCJBcnJvd0Rvd25cIjtcbiAgcmV0dXJuIG5hbWVcbn1cblxuZXhwb3J0cy5iYXNlID0gYmFzZTtcbmV4cG9ydHMua2V5TmFtZSA9IGtleU5hbWU7XG5leHBvcnRzLnNoaWZ0ID0gc2hpZnQ7XG4iLCJpbXBvcnQgJ2FscGluZWpzJztcbmltcG9ydCBOb3RpZnkgZnJvbSAnLi9jb21wb25lbnRzL05vdGlmeSc7XG5pbXBvcnQgU3RhdGVtZW50IGZyb20gJy4vY29tcG9uZW50cy9TdGF0ZW1lbnQnO1xuaW1wb3J0IE1vZGFsIGZyb20gJy4vY29tcG9uZW50cy9Nb2RhbCc7XG5cbmltcG9ydCB7IEVkaXRvclN0YXRlLCBFZGl0b3JWaWV3LCBiYXNpY1NldHVwIH0gZnJvbSBcIkBjb2RlbWlycm9yL2Jhc2ljLXNldHVwXCI7XG5pbXBvcnQgeyBTdGF0ZUZpZWxkIH0gZnJvbSAnQGNvZGVtaXJyb3Ivc3RhdGUnO1xuaW1wb3J0IHsgc2hvd1Rvb2x0aXAgfSBmcm9tIFwiQGNvZGVtaXJyb3IvdG9vbHRpcFwiO1xuXG53aW5kb3cubm90aWZ5ID0gTm90aWZ5O1xud2luZG93LkFwcCA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIG5ldyBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnN0YXJ0ID0gKGZpbGVTZWxlY3RvciwgZmlsdGVyU2VsZWN0b3IsIGNvZGVJbnB1dCwgbW9kYWxUZW1wbGF0ZVJlbW92ZSwgbW9kYWxUZW1wbGF0ZUFkZCkgPT4ge1xuXHRcdFx0bGV0IGRhdGEgPSB7XG5cdFx0XHRcdGNvZGVFZGl0b3I6IHVuZGVmaW5lZCxcblx0XHRcdFx0c3RhdGVtZW50OiBuZXcgU3RhdGVtZW50KHsgbm90aWZpY2F0aW9uOiBOb3RpZnkgfSksXG5cdFx0XHRcdHN0YXRlbWVudE9iamVjdDogdW5kZWZpbmVkLFxuXHRcdFx0XHR0YWJsZUNvbHVtbnM6IFsgXSxcblx0XHRcdFx0ZmlsdGVyVGV4dDogZmFsc2UsXHRcdC8vIGJvb2wsIG9uIHNlbGVjdENvbHVtbiB0aGlzIGlzIHRydWUsIHRoZW4gdGhlIENNIGNoYW5nZSBwbHVnaW4gYmVsb3cgc2V0cyB0aGUgY20gdGV4dCB0byB0aGUgdmFsdWVzXG5cdFx0XHRcdGZpbHRlcmVkVmlldzogZmFsc2UsXHQvLyBuYW1lIG9mIGNvbHVtbiB0byBmaWx0ZXIgYnlcblx0XHRcdFx0cmVzZXRGaWx0ZXI6IGZhbHNlLFxuXHRcdFx0XHRlZGl0b3JEaXJ0eTogZmFsc2UsXHRcdC8vIHdoZW4gdXNlciBzd2l0Y2hlcyB0aGUgY29sdW1uIHRhYmxlcyBhIGxvdCBhbmQgY2hhbmdlcyB2YWx1ZXMgLSBtYWtlIGNvbnRlbnQgb2YgZWRpdG9yIGRpcnR5LT5uZWVkIHRvIHNldCBjb2x1bW4gdmFsdWVzLCBlZGl0b3IgaXMgZGlydHkgd2hlbiB0aGlzIHZhbHVlIGlzICE9PSBmYWxzZSwgaXQgZ2V0cyB0aGUgY2hhbmdlZCBjb2x1bW5cblx0XHRcdFx0bW9kYWxSZW1vdmU6IG5ldyBNb2RhbCh7IHRlbXBsYXRlOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKG1vZGFsVGVtcGxhdGVSZW1vdmUpIH0pLFxuXHRcdFx0XHRtb2RhbEFkZDogbmV3IE1vZGFsKHtcblx0XHRcdFx0XHRcdHRlbXBsYXRlOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKG1vZGFsVGVtcGxhdGVBZGQpLCBcblx0XHRcdFx0XHRcdC8vIHRoaXMgaXMgdGhlIGNvbmZpZyBvYmplY3QgaW4gdGhlIGNvbnRleHQgb2YgdGhlc2UgY2FsbGJhY2tzIFxuXHRcdFx0XHRcdFx0b25TaG93OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5kb21Nb2RhbC5xdWVyeVNlbGVjdG9yKCcuanMtaW5wdXQnKS52YWx1ZSA9ICcnO1xuXHRcdFx0XHRcdFx0XHR0aGlzLmRvbU1vZGFsLnF1ZXJ5U2VsZWN0b3IoJy5qcy1pbnB1dCcpLmZvY3VzKCk7XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0b25Db25maXJtOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuZG9tTW9kYWwucXVlcnlTZWxlY3RvcignLmpzLWlucHV0JykudmFsdWUgIT09ICcnO1xuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdG9uUmVzb2x2ZTogZnVuY3Rpb24oYWNjZXB0ZWQpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFsgYWNjZXB0ZWQsIHRoaXMuZG9tTW9kYWwucXVlcnlTZWxlY3RvcignLmpzLWlucHV0JykudmFsdWUgXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KSxcblx0XHRcdH07XG5cblx0XHRcdGxldCBjbSA9IHtcblx0XHRcdFx0c2V0VGV4dDogdGV4dCA9PiB7XG5cdFx0XHRcdFx0ZGF0YS5jb2RlRWRpdG9yLmRpc3BhdGNoKHtcblx0XHRcdFx0XHRcdGNoYW5nZXM6IHsgZnJvbTogMCwgdG86IGRhdGEuY29kZUVkaXRvci5zdGF0ZS5kb2MubGVuZ3RoLCBpbnNlcnQ6IHRleHQgfVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRnZXRDdXJyZW50TGluZTogKCkgPT4gZGF0YS5jb2RlRWRpdG9yLnN0YXRlLmRvYy5saW5lQXQoZGF0YS5jb2RlRWRpdG9yLnN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpLFxuXHRcdFx0XHRnZXRDYXJldFBvc2l0aW9uOiAoKSA9PiBkYXRhLmNvZGVFZGl0b3Iuc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZCxcblx0XHRcdFx0c2V0Q2FyZXRQb3NpdGlvbjogb2Zmc2V0ID0+IGRhdGEuY29kZUVkaXRvci5kaXNwYXRjaCh7IHNlbGVjdGlvbjogeyBhbmNob3I6IG9mZnNldCB9LCBzY3JvbGxJbnRvVmlldzogdHJ1ZSB9KSxcblx0XHRcdFx0c2V0RmlsdGVyVmlldzogY29sdW1uID0+IHtcblx0XHRcdFx0XHRpZiAoZGF0YS5zdGF0ZW1lbnRPYmplY3QpIHtcblx0XHRcdFx0XHRcdGRhdGEuZmlsdGVyZWRWaWV3ID0gY29sdW1uO1xuXG5cdFx0XHRcdFx0XHRkYXRhLmZpbHRlclRleHQgPSB0cnVlOyAgLy8gaW5kaWNhdGUgd2UncmUgZ29pbmcgdG8gZmlsdGVyIGluIGxpc3RlbkNoYW5nZXNFeHRlbnNpb25cblx0XHRcdFx0XHRcdGNtLnNldFRleHQoZGF0YS5zdGF0ZW1lbnRPYmplY3QuZ2V0VmFsdWVzQnlDb2x1bW4oY29sdW1uKS5qb2luKCdcXG4nKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRyZXNldEZpbHRlclZpZXc6ICgpID0+IHtcblx0XHRcdFx0XHRpZiAoZGF0YS5zdGF0ZW1lbnRPYmplY3QpIHtcblx0XHRcdFx0XHRcdGRhdGEucmVzZXRGaWx0ZXIgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHQvLyBnZXQgY3VycmVudCBmaWx0ZXJlZCB0ZXh0XG5cdFx0XHRcdFx0XHRsZXQgcm93cyA9IGRhdGEuY29kZUVkaXRvci5zdGF0ZS5kb2MudG9KU09OKCk7XG5cblx0XHRcdFx0XHRcdC8vIGNoYW5nZSBleGlzdGluZyB2YWx1ZXNcblx0XHRcdFx0XHRcdGlmIChkYXRhLnN0YXRlbWVudE9iamVjdC51cGRhdGVWYWx1ZXMoZGF0YS5maWx0ZXJlZFZpZXcsIHJvd3MpKSB7XG5cdFx0XHRcdFx0XHRcdGRhdGEuZmlsdGVyZWRWaWV3ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdGRhdGEuZmlsdGVyVGV4dCA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0XHRcdC8vIGFzc2VtYmxlIG5ldyBmdWxsIHN0cmluZ1xuXHRcdFx0XHRcdFx0XHRsZXQgc3RhdGVtZW50ID0gZGF0YS5zdGF0ZW1lbnRPYmplY3QuYXNzZW1ibGUoKTtcblx0XHRcdFx0XHRcdFx0aWYgKHN0YXRlbWVudCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gdXNlIG5ldyBpbnNlcnQgdGV4dCBmb3IgQ01cblx0XHRcdFx0XHRcdFx0XHRjbS5zZXRUZXh0KHN0YXRlbWVudCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Y20uc2V0VGV4dCgnZXJyb3InKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0ZGF0YS5maWx0ZXJlZFZpZXcgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0ZGF0YS5maWx0ZXJUZXh0ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdGNtLnNldFRleHQoZGF0YS5zdGF0ZW1lbnRPYmplY3QuYXNzZW1ibGUoKSk7XG5cblx0XHRcdFx0XHRcdFx0bm90aWZ5Lndhcm5pbmcoJ1VwZGF0ZSB2YWx1ZXMgZmFpbGVkJywgJ1JldmVydGluZyBsYXN0IGNoYW5nZXMnKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0ZGF0YS5lZGl0b3JEaXJ0eSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0bGV0IHRvQ2hhbmdlc1VwZGF0ZSA9IHVuZGVmaW5lZDtcblx0XHRcdGNvbnN0IGxpc3RlbkNoYW5nZXNFeHRlbnNpb24gPSBTdGF0ZUZpZWxkLmRlZmluZSh7XG5cdFx0XHRcdC8vIHdlIHdvbid0IHVzZSB0aGUgYWN0dWFsIFN0YXRlRmllbGQgdmFsdWUsIG51bGwgb3IgdW5kZWZpbmVkIGlzIGZpbmVcblx0XHRcdFx0Y3JlYXRlOiAoKSA9PiBudWxsLFxuXHRcdFx0XHR1cGRhdGU6ICh2YWx1ZSwgdHJhbnNhY3Rpb24pID0+IHtcblx0XHRcdFx0XHRpZiAodHJhbnNhY3Rpb24uZG9jQ2hhbmdlZCkge1xuXHRcdFx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRvQ2hhbmdlc1VwZGF0ZSk7XG5cdFx0XHRcdFx0XHR0b0NoYW5nZXNVcGRhdGUgPSBzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdFx0XHRcdFx0aWYgKGRhdGEucmVzZXRGaWx0ZXIpIHtcblx0XHRcdFx0XHRcdFx0XHRkYXRhLnJlc2V0RmlsdGVyID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGRhdGEuZmlsdGVyVGV4dCkgeyAgLy8gZmlsdGVyIHZpZXcsIGRvIG5vdCByZS1hbmFseXplLCB1c2VyIGNsaWNrcyBkaWZmZXJlbnQgY29sdW1uc1xuXHRcdFx0XHRcdFx0XHRcdGRhdGEuZmlsdGVyVGV4dCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdGlmIChkYXRhLmVkaXRvckRpcnR5ICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCFkYXRhLnN0YXRlbWVudE9iamVjdC51cGRhdGVWYWx1ZXMoZGF0YS5lZGl0b3JEaXJ0eVswXSwgZGF0YS5lZGl0b3JEaXJ0eVsxXSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm90aWZ5Lndhcm5pbmcoJ1VwZGF0ZSB2YWx1ZXMgZmFpbGVkJywgJ1JldmVydGluZyBsYXN0IGNoYW5nZXMnKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdGRhdGEuZWRpdG9yRGlydHkgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoISFkYXRhLmZpbHRlcmVkVmlldykgeyAgLy8gdmFsdWVzIGFyZSBkaXNwbGF5ZWQgZm9yIGEgZ2l2ZW4gY29sdW1uIGFuZCB1c2VyIGVkaXRzIHZhbHVlcyBvZiBhIGNvbHVtblxuXHRcdFx0XHRcdFx0XHRcdC8vIFVzZXIgY2hhbmdlZCBhIHZhbHVlLCBtYWtlIGVkaXRvckRpcnR5IGJ5IHJlbWVtYmVyaW5nIHdoYXQgY29sdW1uIHdhcyBjaGFuZ2VkXG5cdFx0XHRcdFx0XHRcdFx0Ly8gaWYgdXNlciBjbGlja3Mgb24gYW5vdGhlciBjb2x1bW4gdG8gZmlsdGVyIGJ5LCB0aGUgYWJvdmUgZGF0YS5maWx0ZXJ0ZXh0IGlzIHRyaWdnZXJlZFxuXHRcdFx0XHRcdFx0XHRcdC8vIGlmIHVzZXIgcmVzZXRzIHRoZSBmaWx0ZXIgYnkgY2xpY2tpbmcgYWN0aXZlIGNvbHVtbiwgdGhlIGNtLnJlc2V0RmlsdGVyVmlldyBpcyBpbnZva2VkIGRlYWxpbmcgd2l0aCB0aGUgdXBkYXRlIG9mIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdGRhdGEuZWRpdG9yRGlydHkgPSBbIGRhdGEuZmlsdGVyZWRWaWV3LCBkYXRhLmNvZGVFZGl0b3Iuc3RhdGUuZG9jLnRvSlNPTigpIF07XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7ICAvLyBub3JtYWwgdmlldyAtIHRleHQgY2hhbmdlZCwgYW5hbHl6ZSBjb250ZW50XG5cdFx0XHRcdFx0XHRcdFx0bGV0IHNjcm9sbFRvVG9wID0gISghIWRhdGEuc3RhdGVtZW50T2JqZWN0KTsgIC8vIHdoZW4gcHJldmlvdXNseSBhIHZhbGlkIGRvYyBleGlzdGVkIC0gZG8gbm90IHNjcm9sbCB0byB0b3Bcblx0XHRcdFx0XHRcdFx0XHRkYXRhLnN0YXRlbWVudE9iamVjdCA9IGRhdGEuc3RhdGVtZW50LmNyZWF0ZU9iamVjdCh0cmFuc2FjdGlvbi5uZXdEb2MudG9KU09OKCkuam9pbignJykpO1xuXHRcdFx0XHRcdFx0XHRcdGlmIChkYXRhLnN0YXRlbWVudE9iamVjdCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YS50YWJsZUNvbHVtbnMgPSBkYXRhLnN0YXRlbWVudE9iamVjdC5nZXRDb2x1bW5zKCk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIG91dHNpZGUgb2YgYWxwaW5lIHRoaXMgaXMgYSBoYWNreSB3YXkgb2YgYWNjZXNzaW5nIGRhdGFcblx0XHRcdFx0XHRcdFx0XHRcdGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2JvZHlbeC1kYXRhXScpLl9feC4kZGF0YS5kaXNwbGF5ZWRUYWJsZUNvbHVtbnMgPSBkYXRhLnRhYmxlQ29sdW1ucy5zbGljZSgwKTtcblx0XHRcdFx0XHRcdFx0XHRcdGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2JvZHlbeC1kYXRhXScpLl9feC4kZGF0YS5jb250ZXh0TmFtZSA9IGRhdGEuc3RhdGVtZW50T2JqZWN0LmdldFRhYmxlKCk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHNjcm9sbFRvVG9wICYmIGRhdGEuY29kZUVkaXRvci5kaXNwYXRjaCh7IHNlbGVjdGlvbjogeyBhbmNob3I6IDAgfSwgc2Nyb2xsSW50b1ZpZXc6IHRydWUgfSk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2JvZHlbeC1kYXRhXScpLl9feC4kZGF0YS5kaXNwbGF5ZWRUYWJsZUNvbHVtbnMgPSBbXTtcblx0XHRcdFx0XHRcdFx0XHRcdGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2JvZHlbeC1kYXRhXScpLl9feC4kZGF0YS5jb250ZXh0TmFtZSA9ICdRdUVkaXQnO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSwgMjUwKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fSxcblx0XHRcdH0pO1xuXG5cdFx0XHRsZXQgdG9SZW1vdmVUb29sdGlwID0gdW5kZWZpbmVkO1xuXHRcdFx0bGV0IGdldEN1cnNvclRvb2x0aXBzID0gc3RhdGUgPT4ge1xuXHRcdFx0XHRyZXR1cm4gc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5maWx0ZXIocmFuZ2UgPT4gcmFuZ2UuZW1wdHkpLm1hcChyYW5nZSA9PiB7XG5cdFx0XHRcdFx0bGV0IGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHJhbmdlLmhlYWQpO1xuXHRcdFx0XHRcdGlmIChsaW5lLm51bWJlciA+IDEgJiYgZGF0YS5zdGF0ZW1lbnRPYmplY3QpIHtcblx0XHRcdFx0XHRcdGxldCBwb3NPbkxpbmUgPSByYW5nZS5oZWFkIC0gbGluZS5mcm9tO1xuXHRcdFx0XHRcdFx0bGV0IGNvbHVtbiA9IGRhdGEuc3RhdGVtZW50T2JqZWN0LmdldENvbHVtbkF0UG9zaXRpb24ocG9zT25MaW5lLCBsaW5lLnRleHQpO1xuXHRcdFx0XHRcdFx0aWYgKGNvbHVtbiAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRvUmVtb3ZlVG9vbHRpcCk7XG5cdFx0XHRcdFx0XHRcdHRvUmVtb3ZlVG9vbHRpcCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY20tY3Vyc29yLXRvb2x0aXAnKS5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHQvL1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSwgNTAwKTtcblxuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRcdHBvczogcmFuZ2UuaGVhZCxcblx0XHRcdFx0XHRcdFx0XHRhYm92ZTogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0XHRzdHJpY3RTaWRlOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRcdGNsYXNzOiAnY20tY3Vyc29yLXRvb2x0aXAnLFxuXHRcdFx0XHRcdFx0XHRcdGNyZWF0ZTogKCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0bGV0IGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZG9tLnRleHRDb250ZW50ID0gY29sdW1uO1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHsgZG9tIH07XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9KTtcblx0XHRcdH07XG5cdFx0XHRjb25zdCB0b29sdGlwRXh0ZW5zaW9uID0gU3RhdGVGaWVsZC5kZWZpbmUoe1xuXHRcdFx0XHQvLyB3ZSB3b24ndCB1c2UgdGhlIGFjdHVhbCBTdGF0ZUZpZWxkIHZhbHVlLCBudWxsIG9yIHVuZGVmaW5lZCBpcyBmaW5lXG5cdFx0XHRcdGNyZWF0ZTogZ2V0Q3Vyc29yVG9vbHRpcHMsXG5cdFx0XHRcdHVwZGF0ZSh0b29sdGlwcywgdHIpIHtcblx0XHRcdFx0XHRpZiAoIXRyLmRvY0NoYW5nZWQgJiYgIXRyLnNlbGVjdGlvbikge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRvb2x0aXBzO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBnZXRDdXJzb3JUb29sdGlwcyh0ci5zdGF0ZSk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHByb3ZpZGU6IGYgPT4gc2hvd1Rvb2x0aXAuY29tcHV0ZU4oW2ZdLCBzdGF0ZSA9PiBzdGF0ZS5maWVsZChmKSlcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBDcmVhdGUgQ29kZUVkaXRvciBpbnN0YW5jZVxuXHRcdFx0ZGF0YS5jb2RlRWRpdG9yID0gbmV3IEVkaXRvclZpZXcoe1xuXHRcdFx0XHRzdGF0ZTogRWRpdG9yU3RhdGUuY3JlYXRlKHtcblx0XHRcdFx0XHRleHRlbnNpb25zOiBbIGJhc2ljU2V0dXAsIGxpc3RlbkNoYW5nZXNFeHRlbnNpb24sIHRvb2x0aXBFeHRlbnNpb24gXSxcblx0XHRcdFx0XHRsaW5lV3JhcHBpbmc6IHRydWUsXG5cdFx0XHRcdH0pLFxuXHRcdFx0XHRwYXJlbnQ6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoY29kZUlucHV0KVxuXHRcdFx0fSk7XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdC8vIG9wdGlvbnNcblx0XHRcdFx0Y2xlYXJCdXR0b246IGZhbHNlLFxuXG5cdFx0XHRcdC8vIHgtdGV4dFxuXHRcdFx0XHRjb250ZXh0TmFtZTogJ1F1RWRpdCcsXG5cdFx0XHRcdHNlYXJjaFRhYmxlQ29sdW1uc0J5VGV4dDogJycsXHQvLyBUZXh0IHRvIGZpbHRlciB0YWJsZUNvbHVtbnMgYnlcblx0XHRcdFx0c2VsZWN0ZWRDb2x1bW46ICcnLFx0XHRcdFx0Ly8gYSBzZWxlY3RlZCBjb2x1bW4gdG8gZGlzcGxheSB0aGUgdmFsdWVzIGZvclxuXG5cdFx0XHRcdGRpc3BsYXllZFRhYmxlQ29sdW1uczogWyBdLFx0XHQvLyBMaXN0IG9mIHRoZSBkaXNwbGF5ZWQgdGFibGUgY29sdW1ucywgbWFuaXB1bGF0ZWQgYnkgc2VhcmNoVGFibGVDb2x1bW5zQnlUZXh0XG5cblx0XHRcdFx0Ly8gRE9NIGVsZW1lbnRzXG5cdFx0XHRcdHNlYXJjaEZpbHRlcjogZG9jdW1lbnQucXVlcnlTZWxlY3RvcihmaWx0ZXJTZWxlY3RvciksXG5cdFx0XHRcdG9wZW5GaWxlSW5wdXQ6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZmlsZVNlbGVjdG9yKSxcblxuXHRcdFx0XHQvLyBkZWxheSB0aW1lcnNcblx0XHRcdFx0dG9GaWx0ZXJDb2x1bW5zOiB1bmRlZmluZWQsXG5cblx0XHRcdFx0Ly8gY2FjaGVcblx0XHRcdFx0Y2FjaGVTZWFyY2hGaWx0ZXI6IHt9LFxuXG5cdFx0XHRcdG9wZW5GaWxlUGlja2VyKCkge1xuXHRcdFx0XHRcdHRoaXMub3BlbkZpbGVJbnB1dC5jbGljaygpO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdGxvYWRGaWxlKCkge1xuXHRcdFx0XHRcdC8vIFBpY2tpbmcgYSBmaWxlIHRoYXQgcmV0dXJucyBlcnJvciwgdGhlbiBwaWNraW5nIGFnYWluIGFuZCBjbGlja2luZyBjYW5jZWwgYW5kIHRoZSB2YWx1ZSBpcyBlbXB0eVxuXHRcdFx0XHRcdGlmICh0aGlzLm9wZW5GaWxlSW5wdXQudmFsdWUubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dGhpcy5sb2FkZWRGaWxlUGF0aCA9IHRoaXMub3BlbkZpbGVJbnB1dC5maWxlc1swXS5wYXRoO1xuXHRcdFx0XHRcdGxldCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXHRcdFx0XHRcdHJlYWRlci5vbmxvYWQgPSAoKSA9PiB7XG5cdFx0XHRcdFx0XHRjbS5zZXRUZXh0KHJlYWRlci5yZXN1bHQpO1xuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRpZiAodGhpcy5vcGVuRmlsZUlucHV0LmZpbGVzWzBdLnNpemUgPiAyNjJfMTQ0XzAwMCkge1xuXHRcdFx0XHRcdFx0bm90aWZ5LmRhbmdlcignRmlsZSB0b28gbGFyZ2UnLCAnWW91IGNhbiBvbmx5IG9wZW4gZmlsZXMgdXAgdG9vIDI1MCBNaUIgc2l6ZS4nKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZWFkZXIucmVhZEFzVGV4dCh0aGlzLm9wZW5GaWxlSW5wdXQuZmlsZXNbMF0pO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdGNsZWFyRmlsdGVyKCkge1xuXHRcdFx0XHRcdHRoaXMuc2VhcmNoVGFibGVDb2x1bW5zQnlUZXh0ID0gJyc7XG5cdFx0XHRcdFx0dGhpcy5zZWFyY2hGaWx0ZXIudmFsdWUgPSAnJztcblx0XHRcdFx0XHR0aGlzLmNsZWFyQnV0dG9uID0gZmFsc2U7XG5cdFx0XHRcdFx0dGhpcy5kaXNwbGF5ZWRUYWJsZUNvbHVtbnMgPSBkYXRhLnRhYmxlQ29sdW1ucy5zbGljZSgwKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHRmaWx0ZXJDb2x1bW5zKCkge1xuXHRcdFx0XHRcdC8vIGtpbGwgcHJldmlvdXMgdGltZXJcblx0XHRcdFx0XHRjbGVhclRpbWVvdXQodGhpcy50b0ZpbHRlckNvbHVtbnMpO1xuXHRcdFx0XHRcdHRoaXMudG9GaWx0ZXJDb2x1bW5zID0gc2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRcdFx0XHR0aGlzLmNsZWFyQnV0dG9uID0gdHJ1ZTtcblx0XHRcdFx0XHRcdHRoaXMuc2VhcmNoVGFibGVDb2x1bW5zQnlUZXh0ID0gdGhpcy5zZWFyY2hGaWx0ZXIudmFsdWU7XG5cblx0XHRcdFx0XHRcdGlmICh0aGlzLnNlYXJjaFRhYmxlQ29sdW1uc0J5VGV4dC5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5kaXNwbGF5ZWRUYWJsZUNvbHVtbnMgPSBkYXRhLnRhYmxlQ29sdW1ucy5zbGljZSgwKTtcblxuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHR5cGVvZih0aGlzLmNhY2hlU2VhcmNoRmlsdGVyW3RoaXMuc2VhcmNoVGFibGVDb2x1bW5zQnlUZXh0XSkgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuZGlzcGxheWVkVGFibGVDb2x1bW5zID0gdGhpcy5jYWNoZVNlYXJjaEZpbHRlclt0aGlzLnNlYXJjaFRhYmxlQ29sdW1uc0J5VGV4dF0uc2xpY2UoMCk7XG5cblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRsZXQgcmVGaWx0ZXIgPSBuZXcgUmVnRXhwKHRoaXMuc2VhcmNoVGFibGVDb2x1bW5zQnlUZXh0LCAnaScpO1xuXHRcdFx0XHRcdFx0dGhpcy5kaXNwbGF5ZWRUYWJsZUNvbHVtbnMgPSBkYXRhLnRhYmxlQ29sdW1ucy5yZWR1Y2UoKHByZXZWYWwsIGN1clZhbCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRpZiAoY3VyVmFsLm1hdGNoKHJlRmlsdGVyKSkge1xuXHRcdFx0XHRcdFx0XHRcdHByZXZWYWwucHVzaChjdXJWYWwpO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHByZXZWYWw7XG5cdFx0XHRcdFx0XHR9LCBbXSk7XG5cdFx0XHRcdFx0XHR0aGlzLmNhY2hlU2VhcmNoRmlsdGVyW3RoaXMuc2VhcmNoVGFibGVDb2x1bW5zQnlUZXh0XSA9IHRoaXMuZGlzcGxheWVkVGFibGVDb2x1bW5zLnNsaWNlKDApO1xuXHRcdFx0XHRcdH0sIDIwMCk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0c2VsZWN0Q29sdW1uKGNvbHVtbikge1xuXHRcdFx0XHRcdGlmIChjb2x1bW4gPT09IHRoaXMuc2VsZWN0ZWRDb2x1bW4pIHtcblx0XHRcdFx0XHRcdHRoaXMuc2VsZWN0ZWRDb2x1bW4gPSAnJztcblx0XHRcdFx0XHRcdGNtLnJlc2V0RmlsdGVyVmlldygpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRoaXMuc2VsZWN0ZWRDb2x1bW4gPSBjb2x1bW47XG5cdFx0XHRcdFx0Y20uc2V0RmlsdGVyVmlldyh0aGlzLnNlbGVjdGVkQ29sdW1uKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogVHJhc2hpY29uIG9uIGEgY29sdW1uIHdhcyBzZWxlY3RlZC5cblx0XHRcdFx0ICogT25seSBhdmFpbGFibGUgaWYgZGF0YS5zdGF0ZW1lbnRPYmplY3QgaXMgYSB2YWxpZCBpbnN0YW5jZS5cblx0XHRcdFx0ICogXG5cdFx0XHRcdCAqIEBwYXJhbVx0c3RyaW5nXHRjb2x1bW5cdFx0VGhlIGNvbHVtbiB0byByZW1vdmUuXG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRyZW1vdmVWYWx1ZXNCeUNvbHVtbihjb2x1bW4pIHtcblx0XHRcdFx0XHRpZiAoZGF0YS50YWJsZUNvbHVtbnMubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRcdFx0XHRub3RpZnkud2FybmluZygnV2FybmluZycsIGBBdCBsZWFzdCAxIGNvbHVtbiBtdXN0IGJlIHByZXNlbnQsIG9yIHlvdXIgc3RhdGVtZW50IGJlY29tZXMgaW52YWxpZCFgKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGF0YS5tb2RhbFJlbW92ZS5jb25maXJtKGNvbHVtbikudGhlbigoYWNjZXB0ZWQpID0+IHtcblx0XHRcdFx0XHRcdGlmIChhY2NlcHRlZCkge1xuXHRcdFx0XHRcdFx0XHRsZXQgbmV3Q29sdW1ucztcblxuXHRcdFx0XHRcdFx0XHRpZiAobmV3Q29sdW1ucyA9IGRhdGEuc3RhdGVtZW50T2JqZWN0LnJlbW92ZUNvbHVtbihjb2x1bW4pKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS50YWJsZUNvbHVtbnMgPSBuZXdDb2x1bW5zO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuZGlzcGxheWVkVGFibGVDb2x1bW5zID0gZGF0YS50YWJsZUNvbHVtbnMuc2xpY2UoMCk7XG5cblx0XHRcdFx0XHRcdFx0XHR0aGlzLmNhY2hlU2VhcmNoRmlsdGVyID0ge307ICAvLyByZXNldCBvciBkZWxldGVkIGNvbHVtbiBtaWdodCBiZSBkaXNwbGF5ZWRcblx0XHRcdFx0XHRcdFx0XHRub3RpZnkuc3VjY2VzcygnRGVsZXRlZCcsIGAnJHsgY29sdW1uIH0nIHdhcyByZW1vdmVkLmApO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdG5vdGlmeS5kYW5nZXIoJ0Vycm9yJywgYCR7IGNvbHVtbiB9IGNvdWxkIG5vdCBiZSByZW1vdmVkLCByZXZlcnRpbmcuYCk7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRkYXRhLnJlc2V0RmlsdGVyID0gdHJ1ZTsgIC8vIHRyaWNrIGNvZGVFZGl0b3IgaW4gbm90IGRvaW5nIGRvdWJsZSB0aGUgd29ya1xuXHRcdFx0XHRcdFx0XHRjbS5zZXRUZXh0KGRhdGEuc3RhdGVtZW50T2JqZWN0LmFzc2VtYmxlKCkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdGFkZENvbHVtbigpIHtcblx0XHRcdFx0XHRpZiAodGhpcy5zZWxlY3RlZENvbHVtbi5sZW5ndGggPiAwKSB7IHJldHVybjsgfVxuXG5cdFx0XHRcdFx0ZGF0YS5tb2RhbEFkZC5zaG93KCkudGhlbihwYXJhbSA9PiB7XG5cdFx0XHRcdFx0XHRpZiAocGFyYW1bMF0gPT09IHRydWUpIHtcblx0XHRcdFx0XHRcdFx0bGV0IG9sZFN0YXRlbWVudCA9IGRhdGEuc3RhdGVtZW50T2JqZWN0LmFzc2VtYmxlKCk7XG5cdFx0XHRcdFx0XHRcdGlmIChkYXRhLnN0YXRlbWVudE9iamVjdC5hZGRDb2x1bW4ocGFyYW1bMV0pKSB7XG5cdFx0XHRcdFx0XHRcdFx0bGV0IHN0YXRlbWVudCA9IGRhdGEuc3RhdGVtZW50T2JqZWN0LmFzc2VtYmxlKCk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHN0YXRlbWVudCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyB1c2UgbmV3IGluc2VydCB0ZXh0IGZvciBDTVxuXHRcdFx0XHRcdFx0XHRcdFx0Y20uc2V0VGV4dChzdGF0ZW1lbnQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGNtLnNldFRleHQob2xkU3RhdGVtZW50KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHRjbGVhckFwcCgpIHtcblx0XHRcdFx0XHR0aGlzLmNsZWFyQnV0dG9uID0gZmFsc2U7XG5cdFx0XHRcdFx0dGhpcy5jb250ZXh0TmFtZSA9ICdRdUVkaXQnO1xuXHRcdFx0XHRcdHRoaXMuc2VhcmNoVGFibGVDb2x1bW5zQnlUZXh0ID0gJyc7XG5cdFx0XHRcdFx0dGhpcy5zZWxlY3RlZENvbHVtbiA9ICcnO1xuXHRcdFx0XHRcdHRoaXMuZGlzcGxheWVkVGFibGVDb2x1bW5zID0gW107XG5cdFx0XHRcdFx0dGhpcy50b0ZpbHRlckNvbHVtbnMgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0dGhpcy5jYWNoZVNlYXJjaEZpbHRlciA9IHt9O1xuXG5cdFx0XHRcdFx0ZGF0YS5zdGF0ZW1lbnRPYmplY3QgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0ZGF0YS50YWJsZUNvbHVtbnMgPSBbIF07XG5cdFx0XHRcdFx0ZGF0YS5maWx0ZXJUZXh0ID0gZmFsc2U7XG5cdFx0XHRcdFx0ZGF0YS5maWx0ZXJlZFZpZXcgPSBmYWxzZTtcblx0XHRcdFx0XHRkYXRhLnJlc2V0RmlsdGVyID0gZmFsc2U7XG5cdFx0XHRcdFx0ZGF0YS5lZGl0b3JEaXJ0eSA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0Y20uc2V0VGV4dCgnJyk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHR9XG59KSgpOyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEluc2VydChjb25maWcpIHtcblx0dGhpcy5pbnNlcnRUZXh0ID0gJyc7XG5cblx0dGhpcy5jb25maWcgPSB7XG5cdFx0Li4ue1xuXHRcdFx0aXNWYWxpZDogZmFsc2UsXG5cdFx0XHRwYXJlbnQ6IHVuZGVmaW5lZCxcblx0XHR9LFxuXHRcdC4uLmNvbmZpZ1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBOYW1lIG9mIHRoZSB0YWJsZSB3aGVyZSB2YWx1ZXMgYXJlIGluc2VydGVkLlxuXHQgKi9cblx0dGhpcy50YWJsZU5hbWUgPSAnJztcblx0LyoqXG5cdCAqIFRoZSBBcnJheSBvZiBjb2x1bW5zIG9mIHRoZSBzdGF0ZW1lbnQuXG5cdCAqL1xuXHR0aGlzLmNvbHVtbnMgPSBbXTtcblx0dGhpcy5tYXBDb2x1bW5Ub0luZGV4ID0ge307XG5cblx0LyoqXG5cdCAqIFRoZSB2YWx1ZXMgdG8gYmUgaW5zZXJ0ZWQuXG5cdCAqIFRoZSBsZW5ndGggb2YgdGhpcyBwcm9wZXJ0eSBpcyBlcXVpdmFsZW50IHRvIHRoZSBhbW91bnQgb2Ygcm93cywgYmVjYXVzZSBlYWNoIFNRTCB0dXBlbCBpcyBvbmUgZW50cnk6XG5cdCAqIFsgWyd1aWQxJywgJ2Rlc2NyaXB0aW9uMSddLCBbJ3VpZDInLCAnZGVzY3JpcHRpb24yJ10gXVxuXHQgKi9cblx0dGhpcy52YWx1ZXMgPSBbXTtcblxuXHQvKipcblx0ICogQSBsaW5rIGZyb20gY29sdW1uIHRvIHZhbHVlLlxuXHQgKiBJbmRleCBiYXNlZCwgbWVhbmluZywgXCJjb2x1bW5BdEluZGV4WVwiIGluc2lkZSBjb2x1bW5zIG1hcHMgdG8gdmFsdWVzIGEsIGIsIC4uLiwgei5cblx0ICovXG5cdHRoaXMubWFwQ29sdW1uc1RvVmFsdWVzID0gW107XG59XG5cbi8qKlxuICogUmVzZXRzIHRoZSBzdGF0ZSBvZiB0aGUgaW5zdGFuY2UgdG8gdGhlIGluaXRpYWwgb25lLlxuICovXG5JbnNlcnQucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMuaW5zZXJ0VGV4dCA9ICcnO1xuXHR0aGlzLnRhYmxlTmFtZSA9ICcnO1xuXHR0aGlzLmNvbHVtbnMgPSBbXTtcblx0dGhpcy5tYXBDb2x1bW5Ub0luZGV4ID0ge307XG5cdHRoaXMudmFsdWVzID0gW107XG5cdHRoaXMubWFwQ29sdW1uc1RvVmFsdWVzID0gW107XG5cdHRoaXMuY29uZmlnID0ge1xuXHRcdGlzVmFsaWQ6IGZhbHNlLFxuXHRcdHBhcmVudDogdGhpcy5jb25maWcucGFyZW50LFxuXHR9O1xufTtcblxuLyoqXG4gKiBPbmx5IGNoYW5nZWQsIHdoZW5ldmVyIGFuYWx5emUgaXMgaW52b2tlZC5cbiAqIFxuICogQHJldHVybnMgYm9vbFx0SW5kaWNhdGluZywgaWYgcHJldmlvdXMgc3RhdGVtZW50IHdhcyB2YWxpZC5cbiAqL1xuSW5zZXJ0LnByb3RvdHlwZS5pc1ZhbGlkID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLmNvbmZpZy5pc1ZhbGlkO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjYWNoZWQgaW5zZXJ0IHN0YXRlbWVudC5cbiAqIFxuICogQHJldHVybnNcdHN0cmluZ1x0XHRUaGUgY2FjaGVkIGluc2VydCBzdGF0ZW1lbnQuXG4gKi9cbkluc2VydC5wcm90b3R5cGUuZ2V0SW5zZXJ0U3RhdGVtZW50ID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLmluc2VydFRleHQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgdGhlIG5ldyBJTlNFUlQgSU5UTyBzdGF0ZW1lbnQuXG4gKiBTYXZlcyB0aGUgcmVzdWx0IGJhY2sgaW50byB0aGUgaW5zdGFuY2UuXG4gKiBcbiAqIEByZXR1cm5zXHRtaXhlZFx0XHRUaGUgbmV3IElOU0VSVCBzdGF0ZW1lbnQsIHVuZGVmaW5lZCBvbiBlcnJvci5cbiAqL1xuSW5zZXJ0LnByb3RvdHlwZS5hc3NlbWJsZSA9IGZ1bmN0aW9uKCkge1xuXHR0cnkge1xuXHRcdGxldCBuZXdGdWxsU3RhdGVtZW50ID0gJ0lOU0VSVCBJTlRPIGAnICsgdGhpcy50YWJsZU5hbWUgKyAnYCAoJztcblx0XHRcdG5ld0Z1bGxTdGF0ZW1lbnQgKz0gJ2AnICsgdGhpcy5jb2x1bW5zLmpvaW4oJ2AsIGAnKSArICdgKSBWQUxVRVMgXFxuJztcblxuXHRcdGxldCB2YWx1ZXMgPSBbXTtcblx0XHRsZXQgcm93cyA9IHRoaXMudmFsdWVzLmxlbmd0aDsgIC8vIHNlZSBjb21tZW50IG9mIHRoaXMudmFsdWVzIHdoeSB0aGlzIGlzIHVzZWQgZm9yIHJvd3Ncblx0XHRmb3IgKGxldCB2YWwgPSAwOyB2YWwgPCByb3dzOyArK3ZhbCkge1xuXHRcdFx0bGV0IHJvdyA9IFtdO1xuXHRcdFx0Zm9yIChsZXQgY29sID0gMDsgY29sIDwgdGhpcy5jb2x1bW5zLmxlbmd0aDsgKytjb2wpIHtcblx0XHRcdFx0cm93LnB1c2godGhpcy5tYXBDb2x1bW5zVG9WYWx1ZXNbIGNvbCBdWyB2YWwgXSk7XG5cdFx0XHR9XG5cblx0XHRcdHZhbHVlcy5wdXNoKCcoJyArIHJvdy5qb2luKCcsICcpICsgJyknKTtcblx0XHR9XG5cdFx0bmV3RnVsbFN0YXRlbWVudCArPSB2YWx1ZXMuam9pbignLCBcXG4nKSArICc7JztcblxuXHRcdHRoaXMuaW5zZXJ0VGV4dCA9IG5ld0Z1bGxTdGF0ZW1lbnQ7XG5cblx0XHRyZXR1cm4gbmV3RnVsbFN0YXRlbWVudC5zbGljZSgwKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHRoaXMuY29uZmlnLnBhcmVudC5ub3RpZnkoJ2RhbmdlcicsIGUpO1xuXHRcdGNvbnNvbGUuZXJyb3IoZSk7XG5cblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHR9XG59O1xuXG4vKipcbiAqIERpc21lbWJlcnMgYWxsIHRoZSBwYXJ0cyBvZiB0aGUgc3RhdGVtZW50LlxuICogQ3JlYXRlcyBpbmRleGVzIGFuZCBtYXBzLlxuICogXG4gKiBAcGFyYW1cdGluc2VydFRleHRcdFRoZSB0ZXh0IHRvIGFuYXl0ZSBhbmQgdGFrZSBhcGFydC5cbiAqIEByZXR1cm5zIGJvb2xcdFx0SWYgdHJ1ZSwgdmFsaWQgc3RhdGVtZW50LCBvdGhlcndpc2UgcmVzZXRzIHByZXZpb3VzIGRhdGEuXG4gKi9cbkluc2VydC5wcm90b3R5cGUuYW5hbHl6ZSA9IGZ1bmN0aW9uKGluc2VydFRleHQpIHtcblx0dGhpcy5pbnNlcnRUZXh0ID0gaW5zZXJ0VGV4dDtcblx0bGV0IHRleHQgPSBpbnNlcnRUZXh0O1xuXHRsZXQgcmVJbnNlcnQgPSAvSU5TRVJUXFxzSU5UT1xcc2AoLis/KWBcXHMrXFwoKC4rPylcXClcXHMrVkFMVUVTXFxzPyguKikvZ2ltcztcblxuXHRsZXQgbWF0Y2hlZCA9IHJlSW5zZXJ0LmV4ZWModGV4dCk7XG5cdGlmICghbWF0Y2hlZCkge1xuXHRcdHRoaXMucmVzZXQoKTtcblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGxldCB0b0luZm8gPSB1bmRlZmluZWQ7XG5cdHRyeSB7XG5cdFx0bGV0IHJlQ291bnRJbnNlcnQgPSAvSU5TRVJUXFxzSU5UT1xcc2AoLis/KWBcXHMrXFwoKC4rPylcXClcXHMrVkFMVUVTXFxzPy9naW1zO1xuXHRcdGxldCBjb3VudEluc2VydHMgPSB0ZXh0Lm1hdGNoKHJlQ291bnRJbnNlcnQpO1xuXHRcdGlmIChjb3VudEluc2VydHMgJiYgY291bnRJbnNlcnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgY291bnRJbnNlcnRzLmxlbmd0aC0xOyArK2kpIHtcblx0XHRcdFx0aWYgKGNvdW50SW5zZXJ0c1tpXS50cmltKCkgIT0gY291bnRJbnNlcnRzW2krMV0udHJpbSgpKSB7XG5cdFx0XHRcdFx0dGhyb3coJ011bHRpcGxlIGluY29tcGF0aWJsZSBJTlNFUlQgc3RhdGVtZW50cyBmb3VuZC4nKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvdW50SW5zZXJ0cyA9IFtdOyAgLy8gdGhpcyB3YXkgd2UgY2FuIHVzZSAubGVuZ3RoIGVpdGhlciB3YXlcblx0XHR9XG5cblx0XHQvLyBnZXQgcGFydHNcblx0XHRsZXQgWyAsIHRhYmxlLCBjb2x1bW5zLCB2YWx1ZXMgXSA9IFsgLi4ubWF0Y2hlZCBdO1xuXHRcdHRoaXMudGFibGVOYW1lID0gdGFibGU7XG5cblx0XHQvLyBDb2x1bW5zXG5cdFx0Y29sdW1ucyA9IGNvbHVtbnMuc3BsaXQoJywnKTtcblx0XHR0aGlzLm1hcENvbHVtblRvSW5kZXggPSB7fTtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGNvbHVtbnMubGVuZ3RoOyArK2kpIHtcblx0XHRcdGNvbHVtbnNbIGkgXSA9IGNvbHVtbnNbIGkgXS50cmltKCkucmVwbGFjZSgvYC9nLCAnJykudHJpbSgpO1xuXG5cdFx0XHR0aGlzLm1hcENvbHVtblRvSW5kZXhbIGNvbHVtbnNbIGkgXSBdID0gaTtcblx0XHR9XG5cdFx0dGhpcy5jb2x1bW5zID0gY29sdW1ucztcblxuXHRcdC8vIFZhbHVlc1xuXHRcdC8vIFJlbW92ZSBtdWx0aXBsZSBpbnNlcnRzXG5cdFx0aWYgKGNvdW50SW5zZXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0XHR2YWx1ZXMgPSB2YWx1ZXMuc3BsaXQoY291bnRJbnNlcnRzWzBdKS5qb2luKCcnKTtcblxuXHRcdFx0Ly8gZGVsYXkgdGhlIGluZm8sIGluIGNhc2UgbWlzbWF0Y2hlZCB2YWx1ZSBjb3VudCB0cmlnZ2VycyBleGNlcHRpb25cblx0XHRcdC8vIGlmIHRoZXJlJ3MgYSBMT1Qgb2YgdGV4dCB0byBwYXJzZSwgdGFraW5nIGxvbmdlciB0aGFuIH5YWW1zIGl0J3Mgb2theSB0byBmaXJzdCBkaXNwbGF5IHRoZSBpbmZvXG5cdFx0XHR0b0luZm8gPSBzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdFx0dGhpcy5jb25maWcucGFyZW50Lm5vdGlmeSgnaW5mbycsICdEdXBsaWNhdGUgSU5TRVJUXFwncyBkZXRlY3RlZCcsICdUaGV5IHdpbGwgYmUgaWdub3JlZC9yZW1vdmVkIG9uIGNoYW5nZS4nKTtcblx0XHRcdH0sIDUwMCk7XG5cdFx0fVxuXHRcdC8vIFJlbW92ZSBsZWFkaW5nIGFuZCBjbG9zaW5nIGJyYWNrZXRzXG5cdFx0dmFsdWVzID0gdmFsdWVzLnRyaW0oKTtcblxuXHRcdGxldCBmb3VuZFR1cGxlcyA9IFtdLFxuXHRcdFx0b3BlblR1cGxlID0gZmFsc2U7XG5cblx0XHRsZXQgY3VyVmFsID0gJycsXG5cdFx0XHRmb3VuZFZhbHVlcyA9IFtdLFxuXHRcdFx0b3BlblZhbHVlID0gZmFsc2U7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcblx0XHRcdGlmICggKCFvcGVuVHVwbGUgJiYgIW9wZW5WYWx1ZSAmJiB2YWx1ZXNbaV0gPT0gJzsnKSB8fCAoIW9wZW5UdXBsZSAmJiAodmFsdWVzW2ldID09PSAnLCcgfHwgdmFsdWVzW2ldLm1hdGNoKC9cXHMvcykpKSB8fCAob3BlblR1cGxlICYmIG9wZW5WYWx1ZSA9PT0gZmFsc2UgJiYgKHZhbHVlc1tpXSA9PT0gJywnIHx8IHZhbHVlc1tpXS5tYXRjaCgvXFxzL3MpKSkgKSB7XG5cdFx0XHRcdGNvbnRpbnVlOyAgLy8gc2tpcCBjb21tYSBhbmQgd2hpdGVzcGFjZSBiZXR3ZWVuIHR1cGxlc1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBvcGVuaW5nIGJyYWNrZXQgb2YgbmV3IHR1cGxlXG5cdFx0XHRpZiAoIW9wZW5UdXBsZSAmJiB2YWx1ZXNbaV0gPT09ICcoJykge1xuXHRcdFx0XHRvcGVuVHVwbGUgPSB0cnVlO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdC8vIGNsb3NpbmcgYnJhY2tldCBvZiBjdXJyZW50IHR1cGxlLCB3aGlsZSBubyBvcGVuIHZhbHVlIG9yIG9wZW4gdmFsdWUgd2FzIGVtcHR5XG5cdFx0XHRpZiAob3BlblR1cGxlICYmIChvcGVuVmFsdWUgPT09IGZhbHNlIHx8IG9wZW5WYWx1ZSA9PT0gJycpICYmIHZhbHVlc1tpXSA9PT0gJyknKSB7XG5cdFx0XHRcdGlmIChvcGVuVmFsdWUgPT09ICcnKSB7ICAvLyBpbnQgb3IgbnVsbCBhcyBhIHZhbHVlIGF0IHRoZSBlbmRcblx0XHRcdFx0XHRmb3VuZFZhbHVlcy5wdXNoKGN1clZhbCk7XG5cdFx0XHRcdFx0Y3VyVmFsID0gJyc7XG5cdFx0XHRcdFx0b3BlblZhbHVlID0gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRvcGVuVHVwbGUgPSBmYWxzZTtcblx0XHRcdFx0Zm91bmRUdXBsZXMucHVzaChmb3VuZFZhbHVlcy5zbGljZSgwKSk7XG5cdFx0XHRcdGZvdW5kVmFsdWVzLmxlbmd0aCA9IDA7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBjdXJyZW50bHkgb3BlbiB2YWx1ZSBhbmQgdGhlIG5leHQgY2hhciBpcyBhIGNsb3NpbmcgY2hhciB0aGUgc2FtZSBhcyBpdCB3YXMgb3BlbmVkIC0gYnV0IG5vdCBlc2NhcGVkXG5cdFx0XHQvLyBvciB0aGVyZSB3YXMgbm8gJ1wiYCBhcyBiZWdpbm5pbmcgdGhlbiBjb21tYSBpcyB0aGUgc2VwYXJhdG9yXG5cdFx0XHRpZiAob3BlblR1cGxlICYmIG9wZW5WYWx1ZSAhPT0gZmFsc2UgJiYgKCh2YWx1ZXNbaV0gPT09IG9wZW5WYWx1ZSAmJiB2YWx1ZXNbaS0xXSAhPT0gJ1xcXFwnKSB8fCAodmFsdWVzW2ldID09PSAnLCcgJiYgb3BlblZhbHVlID09PSAnJykgKSkge1xuXHRcdFx0XHRpZiAob3BlblZhbHVlICE9PSAnJykge1xuXHRcdFx0XHRcdGN1clZhbCArPSB2YWx1ZXNbaV07XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm91bmRWYWx1ZXMucHVzaChjdXJWYWwudHJpbSgpKTtcblx0XHRcdFx0Y3VyVmFsID0gJyc7XG5cdFx0XHRcdG9wZW5WYWx1ZSA9IGZhbHNlO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdGlmIChvcGVuVHVwbGUgJiYgb3BlblZhbHVlID09PSBmYWxzZSAmJiAodmFsdWVzW2ldID09PSBcIidcIiB8fCB2YWx1ZXNbaV0gPT09ICdcIicgfHwgdmFsdWVzW2ldID09PSAnYCcpKSB7XG5cdFx0XHRcdG9wZW5WYWx1ZSA9IHZhbHVlc1tpXTtcblx0XHRcdFx0Y3VyVmFsICs9IHZhbHVlc1tpXTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAob3BlblZhbHVlID09PSBmYWxzZSkge1xuXHRcdFx0XHRvcGVuVmFsdWUgPSAnJztcblx0XHRcdH1cblxuXHRcdFx0Y3VyVmFsICs9IHZhbHVlc1tpXTtcblx0XHR9XG5cblx0XHR0aGlzLm1hcENvbHVtbnNUb1ZhbHVlcyA9IFtdO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgZm91bmRUdXBsZXMubGVuZ3RoOyArK2kpIHtcblx0XHRcdGlmIChmb3VuZFR1cGxlc1tpXS5sZW5ndGggIT09IGNvbHVtbnMubGVuZ3RoKSB7XG5cdFx0XHRcdHRocm93KGBGb3VuZCAkeyBmb3VuZFR1cGxlc1tpXS5sZW5ndGggfSB2YWx1ZXMgaW4gcm93ICR7IGkrMSB9LCAkeyBjb2x1bW5zLmxlbmd0aCB9IHZhbHVlcyBleHBlY3RlZCwgYWJvcnQhYCk7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgZm91bmRUdXBsZXNbIGkgXS5sZW5ndGg7ICsraikge1xuXHRcdFx0XHRsZXQgY29sSW5kZXggPSB0aGlzLm1hcENvbHVtblRvSW5kZXhbIGNvbHVtbnNbIGogXSBdO1xuXG5cdFx0XHRcdGlmICh0eXBlb2YodGhpcy5tYXBDb2x1bW5zVG9WYWx1ZXNbIGNvbEluZGV4IF0pID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRcdHRoaXMubWFwQ29sdW1uc1RvVmFsdWVzWyBjb2xJbmRleCBdID0gW107XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLm1hcENvbHVtbnNUb1ZhbHVlc1sgY29sSW5kZXggXS5wdXNoKGZvdW5kVHVwbGVzWyBpIF1bIGogXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMudmFsdWVzID0gZm91bmRUdXBsZXM7XG5cblx0XHR0aGlzLmNvbmZpZy5pc1ZhbGlkID0gdHJ1ZTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGNsZWFyVGltZW91dCh0b0luZm8pO1xuXHRcdHRoaXMuY29uZmlnLnBhcmVudC5ub3RpZnkoJ2RhbmdlcicsIGUpO1xuXHRcdGNvbnNvbGUuZXJyb3IoZSk7XG5cdFx0dGhpcy5yZXNldCgpO1xuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIHRhcmdldCB0YWJsZSBuYW1lLlxuICogXG4gKiBAcmV0dXJuc1x0c3RyaW5nXHRUaGUgbmFtZSBvZiB0aGUgdGFibGUgdGhlIHF1ZXJ5IGhhcyBhcyBhIHRhcmdldC5cbiAqL1xuSW5zZXJ0LnByb3RvdHlwZS5nZXRUYWJsZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy50YWJsZU5hbWU7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGF2YWlsYWJsZSBjb2x1bW5zLCBzb3J0ZWQgYXNjZW5kaW5nLlxuICogXG4gKiBAcmV0dXJuc1x0QXJyYXlcdEEgc29ydGVkIEFycmF5IG9mIGNvbHVtbnMsIGVtcHR5IGlmIG5vdCB5ZXQgc2V0LlxuICovXG5JbnNlcnQucHJvdG90eXBlLmdldENvbHVtbnMgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuY29sdW1ucy5zbGljZSgwKS5zb3J0KChhLCBiKSA9PiBhLnRvTG9jYWxlTG93ZXJDYXNlKCkubG9jYWxlQ29tcGFyZShiLnRvTG9jYWxlTG93ZXJDYXNlKCkpKTtcbn07XG5cbi8qKlxuICogXG4gKiBAcGFyYW1cdHN0cmluZ1x0Y29sdW1uXHROYW1lIG9mIHRoZSBjb2x1bW4gdG8gZ2V0IGFsbCB0aGUgdmFsdWVzIG9mLlxuICogQHJldHVybnMgQXJyYXlcdFx0XHRBbiBhcnJheSBvZiB2YWx1ZXMsIGNhbiBiZSBlbXB0eSwgaWYgaW52YWxpZCBjb2x1bW4gcmVxdWVzdGVkLlxuICovXG5JbnNlcnQucHJvdG90eXBlLmdldFZhbHVlc0J5Q29sdW1uID0gZnVuY3Rpb24oY29sdW1uKSB7XG5cdGxldCBjb2xJbmRleCA9IHRoaXMubWFwQ29sdW1uVG9JbmRleFsgY29sdW1uIF07XG5cblx0aWYgKGNvbEluZGV4ID09PSB1bmRlZmluZWQgfHwgdGhpcy5tYXBDb2x1bW5zVG9WYWx1ZXNbIGNvbEluZGV4IF0gPT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBbXTtcblx0fVxuXG5cdGxldCB2YWx1ZXMgPSBbXTtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1hcENvbHVtbnNUb1ZhbHVlc1sgY29sSW5kZXggXS5sZW5ndGg7ICsraSkge1xuXHRcdHZhbHVlcy5wdXNoKHRoaXMubWFwQ29sdW1uc1RvVmFsdWVzWyBjb2xJbmRleCBdWyBpIF0pO1xuXHR9XG5cblx0cmV0dXJuIHZhbHVlcztcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhbiBlbnRpcmUgY29sdW1uLCBpbmNsdWRpbmcgdGhlaXIgdmFsdWVzLlxuICogXG4gKiBAcGFyYW1cdHN0cmluZ1x0Y29sdW1uXHROYW1lIG9mIHRoZSBjb2x1bW4gdG8gcmVtb3ZlLlxuICogQHJldHVybnMgbWl4ZWRcdFx0XHRCb29sZWFuIGZhbHNlIG9uIGVycm9yLCBBcnJheSB3aXRoIHRoZSBuZXcgY29sdW1ucyBvbiBzdWNjZXNzLlxuICovXG5JbnNlcnQucHJvdG90eXBlLnJlbW92ZUNvbHVtbiA9IGZ1bmN0aW9uKGNvbHVtbikge1xuXHR0cnkge1xuXHRcdGxldCBjb2xJbmRleCA9IHRoaXMubWFwQ29sdW1uVG9JbmRleFsgY29sdW1uIF07XG5cblx0XHRpZiAoY29sSW5kZXggPT09IHVuZGVmaW5lZCB8fCB0aGlzLm1hcENvbHVtbnNUb1ZhbHVlc1sgY29sSW5kZXggXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0bGV0IG5ld0NvbHVtbnMgPSB0aGlzLmNvbHVtbnMuc2xpY2UoMCk7XG5cdFx0XHRuZXdDb2x1bW5zLnNwbGljZShjb2xJbmRleCwgMSk7XG5cdFx0bGV0IG5ld01hcENvbHVtblRvSW5kZXggPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm1hcENvbHVtblRvSW5kZXgpO1xuXG5cdFx0Ly8gVXBkYXRlIGluZGV4IGZvciBjb2x1bW5OYW1lIC0+IGluZGV4LWluLXZhbHVlc1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbmV3Q29sdW1ucy5sZW5ndGg7ICsraSkge1xuXHRcdFx0aWYgKG5ld01hcENvbHVtblRvSW5kZXhbIG5ld0NvbHVtbnNbaV0gXSA8IGNvbEluZGV4KSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRuZXdNYXBDb2x1bW5Ub0luZGV4WyBuZXdDb2x1bW5zW2ldIF0gPSBuZXdNYXBDb2x1bW5Ub0luZGV4WyBuZXdDb2x1bW5zW2ldIF0gLSAxO1xuXHRcdH1cblxuXHRcdGxldCBuZXdWYWx1ZXMgPSB0aGlzLnZhbHVlcy5zbGljZSgwKTtcblx0XHQvLyByZW1vdmUgdGhlIGNvbHVtbiBmcm9tIGVhY2ggcm93XG5cdFx0Zm9yIChsZXQgcm93ID0gMDsgcm93IDwgbmV3VmFsdWVzLmxlbmd0aDsgKytyb3cpIHtcblx0XHRcdG5ld1ZhbHVlc1sgcm93IF0uc3BsaWNlKGNvbEluZGV4LCAxKTtcblx0XHR9XG5cblx0XHRkZWxldGUgdGhpcy5tYXBDb2x1bW5Ub0luZGV4WyBjb2x1bW4gXTtcblx0XHR0aGlzLm1hcENvbHVtbnNUb1ZhbHVlcy5zcGxpY2UoY29sSW5kZXgsIDEpO1xuXG5cdFx0dGhpcy52YWx1ZXMgPSBuZXdWYWx1ZXM7XG5cdFx0dGhpcy5jb2x1bW5zID0gbmV3Q29sdW1ucztcblx0XHR0aGlzLm1hcENvbHVtblRvSW5kZXggPSBuZXdNYXBDb2x1bW5Ub0luZGV4O1xuXG5cdFx0cmV0dXJuIHRoaXMuY29sdW1ucy5zbGljZSgwKS5zb3J0KCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHR0aGlzLmNvbmZpZy5wYXJlbnQubm90aWZ5KCdkYW5nZXInLCBlKTtcblx0XHRjb25zb2xlLmVycm9yKGUpO1xuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59O1xuXG5cbi8qKlxuICogXG4gKiBAcGFyYW1cdHN0cmluZ1x0Y29sdW1uXHRUaGUgbmFtZSBvZiB0aGUgY29sdW1uIHRvIHVwZGF0ZSBhIHZhbHVlIG9mLlxuICogQHBhcmFtXHRpbnRcdFx0cm93XHRcdFRoZSByb3cgb2YgdGhlIHZhbHVlIHRvIHVwZGF0ZSwgMCBiYXNlZCFcbiAqIEBwYXJhbVx0bWl4ZWRcdHZhbHVlXHRUaGUgbmV3IHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zXHRib29sXHRcdFx0VHJ1ZSBvbiBzdWNjZXNzLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbkluc2VydC5wcm90b3R5cGUudXBkYXRlVmFsdWUgPSBmdW5jdGlvbihjb2x1bW4sIHJvdywgdmFsdWUpIHtcblx0dHJ5IHtcblx0XHRsZXQgY29sSW5kZXggPSB0aGlzLm1hcENvbHVtblRvSW5kZXhbY29sdW1uXTtcblx0XHRpZiAoY29sSW5kZXggPT09IHVuZGVmaW5lZCB8fCB0aGlzLm1hcENvbHVtbnNUb1ZhbHVlc1sgY29sSW5kZXggXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0bGV0IG5ld1ZhbHVlID0gdmFsdWUvKi5yZXBsYWNlKC9eKGB8J3xcIil8KGB8J3xcIikkL2csICcnKSovLnRyaW0oKTtcblx0XHQvLyBVcGRhdGUgdGhlIHZhbHVlXG5cdFx0dGhpcy52YWx1ZXNbIHJvdyBdWyBjb2xJbmRleCBdID0gbmV3VmFsdWU7XG5cdFx0Ly8gVXBkYXRlIHRoZSBtYXAgb2YgY29sdW1YID0+IFsgdmFsdWUxLCB2YWx1ZTIgXVxuXHRcdHRoaXMubWFwQ29sdW1uc1RvVmFsdWVzWyBjb2xJbmRleCBdWyByb3cgXSA9IG5ld1ZhbHVlO1xuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHR0aGlzLmNvbmZpZy5wYXJlbnQubm90aWZ5KCdkYW5nZXInLCBlKTtcblx0XHRjb25zb2xlLmVycm9yKGUpO1xuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59O1xuXG4vKipcbiAqIFNpbWlsYXIgdG8gYHVwZGF0ZVZhbHVlYCBvbmx5IGZvciBhbGwgdmFsdWVzIG9mIGEgc3BlY2lmaWMgY29sdW1uLlxuICogXG4gKiBAcGFyYW1cdHN0cmluZ1x0Y29sdW1uXHROYW1lIG9mIHRoZSBjb2x1bW4gdG8gdXBkYXRlIHZhbHVlcyBvZi5cbiAqIEBwYXJhbVx0QXJyYXlcdHZhbHVlc1x0QW4gYXJyYXkgb2YgbmV3IHZhbHVlcyBmb3IgdGhlIGNvbHVtbi5cbiAqIEByZXR1cm5zXHRib29sXHRcdFx0VHJ1ZSBvbiBzdWNjZXNzLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbkluc2VydC5wcm90b3R5cGUudXBkYXRlVmFsdWVzID0gZnVuY3Rpb24oY29sdW1uLCB2YWx1ZXMpIHtcblx0dHJ5IHtcblx0XHRsZXQgY29sSW5kZXggPSB0aGlzLm1hcENvbHVtblRvSW5kZXhbIGNvbHVtbiBdO1xuXHRcdGlmIChjb2xJbmRleCA9PT0gdW5kZWZpbmVkIHx8IHRoaXMubWFwQ29sdW1uc1RvVmFsdWVzWyBjb2xJbmRleCBdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBDaGVjayBmb3IgY29ycmVjdCBjb3VudCBvZiB2YWx1ZXNcblx0XHRsZXQgcm93cyA9IHZhbHVlcy5sZW5ndGg7XG5cdFx0aWYgKHRoaXMudmFsdWVzLmxlbmd0aCAhPT0gcm93cykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcm93czsgKytpKSB7XG5cdFx0XHRsZXQgbmV3VmFsdWUgPSB2YWx1ZXNbIGkgXS50cmltKCk7XG5cblx0XHRcdC8vIFVwZGF0ZSB0aGUgdmFsdWVcblx0XHRcdHRoaXMudmFsdWVzWyBpIF1bIGNvbEluZGV4IF0gPSBuZXdWYWx1ZTtcblx0XHRcdC8vIFVwZGF0ZSB0aGUgbWFwIG9mIGNvbHVtWCA9PiBbIHZhbHVlMSwgdmFsdWUyIF1cblx0XHRcdHRoaXMubWFwQ29sdW1uc1RvVmFsdWVzWyBjb2xJbmRleCBdWyBpIF0gPSBuZXdWYWx1ZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHRoaXMuY29uZmlnLnBhcmVudC5ub3RpZnkoJ2RhbmdlcicsIGUpO1xuXHRcdGNvbnNvbGUuZXJyb3IoZSk7XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgY29sdW1uIG5hbWUgd2l0aGluIGEgdmFsdWVzIHBvc2l0aW9uLlxuICogXG4gKiBAcGFyYW1cdGludFx0XHRwb3NpdGlvblx0XHRUaGUgcG9zaXRpb24gd2l0aGluIHRoZSBzdHJpbmcuXG4gKiBAcGFyYW1cdHN0cmluZ1x0dmFsdWVTdHJpbmdcdFx0VGhlIHN0cmluZyB0byBhbmFseXplLiBcbiAqIEByZXR1cm5zXHRtaXhlZFx0XHRcdFx0XHRCb29sZWFuIGZhbHNlIG9uIGVycm9yLCBpZSBjb2x1bW4gaXMgaW52YWxpZCwgdGhlIGNvbHVtbiBuYW1lIGFzIGEgc3RyaW5nIG90aGVyd2lzZS5cbiAqL1xuSW5zZXJ0LnByb3RvdHlwZS5nZXRDb2x1bW5BdFBvc2l0aW9uID0gZnVuY3Rpb24ocG9zaXRpb24sIHZhbHVlU3RyaW5nKSB7XG5cdHRyeSB7XG5cblx0XHRsZXQgb3BlblR1cGxlID0gZmFsc2UsXG5cdFx0XHRvcGVuVmFsdWUgPSBmYWxzZSxcblx0XHRcdHZhbHVlSW5kZXggPSAtMTtcblxuXHRcdGxldCBzdHIgPSB2YWx1ZVN0cmluZy50cmltKCkucmVwbGFjZSgvKDt8LCkkLywgJycpO1xuXHRcdC8vIGVuZCBvZiBiZWdpbm5pbmcgb2Ygc3RyaW5nIC0gbm8gY29sdW1ucyBhdmFpbGFibGVcblx0XHRpZiAocG9zaXRpb24gPj0gc3RyLmxlbmd0aCB8fCBwb3NpdGlvbiA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IHN0ci5sZW5ndGg7ICsrcG9zKSB7XG5cdFx0XHRpZiAoICghb3BlblR1cGxlICYmIChzdHJbcG9zXSA9PT0gJywnIHx8IHN0cltwb3NdLm1hdGNoKC9cXHMvcykpKSB8fCAob3BlblR1cGxlICYmIG9wZW5WYWx1ZSA9PT0gZmFsc2UgJiYgKHN0cltwb3NdID09PSAnLCcgfHwgc3RyW3Bvc10ubWF0Y2goL1xccy9zKSkpICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gb3BlbmluZyBicmFja2V0IG9mIG5ldyB0dXBsZVxuXHRcdFx0aWYgKCFvcGVuVHVwbGUgJiYgc3RyW3Bvc10gPT09ICcoJykge1xuXHRcdFx0XHRvcGVuVHVwbGUgPSB0cnVlO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdC8vIGNsb3NpbmcgYnJhY2tldCBvZiBjdXJyZW50IHR1cGxlLCB3aGlsZSBubyBvcGVuIHZhbHVlIG9yIG9wZW4gdmFsdWUgd2FzIGVtcHR5XG5cdFx0XHRpZiAob3BlblR1cGxlICYmIChvcGVuVmFsdWUgPT09IGZhbHNlIHx8IG9wZW5WYWx1ZSA9PT0gJycpICYmIHN0cltwb3NdID09PSAnKScpIHtcblx0XHRcdFx0aWYgKG9wZW5WYWx1ZSA9PT0gJycpIHsgIC8vIGludCBvciBudWxsIGFzIGEgdmFsdWUgYXQgdGhlIGVuZFxuXHRcdFx0XHRcdG9wZW5WYWx1ZSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG9wZW5UdXBsZSA9IGZhbHNlO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gY3VycmVudGx5IG9wZW4gdmFsdWUgYW5kIHRoZSBuZXh0IGNoYXIgaXMgYSBjbG9zaW5nIGNoYXIgdGhlIHNhbWUgYXMgaXQgd2FzIG9wZW5lZCAtIGJ1dCBub3QgZXNjYXBlZFxuXHRcdFx0Ly8gb3IgdGhlcmUgd2FzIG5vICdcImAgYXMgYmVnaW5uaW5nIHRoZW4gY29tbWEgaXMgdGhlIHNlcGFyYXRvclxuXHRcdFx0aWYgKG9wZW5UdXBsZSAmJiBvcGVuVmFsdWUgIT09IGZhbHNlICYmICgoc3RyW3Bvc10gPT09IG9wZW5WYWx1ZSAmJiBzdHJbcG9zLTFdICE9PSAnXFxcXCcpIHx8IChzdHJbcG9zXSA9PT0gJywnICYmIG9wZW5WYWx1ZSA9PT0gJycpICkpIHtcblx0XHRcdFx0b3BlblZhbHVlID0gZmFsc2U7XG5cdFx0XHRcdGlmIChwb3MgPj0gcG9zaXRpb24pIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9wZW5UdXBsZSAmJiBvcGVuVmFsdWUgPT09IGZhbHNlICYmIChzdHJbcG9zXSA9PT0gXCInXCIgfHwgc3RyW3Bvc10gPT09ICdcIicgfHwgc3RyW3Bvc10gPT09ICdgJykpIHtcblx0XHRcdFx0Kyt2YWx1ZUluZGV4O1xuXHRcdFx0XHRvcGVuVmFsdWUgPSBzdHJbcG9zXTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAob3BlblZhbHVlID09PSBmYWxzZSkge1xuXHRcdFx0XHQrK3ZhbHVlSW5kZXg7XG5cdFx0XHRcdG9wZW5WYWx1ZSA9ICcnO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTcGVjaWZpY2FsbHkgY2hlY2sgYXQgZW5kLCBzbyBcIigzXCIgd2l0aCBjdXJzb3IgYmVmb3JlIDMgd2lsbCBoYXZlIDMgY2hlY2tlZCBhcyBvcGVuVmFsdWUgPSAnJyAtPiArK3ZhbHVlSW5kZXhcblx0XHRcdGlmIChwb3MgPj0gcG9zaXRpb24pIHtcblx0XHRcdFx0aWYgKCFvcGVuVHVwbGUgfHwgb3BlblZhbHVlID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdHZhbHVlSW5kZXggPSAtMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodHlwZW9mKHRoaXMuY29sdW1uc1t2YWx1ZUluZGV4XSkgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jb2x1bW5zW3ZhbHVlSW5kZXhdO1xuXHRcdH1cblxuXHRcdHRocm93KFwiSW52YWxpZCBjb2x1bW5cIik7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG5cbi8qKlxuICogQWRkcyBhIG5ldyBjb2x1bW4uXG4gKiBcbiAqIEBwYXJhbVx0c3RyaW5nXHRjb2x1bW5OYW1lXHRUaGUgbmV3IGNvbHVtbiBuYW1lIHRvIGFkZC5cbiAqIEBwYXJhbVx0bWl4ZWRcdHZhbHVlXHRcdE9wdGlvbmFsIG5ldyB2YWx1ZSwgZGVmYXVsdCBpcyBlbXB0eSBzdHJpbmcuXG4gKiBAcmV0dXJuc1x0Ym9vbFx0XHRcdFx0QSBib29sZWFuIGluZGljYXRpbmcgc3VjY2Vzcy5cbiAqL1xuSW5zZXJ0LnByb3RvdHlwZS5hZGRDb2x1bW4gPSBmdW5jdGlvbihjb2x1bW5OYW1lLCB2YWx1ZSA9IFwiJydcIikge1xuXHR0cnkge1xuXHRcdHRoaXMuY29sdW1ucy5wdXNoKGNvbHVtbk5hbWUpO1xuXHRcdHRoaXMubWFwQ29sdW1uVG9JbmRleFtjb2x1bW5OYW1lXSA9IHRoaXMuY29sdW1ucy5sZW5ndGgtMTtcblxuXHRcdHRoaXMubWFwQ29sdW1uc1RvVmFsdWVzLnB1c2goW10pO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52YWx1ZXMubGVuZ3RoOyArK2kpIHtcblx0XHRcdHRoaXMudmFsdWVzWyB0aGlzLm1hcENvbHVtblRvSW5kZXhbY29sdW1uTmFtZV0gXS5wdXNoKHZhbHVlKTtcblx0XHRcdHRoaXMubWFwQ29sdW1uc1RvVmFsdWVzWyB0aGlzLm1hcENvbHVtblRvSW5kZXhbY29sdW1uTmFtZV0gXS5wdXNoKHZhbHVlKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHRoaXMuY29uZmlnLnBhcmVudC5ub3RpZnkoJ2RhbmdlcicsIGUpO1xuXHRcdGNvbnNvbGUuZXJyb3IoZSk7XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTW9kYWwoY29uZmlnKSB7XG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBNb2RhbCkpIHtcblx0XHRyZXR1cm4gbmV3IE1vZGFsKGNvbmZpZyk7XG5cdH1cblxuXHR0aGlzLmNvbmZpZyA9IHtcblx0XHQuLi57XG5cdFx0XHRvcGVuOiBmYWxzZSxcblx0XHRcdHRlbXBsYXRlOiB1bmRlZmluZWQsXG5cdFx0XHRhY3RpdmVQcm9taXNlOiB1bmRlZmluZWQsXG5cblx0XHRcdGRvbU1vZGFsOiB1bmRlZmluZWQsXG5cdFx0XHRkb21CYWNrZHJvcDogdW5kZWZpbmVkLFxuXHRcdFx0ZG9tQ29udGVudDogdW5kZWZpbmVkLFxuXHRcdFx0YnRuQWJvcnQ6IHVuZGVmaW5lZCxcblx0XHRcdGJ0bkNvbmZpcm06IHVuZGVmaW5lZCxcblxuXHRcdFx0b25Db25maXJtOiAoKSA9PiB0cnVlLFxuXHRcdFx0b25BYm9ydDogKCkgPT4gdHJ1ZSxcblx0XHRcdG9uU2hvdzogKCkgPT4geyB0aGlzLmNvbmZpZy5idG5Db25maXJtLmZvY3VzKCk7IH0sXG5cdFx0XHRvblJlc29sdmU6IHJlc3AgPT4gcmVzcCxcblx0XHR9LFxuXHRcdC4uLmNvbmZpZ1xuXHR9O1xuXG5cdHRyeSB7XG5cdFx0bGV0IF9kaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHRsZXQgbW9kYWxIVE1MID0gdGhpcy5jb25maWcudGVtcGxhdGUuaW5uZXJIVE1MLnNsaWNlKDApO1xuXHRcdFx0X2Rpdi5pbm5lckhUTUwgPSBtb2RhbEhUTUw7XG5cdFx0dGhpcy5jb25maWcuZG9tTW9kYWwgPSBfZGl2LmZpcnN0RWxlbWVudENoaWxkO1xuXG5cdFx0dGhpcy5jb25maWcuZG9tQmFja2Ryb3AgPSB0aGlzLmNvbmZpZy5kb21Nb2RhbC5xdWVyeVNlbGVjdG9yKCcubW9kYWwtYmFja2Ryb3AnKTtcblx0XHR0aGlzLmNvbmZpZy5kb21Db250ZW50ID0gdGhpcy5jb25maWcuZG9tTW9kYWwucXVlcnlTZWxlY3RvcignLm1vZGFsLWNvbnRlbnQnKTtcblxuXHRcdHRoaXMuY29uZmlnLmRvbUJhY2tkcm9wLmNsYXNzTGlzdC5hZGQoJ2Vhc2Utb3V0JywgJ2R1cmF0aW9uLTMwMCcsICdvcGFjaXR5LTAnLCAncG9pbnRlci1ldmVudHMtbm9uZScpO1xuXHRcdHRoaXMuY29uZmlnLmRvbUNvbnRlbnQuY2xhc3NMaXN0LmFkZCgnb3BhY2l0eS0wJywgJ3RyYW5zbGF0ZS15LTQnLCAnc206dHJhbnNsYXRlLXktMCcsICdzbTpzY2FsZS05NScpO1xuXG5cdFx0ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmNvbmZpZy5kb21Nb2RhbCk7XG5cdFx0ZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIGUgPT4ge1xuXHRcdFx0aWYgKCF0aGlzLmNvbmZpZy5vcGVuKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGUua2V5ID09PSAnRW50ZXInIHx8IGUua2V5ID09PSAnRXNjYXBlJykge1xuXHRcdFx0XHR0aGlzLmhpZGUoZS5rZXkgPT09ICdFbnRlcicpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dGhpcy5jb25maWcuYnRuQ29uZmlybSA9IHRoaXMuY29uZmlnLmRvbU1vZGFsLnF1ZXJ5U2VsZWN0b3IoJy5qcy1jb25maXJtJyk7XG5cdFx0dGhpcy5jb25maWcuYnRuQ29uZmlybS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGUgPT4ge1xuXHRcdFx0aWYgKCF0aGlzLmNvbmZpZy5vcGVuKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCF0aGlzLmNvbmZpZy5vbkNvbmZpcm0oKSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmhpZGUodHJ1ZSk7XG5cdFx0fSk7XG5cdFx0dGhpcy5jb25maWcuYnRuQWJvcnQgPSB0aGlzLmNvbmZpZy5kb21Nb2RhbC5xdWVyeVNlbGVjdG9yKCcuanMtYWJvcnQnKTtcblx0XHR0aGlzLmNvbmZpZy5idG5BYm9ydC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGUgPT4ge1xuXHRcdFx0aWYgKCF0aGlzLmNvbmZpZy5vbkFib3J0KCkpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmhpZGUoZmFsc2UpO1xuXHRcdH0pO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Y29uc29sZS5sb2coZSk7XG5cdH1cbn1cblxuTW9kYWwucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHRpZiAodGhpcy5jb25maWcub3Blbikge1xuXHRcdFx0cmV0dXJuIFxuXHRcdH1cblxuXHRcdHRoaXMuY29uZmlnLmRvbU1vZGFsLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpO1xuXHRcdHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0dGhpcy5jb25maWcuZG9tQmFja2Ryb3AuY2xhc3NMaXN0LnJlbW92ZSgnZWFzZS1pbicsICdkdXJhdGlvbi0yMDAnLCAnb3BhY2l0eS0wJyk7XG5cdFx0XHR0aGlzLmNvbmZpZy5kb21CYWNrZHJvcC5jbGFzc0xpc3QuYWRkKCdlYXNlLW91dCcsICdkdXJhdGlvbi0zMDAnLCAnb3BhY2l0eS0xMDAnKTtcblxuXHRcdFx0dGhpcy5jb25maWcuZG9tQ29udGVudC5jbGFzc0xpc3QucmVtb3ZlKCdlYXNlLWluJywgJ2R1cmF0aW9uLTIwMCcsICdvcGFjaXR5LTAnLCAndHJhbnNsYXRlLXktNCcsICdzbTp0cmFuc2xhdGUteS0wJywgJ3NtOnNjYWxlLTk1Jyk7XG5cdFx0XHR0aGlzLmNvbmZpZy5kb21Db250ZW50LmNsYXNzTGlzdC5hZGQoJ2Vhc2Utb3V0JywgJ2R1cmF0aW9uLTMwMCcsICdvcGFjaXR5LTEwMCcsICd0cmFuc2xhdGUteS0wJywgJ3NtOnNjYWxlLTEwMCcpO1xuXHRcdH0sIDI1KTtcblxuXHRcdHRoaXMuY29uZmlnLm9wZW4gPSB0cnVlO1xuXHRcdHRoaXMuY29uZmlnLmFjdGl2ZVByb21pc2UgPSByZXNvbHZlO1xuXHRcdHRoaXMuY29uZmlnLm9uU2hvdygpO1xuXHR9KTtcbn07XG5cbk1vZGFsLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24oYWNjZXB0ZWQpIHtcblx0aWYgKCF0aGlzLmNvbmZpZy5vcGVuKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dGhpcy5jb25maWcuZG9tQmFja2Ryb3AuY2xhc3NMaXN0LnJlbW92ZSgnZWFzZS1vdXQnLCAnZHVyYXRpb24tMzAwJywgJ29wYWNpdHktMTAwJyk7XG5cdHRoaXMuY29uZmlnLmRvbUJhY2tkcm9wLmNsYXNzTGlzdC5hZGQoJ2Vhc2UtaW4nLCAnZHVyYXRpb24tMjAwJywgJ29wYWNpdHktMCcpO1xuXG5cdHRoaXMuY29uZmlnLmRvbUNvbnRlbnQuY2xhc3NMaXN0LnJlbW92ZSgnZWFzZS1vdXQnLCAnZHVyYXRpb24tMzAwJywgJ29wYWNpdHktMTAwJywgJ3RyYW5zbGF0ZS15LTAnLCAnc206c2NhbGUtMTAwJyk7XG5cdHRoaXMuY29uZmlnLmRvbUNvbnRlbnQuY2xhc3NMaXN0LmFkZCgnZWFzZS1pbicsICdkdXJhdGlvbi0yMDAnLCAnb3BhY2l0eS0wJywgJ3RyYW5zbGF0ZS15LTQnLCAnc206dHJhbnNsYXRlLXktMCcsICdzbTpzY2FsZS05NScpO1xuXHRzZXRUaW1lb3V0KCgpID0+IHRoaXMuY29uZmlnLmRvbU1vZGFsLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpLCAyMDApO1xuXG5cdHRoaXMuY29uZmlnLm9wZW4gPSBmYWxzZTtcblx0dGhpcy5jb25maWcuYWN0aXZlUHJvbWlzZSh0aGlzLmNvbmZpZy5vblJlc29sdmUoYWNjZXB0ZWQpKTtcblx0dGhpcy5jb25maWcuYWN0aXZlUHJvbWlzZSA9IHVuZGVmaW5lZDtcbn07XG5cbk1vZGFsLnByb3RvdHlwZS5jb25maXJtID0gZnVuY3Rpb24oY29sdW1uKSB7XG5cdHRoaXMuY29uZmlnLmRvbUNvbnRlbnQucXVlcnlTZWxlY3RvckFsbCgnLmpzLWNvbHVtbicpLmZvckVhY2goZWwgPT4gZWwuaW5uZXJUZXh0ID0gY29sdW1uKTtcblxuXHRyZXR1cm4gdGhpcy5zaG93KCk7XG59O1xuIiwiLyoqXG4gKiBIZWxwZXIgY2xhc3MgdG8ga2VlcCB0cmFjayBvbiB0aGUgbGFzdCBkaXNwbGF5ZWQgbm90aWZpY2F0aW9uLlxuICogUHJldmVudGluZyBkdXBsaWNhdGVzIGJlaW5nIGRpc3BsYXllZCBmb3IgYSBjZXJ0YWluIGFtb3VudCBvZiB0aW1lLlxuICogVW5sZXNzIGFub3RoZXIgbm90aWZpY2F0aW9uIHdhcyBkaXNwbGF5ZWQgaW4gdGhlIG1lYW50aW1lLlxuICogSW1wbGVtZW50ZWQgd2l0aCBhIFNpbmdsZXRvbiBwYXR0ZXJuIHNpbmNlIE5vdGlmeSBpcyBub3QgaW5zdGFudGlhdGVkLlxuICovXG5sZXQgTm90aWZpY2F0aW9uU3RhdHVzID0gKGZ1bmN0aW9uICgpIHtcblx0bGV0IGluc3RhbmNlO1xuXG5cdGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKCkge1xuXHRcdGxldCBOb3RpZmljYXRpb25TdGF0dXMgPSBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMubGFzdE5vdGlmeSA9ICcnO1xuXHRcdFx0dGhpcy50aHJlc2hvbGQgPSB1bmRlZmluZWQ7XG5cdFx0fTtcblx0XHROb3RpZmljYXRpb25TdGF0dXMucHJvdG90eXBlLmxhc3QgPSBmdW5jdGlvbihtc2cpIHtcblx0XHRcdHRoaXMudGltZXIobXNnKTtcblxuXHRcdFx0bGV0IG9sZFZhbHVlID0gdGhpcy5sYXN0Tm90aWZ5O1xuXHRcdFx0cmV0dXJuIHRoaXMubGFzdE5vdGlmeSA9IG1zZywgb2xkVmFsdWUgPT09IG1zZztcblx0XHR9O1xuXHRcdC8vIFJlc2V0cyB0aW1lciBpZiBuZWNlc3NhcnksIG9yIHN0YXJ0cyBpdFxuXHRcdE5vdGlmaWNhdGlvblN0YXR1cy5wcm90b3R5cGUudGltZXIgPSBmdW5jdGlvbihtc2cpIHtcblx0XHRcdGlmICghdGhpcy50aHJlc2hvbGQpIHtcblx0XHRcdFx0dGhpcy50aHJlc2hvbGQgPSBzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdFx0XHR0aGlzLmxhc3ROb3RpZnkgPSAnJztcblx0XHRcdFx0XHR0aGlzLnRocmVzaG9sZCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fSwgMzAwMCk7XG5cdFx0XHR9IGVsc2UgaWYgKG1zZyAhPSB0aGlzLmxhc3ROb3RpZnkpIHtcblx0XHRcdFx0dGhpcy50aHJlc2hvbGQgPSBjbGVhclRpbWVvdXQodGhpcy50aHJlc2hvbGQpO1xuXHRcdFx0XHR0aGlzLnRpbWVyKCk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHJldHVybiBuZXcgTm90aWZpY2F0aW9uU3RhdHVzKCk7XG5cdH1cbiBcblx0cmV0dXJuIHtcblx0XHRnZXRJbnN0YW5jZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIWluc3RhbmNlKSB7XG5cdFx0XHRcdGluc3RhbmNlID0gY3JlYXRlSW5zdGFuY2UoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBpbnN0YW5jZTtcblx0XHR9XG5cdH07XG59KSgpO1xuXG5mdW5jdGlvbiBOb3RpZnkodGl0bGUgPSAndGl0bGUnLCB0ZXh0ID0gJ3RleHQnLCBjZmcgPSB7fSkge1xuXHRsZXQgc3RhdHVzID0gTm90aWZpY2F0aW9uU3RhdHVzLmdldEluc3RhbmNlKCk7XG5cdGlmIChzdGF0dXMubGFzdCh0ZXh0KSkgeyByZXR1cm47IH1cblxuXHRsZXQgY29uZmlnID0ge1xuXHRcdC4uLntcblx0XHRcdC8vIFRpdGxlIG9mIHRoZSBub3RpZmljYXRpb25cblx0XHRcdHRpdGxlOiB0aXRsZSxcblx0XHRcdC8vIE1lc3NhZ2UgY29udGVudFxuXHRcdFx0dGV4dDogdGV4dCxcblx0XHRcdC8vIFR5cGUgb2Ygbm90aWZjYXRpb24sIGluZm8sIHdhcm5pbmcsIGRhbmdlciwgc3VjY2Vzc1xuXHRcdFx0dHlwZTogJ2luZm8nLFxuXHRcdFx0Ly8gdGhlIGNvbnRhaW5lciBob2xkaW5nIGFsbCBub3RpZmljYXRpb24gaXRlbXNcblx0XHRcdG5vdGlmaWNhdGlvbnNDb250YWluZXI6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5ub3RpZmljYXRpb25zJyksXG5cdFx0XHQvLyBBdXRvIHJlbW92aW5nIG5vdGlmaWNhdGlvbiBhZnRlciB0aGlzLCBpbiBtc1xuXHRcdFx0YXV0b1JlbW92ZUR1cmF0aW9uOiAzMDAwLFxuXHRcdFx0Ly8gZmFkZWluLy1vdXQgYW5pbWF0aW9uIHRpbWVcblx0XHRcdGFuaW1hdGlvbkR1cmF0aW9uOiA4MDAsXG5cdFx0XHQvLyB0aGUgdGVtcGxhdGUgZm9yIG5vdGlmaWNhdGlvbnMgdG8gdXNlXG5cdFx0XHR0ZW1wbGF0ZUhUTUw6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNub3RpZmljYXRpb24taXRlbScpLmlubmVySFRNTCxcblx0XHRcdC8vIGNsYXNzIGZvciBvcGVuaW5nIGFuaW1hdGlvblxuXHRcdFx0b3BlbmluZ0FuaW1hdGlvbkNsYXNzOiAnZmFkZUluRG93bicsXG5cdFx0XHQvLyBjbGFzcyBmb3IgY2xvc2luZyBhbmltYXRpb25cblx0XHRcdGNsb3NpbmdBbmltYXRpb25DbGFzczogJ2ZhZGVPdXRSaWdodCcsXG5cdFx0XHQvLyBjbG9zZSBidG4gaG92ZXI6Y29sb3IgZm9yIGluZm8gYW5kIHdhcm5pbmdcblx0XHRcdHdhcm5pbmdJbmZvQ2xvc2VDb2xvcjogJ3RleHQtZ3JheS01MDAnLFxuXHRcdFx0Ly8gY2xvc2UgYm50IGhvdmVyOmNvbG9yIGZvciBkYW5nZXIgYW5kIHN1Y2Nlc3Ncblx0XHRcdGRhbmdlclN1Y2Nlc3NDbG9zZUNvbG9yOiAndGV4dC1ncmF5LTIwMCcsXG5cdFx0fSxcblx0XHQuLi5jZmdcblx0fTtcblx0XG5cdGxldCB0aW1lckNsb3NlID0gdW5kZWZpbmVkO1xuXHRsZXQgdGltZXJGYWRlSW4gPSB1bmRlZmluZWQ7XG5cblx0bGV0IF9kaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0bGV0IHRtcGwgPSBjb25maWcudGVtcGxhdGVIVE1MLnNsaWNlKDApO1xuXG5cdF9kaXYuaW5uZXJIVE1MID0gdG1wbDtcblx0X2RpdiA9IF9kaXYuZmlyc3RFbGVtZW50Q2hpbGQ7XG5cdF9kaXYuY2xhc3NMaXN0LmFkZCgnaXMtJyArIGNvbmZpZy50eXBlLCBjb25maWcub3BlbmluZ0FuaW1hdGlvbkNsYXNzKTtcblx0XG5cdF9kaXYuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBlID0+IHtcblx0XHRpZiAodGltZXJDbG9zZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aW1lckNsb3NlID0gY2xlYXJUaW1lb3V0KHRpbWVyQ2xvc2UpO1xuXHRcdH1cblx0XHRpZiAodGltZXJGYWRlSW4gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGltZXJGYWRlSW4gPSBjbGVhclRpbWVvdXQodGltZXJGYWRlSW4pO1xuXHRcdH1cblx0XHRcblx0XHRfZGl2LmNsYXNzTGlzdC5hZGQoY29uZmlnLmNsb3NpbmdBbmltYXRpb25DbGFzcyk7XG5cdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdF9kaXYucmVtb3ZlKCk7XG5cdFx0fSwgY29uZmlnLmFuaW1hdGlvbkR1cmF0aW9uKzUwKTtcblx0fSk7XG5cblx0X2Rpdi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCBmdW5jdGlvbihlKSB7XG5cdFx0aWYgKHRpbWVyQ2xvc2UgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGltZXJDbG9zZSA9IGNsZWFyVGltZW91dCh0aW1lckNsb3NlKTtcblx0XHR9XG5cdH0pO1xuXHRfZGl2LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBmdW5jdGlvbihlKSB7XG5cdFx0dGltZXJDbG9zZSA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRfZGl2LmNsaWNrKCk7XG5cdFx0fSwgY29uZmlnLmF1dG9SZW1vdmVEdXJhdGlvbik7XG5cdH0pO1xuXG5cdGxldCBjbG9zZUJ0biA9IFsgLi4uX2Rpdi5xdWVyeVNlbGVjdG9yQWxsKCdbbi1jbG9zZV0nKSBdO1xuXHRcdGNsb3NlQnRuLmZvckVhY2goYnRuID0+IHtcblx0XHRcdGJ0bi5pbm5lckhUTUwgPSAneCc7XG5cblx0XHRcdGJ0bi5jbGFzc0xpc3QuYWRkKChjb25maWcudHlwZSA9PT0gJ3dhcm5pbmcnIHx8IGNvbmZpZy50eXBlID09PSAnaW5mbycgPyBgZ3JvdXAtaG92ZXI6JHsgY29uZmlnLndhcm5pbmdJbmZvQ2xvc2VDb2xvciB9YCA6IGBncm91cC1ob3ZlcjokeyBjb25maWcuZGFuZ2VyU3VjY2Vzc0Nsb3NlQ29sb3IgfWApKTtcblxuXHRcdFx0YnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZSA9PiB7XG5cdFx0XHRcdF9kaXYuY2xpY2soKTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXG5cdFsgJ3RpdGxlJywgJ3RleHQnIF0uZm9yRWFjaChrZXkgPT4ge1xuXHRcdGxldCBlbCA9IF9kaXYucXVlcnlTZWxlY3RvcihgW24tJHsga2V5IH1dYCk7XG5cdFx0ZWwgJiYgKGVsLmlubmVySFRNTCA9IGNvbmZpZ1trZXldKTtcblx0fSk7XG5cblx0bGV0IGljb24gPSBfZGl2LnF1ZXJ5U2VsZWN0b3IoYFtuLXR5cGUtJHsgY29uZmlnLnR5cGUgfV1gKTtcblx0aWNvbiAmJiBpY29uLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpO1xuXG5cdCEhY29uZmlnLm5vdGlmaWNhdGlvbnNDb250YWluZXIgJiYgY29uZmlnLm5vdGlmaWNhdGlvbnNDb250YWluZXIucHJlcGVuZChfZGl2KTtcblxuXHR0aW1lckZhZGVJbiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0X2Rpdi5jbGFzc0xpc3QucmVtb3ZlKGNvbmZpZy5vcGVuaW5nQW5pbWF0aW9uQ2xhc3MpO1xuXHR9LCBjb25maWcuYW5pbWF0aW9uRHVyYXRpb24rNTApO1xuXG5cdC8vIHN0YXJ0IHRpbWVyIHRvIGNsb3NlIGF1dG9tYXRpY2FsbHkgYWZ0ZXIgNXNcblx0X2Rpdi5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnbW91c2VsZWF2ZScpKTtcbn1cblxuXG4vLyBDcmVhdGluZyBzaG9ydGhhbmRzIGluIGEgaGFja3kgd2F5XG5sZXQgd3JhcHBlZE5vdGlmeSA9ICgoKSA9PiB7XG5cdE5vdGlmeS5kYW5nZXIgPSBmdW5jdGlvbih0aXRsZSA9ICd0aXRsZScsIHRleHQgPSAndGV4dCcsIGNmZyA9IHt9KSB7XG5cdFx0cmV0dXJuIE5vdGlmeSh0aXRsZSwgdGV4dCwgeyB0eXBlOiAnZGFuZ2VyJywgLi4uY2ZnIH0pO1xuXHR9O1xuXHROb3RpZnkuaW5mbyA9IGZ1bmN0aW9uKHRpdGxlID0gJ3RpdGxlJywgdGV4dCA9ICd0ZXh0JywgY2ZnID0ge30pIHtcblx0XHRyZXR1cm4gTm90aWZ5KHRpdGxlLCB0ZXh0LCB7IHR5cGU6ICdpbmZvJywgLi4uY2ZnIH0pO1xuXHR9O1xuXHROb3RpZnkuc3VjY2VzcyA9IGZ1bmN0aW9uKHRpdGxlID0gJ3RpdGxlJywgdGV4dCA9ICd0ZXh0JywgY2ZnID0ge30pIHtcblx0XHRyZXR1cm4gTm90aWZ5KHRpdGxlLCB0ZXh0LCB7IHR5cGU6ICdzdWNjZXNzJywgLi4uY2ZnIH0pO1xuXHR9O1xuXHROb3RpZnkud2FybmluZyA9IGZ1bmN0aW9uKHRpdGxlID0gJ3RpdGxlJywgdGV4dCA9ICd0ZXh0JywgY2ZnID0ge30pIHtcblx0XHRyZXR1cm4gTm90aWZ5KHRpdGxlLCB0ZXh0LCB7IHR5cGU6ICd3YXJuaW5nJywgLi4uY2ZnIH0pO1xuXHR9O1xuXG5cdHJldHVybiBOb3RpZnk7XG59KSgpO1xuXG5leHBvcnQgZGVmYXVsdCB3cmFwcGVkTm90aWZ5OyIsImltcG9ydCBJbnNlcnQgZnJvbSAnLi9JbnNlcnQnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTdGF0ZW1lbnQoY29uZmlnKSB7XG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBTdGF0ZW1lbnQpKSB7XG5cdFx0cmV0dXJuIG5ldyBTdGF0ZW1lbnQoY29uZmlnKTtcblx0fVxuXG5cdHRoaXMuY29uZmlnID0ge1xuXHRcdC4uLntcblx0XHRcdG5vdGlmaWNhdGlvbjogdW5kZWZpbmVkLFxuXHRcdH0sXG5cdFx0Li4uY29uZmlnXG5cdH07XG5cdHRoaXMub2JqZWN0ID0gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBub3RpZmljYXRpb24uXG4gKiBcbiAqIEBwYXJhbVx0c3RyaW5nXHR0eXBlXHRcdFx0XHRUaGUgdHlwZSBvZiBub3RpZmljYXRpb24sIGluZm8sIHdhcm5pbmcsIHN1Y2Nlc3MsIGRhbmdlci5cbiAqIEBwYXJhbVx0c3RyaW5nXHR0aXRsZSBcdFx0XHRcdFRoZSB0aXRsZSBvZiB0aGUgbm90aWZpY2F0aW9uLlxuICogQHBhcmFtXHRzdHJpbmdcdG1lc3NhZ2VcdFx0XHRcdE9wdGlvbmFsIGJvZHkgb2YgdGhlIG5vdGlmY2F0aW9uLCBjYW5ub3QgYmUgYW4gZW1wdHkgc3RyaW5nLCBvciBpdCBtaWdodCBub3QgYmUgZGlzcGxheWVkLlxuICogQHBhcmFtXHRpbnRcdFx0YXV0b1JlbW92ZUR1cmF0aW9uXHRUaW1lIGZvciBub3RpZmljYXRpb24gdG8gYmUgZGlzcGxheWVkLlxuICovXG5TdGF0ZW1lbnQucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uKHR5cGUsIHRpdGxlLCBtZXNzYWdlID0gJyAnLCBhdXRvUmVtb3ZlRHVyYXRpb24gPSA1MDAwKSB7XG5cdGlmICh0aGlzLmNvbmZpZy5ub3RpZmljYXRpb24gIT09IHVuZGVmaW5lZCkge1xuXHRcdGlmICh0eXBlb2YodGhpcy5jb25maWcubm90aWZpY2F0aW9uW3R5cGVdICE9PSAndW5kZWZpbmVkJykpIHtcblx0XHRcdHRoaXMuY29uZmlnLm5vdGlmaWNhdGlvblt0eXBlXSh0aXRsZSwgbWVzc2FnZSwgeyBhdXRvUmVtb3ZlRHVyYXRpb24gfSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuY29uZmlnLm5vdGlmaWNhdGlvbih0aXRsZSwgbWVzc2FnZSwgeyBhdXRvUmVtb3ZlRHVyYXRpb24gfSk7XG5cdFx0fVxuXHR9XG59O1xuXG4vKipcbiAqIFxuICogQHBhcmFtXHRzdHJpbmdcdHN0YXRlbWVudFx0QSBzdGF0ZW1lbnQgdG8gYW5hbHl6ZSBhbmQgY29udmVydCBpbnRvIGFuIG9iamVjdC5cbiAqIEByZXR1cm5zXHRtaXhlZFx0XHRcdFx0QW4gT2JqZWN0IGluc3RhbmNlIGNvcnJlc3BvbmRpbmcgd2l0aCB0aGUgaW5wdXQsIHVuZGVmaW5lZCBpZiBpbnZhbGlkIGlucHV0LlxuICovXG5TdGF0ZW1lbnQucHJvdG90eXBlLmNyZWF0ZU9iamVjdCA9IGZ1bmN0aW9uKHN0YXRlbWVudCkge1xuXHRzd2l0Y2ggKHN0YXRlbWVudC5zdWJzdHIoMCwgMTEpLnRvTG93ZXJDYXNlKCkpIHtcblx0XHRjYXNlICdpbnNlcnQgaW50byc6XG5cdFx0XHR0aGlzLm9iamVjdCA9IG5ldyBJbnNlcnQoeyBwYXJlbnQ6IHRoaXMgfSk7XG5cdFx0XHRpZiAoIXRoaXMub2JqZWN0LmFuYWx5emUoc3RhdGVtZW50KSkge1xuXHRcdFx0XHR0aGlzLm9iamVjdCA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHRicmVhaztcblxuXHRcdGRlZmF1bHQ6XG5cdFx0XHR0aGlzLm9iamVjdCA9IHVuZGVmaW5lZDtcblx0XHRicmVhaztcblx0fVxuXG5cdHJldHVybiB0aGlzLm9iamVjdDtcbn0iXX0=
